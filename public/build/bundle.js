
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$5() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function append$2(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals$1 = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$z(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$5,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$5;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.4' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append$2(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /* Mapbox GL JS is Copyright © 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */

    var mapboxGl = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
    module.exports = factory() ;
    })(commonjsGlobal, (function () {
    /* eslint-disable */

    var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
    if (!shared) {
        shared = chunk;
    } else if (!worker) {
        worker = chunk;
    } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";

        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl = chunk(sharedChunk);
        if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
            mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' }));
        }
    }
    }


    define(["exports"],(function(t){var e="3.3.0";let r;const n={API_URL:"https://api.mapbox.com",get API_URL_REGEX(){if(null==r){const t=/^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;try{r=null!=process.env.API_URL_REGEX?new RegExp(process.env.API_URL_REGEX):t;}catch(e){r=t;}}return r},get API_TILEJSON_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i},get API_SPRITE_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i},get API_FONTS_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i},get API_STYLE_REGEX(){return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i},get API_CDN_URL_REGEX(){return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i},get EVENTS_URL(){if(!n.API_URL)return null;try{const t=new URL(n.API_URL);return "api.mapbox.cn"===t.hostname?"https://events.mapbox.cn/events/v2":"api.mapbox.com"===t.hostname?"https://events.mapbox.com/events/v2":null}catch(t){return null}},SESSION_PATH:"/map-sessions/v1",FEEDBACK_URL:"https://apps.mapbox.com/feedback",TILE_URL_VERSION:"v4",RASTER_URL_PREFIX:"raster/v1",RASTERARRAYS_URL_PREFIX:"rasterarrays/v1",REQUIRE_ACCESS_TOKEN:!0,ACCESS_TOKEN:null,DEFAULT_STYLE:"mapbox://styles/mapbox/standard",MAX_PARALLEL_IMAGE_REQUESTS:16,DRACO_URL:"https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",MESHOPT_URL:"https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",MESHOPT_SIMD_URL:"https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",GLYPHS_URL:"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"};function i(t){return n.API_URL_REGEX.test(t)}function a(t){return 0===t.indexOf("mapbox:")}function s(t){return n.API_CDN_URL_REGEX.test(t)}function o(t){return n.API_SPRITE_REGEX.test(t)}function l(t){return n.API_STYLE_REGEX.test(t)&&!o(t)}const u={create:"create",load:"load",fullLoad:"fullLoad"};function c(t){const e=t.name.split("?")[0];return s(e)&&e.includes("mapbox-gl.js")?"javascript":s(e)&&e.includes("mapbox-gl.css")?"css":function(t){return n.API_FONTS_REGEX.test(t)}(e)?"fontRange":o(e)?"sprite":l(e)?"style":function(t){return n.API_TILEJSON_REGEX.test(t)}(e)?"tilejson":"other"}function h(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var p=f;function f(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=e,this.p2x=r,this.p2y=n;}f.prototype={sampleCurveX:function(t){return ((this.ax*t+this.bx)*t+this.cx)*t},sampleCurveY:function(t){return ((this.ay*t+this.by)*t+this.cy)*t},sampleCurveDerivativeX:function(t){return (3*this.ax*t+2*this.bx)*t+this.cx},solveCurveX:function(t,e){if(void 0===e&&(e=1e-6),t<0)return 0;if(t>1)return 1;for(var r=t,n=0;n<8;n++){var i=this.sampleCurveX(r)-t;if(Math.abs(i)<e)return r;var a=this.sampleCurveDerivativeX(r);if(Math.abs(a)<1e-6)break;r-=i/a;}var s=0,o=1;for(r=t,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-t)<e));n++)t>i?s=r:o=r,r=.5*(o-s)+s;return r},solve:function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))}};var d=h(p),m=y;function y(t,e){this.x=t,this.y=e;}y.prototype={clone:function(){return new y(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[2]*this.x+t[3]*this.y;return this.x=t[0]*this.x+t[1]*this.y,this.y=e,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=r*this.x+e*this.y;return this.x=e*this.x-r*this.y,this.y=n,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=e.x+r*(this.x-e.x)-n*(this.y-e.y),this.y=i,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},y.convert=function(t){return t instanceof y?t:Array.isArray(t)?new y(t[0],t[1]):t};var g=h(m);const x=Math.PI/180,v=180/Math.PI;function b(t){return t*x}function _(t){return t*v}const w=[[0,0],[1,0],[1,1],[0,1]];function M(t){if(t<=0)return 0;if(t>=1)return 1;const e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}function A(t,e,r,n){const i=new d(t,e,r,n);return function(t){return i.solve(t)}}const S=A(.25,.1,.25,1);function I(t,e,r){return Math.min(r,Math.max(e,t))}function k(t,e,r){return (r=I((r-t)/(e-t),0,1))*r*(3-2*r)}function P(t,e,r){const n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function E(t,e,r){if(!t.length)return r(null,[]);let n=t.length;const i=new Array(t.length);let a=null;t.forEach(((t,s)=>{e(t,((t,e)=>{t&&(a=t),i[s]=e,0==--n&&r(a,i);}));}));}function z(t,...e){for(const r of e)for(const e in r)t[e]=r[e];return t}let T=1;function B(){return T++}function C(){return function t(e){return e?(e^Math.random()*(16>>e/4)).toString(16):([1e7]+-[1e3]+-4e3+-8e3+-1e11).replace(/[018]/g,t)}()}function R(t){return t<=1?1:Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function D(t){return !!t&&/^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)}function V(t,e){t.forEach((t=>{e[t]&&(e[t]=e[t].bind(e));}));}function L(t,e){return -1!==t.indexOf(e,t.length-e.length)}function F(t,e,r){const n={};for(const i in t)n[i]=e.call(r||this,t[i],i,t);return n}function N(t,e,r){const n={};for(const i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function O(t){return Array.isArray(t)?t.map(O):"object"==typeof t&&t?F(t,O):t}const U={};function j(t){U[t]||("undefined"!=typeof console&&console.warn(t),U[t]=!0);}function q(t,e,r){return (r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function $(t){let e=0;for(let r,n,i=0,a=t.length,s=a-1;i<a;s=i++)r=t[i],n=t[s],e+=(n.x-r.x)*(r.y+n.y);return e}function G([t,e,r]){const n=b(e+90),i=b(r);return {x:t*Math.cos(n)*Math.sin(i),y:t*Math.sin(n)*Math.sin(i),z:t*Math.cos(i),azimuthal:e,polar:r}}function Y(){return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope}function X(t){const e={};if(t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,((t,r,n,i)=>{const a=n||i;return e[r]=!a||a.toLowerCase(),""})),e["max-age"]){const t=parseInt(e["max-age"],10);isNaN(t)?delete e["max-age"]:e["max-age"]=t;}return e}let Z,K,H,W,J,Q,tt=null;function et(t){try{const e=self[t];return e.setItem("_mapbox_test_",1),e.removeItem("_mapbox_test_"),!0}catch(t){return !1}}function rt(t,e){return [t[4*e],t[4*e+1],t[4*e+2],t[4*e+3]]}function nt(t,e,r,n){for(;e<r;){const i=e+r>>1;t[i]<n?e=i+1:r=i;}return e}function it(t,e,r,n){for(;e<r;){const i=e+r>>1;t[i]<=n?e=i+1:r=i;}return e}function at(){return null==Z&&(Z=self.OffscreenCanvas&&new OffscreenCanvas(1,1).getContext("2d")&&"function"==typeof self.createImageBitmap),Z}const st={now:()=>void 0!==W?W:performance.now(),setNow(t){W=t;},restoreNow(){W=void 0;},frame(t){const e=requestAnimationFrame(t);return {cancel:()=>cancelAnimationFrame(e)}},getImageData(t,e=0){const{width:r,height:n}=t;J||(J=document.createElement("canvas"));const i=J.getContext("2d",{willReadFrequently:!0});if(!i)throw new Error("failed to create canvas 2d context");return (r>J.width||n>J.height)&&(J.width=r,J.height=n),i.clearRect(-e,-e,r+2*e,n+2*e),i.drawImage(t,0,0,r,n),i.getImageData(-e,-e,r+2*e,n+2*e)},resolveURL:t=>(K||(K=document.createElement("a")),K.href=t,K.href),get devicePixelRatio(){return window.devicePixelRatio},get prefersReducedMotion(){return !!window.matchMedia&&(null==H&&(H=window.matchMedia("(prefers-reduced-motion: reduce)")),H.matches)},hasCanvasFingerprintNoise(){if(void 0!==Q)return Q;if(!at())return Q=!1,!1;const t=new OffscreenCanvas(85,1),e=t.getContext("2d",{willReadFrequently:!0});let r=0;for(let n=0;n<t.width;++n)e.fillStyle=`rgba(${r++},${r++},${r++}, 255)`,e.fillRect(n,0,1,1);const n=e.getImageData(0,0,t.width,t.height);r=0;for(let t=0;t<n.data.length;++t)if(t%4!=3&&r++!==n.data[t])return Q=!0,!0;return Q=!1,!1}},ot="mapbox-tiles";let lt=500,ut=50;let ct,ht;function pt(){try{return caches}catch(t){}}function ft(){const t=pt();t&&!ct&&(ct=t.open(ot));}function dt(t){const e=t.indexOf("?");if(e<0)return t;const r=["language","worldview"],n=new URLSearchParams,i=new URLSearchParams(t.slice(e));for(const t of r){const e=i.get(t);e&&n.set(t,e);}return `${t.slice(0,e)}?${n.toString()}`}function mt(t,e){const r=t.indexOf("?");if(r<0)return `${t}?${new URLSearchParams(e).toString()}`;const n=new URLSearchParams(t.slice(r));for(const t in e)n.set(t,e[t]);return `${t.slice(0,r)}?${n.toString()}`}let yt=1/0;const gt={supported:!1,testSupport:function(t){!bt&&vt&&(_t?Mt(t):xt=t);}};let xt,vt,bt=!1,_t=!1;const wt="undefined"!=typeof self?self:{};function Mt(t){const e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);try{if(t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,vt),t.isContextLost())return;gt.supported=!0;}catch(t){}t.deleteTexture(e),bt=!0;}wt.document&&(vt=wt.document.createElement("img"),vt.onload=function(){xt&&Mt(xt),xt=null,_t=!0;},vt.onerror=function(){bt=!0,xt=null;},vt.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");const At={Unknown:"Unknown",Style:"Style",Source:"Source",Tile:"Tile",Glyphs:"Glyphs",SpriteImage:"SpriteImage",SpriteJSON:"SpriteJSON",Image:"Image",Model:"Model"};"function"==typeof Object.freeze&&Object.freeze(At);class St extends Error{constructor(t,e,r){401===e&&i(r)&&(t+=": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),super(t),this.status=e,this.url=r;}toString(){return `${this.name}: ${this.message} (${this.status}): ${this.url}`}}const It=Y()?()=>self.worker&&self.worker.referrer:()=>("blob:"===location.protocol?parent:self).location.href;const kt=function(t,e){if(!(/^file:/.test(r=t.url)||/^file:/.test(It())&&!/^\w+:/.test(r))){if(self.fetch&&self.Request&&self.AbortController&&Request.prototype.hasOwnProperty("signal"))return function(t,e){const r=new AbortController,n=new Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,referrer:It(),referrerPolicy:t.referrerPolicy,signal:r.signal});let a=!1,s=!1;const o=(l=n.url).indexOf("sku=")>0&&i(l);var l;"json"===t.type&&n.headers.set("Accept","application/json");const u=(r,i,a)=>{if(s)return;if(r&&"SecurityError"!==r.message&&j(r.toString()),i&&a)return c(i);const l=Date.now();fetch(n).then((r=>{if(r.ok){const t=o?r.clone():null;return c(r,t,l)}return e(new St(r.statusText,r.status,t.url))})).catch((r=>{"AbortError"!==r.name&&e(new Error(`${r.message} ${t.url}`));}));},c=(r,i,o)=>{("arrayBuffer"===t.type?r.arrayBuffer():"json"===t.type?r.json():r.text()).then((t=>{s||(i&&o&&function(t,e,r){if(ft(),!ct)return;const n=X(e.headers.get("Cache-Control")||"");if(n["no-store"])return;const i={status:e.status,statusText:e.statusText,headers:new Headers};e.headers.forEach(((t,e)=>i.headers.set(e,t))),n["max-age"]&&i.headers.set("Expires",new Date(r+1e3*n["max-age"]).toUTCString());const a=i.headers.get("Expires");if(!a)return;if(new Date(a).getTime()-r<42e4)return;let s=dt(t.url);if(206===e.status){const e=t.headers.get("Range");if(!e)return;i.status=200,s=mt(s,{range:e});}!function(t,e){if(void 0===ht)try{new Response(new ReadableStream),ht=!0;}catch(t){ht=!1;}ht?e(t.body):t.blob().then(e);}(e,(t=>{const e=new Response(t,i);ft(),ct&&ct.then((t=>t.put(s,e))).catch((t=>j(t.message)));}));}(n,i,o),a=!0,e(null,t,r.headers.get("Cache-Control"),r.headers.get("Expires")));})).catch((t=>{s||e(new Error(t.message));}));};return o?function(t,e){if(ft(),!ct)return e(null);ct.then((r=>{let n=dt(t.url);const i=t.headers.get("Range");i&&(n=mt(n,{range:i})),r.match(n).then((t=>{const i=function(t){if(!t)return !1;const e=new Date(t.headers.get("Expires")||0),r=X(t.headers.get("Cache-Control")||"");return e>Date.now()&&!r["no-cache"]}(t);r.delete(n),i&&r.put(n,t.clone()),e(null,t,i);})).catch(e);})).catch(e);}(n,u):u(null,null),{cancel:()=>{s=!0,a||r.abort();}}}(t,e);if(Y()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",t,e,void 0,!0)}var r;return function(t,e){const r=new XMLHttpRequest;r.open(t.method||"GET",t.url,!0),"arrayBuffer"===t.type&&(r.responseType="arraybuffer");for(const e in t.headers)r.setRequestHeader(e,t.headers[e]);return "json"===t.type&&(r.responseType="text",r.setRequestHeader("Accept","application/json")),r.withCredentials="include"===t.credentials,r.onerror=()=>{e(new Error(r.statusText));},r.onload=()=>{if((r.status>=200&&r.status<300||0===r.status)&&null!==r.response){let n=r.response;if("json"===t.type)try{n=JSON.parse(r.response);}catch(t){return e(t)}e(null,n,r.getResponseHeader("Cache-Control"),r.getResponseHeader("Expires"));}else e(new St(r.statusText,r.status,t.url));},r.send(t.body),{cancel:()=>r.abort()}}(t,e)},Pt=function(t,e){return kt(z(t,{type:"arrayBuffer"}),e)};function Et(t){const e=document.createElement("a");return e.href=t,e.protocol===location.protocol&&e.host===location.host}const zt="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";let Tt,Bt;Tt=[],Bt=0;const Ct=function(t,e){if(gt.supported&&(t.headers||(t.headers={}),t.headers.accept="image/webp,*/*"),Bt>=n.MAX_PARALLEL_IMAGE_REQUESTS){const r={requestParameters:t,callback:e,cancelled:!1,cancel(){this.cancelled=!0;}};return Tt.push(r),r}Bt++;let r=!1;const i=()=>{if(!r)for(r=!0,Bt--;Tt.length&&Bt<n.MAX_PARALLEL_IMAGE_REQUESTS;){const t=Tt.shift(),{requestParameters:e,callback:r,cancelled:n}=t;n||(t.cancel=Ct(e,r).cancel);}},a=Pt(t,((t,r,n,a)=>{i(),t?e(t):r&&(self.createImageBitmap?function(t,e){const r=new Blob([new Uint8Array(t)],{type:"image/png"});createImageBitmap(r).then((t=>{e(null,t);})).catch((t=>{e(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));}));}(r,((t,r)=>e(t,r,n,a))):function(t,e){const r=new Image;r.onload=()=>{e(null,r),URL.revokeObjectURL(r.src),r.onload=null,requestAnimationFrame((()=>{r.src=zt;}));},r.onerror=()=>e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));const n=new Blob([new Uint8Array(t)],{type:"image/png"});r.src=t.byteLength?URL.createObjectURL(n):zt;}(r,((t,r)=>e(t,r,n,a))));}));return {cancel:()=>{a.cancel(),i();}}},Rt="01",Dt="NO_ACCESS_TOKEN",Vt=/^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;function Lt(t){const e=t.match(Vt);if(!e)throw new Error("Unable to parse URL object");return {protocol:e[1],authority:e[2],path:e[3]||"/",params:e[4]?e[4].split("&"):[]}}function Ft(t){const e=t.params.length?`?${t.params.join("&")}`:"";return `${t.protocol}://${t.authority}${t.path}${e}`}const Nt="mapbox.eventData";function Ot(t){if(!t)return null;const e=t.split(".");if(!e||3!==e.length)return null;try{return JSON.parse(decodeURIComponent(atob(e[1]).split("").map((t=>"%"+("00"+t.charCodeAt(0).toString(16)).slice(-2))).join("")))}catch(t){return null}}class Ut{constructor(t){this.type=t,this.anonId=null,this.eventData={},this.queue=[],this.pendingRequest=null;}getStorageKey(t){const e=Ot(n.ACCESS_TOKEN);let r="";return r=e&&e.u?btoa(encodeURIComponent(e.u).replace(/%([0-9A-F]{2})/g,((t,e)=>String.fromCharCode(Number("0x"+e))))):n.ACCESS_TOKEN||"",t?`${Nt}.${t}:${r}`:`${Nt}:${r}`}fetchEventData(){const t=et("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid");if(t)try{const t=localStorage.getItem(e);t&&(this.eventData=JSON.parse(t));const n=localStorage.getItem(r);n&&(this.anonId=n);}catch(t){j("Unable to read from LocalStorage");}}saveEventData(){const t=et("localStorage"),e=this.getStorageKey(),r=this.getStorageKey("uuid"),n=this.anonId;if(t&&n)try{localStorage.setItem(r,n),Object.keys(this.eventData).length>=1&&localStorage.setItem(e,JSON.stringify(this.eventData));}catch(t){j("Unable to write to LocalStorage");}}processRequests(t){}postEvent(t,e,r,i){if(!n.EVENTS_URL)return;const a=Lt(n.EVENTS_URL);a.params.push(`access_token=${i||n.ACCESS_TOKEN||""}`);const s={event:this.type,created:new Date(t).toISOString()},o=e?z(s,e):s,l={url:Ft(a),headers:{"Content-Type":"text/plain"},body:JSON.stringify([o])};this.pendingRequest=function(t,e){return kt(z(t,{method:"POST"}),e)}(l,(t=>{this.pendingRequest=null,r(t),this.saveEventData(),this.processRequests(i);}));}queueRequest(t,e){this.queue.push(t),this.processRequests(e);}}const jt=new class extends Ut{constructor(t){super("appUserTurnstile"),this._customAccessToken=t;}postTurnstileEvent(t,e){n.EVENTS_URL&&n.ACCESS_TOKEN&&Array.isArray(t)&&t.some((t=>a(t)||i(t)))&&this.queueRequest(Date.now(),e);}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;this.anonId&&this.eventData.lastSuccess&&this.eventData.tokenU||this.fetchEventData();const r=Ot(n.ACCESS_TOKEN),i=r?r.u:n.ACCESS_TOKEN;let a=i!==this.eventData.tokenU;D(this.anonId)||(this.anonId=C(),a=!0);const s=this.queue.shift();if(this.eventData.lastSuccess){const t=new Date(this.eventData.lastSuccess),e=new Date(s),r=(s-this.eventData.lastSuccess)/864e5;a=a||r>=1||r<-1||t.getDate()!==e.getDate();}else a=!0;a?this.postEvent(s,{sdkIdentifier:"mapbox-gl-js",sdkVersion:e,skuId:Rt,"enabled.telemetry":!1,userId:this.anonId},(t=>{t||(this.eventData.lastSuccess=s,this.eventData.tokenU=i);}),t):this.processRequests();}},qt=jt.postTurnstileEvent.bind(jt),$t=new class extends Ut{constructor(){super("map.load"),this.success={},this.skuToken="";}postMapLoadEvent(t,e,r,i){this.skuToken=e,this.errorCb=i,n.EVENTS_URL&&(r||n.ACCESS_TOKEN?this.queueRequest({id:t,timestamp:Date.now()},r):this.errorCb(new Error(Dt)));}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;const{id:r,timestamp:n}=this.queue.shift();r&&this.success[r]||(this.anonId||this.fetchEventData(),D(this.anonId)||(this.anonId=C()),this.postEvent(n,{sdkIdentifier:"mapbox-gl-js",sdkVersion:e,skuId:Rt,skuToken:this.skuToken,userId:this.anonId},(t=>{t?this.errorCb(t):r&&(this.success[r]=!0);}),t));}remove(){this.errorCb=null;}},Gt=$t.postMapLoadEvent.bind($t),Yt=new class extends Ut{constructor(){super("gljs.performance");}postPerformanceEvent(t,e){n.EVENTS_URL&&(t||n.ACCESS_TOKEN)&&this.queueRequest({timestamp:Date.now(),performanceData:e},t);}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;const{timestamp:r,performanceData:n}=this.queue.shift(),i=function(t){const r=performance.getEntriesByType("resource"),n=performance.getEntriesByType("mark"),i=function(t){const e={};if(t)for(const r in t)if("other"!==r)for(const n of t[r]){const t=`${r}ResolveRangeMin`,i=`${r}ResolveRangeMax`,a=`${r}RequestCount`,s=`${r}RequestCachedCount`;e[t]=Math.min(e[t]||1/0,n.startTime),e[i]=Math.max(e[i]||-1/0,n.responseEnd);const o=t=>{void 0===e[t]&&(e[t]=0),++e[t];};void 0!==n.transferSize&&0===n.transferSize&&o(s),o(a);}return e}(function(t,e){const r={};if(t)for(const n of t){const t=e(n);void 0===r[t]&&(r[t]=[]),r[t].push(n);}return r}(r,c)),a=window.devicePixelRatio,s=navigator.connection||navigator.mozConnection||navigator.webkitConnection,o=s?s.effectiveType:void 0,h={counters:[],metadata:[],attributes:[]},p=(t,e,r)=>{null!=r&&t.push({name:e,value:r.toString()});};for(const t in i)p(h.counters,t,i[t]);if(t.interactionRange[0]!==1/0&&t.interactionRange[1]!==-1/0&&(p(h.counters,"interactionRangeMin",t.interactionRange[0]),p(h.counters,"interactionRangeMax",t.interactionRange[1])),n)for(const t of Object.keys(u)){const e=u[t],r=n.find((t=>t.name===e));r&&p(h.counters,e,r.startTime);}return p(h.counters,"visibilityHidden",t.visibilityHidden),p(h.attributes,"style",function(t){if(t)for(const e of t){const t=e.name.split("?")[0];if(l(t)){const e=t.split("/").slice(-2);if(2===e.length)return `mapbox://styles/${e[0]}/${e[1]}`}}}(r)),p(h.attributes,"terrainEnabled",t.terrainEnabled?"true":"false"),p(h.attributes,"fogEnabled",t.fogEnabled?"true":"false"),p(h.attributes,"projection",t.projection),p(h.attributes,"zoom",t.zoom),p(h.metadata,"devicePixelRatio",a),p(h.metadata,"connectionEffectiveType",o),p(h.metadata,"navigatorUserAgent",navigator.userAgent),p(h.metadata,"screenWidth",window.screen.width),p(h.metadata,"screenHeight",window.screen.height),p(h.metadata,"windowWidth",window.innerWidth),p(h.metadata,"windowHeight",window.innerHeight),p(h.metadata,"mapWidth",t.width/a),p(h.metadata,"mapHeight",t.height/a),p(h.metadata,"webglRenderer",t.renderer),p(h.metadata,"webglVendor",t.vendor),p(h.metadata,"sdkVersion",e),p(h.metadata,"sdkIdentifier","mapbox-gl-js"),h}(n);for(const t of i.metadata);for(const t of i.counters);for(const t of i.attributes);this.postEvent(r,i,(()=>{}),t);}},Xt=Yt.postPerformanceEvent.bind(Yt),Zt=new class extends Ut{constructor(){super("map.auth"),this.success={},this.skuToken="";}getSession(t,e,r,i){if(!n.API_URL||!n.SESSION_PATH)return;const a=Lt(n.API_URL+n.SESSION_PATH);a.params.push(`sku=${e||""}`),a.params.push(`access_token=${i||n.ACCESS_TOKEN||""}`);const s={url:Ft(a),headers:{"Content-Type":"text/plain"}};this.pendingRequest=function(t,e){return kt(z(t,{method:"GET"}),e)}(s,(t=>{this.pendingRequest=null,r(t),this.saveEventData(),this.processRequests(i);}));}getSessionAPI(t,e,r,i){this.skuToken=e,this.errorCb=i,n.SESSION_PATH&&n.API_URL&&(r||n.ACCESS_TOKEN?this.queueRequest({id:t,timestamp:Date.now()},r):this.errorCb(new Error(Dt)));}processRequests(t){if(this.pendingRequest||0===this.queue.length)return;const{id:e,timestamp:r}=this.queue.shift();e&&this.success[e]||this.getSession(r,this.skuToken,(t=>{t?this.errorCb(t):e&&(this.success[e]=!0);}),t);}remove(){this.errorCb=null;}},Kt=Zt.getSessionAPI.bind(Zt),Ht=new Set;function Wt(t,e,r){r[t]&&-1!==r[t].indexOf(e)||(r[t]=r[t]||[],r[t].push(e));}function Jt(t,e,r){if(r&&r[t]){const n=r[t].indexOf(e);-1!==n&&r[t].splice(n,1);}}class Qt{constructor(t,e={}){z(this,e),this.type=t;}}class te extends Qt{constructor(t,e={}){super("error",z({error:t},e));}}class ee{on(t,e){return this._listeners=this._listeners||{},Wt(t,e,this._listeners),this}off(t,e){return Jt(t,e,this._listeners),Jt(t,e,this._oneTimeListeners),this}once(t,e){return e?(this._oneTimeListeners=this._oneTimeListeners||{},Wt(t,e,this._oneTimeListeners),this):new Promise((e=>this.once(t,e)))}fire(t,e){"string"==typeof t&&(t=new Qt(t,e||{}));const r=t.type;if(this.listens(r)){t.target=this;const e=this._listeners&&this._listeners[r]?this._listeners[r].slice():[];for(const r of e)r.call(this,t);const n=this._oneTimeListeners&&this._oneTimeListeners[r]?this._oneTimeListeners[r].slice():[];for(const e of n)Jt(r,e,this._oneTimeListeners),e.call(this,t);const i=this._eventedParent;i&&(z(t,"function"==typeof this._eventedParentData?this._eventedParentData():this._eventedParentData),i.fire(t));}else t instanceof te&&console.error(t.error);return this}listens(t){return !!(this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t))}setEventedParent(t,e){return this._eventedParent=t,this._eventedParentData=e,this}}t.y=void 0;var re={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function ne(t){return (t=Math.round(t))<0?0:t>255?255:t}function ie(t){return ne("%"===t[t.length-1]?parseFloat(t)/100*255:parseInt(t))}function ae(t){return (e="%"===t[t.length-1]?parseFloat(t)/100:parseFloat(t))<0?0:e>1?1:e;var e;}function se(t,e,r){return r<0?r+=1:r>1&&(r-=1),6*r<1?t+(e-t)*r*6:2*r<1?e:3*r<2?t+(e-t)*(2/3-r)*6:t}try{t.y={}.parseCSSColor=function(t){var e,r=t.replace(/ /g,"").toLowerCase();if(r in re)return re[r].slice();if("#"===r[0])return 4===r.length?(e=parseInt(r.substr(1),16))>=0&&e<=4095?[(3840&e)>>4|(3840&e)>>8,240&e|(240&e)>>4,15&e|(15&e)<<4,1]:null:7===r.length&&(e=parseInt(r.substr(1),16))>=0&&e<=16777215?[(16711680&e)>>16,(65280&e)>>8,255&e,1]:null;var n=r.indexOf("("),i=r.indexOf(")");if(-1!==n&&i+1===r.length){var a=r.substr(0,n),s=r.substr(n+1,i-(n+1)).split(","),o=1;switch(a){case"rgba":if(4!==s.length)return null;o=ae(s.pop());case"rgb":return 3!==s.length?null:[ie(s[0]),ie(s[1]),ie(s[2]),o];case"hsla":if(4!==s.length)return null;o=ae(s.pop());case"hsl":if(3!==s.length)return null;var l=(parseFloat(s[0])%360+360)%360/360,u=ae(s[1]),c=ae(s[2]),h=c<=.5?c*(u+1):c+u-c*u,p=2*c-h;return [ne(255*se(p,h,l+1/3)),ne(255*se(p,h,l)),ne(255*se(p,h,l-1/3)),o];default:return null}}return null};}catch(t){}class oe{constructor(t,e,r,n=1){this.r=t,this.g=e,this.b=r,this.a=n;}static parse(e){if(!e)return;if(e instanceof oe)return e;if("string"!=typeof e)return;const r=t.y(e);return r?new oe(r[0]/255*r[3],r[1]/255*r[3],r[2]/255*r[3],r[3]):void 0}toString(){const[t,e,r,n]=this.toArray();return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`}toArray(){const{r:t,g:e,b:r,a:n}=this;return 0===n?[0,0,0,0]:[255*t/n,255*e/n,255*r/n,n]}toArray01(){const{r:t,g:e,b:r,a:n}=this;return 0===n?[0,0,0,0]:[t/n,e/n,r/n,n]}toArray01Scaled(t){const{r:e,g:r,b:n,a:i}=this;return 0===i?[0,0,0]:[e/i*t,r/i*t,n/i*t]}toArray01PremultipliedAlpha(){const{r:t,g:e,b:r,a:n}=this;return [t,e,r,n]}toArray01Linear(){const{r:t,g:e,b:r,a:n}=this;return 0===n?[0,0,0,0]:[Math.pow(t/n,2.2),Math.pow(e/n,2.2),Math.pow(r/n,2.2),n]}}oe.black=new oe(0,0,0,1),oe.white=new oe(1,1,1,1),oe.transparent=new oe(0,0,0,0),oe.red=new oe(1,0,0,1),oe.blue=new oe(0,0,1,1);var le=oe;function ue(t,e,r){return t*(1-r)+e*r}function ce(t,e,r){return t.map(((t,n)=>ue(t,e[n],r)))}var he=Object.freeze({__proto__:null,array:ce,color:function(t,e,r){return new le(ue(t.r,e.r,r),ue(t.g,e.g,r),ue(t.b,e.b,r),ue(t.a,e.a,r))},number:ue});function pe(t,...e){for(const r of e)for(const e in r)t[e]=r[e];return t}class fe extends Error{constructor(t,e){super(e),this.message=e,this.key=t;}}var de=fe;class me{constructor(t,e=[]){this.parent=t,this.bindings={};for(const[t,r]of e)this.bindings[t]=r;}concat(t){return new me(this,t)}get(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(`${t} not found in scope.`)}has(t){return !!this.bindings[t]||!!this.parent&&this.parent.has(t)}}var ye=me;const ge={kind:"null"},xe={kind:"number"},ve={kind:"string"},be={kind:"boolean"},_e={kind:"color"},we={kind:"object"},Me={kind:"value"},Ae={kind:"collator"},Se={kind:"formatted"},Ie={kind:"resolvedImage"};function ke(t,e){return {kind:"array",itemType:t,N:e}}function Pe(t){if("array"===t.kind){const e=Pe(t.itemType);return "number"==typeof t.N?`array<${e}, ${t.N}>`:"value"===t.itemType.kind?"array":`array<${e}>`}return t.kind}const Ee=[ge,xe,ve,be,_e,Se,we,ke(Me),Ie];function ze(t,e){if("error"===e.kind)return null;if("array"===t.kind){if("array"===e.kind&&(0===e.N&&"value"===e.itemType.kind||!ze(t.itemType,e.itemType))&&("number"!=typeof t.N||t.N===e.N))return null}else {if(t.kind===e.kind)return null;if("value"===t.kind)for(const t of Ee)if(!ze(t,e))return null}return `Expected ${Pe(t)} but found ${Pe(e)} instead.`}function Te(t,e){return e.some((e=>e.kind===t.kind))}function Be(t,e){return e.some((e=>"null"===e?null===t:"array"===e?Array.isArray(t):"object"===e?t&&!Array.isArray(t)&&"object"==typeof t:e===typeof t))}class Ce{constructor(t,e,r){this.sensitivity=t?e?"variant":"case":e?"accent":"base",this.locale=r,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"});}compare(t,e){return this.collator.compare(t,e)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}}class Re{constructor(t,e,r,n,i){this.text=t.normalize?t.normalize():t,this.image=e,this.scale=r,this.fontStack=n,this.textColor=i;}}class De{constructor(t){this.sections=t;}static fromString(t){return new De([new Re(t,null,null,null,null)])}isEmpty(){return 0===this.sections.length||!this.sections.some((t=>0!==t.text.length||t.image&&0!==t.image.namePrimary.length))}static factory(t){return t instanceof De?t:De.fromString(t)}toString(){return 0===this.sections.length?"":this.sections.map((t=>t.text)).join("")}serialize(){const t=["format"];for(const e of this.sections){if(e.image){t.push(["image",e.image.namePrimary]);continue}t.push(e.text);const r={};e.fontStack&&(r["text-font"]=["literal",e.fontStack.split(",")]),e.scale&&(r["font-scale"]=e.scale),e.textColor&&(r["text-color"]=["rgba"].concat(e.textColor.toArray())),t.push(r);}return t}}class Ve{constructor(t){this.namePrimary=t.namePrimary,t.nameSecondary&&(this.nameSecondary=t.nameSecondary),this.available=t.available;}toString(){return this.nameSecondary?`[${this.namePrimary},${this.nameSecondary}]`:this.namePrimary}static fromString(t,e){return t?new Ve({namePrimary:t,nameSecondary:e,available:!1}):null}serialize(){return this.nameSecondary?["image",this.namePrimary,this.nameSecondary]:["image",this.namePrimary]}}function Le(t,e,r,n){return "number"==typeof t&&t>=0&&t<=255&&"number"==typeof e&&e>=0&&e<=255&&"number"==typeof r&&r>=0&&r<=255?void 0===n||"number"==typeof n&&n>=0&&n<=1?null:`Invalid rgba value [${[t,e,r,n].join(", ")}]: 'a' must be between 0 and 1.`:`Invalid rgba value [${("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`}function Fe(t){if(null===t)return !0;if("string"==typeof t)return !0;if("boolean"==typeof t)return !0;if("number"==typeof t)return !0;if(t instanceof le)return !0;if(t instanceof Ce)return !0;if(t instanceof De)return !0;if(t instanceof Ve)return !0;if(Array.isArray(t)){for(const e of t)if(!Fe(e))return !1;return !0}if("object"==typeof t){for(const e in t)if(!Fe(t[e]))return !1;return !0}return !1}function Ne(t){if(null===t)return ge;if("string"==typeof t)return ve;if("boolean"==typeof t)return be;if("number"==typeof t)return xe;if(t instanceof le)return _e;if(t instanceof Ce)return Ae;if(t instanceof De)return Se;if(t instanceof Ve)return Ie;if(Array.isArray(t)){const e=t.length;let r;for(const e of t){const t=Ne(e);if(r){if(r===t)continue;r=Me;break}r=t;}return ke(r||Me,e)}return we}function Oe(t){const e=typeof t;return null===t?"":"string"===e||"number"===e||"boolean"===e?String(t):t instanceof le||t instanceof De||t instanceof Ve?t.toString():JSON.stringify(t)}class Ue{constructor(t,e){this.type=t,this.value=e;}static parse(t,e){if(2!==t.length)return e.error(`'literal' expression requires exactly one argument, but found ${t.length-1} instead.`);if(!Fe(t[1]))return e.error("invalid value");const r=t[1];let n=Ne(r);const i=e.expectedType;return "array"!==n.kind||0!==n.N||!i||"array"!==i.kind||"number"==typeof i.N&&0!==i.N||(n=i),new Ue(n,r)}evaluate(){return this.value}eachChild(){}outputDefined(){return !0}serialize(){return "array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof le?["rgba"].concat(this.value.toArray()):this.value instanceof De?this.value.serialize():this.value}}var je=Ue,qe=class{constructor(t){this.name="ExpressionEvaluationError",this.message=t;}toJSON(){return this.message}};const $e={string:ve,number:xe,boolean:be,object:we};class Ge{constructor(t,e){this.type=t,this.args=e;}static parse(t,e){if(t.length<2)return e.error("Expected at least one argument.");let r,n=1;const i=t[0];if("array"===i){let i,a;if(t.length>2){const r=t[1];if("string"!=typeof r||!(r in $e)||"object"===r)return e.error('The item type argument of "array" must be one of string, number, boolean',1);i=$e[r],n++;}else i=Me;if(t.length>3){if(null!==t[2]&&("number"!=typeof t[2]||t[2]<0||t[2]!==Math.floor(t[2])))return e.error('The length argument to "array" must be a positive integer literal',2);a=t[2],n++;}r=ke(i,a);}else r=$e[i];const a=[];for(;n<t.length;n++){const r=e.parse(t[n],n,Me);if(!r)return null;a.push(r);}return new Ge(r,a)}evaluate(t){for(let e=0;e<this.args.length;e++){const r=this.args[e].evaluate(t);if(!ze(this.type,Ne(r)))return r;if(e===this.args.length-1)throw new qe(`Expected value to be of type ${Pe(this.type)}, but found ${Pe(Ne(r))} instead.`)}return null}eachChild(t){this.args.forEach(t);}outputDefined(){return this.args.every((t=>t.outputDefined()))}serialize(){const t=this.type,e=[t.kind];if("array"===t.kind){const r=t.itemType;if("string"===r.kind||"number"===r.kind||"boolean"===r.kind){e.push(r.kind);const n=t.N;("number"==typeof n||this.args.length>1)&&e.push(n);}}return e.concat(this.args.map((t=>t.serialize())))}}var Ye=Ge;class Xe{constructor(t){this.type=Se,this.sections=t;}static parse(t,e){if(t.length<2)return e.error("Expected at least one argument.");const r=t[1];if(!Array.isArray(r)&&"object"==typeof r)return e.error("First argument must be an image or text section.");const n=[];let i=!1;for(let r=1;r<=t.length-1;++r){const a=t[r];if(i&&"object"==typeof a&&!Array.isArray(a)){i=!1;let t=null;if(a["font-scale"]&&(t=e.parse(a["font-scale"],1,xe),!t))return null;let r=null;if(a["text-font"]&&(r=e.parse(a["text-font"],1,ke(ve)),!r))return null;let s=null;if(a["text-color"]&&(s=e.parse(a["text-color"],1,_e),!s))return null;const o=n[n.length-1];o.scale=t,o.font=r,o.textColor=s;}else {const a=e.parse(t[r],1,Me);if(!a)return null;const s=a.type.kind;if("string"!==s&&"value"!==s&&"null"!==s&&"resolvedImage"!==s)return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");i=!0,n.push({content:a,scale:null,font:null,textColor:null});}}return new Xe(n)}evaluate(t){return new De(this.sections.map((e=>{const r=e.content.evaluate(t);return Ne(r)===Ie?new Re("",r,null,null,null):new Re(Oe(r),null,e.scale?e.scale.evaluate(t):null,e.font?e.font.evaluate(t).join(","):null,e.textColor?e.textColor.evaluate(t):null)})))}eachChild(t){for(const e of this.sections)t(e.content),e.scale&&t(e.scale),e.font&&t(e.font),e.textColor&&t(e.textColor);}outputDefined(){return !1}serialize(){const t=["format"];for(const e of this.sections){t.push(e.content.serialize());const r={};e.scale&&(r["font-scale"]=e.scale.serialize()),e.font&&(r["text-font"]=e.font.serialize()),e.textColor&&(r["text-color"]=e.textColor.serialize()),t.push(r);}return t}}class Ze{constructor(t,e){this.type=Ie,this.inputPrimary=t,this.inputSecondary=e;}static parse(t,e){if(t.length<2)return e.error("Expected two or more arguments.");const r=e.parse(t[1],1,ve);if(!r)return e.error("No image name provided.");if(2===t.length)return new Ze(r);const n=e.parse(t[2],1,ve);return n?new Ze(r,n):e.error("Secondary image variant is not a string.")}evaluate(t){const e=Ve.fromString(this.inputPrimary.evaluate(t),this.inputSecondary?this.inputSecondary.evaluate(t):void 0);return e&&t.availableImages&&(e.available=t.availableImages.indexOf(e.namePrimary)>-1,e.nameSecondary&&e.available&&t.availableImages&&(e.available=t.availableImages.indexOf(e.nameSecondary)>-1)),e}eachChild(t){t(this.inputPrimary),this.inputSecondary&&t(this.inputSecondary);}outputDefined(){return !1}serialize(){return this.inputSecondary?["image",this.inputPrimary.serialize(),this.inputSecondary.serialize()]:["image",this.inputPrimary.serialize()]}}function Ke(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":null===t?"null":typeof t}const He={"to-boolean":be,"to-color":_e,"to-number":xe,"to-string":ve};class We{constructor(t,e){this.type=t,this.args=e;}static parse(t,e){if(t.length<2)return e.error("Expected at least one argument.");const r=t[0],n=[];let i=ge;if("to-array"===r){if(!Array.isArray(t[1]))return null;const r=t[1].length;if(e.expectedType){if("array"!==e.expectedType.kind)return e.error(`Expected ${e.expectedType.kind} but found array.`);i=ke(e.expectedType.itemType,r);}else {if(!(r>0&&Fe(t[1][0])))return null;i=ke(Ne(t[1][0]),r);}for(let a=0;a<r;a++){const r=t[1][a];let s;if("array"===Ke(r))s=e.parse(r,void 0,i.itemType);else {const t=Ke(r);if(t!==i.itemType.kind)return e.error(`Expected ${i.itemType.kind} but found ${t}.`);s=e.registry.literal.parse(["literal",void 0===r?null:r],e);}if(!s)return null;n.push(s);}}else {if(("to-boolean"===r||"to-string"===r)&&2!==t.length)return e.error("Expected one argument.");i=He[r];for(let r=1;r<t.length;r++){const i=e.parse(t[r],r,Me);if(!i)return null;n.push(i);}}return new We(i,n)}evaluate(t){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(t));if("color"===this.type.kind){let e,r;for(const n of this.args){if(e=n.evaluate(t),r=null,e instanceof le)return e;if("string"==typeof e){const r=t.parseColor(e);if(r)return r}else if(Array.isArray(e)&&(r=e.length<3||e.length>4?`Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.`:Le(e[0],e[1],e[2],e[3]),!r))return new le(e[0]/255,e[1]/255,e[2]/255,e[3])}throw new qe(r||`Could not parse color from value '${"string"==typeof e?e:String(JSON.stringify(e))}'`)}if("number"===this.type.kind){let e=null;for(const r of this.args){if(e=r.evaluate(t),null===e)return 0;const n=Number(e);if(!isNaN(n))return n}throw new qe(`Could not convert ${JSON.stringify(e)} to number.`)}return "formatted"===this.type.kind?De.fromString(Oe(this.args[0].evaluate(t))):"resolvedImage"===this.type.kind?Ve.fromString(Oe(this.args[0].evaluate(t))):"array"===this.type.kind?this.args.map((e=>e.evaluate(t))):Oe(this.args[0].evaluate(t))}eachChild(t){this.args.forEach(t);}outputDefined(){return this.args.every((t=>t.outputDefined()))}serialize(){if("formatted"===this.type.kind)return new Xe([{content:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("resolvedImage"===this.type.kind)return new Ze(this.args[0]).serialize();const t="array"===this.type.kind?[]:[`to-${this.type.kind}`];return this.eachChild((e=>{t.push(e.serialize());})),t}}var Je=We;const Qe=["Unknown","Point","LineString","Polygon"];var tr=class{constructor(t,e){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null,this.featureTileCoord=null,this.featureDistanceData=null,this.scope=t,this.options=e;}id(){return this.feature&&void 0!==this.feature.id?this.feature.id:null}geometryType(){return this.feature?"number"==typeof this.feature.type?Qe[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}measureLight(t){return this.globals.brightness||0}distanceFromCenter(){if(this.featureTileCoord&&this.featureDistanceData){const t=this.featureDistanceData.center,e=this.featureDistanceData.scale,{x:r,y:n}=this.featureTileCoord;return this.featureDistanceData.bearing[0]*(r*e-t[0])+this.featureDistanceData.bearing[1]*(n*e-t[1])}return 0}parseColor(t){let e=this._parseColorCache[t];return e||(e=this._parseColorCache[t]=le.parse(t)),e}getConfig(t){return this.options?this.options.get(t):null}};class er{constructor(t,e,r,n,i){this.name=t,this.type=e,this._evaluate=r,this.args=n,this._overloadIndex=i;}evaluate(t){if(!this._evaluate){const t=er.definitions[this.name];this._evaluate=Array.isArray(t)?t[2]:t.overloads[this._overloadIndex][1];}return this._evaluate(t,this.args)}eachChild(t){this.args.forEach(t);}outputDefined(){return !1}serialize(){return [this.name].concat(this.args.map((t=>t.serialize())))}static parse(t,e){const r=t[0],n=er.definitions[r];if(!n)return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`,0);const i=Array.isArray(n)?n[0]:n.type,a=Array.isArray(n)?[[n[1],n[2]]]:n.overloads,s=[];let o=null,l=-1;for(const[n,u]of a){if(Array.isArray(n)&&n.length!==t.length-1)continue;s.push(n),l++,o=new _n(e.registry,e.path,null,e.scope,void 0,e._scope,e.options);const a=[];let c=!1;for(let e=1;e<t.length;e++){const r=t[e],i=Array.isArray(n)?n[e-1]:n.type,s=o.parse(r,1+a.length,i);if(!s){c=!0;break}a.push(s);}if(!c)if(Array.isArray(n)&&n.length!==a.length)o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {for(let t=0;t<a.length;t++){const e=Array.isArray(n)?n[t]:n.type,r=a[t];o.concat(t+1).checkSubtype(e,r.type);}if(0===o.errors.length)return new er(r,i,u,a,l)}}if(1===s.length)e.errors.push(...o.errors);else {const r=(s.length?s:a.map((([t])=>t))).map(rr).join(" | "),n=[];for(let r=1;r<t.length;r++){const i=e.parse(t[r],1+n.length);if(!i)return null;n.push(Pe(i.type));}e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);}return null}static register(t,e){er.definitions=e;for(const r in e)t[r]=er;}}function rr(t){return Array.isArray(t)?`(${t.map(Pe).join(", ")})`:`(${Pe(t.type)}...)`}var nr=er;class ir{constructor(t,e,r){this.type=Ae,this.locale=r,this.caseSensitive=t,this.diacriticSensitive=e;}static parse(t,e){if(2!==t.length)return e.error("Expected one argument.");const r=t[1];if("object"!=typeof r||Array.isArray(r))return e.error("Collator options argument must be an object.");const n=e.parse(void 0!==r["case-sensitive"]&&r["case-sensitive"],1,be);if(!n)return null;const i=e.parse(void 0!==r["diacritic-sensitive"]&&r["diacritic-sensitive"],1,be);if(!i)return null;let a=null;return r.locale&&(a=e.parse(r.locale,1,ve),!a)?null:new ir(n,i,a)}evaluate(t){return new Ce(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)}eachChild(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale);}outputDefined(){return !1}serialize(){const t={};return t["case-sensitive"]=this.caseSensitive.serialize(),t["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(t.locale=this.locale.serialize()),["collator",t]}}var ar={exports:{}};ar.exports=function(){function t(r,n,i,a,s){for(;a>i;){if(a-i>600){var o=a-i+1,l=n-i+1,u=Math.log(o),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(o-c)/o)*(l-o/2<0?-1:1);t(r,n,Math.max(i,Math.floor(n-l*c/o+h)),Math.min(a,Math.floor(n+(o-l)*c/o+h)),s);}var p=r[n],f=i,d=a;for(e(r,i,n),s(r[a],p)>0&&e(r,i,a);f<d;){for(e(r,f,d),f++,d--;s(r[f],p)<0;)f++;for(;s(r[d],p)>0;)d--;}0===s(r[i],p)?e(r,i,d):e(r,++d,a),d<=n&&(i=d+1),n<=d&&(a=d-1);}}function e(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}function r(t,e){return t<e?-1:t>e?1:0}return function(e,n,i,a,s){t(e,n,i||0,a||e.length-1,s||r);}}();var sr=h(ar.exports);function or(t){let e=0;for(let r,n,i=0,a=t.length,s=a-1;i<a;s=i++)r=t[i],n=t[s],e+=(n.x-r.x)*(r.y+n.y);return e}function lr(t,e){t[0]=Math.min(t[0],e[0]),t[1]=Math.min(t[1],e[1]),t[2]=Math.max(t[2],e[0]),t[3]=Math.max(t[3],e[1]);}function ur(t,e){return !(t[0]<=e[0]||t[2]>=e[2]||t[1]<=e[1]||t[3]>=e[3])}function cr(t,e,r){const n=t[0]-e[0],i=t[1]-e[1],a=t[0]-r[0],s=t[1]-r[1];return n*s-a*i==0&&n*a<=0&&i*s<=0}function hr(t,e,r=!1){let n=!1;for(let o=0,l=e.length;o<l;o++){const l=e[o];for(let e=0,o=l.length,u=o-1;e<o;u=e++){const o=l[u],c=l[e];if(cr(t,o,c))return r;(a=o)[1]>(i=t)[1]!=(s=c)[1]>i[1]&&i[0]<(s[0]-a[0])*(i[1]-a[1])/(s[1]-a[1])+a[0]&&(n=!n);}}var i,a,s;return n}function pr(t,e,r,n){const i=n[0]-r[0],a=n[1]-r[1],s=(t[0]-r[0])*a-i*(t[1]-r[1]),o=(e[0]-r[0])*a-i*(e[1]-r[1]);return s>0&&o<0||s<0&&o>0}function fr(t,e,r,n){return 0!=(i=[n[0]-r[0],n[1]-r[1]])[0]*(a=[e[0]-t[0],e[1]-t[1]])[1]-i[1]*a[0]&&!(!pr(t,e,r,n)||!pr(r,n,t,e));var i,a;}const dr=8192;function mr(t,e){const r=(180+t[0])/360,n=(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t[1]*Math.PI/360)))/360,i=Math.pow(2,e.z);return [Math.round(r*i*dr),Math.round(n*i*dr)]}function yr(t,e){for(let r=0;r<e.length;r++)if(hr(t,e[r]))return !0;return !1}function gr(t,e,r){for(const n of r)for(let r=0,i=n.length,a=i-1;r<i;a=r++)if(fr(t,e,n[a],n[r]))return !0;return !1}function xr(t,e){for(let r=0;r<t.length;++r)if(!hr(t[r],e))return !1;for(let r=0;r<t.length-1;++r)if(gr(t[r],t[r+1],e))return !1;return !0}function vr(t,e){for(let r=0;r<e.length;r++)if(xr(t,e[r]))return !0;return !1}function br(t,e,r){const n=[];for(let i=0;i<t.length;i++){const a=[];for(let n=0;n<t[i].length;n++){const s=mr(t[i][n],r);lr(e,s),a.push(s);}n.push(a);}return n}function _r(t,e,r){const n=[];for(let i=0;i<t.length;i++){const a=br(t[i],e,r);n.push(a);}return n}function wr(t,e,r,n){if(t[0]<r[0]||t[0]>r[2]){const e=.5*n;let i=t[0]-r[0]>e?-n:r[0]-t[0]>e?n:0;0===i&&(i=t[0]-r[2]>e?-n:r[2]-t[0]>e?n:0),t[0]+=i;}lr(e,t);}function Mr(t,e,r,n){const i=Math.pow(2,n.z)*dr,a=[n.x*dr,n.y*dr],s=[];if(!t)return s;for(const n of t)for(const t of n){const n=[t.x+a[0],t.y+a[1]];wr(n,e,r,i),s.push(n);}return s}function Ar(t,e,r,n){const i=Math.pow(2,n.z)*dr,a=[n.x*dr,n.y*dr],s=[];if(!t)return s;for(const r of t){const t=[];for(const n of r){const r=[n.x+a[0],n.y+a[1]];lr(e,r),t.push(r);}s.push(t);}if(e[2]-e[0]<=i/2){(o=e)[0]=o[1]=1/0,o[2]=o[3]=-1/0;for(const t of s)for(const n of t)wr(n,e,r,i);}var o;return s}class Sr{constructor(t,e){this.type=be,this.geojson=t,this.geometries=e;}static parse(t,e){if(2!==t.length)return e.error(`'within' expression requires exactly one argument, but found ${t.length-1} instead.`);if(Fe(t[1])){const e=t[1];if("FeatureCollection"===e.type)for(let t=0;t<e.features.length;++t){const r=e.features[t].geometry.type;if("Polygon"===r||"MultiPolygon"===r)return new Sr(e,e.features[t].geometry)}else if("Feature"===e.type){const t=e.geometry.type;if("Polygon"===t||"MultiPolygon"===t)return new Sr(e,e.geometry)}else if("Polygon"===e.type||"MultiPolygon"===e.type)return new Sr(e,e)}return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(null!=t.geometry()&&null!=t.canonicalID()){if("Point"===t.geometryType())return function(t,e){const r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(!i)return !1;if("Polygon"===e.type){const a=br(e.coordinates,n,i),s=Mr(t.geometry(),r,n,i);if(!ur(r,n))return !1;for(const t of s)if(!hr(t,a))return !1}if("MultiPolygon"===e.type){const a=_r(e.coordinates,n,i),s=Mr(t.geometry(),r,n,i);if(!ur(r,n))return !1;for(const t of s)if(!yr(t,a))return !1}return !0}(t,this.geometries);if("LineString"===t.geometryType())return function(t,e){const r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(!i)return !1;if("Polygon"===e.type){const a=br(e.coordinates,n,i),s=Ar(t.geometry(),r,n,i);if(!ur(r,n))return !1;for(const t of s)if(!xr(t,a))return !1}if("MultiPolygon"===e.type){const a=_r(e.coordinates,n,i),s=Ar(t.geometry(),r,n,i);if(!ur(r,n))return !1;for(const t of s)if(!vr(t,a))return !1}return !0}(t,this.geometries)}return !1}eachChild(){}outputDefined(){return !0}serialize(){return ["within",this.geojson]}}var Ir=Sr,kr={exports:{}};kr.exports=function(){var t={kilometers:1,miles:1e3/1609.344,nauticalmiles:1e3/1852,meters:1e3,metres:1e3,yards:1e3/.9144,feet:1e3/.3048,inches:1e3/.0254},e=1/298.257223563,r=e*(2-e),n=Math.PI/180,i=function(e,i){if(void 0===e)throw new Error("No latitude given.");if(i&&!t[i])throw new Error("Unknown unit "+i+". Use one of: "+Object.keys(t).join(", "));var a=6378.137*n*(i?t[i]:1),s=Math.cos(e*n),o=1/(1-r*(1-s*s)),l=Math.sqrt(o);this.kx=a*l*s,this.ky=a*l*o*(1-r);},a={units:{configurable:!0}};function s(t,e){return t[0]===e[0]&&t[1]===e[1]}function o(t,e,r){var n=l(e[0]-t[0]);return [t[0]+n*r,t[1]+(e[1]-t[1])*r]}function l(t){for(;t<-180;)t+=360;for(;t>180;)t-=360;return t}return i.fromTile=function(t,e,r){var a=Math.PI*(1-2*(t+.5)/Math.pow(2,e)),s=Math.atan(.5*(Math.exp(a)-Math.exp(-a)))/n;return new i(s,r)},a.units.get=function(){return t},i.prototype.distance=function(t,e){var r=l(t[0]-e[0])*this.kx,n=(t[1]-e[1])*this.ky;return Math.sqrt(r*r+n*n)},i.prototype.bearing=function(t,e){var r=l(e[0]-t[0])*this.kx;return Math.atan2(r,(e[1]-t[1])*this.ky)/n},i.prototype.destination=function(t,e,r){var i=r*n;return this.offset(t,Math.sin(i)*e,Math.cos(i)*e)},i.prototype.offset=function(t,e,r){return [t[0]+e/this.kx,t[1]+r/this.ky]},i.prototype.lineDistance=function(t){for(var e=0,r=0;r<t.length-1;r++)e+=this.distance(t[r],t[r+1]);return e},i.prototype.area=function(t){for(var e=0,r=0;r<t.length;r++)for(var n=t[r],i=0,a=n.length,s=a-1;i<a;s=i++)e+=l(n[i][0]-n[s][0])*(n[i][1]+n[s][1])*(r?-1:1);return Math.abs(e)/2*this.kx*this.ky},i.prototype.along=function(t,e){var r=0;if(e<=0)return t[0];for(var n=0;n<t.length-1;n++){var i=t[n],a=t[n+1],s=this.distance(i,a);if((r+=s)>e)return o(i,a,(e-(r-s))/s)}return t[t.length-1]},i.prototype.pointToSegmentDistance=function(t,e,r){var n=e[0],i=e[1],a=l(r[0]-n)*this.kx,s=(r[1]-i)*this.ky,o=0;return 0===a&&0===s||((o=(l(t[0]-n)*this.kx*a+(t[1]-i)*this.ky*s)/(a*a+s*s))>1?(n=r[0],i=r[1]):o>0&&(n+=a/this.kx*o,i+=s/this.ky*o)),a=l(t[0]-n)*this.kx,s=(t[1]-i)*this.ky,Math.sqrt(a*a+s*s)},i.prototype.pointOnLine=function(t,e){for(var r,n,i,a,s=1/0,o=0;o<t.length-1;o++){var u=t[o][0],c=t[o][1],h=l(t[o+1][0]-u)*this.kx,p=(t[o+1][1]-c)*this.ky,f=0;0===h&&0===p||((f=(l(e[0]-u)*this.kx*h+(e[1]-c)*this.ky*p)/(h*h+p*p))>1?(u=t[o+1][0],c=t[o+1][1]):f>0&&(u+=h/this.kx*f,c+=p/this.ky*f));var d=(h=l(e[0]-u)*this.kx)*h+(p=(e[1]-c)*this.ky)*p;d<s&&(s=d,r=u,n=c,i=o,a=f);}return {point:[r,n],index:i,t:Math.max(0,Math.min(1,a))}},i.prototype.lineSlice=function(t,e,r){var n=this.pointOnLine(r,t),i=this.pointOnLine(r,e);if(n.index>i.index||n.index===i.index&&n.t>i.t){var a=n;n=i,i=a;}var o=[n.point],l=n.index+1,u=i.index;!s(r[l],o[0])&&l<=u&&o.push(r[l]);for(var c=l+1;c<=u;c++)o.push(r[c]);return s(r[u],i.point)||o.push(i.point),o},i.prototype.lineSliceAlong=function(t,e,r){for(var n=0,i=[],a=0;a<r.length-1;a++){var s=r[a],l=r[a+1],u=this.distance(s,l);if((n+=u)>t&&0===i.length&&i.push(o(s,l,(t-(n-u))/u)),n>=e)return i.push(o(s,l,(e-(n-u))/u)),i;n>t&&i.push(l);}return i},i.prototype.bufferPoint=function(t,e){var r=e/this.ky,n=e/this.kx;return [t[0]-n,t[1]-r,t[0]+n,t[1]+r]},i.prototype.bufferBBox=function(t,e){var r=e/this.ky,n=e/this.kx;return [t[0]-n,t[1]-r,t[2]+n,t[3]+r]},i.prototype.insideBBox=function(t,e){return l(t[0]-e[0])>=0&&l(t[0]-e[2])<=0&&t[1]>=e[1]&&t[1]<=e[3]},Object.defineProperties(i,a),i}();var Pr=h(kr.exports),Er={exports:{}};Er.exports=function(){var t=function(t,r){if(void 0===t&&(t=[]),void 0===r&&(r=e),this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(var n=(this.length>>1)-1;n>=0;n--)this._down(n);};function e(t,e){return t<e?-1:t>e?1:0}return t.prototype.push=function(t){this.data.push(t),this.length++,this._up(this.length-1);},t.prototype.pop=function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}},t.prototype.peek=function(){return this.data[0]},t.prototype._up=function(t){for(var e=this.data,r=this.compare,n=e[t];t>0;){var i=t-1>>1,a=e[i];if(r(n,a)>=0)break;e[t]=a,t=i;}e[t]=n;},t.prototype._down=function(t){for(var e=this.data,r=this.compare,n=this.length>>1,i=e[t];t<n;){var a=1+(t<<1),s=e[a],o=a+1;if(o<this.length&&r(e[o],s)<0&&(a=o,s=e[o]),r(s,i)>=0)break;e[t]=s,t=a;}e[t]=i;},t}();var zr=h(Er.exports),Tr=8192;function Br(t,e){return e.dist-t.dist}const Cr=100,Rr=50;function Dr(t){const e=[1/0,1/0,-1/0,-1/0];if(e.length!==t.length)return !1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return !1;return !0}function Vr(t){return t[1]-t[0]+1}function Lr(t,e){const r=t[1]>=t[0]&&t[1]<e;return r||console.warn("Distance Expression: Index is out of range"),r}function Fr(t,e){if(t[0]>t[1])return [null,null];const r=Vr(t);if(e){if(2===r)return [t,null];const e=Math.floor(r/2);return [[t[0],t[0]+e],[t[0]+e,t[1]]]}{if(1===r)return [t,null];const e=Math.floor(r/2)-1;return [[t[0],t[0]+e],[t[0]+e+1,t[1]]]}}function Nr(t,e){const r=[1/0,1/0,-1/0,-1/0];if(!Lr(e,t.length))return r;for(let n=e[0];n<=e[1];++n)lr(r,t[n]);return r}function Or(t){const e=[1/0,1/0,-1/0,-1/0];for(let r=0;r<t.length;++r)for(let n=0;n<t[r].length;++n)lr(e,t[r][n]);return e}function Ur(t,e,r){if(Dr(t)||Dr(e))return NaN;let n=0,i=0;return t[2]<e[0]&&(n=e[0]-t[2]),t[0]>e[2]&&(n=t[0]-e[2]),t[1]>e[3]&&(i=t[1]-e[3]),t[3]<e[1]&&(i=e[1]-t[3]),r.distance([0,0],[n,i])}function jr(t){return 360*t-180}function qr(t){return 360/Math.PI*Math.atan(Math.exp((180-360*t)*Math.PI/180))-90}function $r(t,e){const r=Math.pow(2,e.z),n=(t.y/Tr+e.y)/r;return [jr((t.x/Tr+e.x)/r),qr(n)]}function Gr(t,e){const r=[];for(let n=0;n<t.length;++n)r.push($r(t[n],e));return r}function Yr(t,e,r){const n=r.pointOnLine(e,t).point;return r.distance(t,n)}function Xr(t,e,r,n,i){const a=r.slice(n[0],n[1]+1);let s=1/0;for(let r=e[0];r<=e[1];++r)if(0===(s=Math.min(s,Yr(t[r],a,i))))return 0;return s}function Zr(t,e,r,n,i){const a=Math.min(i.pointToSegmentDistance(t,r,n),i.pointToSegmentDistance(e,r,n)),s=Math.min(i.pointToSegmentDistance(r,t,e),i.pointToSegmentDistance(n,t,e));return Math.min(a,s)}function Kr(t,e,r,n,i){if(!Lr(e,t.length)||!Lr(n,r.length))return NaN;let a=1/0;for(let s=e[0];s<e[1];++s)for(let e=n[0];e<n[1];++e){if(fr(t[s],t[s+1],r[e],r[e+1]))return 0;a=Math.min(a,Zr(t[s],t[s+1],r[e],r[e+1],i));}return a}function Hr(t,e,r,n,i){if(!Lr(e,t.length)||!Lr(n,r.length))return NaN;let a=1/0;for(let s=e[0];s<=e[1];++s)for(let e=n[0];e<=n[1];++e)if(0===(a=Math.min(a,i.distance(t[s],r[e]))))return a;return a}function Wr(t,e,r){if(hr(t,e,!0))return 0;let n=1/0;for(const i of e){const e=i.length;if(e<2)return console.warn("Distance Expression: Invalid polygon!"),NaN;if(i[0]!==i[e-1]&&0===(n=Math.min(n,r.pointToSegmentDistance(t,i[e-1],i[0]))))return n;if(0===(n=Math.min(n,Yr(t,i,r))))return n}return n}function Jr(t,e,r,n){if(!Lr(e,t.length))return NaN;for(let n=e[0];n<=e[1];++n)if(hr(t[n],r,!0))return 0;let i=1/0;for(let a=e[0];a<e[1];++a)for(const e of r)for(let r=0,s=e.length,o=s-1;r<s;o=r++){if(fr(t[a],t[a+1],e[o],e[r]))return 0;i=Math.min(i,Zr(t[a],t[a+1],e[o],e[r],n));}return i}function Qr(t,e){for(const r of t)for(let t=0;t<=r.length-1;++t)if(hr(r[t],e,!0))return !0;return !1}function tn(t,e,r,n=1/0){const i=Or(t),a=Or(e);if(n!==1/0&&Ur(i,a,r)>=n)return n;if(ur(i,a)){if(Qr(t,e))return 0}else if(Qr(e,t))return 0;let s=n;for(const n of t)for(let t=0,i=n.length,a=i-1;t<i;a=t++)for(const i of e)for(let e=0,o=i.length,l=o-1;e<o;l=e++){if(fr(n[a],n[t],i[l],i[e]))return 0;s=Math.min(s,Zr(n[a],n[t],i[l],i[e],r));}return s}function en(t,e,r,n,i,a,s){if(null===a||null===s)return;const o=Ur(Nr(n,a),Nr(i,s),r);o<e&&t.push({dist:o,range1:a,range2:s});}function rn(t,e,r,n,i=1/0){let a=Math.min(n.distance(t[0],r[0][0]),i);if(0===a)return a;const s=new zr([{dist:0,range1:[0,t.length-1],range2:[0,0]}],Br),o=e?Rr:Cr,l=Or(r);for(;s.length;){const i=s.pop();if(i.dist>=a)continue;const u=i.range1;if(Vr(u)<=o){if(!Lr(u,t.length))return NaN;if(e){const e=Jr(t,u,r,n);if(0===(a=Math.min(a,e)))return a}else for(let e=u[0];e<=u[1];++e){const i=Wr(t[e],r,n);if(0===(a=Math.min(a,i)))return a}}else {const r=Fr(u,e);if(null!==r[0]){const e=Ur(Nr(t,r[0]),l,n);e<a&&s.push({dist:e,range1:r[0],range2:[0,0]});}if(null!==r[1]){const e=Ur(Nr(t,r[1]),l,n);e<a&&s.push({dist:e,range1:r[1],range2:[0,0]});}}}return a}function nn(t,e,r,n,i,a=1/0){let s=Math.min(a,i.distance(t[0],r[0]));if(0===s)return s;const o=new zr([{dist:0,range1:[0,t.length-1],range2:[0,r.length-1]}],Br),l=e?Rr:Cr,u=n?Rr:Cr;for(;o.length;){const a=o.pop();if(a.dist>=s)continue;const c=a.range1,h=a.range2;if(Vr(c)<=l&&Vr(h)<=u){if(!Lr(c,t.length)||!Lr(h,r.length))return NaN;if(e&&n?s=Math.min(s,Kr(t,c,r,h,i)):e||n?e&&!n?s=Math.min(s,Xr(r,h,t,c,i)):!e&&n&&(s=Math.min(s,Xr(t,c,r,h,i))):s=Math.min(s,Hr(t,c,r,h,i)),0===s)return s}else {const a=Fr(c,e),l=Fr(h,n);en(o,s,i,t,r,a[0],l[0]),en(o,s,i,t,r,a[0],l[1]),en(o,s,i,t,r,a[1],l[0]),en(o,s,i,t,r,a[1],l[1]);}}return s}function an(t,e,r,n,i=1/0){let a=i;const s=Nr(t,[0,t.length-1]);for(const i of r)if(!(a!==1/0&&Ur(s,Nr(i,[0,i.length-1]),n)>=a)&&(a=Math.min(a,nn(t,e,i,!0,n,a)),0===a))return a;return a}function sn(t,e,r,n,i=1/0){let a=i;const s=Nr(t,[0,t.length-1]);for(const i of r){if(a!==1/0&&Ur(s,Or(i),n)>=a)continue;const r=rn(t,e,i,n,a);if(isNaN(r))return r;if(0===(a=Math.min(a,r)))return a}return a}function on(t){return "Point"===t||"MultiPoint"===t||"LineString"===t||"MultiLineString"===t||"Polygon"===t||"MultiPolygon"===t}class ln{constructor(t,e){this.type=xe,this.geojson=t,this.geometries=e;}static parse(t,e){if(2!==t.length)return e.error(`'distance' expression requires either one argument, but found ' ${t.length-1} instead.`);if(Fe(t[1])){const e=t[1];if("FeatureCollection"===e.type){for(let t=0;t<e.features.length;++t)if(on(e.features[t].geometry.type))return new ln(e,e.features[t].geometry)}else if("Feature"===e.type){if(on(e.geometry.type))return new ln(e,e.geometry)}else if(on(e.type))return new ln(e,e)}return e.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].")}evaluate(t){const e=t.geometry(),r=t.canonicalID();if(null!=e&&null!=r){if("Point"===t.geometryType())return function(t,e,r){const n=[];for(const r of t)for(const t of r)n.push($r(t,e));const i=new Pr(n[0][1],"meters");return "Point"===r.type||"MultiPoint"===r.type||"LineString"===r.type?nn(n,!1,"Point"===r.type?[r.coordinates]:r.coordinates,"LineString"===r.type,i):"MultiLineString"===r.type?an(n,!1,r.coordinates,i):"Polygon"===r.type||"MultiPolygon"===r.type?sn(n,!1,"Polygon"===r.type?[r.coordinates]:r.coordinates,i):null}(e,r,this.geometries);if("LineString"===t.geometryType())return function(t,e,r){const n=[];for(const r of t){const t=[];for(const n of r)t.push($r(n,e));n.push(t);}const i=new Pr(n[0][0][1],"meters");if("Point"===r.type||"MultiPoint"===r.type||"LineString"===r.type)return an("Point"===r.type?[r.coordinates]:r.coordinates,"LineString"===r.type,n,i);if("MultiLineString"===r.type){let t=1/0;for(let e=0;e<r.coordinates.length;e++){const a=an(r.coordinates[e],!0,n,i,t);if(isNaN(a))return a;if(0===(t=Math.min(t,a)))return t}return t}if("Polygon"===r.type||"MultiPolygon"===r.type){let t=1/0;for(let e=0;e<n.length;e++){const a=sn(n[e],!0,"Polygon"===r.type?[r.coordinates]:r.coordinates,i,t);if(isNaN(a))return a;if(0===(t=Math.min(t,a)))return t}return t}return null}(e,r,this.geometries);if("Polygon"===t.geometryType())return function(t,e,r){const n=[];for(const r of function(t,e){const r=t.length;if(r<=1)return [t];const n=[];let i,a;for(let e=0;e<r;e++){const r=or(t[e]);0!==r&&(t[e].area=Math.abs(r),void 0===a&&(a=r<0),a===r<0?(i&&n.push(i),i=[t[e]]):i.push(t[e]));}return i&&n.push(i),n}(t)){const t=[];for(let n=0;n<r.length;++n)t.push(Gr(r[n],e));n.push(t);}const i=new Pr(n[0][0][0][1],"meters");if("Point"===r.type||"MultiPoint"===r.type||"LineString"===r.type)return sn("Point"===r.type?[r.coordinates]:r.coordinates,"LineString"===r.type,n,i);if("MultiLineString"===r.type){let t=1/0;for(let e=0;e<r.coordinates.length;e++){const a=sn(r.coordinates[e],!0,n,i,t);if(isNaN(a))return a;if(0===(t=Math.min(t,a)))return t}return t}return "Polygon"===r.type||"MultiPolygon"===r.type?function(t,e,r){let n=1/0;for(const i of t)for(const t of e){const e=tn(i,t,r,n);if(isNaN(e))return e;if(0===(n=Math.min(n,e)))return n}return n}("Polygon"===r.type?[r.coordinates]:r.coordinates,n,i):null}(e,r,this.geometries);console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");}else console.warn("Distance Expression: requirs valid feature and canonical information.");return null}eachChild(){}outputDefined(){return !0}serialize(){return ["distance",this.geojson]}}var un=ln;function cn(t,e){switch(t){case"string":return Oe(e);case"number":return +e;case"boolean":return !!e;case"color":return le.parse(e);case"formatted":return De.fromString(Oe(e));case"resolvedImage":return Ve.fromString(Oe(e))}return e}function hn(t,e,r,n){return void 0!==n&&(t=n*Math.round(t/n)),void 0!==e&&t<e&&(t=e),void 0!==r&&t>r&&(t=r),t}class pn{constructor(t,e,r){this.type=t,this.key=e,this.scope=r;}static parse(t,e){let r=e.expectedType;if(null==r&&(r=Me),t.length<2||t.length>3)return e.error("Invalid number of arguments for 'config' expression.");const n=e.parse(t[1],1);if(!(n instanceof je))return e.error("Key name of 'config' expression must be a string literal.");if(t.length>=3){const i=e.parse(t[2],2);return i instanceof je?new pn(r,Oe(n.value),Oe(i.value)):e.error("Scope of 'config' expression must be a string literal.")}return new pn(r,Oe(n.value))}evaluate(t){const e=[this.key,this.scope,t.scope].filter(Boolean).join(""),r=t.getConfig(e);if(!r)return null;const{type:n,value:i,values:a,minValue:s,maxValue:o,stepValue:l}=r,u=r.default.evaluate(t);let c=u;if(i){const e=t.scope;t.scope=(e||"").split("").slice(1).join(""),c=i.evaluate(t),t.scope=e;}return n&&(c=cn(n,c)),void 0===c||void 0===s&&void 0===o&&void 0===l||("number"==typeof c?c=hn(c,s,o,l):Array.isArray(c)&&(c=c.map((t=>"number"==typeof t?hn(t,s,o,l):t)))),void 0!==i&&void 0!==c&&a&&!a.includes(c)&&(c=u,n&&(c=cn(n,c))),(n&&n!==this.type||void 0!==c&&Ne(c)!==this.type)&&(c=cn(this.type.kind,c)),c}eachChild(){}outputDefined(){return !1}serialize(){const t=["config",this.key];return this.scope&&t.concat(this.key),t}}var fn=pn;function dn(t){if(t instanceof nr){if("get"===t.name&&1===t.args.length)return !1;if("feature-state"===t.name)return !1;if("has"===t.name&&1===t.args.length)return !1;if("properties"===t.name||"geometry-type"===t.name||"id"===t.name)return !1;if(/^filter-/.test(t.name))return !1}if(t instanceof Ir)return !1;if(t instanceof un)return !1;let e=!0;return t.eachChild((t=>{e&&!dn(t)&&(e=!1);})),e}function mn(t){if(t instanceof nr&&"feature-state"===t.name)return !1;let e=!0;return t.eachChild((t=>{e&&!mn(t)&&(e=!1);})),e}function yn(t){if(t instanceof fn)return !1;let e=!0;return t.eachChild((t=>{e&&!yn(t)&&(e=!1);})),e}function gn(t,e){if(t instanceof nr&&e.indexOf(t.name)>=0)return !1;let r=!0;return t.eachChild((t=>{r&&!gn(t,e)&&(r=!1);})),r}class xn{constructor(t,e){this.type=e.type,this.name=t,this.boundExpression=e;}static parse(t,e){if(2!==t.length||"string"!=typeof t[1])return e.error("'var' expression requires exactly one string literal argument.");const r=t[1];return e.scope.has(r)?new xn(r,e.scope.get(r)):e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(t){return this.boundExpression.evaluate(t)}eachChild(){}outputDefined(){return !1}serialize(){return ["var",this.name]}}var vn=xn;class bn{constructor(t,e=[],r,n=new ye,i=[],a,s){this.registry=t,this.path=e,this.key=e.map((t=>`[${t}]`)).join(""),this.scope=n,this.errors=i,this.expectedType=r,this._scope=a,this.options=s;}parse(t,e,r,n,i={}){return e||r?this.concat(e,r,n)._parse(t,i):this._parse(t,i)}_parse(t,e){function r(t,e,r){return "assert"===r?new Ye(e,[t]):"coerce"===r?new Je(e,[t]):t}if(null!==t&&"string"!=typeof t&&"boolean"!=typeof t&&"number"!=typeof t||(t=["literal",t]),Array.isArray(t)){if(0===t.length)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');const n="string"==typeof t[0]?this.registry[t[0]]:void 0;if(n){let i=n.parse(t,this);if(!i)return null;if(this.expectedType){const t=this.expectedType,n=i.type;if("string"!==t.kind&&"number"!==t.kind&&"boolean"!==t.kind&&"object"!==t.kind&&"array"!==t.kind||"value"!==n.kind)if("color"!==t.kind&&"formatted"!==t.kind&&"resolvedImage"!==t.kind||"value"!==n.kind&&"string"!==n.kind){if(this.checkSubtype(t,n))return null}else i=r(i,t,e.typeAnnotation||"coerce");else i=r(i,t,e.typeAnnotation||"assert");}if(!(i instanceof je)&&"resolvedImage"!==i.type.kind&&wn(i)){const t=new tr(this._scope,this.options);try{i=new je(i.type,i.evaluate(t));}catch(t){return this.error(t.message),null}}return i}return Je.parse(["to-array",t],this)}return this.error(void 0===t?"'undefined' value invalid. Use null instead.":"object"==typeof t?'Bare objects invalid. Use ["literal", {...}] instead.':`Expected an array, but found ${typeof t} instead.`)}concat(t,e,r){const n="number"==typeof t?this.path.concat(t):this.path,i=r?this.scope.concat(r):this.scope;return new bn(this.registry,n,e||null,i,this.errors,this._scope,this.options)}error(t,...e){const r=`${this.key}${e.map((t=>`[${t}]`)).join("")}`;this.errors.push(new de(r,t));}checkSubtype(t,e){const r=ze(t,e);return r&&this.error(r),r}}var _n=bn;function wn(t){if(t instanceof vn)return wn(t.boundExpression);if(t instanceof nr&&"error"===t.name)return !1;if(t instanceof ir)return !1;if(t instanceof Ir)return !1;if(t instanceof un)return !1;if(t instanceof fn)return !1;const e=t instanceof Je||t instanceof Ye;let r=!0;return t.eachChild((t=>{r=e?r&&wn(t):r&&t instanceof je;})),!!r&&dn(t)&&gn(t,["zoom","heatmap-density","line-progress","raster-value","sky-radial-progress","accumulated","is-supported-script","pitch","distance-from-center","measure-light","raster-particle-speed"])}function Mn(t,e){const r=t.length-1;let n,i,a=0,s=r,o=0;for(;a<=s;)if(o=Math.floor((a+s)/2),n=t[o],i=t[o+1],n<=e){if(o===r||e<i)return o;a=o+1;}else {if(!(n>e))throw new qe("Input is not a number.");s=o-1;}return 0}class An{constructor(t,e,r){this.type=t,this.input=e,this.labels=[],this.outputs=[];for(const[t,e]of r)this.labels.push(t),this.outputs.push(e);}static parse(t,e){if(t.length-1<4)return e.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");const r=e.parse(t[1],1,xe);if(!r)return null;const n=[];let i=null;e.expectedType&&"value"!==e.expectedType.kind&&(i=e.expectedType);for(let r=1;r<t.length;r+=2){const a=1===r?-1/0:t[r],s=t[r+1],o=r,l=r+1;if("number"!=typeof a)return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',o);if(n.length&&n[n.length-1][0]>=a)return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',o);const u=e.parse(s,l,i);if(!u)return null;i=i||u.type,n.push([a,u]);}return new An(i,r,n)}evaluate(t){const e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);const n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);const i=e.length;return n>=e[i-1]?r[i-1].evaluate(t):r[Mn(e,n)].evaluate(t)}eachChild(t){t(this.input);for(const e of this.outputs)t(e);}outputDefined(){return this.outputs.every((t=>t.outputDefined()))}serialize(){const t=["step",this.input.serialize()];for(let e=0;e<this.labels.length;e++)e>0&&t.push(this.labels[e]),t.push(this.outputs[e].serialize());return t}}var Sn=An;const In=.95047,kn=1.08883,Pn=4/29,En=6/29,zn=3*En*En,Tn=En*En*En,Bn=Math.PI/180,Cn=180/Math.PI;function Rn(t){return t>Tn?Math.pow(t,1/3):t/zn+Pn}function Dn(t){return t>En?t*t*t:zn*(t-Pn)}function Vn(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Ln(t){return (t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Fn(t){const e=Ln(t.r),r=Ln(t.g),n=Ln(t.b),i=Rn((.4124564*e+.3575761*r+.1804375*n)/In),a=Rn((.2126729*e+.7151522*r+.072175*n)/1);return {l:116*a-16,a:500*(i-a),b:200*(a-Rn((.0193339*e+.119192*r+.9503041*n)/kn)),alpha:t.a}}function Nn(t){let e=(t.l+16)/116,r=isNaN(t.a)?e:e+t.a/500,n=isNaN(t.b)?e:e-t.b/200;return e=1*Dn(e),r=In*Dn(r),n=kn*Dn(n),new le(Vn(3.2404542*r-1.5371385*e-.4985314*n),Vn(-.969266*r+1.8760108*e+.041556*n),Vn(.0556434*r-.2040259*e+1.0572252*n),t.alpha)}function On(t,e,r){const n=e-t;return t+r*(n>180||n<-180?n-360*Math.round(n/360):n)}const Un={forward:Fn,reverse:Nn,interpolate:function(t,e,r){return {l:ue(t.l,e.l,r),a:ue(t.a,e.a,r),b:ue(t.b,e.b,r),alpha:ue(t.alpha,e.alpha,r)}}},jn={forward:function(t){const{l:e,a:r,b:n}=Fn(t),i=Math.atan2(n,r)*Cn;return {h:i<0?i+360:i,c:Math.sqrt(r*r+n*n),l:e,alpha:t.a}},reverse:function(t){const e=t.h*Bn,r=t.c;return Nn({l:t.l,a:Math.cos(e)*r,b:Math.sin(e)*r,alpha:t.alpha})},interpolate:function(t,e,r){return {h:On(t.h,e.h,r),c:ue(t.c,e.c,r),l:ue(t.l,e.l,r),alpha:ue(t.alpha,e.alpha,r)}}};var qn=Object.freeze({__proto__:null,hcl:jn,lab:Un});class $n{constructor(t,e,r,n,i){this.type=t,this.operator=e,this.interpolation=r,this.input=n,this.labels=[],this.outputs=[];for(const[t,e]of i)this.labels.push(t),this.outputs.push(e);}static interpolationFactor(t,e,r,n){let i=0;if("exponential"===t.name)i=Gn(e,t.base,r,n);else if("linear"===t.name)i=Gn(e,1,r,n);else if("cubic-bezier"===t.name){const a=t.controlPoints;i=new d(a[0],a[1],a[2],a[3]).solve(Gn(e,1,r,n));}return i}static parse(t,e){let[r,n,i,...a]=t;if(!Array.isArray(n)||0===n.length)return e.error("Expected an interpolation type expression.",1);if("linear"===n[0])n={name:"linear"};else if("exponential"===n[0]){const t=n[1];if("number"!=typeof t)return e.error("Exponential interpolation requires a numeric base.",1,1);n={name:"exponential",base:t};}else {if("cubic-bezier"!==n[0])return e.error(`Unknown interpolation type ${String(n[0])}`,1,0);{const t=n.slice(1);if(4!==t.length||t.some((t=>"number"!=typeof t||t<0||t>1)))return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);n={name:"cubic-bezier",controlPoints:t};}}if(t.length-1<4)return e.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!=0)return e.error("Expected an even number of arguments.");if(i=e.parse(i,2,xe),!i)return null;const s=[];let o=null;"interpolate-hcl"===r||"interpolate-lab"===r?o=_e:e.expectedType&&"value"!==e.expectedType.kind&&(o=e.expectedType);for(let t=0;t<a.length;t+=2){const r=a[t],n=a[t+1],i=t+3,l=t+4;if("number"!=typeof r)return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',i);if(s.length&&s[s.length-1][0]>=r)return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',i);const u=e.parse(n,l,o);if(!u)return null;o=o||u.type,s.push([r,u]);}return "number"===o.kind||"color"===o.kind||"array"===o.kind&&"number"===o.itemType.kind&&"number"==typeof o.N?new $n(o,r,n,i,s):e.error(`Type ${Pe(o)} is not interpolatable.`)}evaluate(t){const e=this.labels,r=this.outputs;if(1===e.length)return r[0].evaluate(t);const n=this.input.evaluate(t);if(n<=e[0])return r[0].evaluate(t);const i=e.length;if(n>=e[i-1])return r[i-1].evaluate(t);const a=Mn(e,n),s=$n.interpolationFactor(this.interpolation,n,e[a],e[a+1]),o=r[a].evaluate(t),l=r[a+1].evaluate(t);return "interpolate"===this.operator?he[this.type.kind.toLowerCase()](o,l,s):"interpolate-hcl"===this.operator?jn.reverse(jn.interpolate(jn.forward(o),jn.forward(l),s)):Un.reverse(Un.interpolate(Un.forward(o),Un.forward(l),s))}eachChild(t){t(this.input);for(const e of this.outputs)t(e);}outputDefined(){return this.outputs.every((t=>t.outputDefined()))}serialize(){let t;t="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);const e=[this.operator,t,this.input.serialize()];for(let t=0;t<this.labels.length;t++)e.push(this.labels[t],this.outputs[t].serialize());return e}}function Gn(t,e,r,n){const i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}var Yn=$n;class Xn{constructor(t,e){this.type=t,this.args=e;}static parse(t,e){if(t.length<2)return e.error("Expectected at least one argument.");let r=null;const n=e.expectedType;n&&"value"!==n.kind&&(r=n);const i=[];for(const n of t.slice(1)){const t=e.parse(n,1+i.length,r,void 0,{typeAnnotation:"omit"});if(!t)return null;r=r||t.type,i.push(t);}const a=n&&i.some((t=>ze(n,t.type)));return new Xn(a?Me:r,i)}evaluate(t){let e,r=null,n=0;for(const i of this.args){if(n++,r=i.evaluate(t),r&&r instanceof Ve&&!r.available&&(e||(e=r),r=null,n===this.args.length))return e;if(null!==r)break}return r}eachChild(t){this.args.forEach(t);}outputDefined(){return this.args.every((t=>t.outputDefined()))}serialize(){const t=["coalesce"];return this.eachChild((e=>{t.push(e.serialize());})),t}}var Zn=Xn;class Kn{constructor(t,e){this.type=e.type,this.bindings=[].concat(t),this.result=e;}evaluate(t){return this.result.evaluate(t)}eachChild(t){for(const e of this.bindings)t(e[1]);t(this.result);}static parse(t,e){if(t.length<4)return e.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);const r=[];for(let n=1;n<t.length-1;n+=2){const i=t[n];if("string"!=typeof i)return e.error(`Expected string, but found ${typeof i} instead.`,n);if(/[^a-zA-Z0-9_]/.test(i))return e.error("Variable names must contain only alphanumeric characters or '_'.",n);const a=e.parse(t[n+1],n+1);if(!a)return null;r.push([i,a]);}const n=e.parse(t[t.length-1],t.length-1,e.expectedType,r);return n?new Kn(r,n):null}outputDefined(){return this.result.outputDefined()}serialize(){const t=["let"];for(const[e,r]of this.bindings)t.push(e,r.serialize());return t.push(this.result.serialize()),t}}var Hn=Kn;class Wn{constructor(t,e,r){this.type=t,this.index=e,this.input=r;}static parse(t,e){if(3!==t.length)return e.error(`Expected 2 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,xe),n=e.parse(t[2],2,ke(e.expectedType||Me));return r&&n?new Wn(n.type.itemType,r,n):null}evaluate(t){const e=this.index.evaluate(t),r=this.input.evaluate(t);if(e<0)throw new qe(`Array index out of bounds: ${e} < 0.`);if(e>=r.length)throw new qe(`Array index out of bounds: ${e} > ${r.length-1}.`);if(e!==Math.floor(e))throw new qe(`Array index must be an integer, but found ${e} instead.`);return r[e]}eachChild(t){t(this.index),t(this.input);}outputDefined(){return !1}serialize(){return ["at",this.index.serialize(),this.input.serialize()]}}var Jn=Wn;class Qn{constructor(t,e){this.type=be,this.needle=t,this.haystack=e;}static parse(t,e){if(3!==t.length)return e.error(`Expected 2 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,Me),n=e.parse(t[2],2,Me);return r&&n?Te(r.type,[be,ve,xe,ge,Me])?new Qn(r,n):e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(r.type)} instead`):null}evaluate(t){const e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(null==r)return !1;if(!Be(e,["boolean","string","number","null"]))throw new qe(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(Ne(e))} instead.`);if(!Be(r,["string","array"]))throw new qe(`Expected second argument to be of type array or string, but found ${Pe(Ne(r))} instead.`);return r.indexOf(e)>=0}eachChild(t){t(this.needle),t(this.haystack);}outputDefined(){return !0}serialize(){return ["in",this.needle.serialize(),this.haystack.serialize()]}}var ti=Qn;class ei{constructor(t,e,r){this.type=xe,this.needle=t,this.haystack=e,this.fromIndex=r;}static parse(t,e){if(t.length<=2||t.length>=5)return e.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,Me),n=e.parse(t[2],2,Me);if(!r||!n)return null;if(!Te(r.type,[be,ve,xe,ge,Me]))return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(r.type)} instead`);if(4===t.length){const i=e.parse(t[3],3,xe);return i?new ei(r,n,i):null}return new ei(r,n)}evaluate(t){const e=this.needle.evaluate(t),r=this.haystack.evaluate(t);if(!Be(e,["boolean","string","number","null"]))throw new qe(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(Ne(e))} instead.`);if(!Be(r,["string","array"]))throw new qe(`Expected second argument to be of type array or string, but found ${Pe(Ne(r))} instead.`);if(this.fromIndex){const n=this.fromIndex.evaluate(t);return r.indexOf(e,n)}return r.indexOf(e)}eachChild(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex);}outputDefined(){return !1}serialize(){if(null!=this.fromIndex&&void 0!==this.fromIndex){const t=this.fromIndex.serialize();return ["index-of",this.needle.serialize(),this.haystack.serialize(),t]}return ["index-of",this.needle.serialize(),this.haystack.serialize()]}}var ri=ei;class ni{constructor(t,e,r,n,i,a){this.inputType=t,this.type=e,this.input=r,this.cases=n,this.outputs=i,this.otherwise=a;}static parse(t,e){if(t.length<5)return e.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if(t.length%2!=1)return e.error("Expected an even number of arguments.");let r,n;e.expectedType&&"value"!==e.expectedType.kind&&(n=e.expectedType);const i={},a=[];for(let s=2;s<t.length-1;s+=2){let o=t[s];const l=t[s+1];Array.isArray(o)||(o=[o]);const u=e.concat(s);if(0===o.length)return u.error("Expected at least one branch label.");for(const t of o){if("number"!=typeof t&&"string"!=typeof t)return u.error("Branch labels must be numbers or strings.");if("number"==typeof t&&Math.abs(t)>Number.MAX_SAFE_INTEGER)return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if("number"==typeof t&&Math.floor(t)!==t)return u.error("Numeric branch labels must be integer values.");if(r){if(u.checkSubtype(r,Ne(t)))return null}else r=Ne(t);if(void 0!==i[String(t)])return u.error("Branch labels must be unique.");i[String(t)]=a.length;}const c=e.parse(l,s,n);if(!c)return null;n=n||c.type,a.push(c);}const s=e.parse(t[1],1,Me);if(!s)return null;const o=e.parse(t[t.length-1],t.length-1,n);return o?"value"!==s.type.kind&&e.concat(1).checkSubtype(r,s.type)?null:new ni(r,n,s,i,a,o):null}evaluate(t){const e=this.input.evaluate(t);return (Ne(e)===this.inputType&&this.outputs[this.cases[e]]||this.otherwise).evaluate(t)}eachChild(t){t(this.input),this.outputs.forEach(t),t(this.otherwise);}outputDefined(){return this.outputs.every((t=>t.outputDefined()))&&this.otherwise.outputDefined()}serialize(){const t=["match",this.input.serialize()],e=Object.keys(this.cases).sort(),r=[],n={};for(const t of e){const e=n[this.cases[t]];void 0===e?(n[this.cases[t]]=r.length,r.push([this.cases[t],[t]])):r[e][1].push(t);}const i=t=>"number"===this.inputType.kind?Number(t):t;for(const[e,n]of r)t.push(1===n.length?i(n[0]):n.map(i)),t.push(this.outputs[e].serialize());return t.push(this.otherwise.serialize()),t}}var ii=ni;class ai{constructor(t,e,r){this.type=t,this.branches=e,this.otherwise=r;}static parse(t,e){if(t.length<4)return e.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);if(t.length%2!=0)return e.error("Expected an odd number of arguments.");let r;e.expectedType&&"value"!==e.expectedType.kind&&(r=e.expectedType);const n=[];for(let i=1;i<t.length-1;i+=2){const a=e.parse(t[i],i,be);if(!a)return null;const s=e.parse(t[i+1],i+1,r);if(!s)return null;n.push([a,s]),r=r||s.type;}const i=e.parse(t[t.length-1],t.length-1,r);return i?new ai(r,n,i):null}evaluate(t){for(const[e,r]of this.branches)if(e.evaluate(t))return r.evaluate(t);return this.otherwise.evaluate(t)}eachChild(t){for(const[e,r]of this.branches)t(e),t(r);t(this.otherwise);}outputDefined(){return this.branches.every((([t,e])=>e.outputDefined()))&&this.otherwise.outputDefined()}serialize(){const t=["case"];return this.eachChild((e=>{t.push(e.serialize());})),t}}var si=ai;class oi{constructor(t,e,r,n){this.type=t,this.input=e,this.beginIndex=r,this.endIndex=n;}static parse(t,e){if(t.length<=2||t.length>=5)return e.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);const r=e.parse(t[1],1,Me),n=e.parse(t[2],2,xe);if(!r||!n)return null;if(!Te(r.type,[ke(Me),ve,Me]))return e.error(`Expected first argument to be of type array or string, but found ${Pe(r.type)} instead`);if(4===t.length){const i=e.parse(t[3],3,xe);return i?new oi(r.type,r,n,i):null}return new oi(r.type,r,n)}evaluate(t){const e=this.input.evaluate(t),r=this.beginIndex.evaluate(t);if(!Be(e,["string","array"]))throw new qe(`Expected first argument to be of type array or string, but found ${Pe(Ne(e))} instead.`);if(this.endIndex){const n=this.endIndex.evaluate(t);return e.slice(r,n)}return e.slice(r)}eachChild(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex);}outputDefined(){return !1}serialize(){if(null!=this.endIndex&&void 0!==this.endIndex){const t=this.endIndex.serialize();return ["slice",this.input.serialize(),this.beginIndex.serialize(),t]}return ["slice",this.input.serialize(),this.beginIndex.serialize()]}}var li=oi;function ui(t,e){return "=="===t||"!="===t?"boolean"===e.kind||"string"===e.kind||"number"===e.kind||"null"===e.kind||"value"===e.kind:"string"===e.kind||"number"===e.kind||"value"===e.kind}function ci(t,e,r,n){return 0===n.compare(e,r)}function hi(t,e,r){const n="=="!==t&&"!="!==t;return class i{constructor(t,e,r){this.type=be,this.lhs=t,this.rhs=e,this.collator=r,this.hasUntypedArgument="value"===t.type.kind||"value"===e.type.kind;}static parse(t,e){if(3!==t.length&&4!==t.length)return e.error("Expected two or three arguments.");const r=t[0];let a=e.parse(t[1],1,Me);if(!a)return null;if(!ui(r,a.type))return e.concat(1).error(`"${r}" comparisons are not supported for type '${Pe(a.type)}'.`);let s=e.parse(t[2],2,Me);if(!s)return null;if(!ui(r,s.type))return e.concat(2).error(`"${r}" comparisons are not supported for type '${Pe(s.type)}'.`);if(a.type.kind!==s.type.kind&&"value"!==a.type.kind&&"value"!==s.type.kind)return e.error(`Cannot compare types '${Pe(a.type)}' and '${Pe(s.type)}'.`);n&&("value"===a.type.kind&&"value"!==s.type.kind?a=new Ye(s.type,[a]):"value"!==a.type.kind&&"value"===s.type.kind&&(s=new Ye(a.type,[s])));let o=null;if(4===t.length){if("string"!==a.type.kind&&"string"!==s.type.kind&&"value"!==a.type.kind&&"value"!==s.type.kind)return e.error("Cannot use collator to compare non-string types.");if(o=e.parse(t[3],3,Ae),!o)return null}return new i(a,s,o)}evaluate(i){const a=this.lhs.evaluate(i),s=this.rhs.evaluate(i);if(n&&this.hasUntypedArgument){const e=Ne(a),r=Ne(s);if(e.kind!==r.kind||"string"!==e.kind&&"number"!==e.kind)throw new qe(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`)}if(this.collator&&!n&&this.hasUntypedArgument){const t=Ne(a),r=Ne(s);if("string"!==t.kind||"string"!==r.kind)return e(i,a,s)}return this.collator?r(i,a,s,this.collator.evaluate(i)):e(i,a,s)}eachChild(t){t(this.lhs),t(this.rhs),this.collator&&t(this.collator);}outputDefined(){return !0}serialize(){const e=[t];return this.eachChild((t=>{e.push(t.serialize());})),e}}}const pi=hi("==",(function(t,e,r){return e===r}),ci),fi=hi("!=",(function(t,e,r){return e!==r}),(function(t,e,r,n){return !ci(0,e,r,n)})),di=hi("<",(function(t,e,r){return e<r}),(function(t,e,r,n){return n.compare(e,r)<0})),mi=hi(">",(function(t,e,r){return e>r}),(function(t,e,r,n){return n.compare(e,r)>0})),yi=hi("<=",(function(t,e,r){return e<=r}),(function(t,e,r,n){return n.compare(e,r)<=0})),gi=hi(">=",(function(t,e,r){return e>=r}),(function(t,e,r,n){return n.compare(e,r)>=0}));class xi{constructor(t,e,r,n,i,a){this.type=ve,this.number=t,this.locale=e,this.currency=r,this.unit=n,this.minFractionDigits=i,this.maxFractionDigits=a;}static parse(t,e){if(3!==t.length)return e.error("Expected two arguments.");const r=e.parse(t[1],1,xe);if(!r)return null;const n=t[2];if("object"!=typeof n||Array.isArray(n))return e.error("NumberFormat options argument must be an object.");let i=null;if(n.locale&&(i=e.parse(n.locale,1,ve),!i))return null;let a=null;if(n.currency&&(a=e.parse(n.currency,1,ve),!a))return null;let s=null;if(n.unit&&(s=e.parse(n.unit,1,ve),!s))return null;let o=null;if(n["min-fraction-digits"]&&(o=e.parse(n["min-fraction-digits"],1,xe),!o))return null;let l=null;return n["max-fraction-digits"]&&(l=e.parse(n["max-fraction-digits"],1,xe),!l)?null:new xi(r,i,a,s,o,l)}evaluate(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:(this.currency?"currency":this.unit&&"unit")||"decimal",currency:this.currency?this.currency.evaluate(t):void 0,unit:this.unit?this.unit.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))}eachChild(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.unit&&t(this.unit),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits);}outputDefined(){return !1}serialize(){const t={};return this.locale&&(t.locale=this.locale.serialize()),this.currency&&(t.currency=this.currency.serialize()),this.unit&&(t.unit=this.unit.serialize()),this.minFractionDigits&&(t["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(t["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),t]}}class vi{constructor(t){this.type=xe,this.input=t;}static parse(t,e){if(2!==t.length)return e.error(`Expected 1 argument, but found ${t.length-1} instead.`);const r=e.parse(t[1],1);return r?"array"!==r.type.kind&&"string"!==r.type.kind&&"value"!==r.type.kind?e.error(`Expected argument of type string or array, but found ${Pe(r.type)} instead.`):new vi(r):null}evaluate(t){const e=this.input.evaluate(t);if("string"==typeof e)return e.length;if(Array.isArray(e))return e.length;throw new qe(`Expected value to be of type string or array, but found ${Pe(Ne(e))} instead.`)}eachChild(t){t(this.input);}outputDefined(){return !1}serialize(){const t=["length"];return this.eachChild((e=>{t.push(e.serialize());})),t}}function bi(t){return function(){t=1831565813+(t|=0)|0;let e=Math.imul(t^t>>>15,1|t);return e=e+Math.imul(e^e>>>7,61|e)^e,((e^e>>>14)>>>0)/4294967296}}const _i={"==":pi,"!=":fi,">":mi,"<":di,">=":gi,"<=":yi,array:Ye,at:Jn,boolean:Ye,case:si,coalesce:Zn,collator:ir,format:Xe,image:Ze,in:ti,"index-of":ri,interpolate:Yn,"interpolate-hcl":Yn,"interpolate-lab":Yn,length:vi,let:Hn,literal:je,match:ii,number:Ye,"number-format":xi,object:Ye,slice:li,step:Sn,string:Ye,"to-boolean":Je,"to-color":Je,"to-number":Je,"to-string":Je,var:vn,within:Ir,distance:un,config:fn};function wi(t,[e,r,n,i]){e=e.evaluate(t),r=r.evaluate(t),n=n.evaluate(t);const a=i?i.evaluate(t):1,s=Le(e,r,n,a);if(s)throw new qe(s);return new le(e/255*a,r/255*a,n/255*a,a)}function Mi(t,[e,r,n,i]){e=e.evaluate(t),r=r.evaluate(t),n=n.evaluate(t);const a=i?i.evaluate(t):1,s=function(t,e,r,n){return "number"==typeof t&&t>=0&&t<=360?"number"==typeof e&&e>=0&&e<=100&&"number"==typeof r&&r>=0&&r<=100?void 0===n||"number"==typeof n&&n>=0&&n<=1?null:`Invalid hsla value [${[t,e,r,n].join(", ")}]: 'a' must be between 0 and 1.`:`Invalid hsla value [${("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")}]: 's', and 'l' must be between 0 and 100.`:`Invalid hsla value [${("number"==typeof n?[t,e,r,n]:[t,e,r]).join(", ")}]: 'h' must be between 0 and 360.`}(e,r,n,a);if(s)throw new qe(s);const o=`hsla(${e}, ${r}%, ${n}%, ${a})`,l=le.parse(o);if(!l)throw new qe(`Failed to parse HSLA color: ${o}`);return l}function Ai(t,e){return t in e}function Si(t,e){const r=e[t];return void 0===r?null:r}function Ii(t){return {type:t}}nr.register(_i,{error:[{kind:"error"},[ve],(t,[e])=>{throw new qe(e.evaluate(t))}],typeof:[ve,[Me],(t,[e])=>Pe(Ne(e.evaluate(t)))],"to-rgba":[ke(xe,4),[_e],(t,[e])=>e.evaluate(t).toArray()],rgb:[_e,[xe,xe,xe],wi],rgba:[_e,[xe,xe,xe,xe],wi],hsl:[_e,[xe,xe,xe],Mi],hsla:[_e,[xe,xe,xe,xe],Mi],has:{type:be,overloads:[[[ve],(t,[e])=>Ai(e.evaluate(t),t.properties())],[[ve,we],(t,[e,r])=>Ai(e.evaluate(t),r.evaluate(t))]]},get:{type:Me,overloads:[[[ve],(t,[e])=>Si(e.evaluate(t),t.properties())],[[ve,we],(t,[e,r])=>Si(e.evaluate(t),r.evaluate(t))]]},"feature-state":[Me,[ve],(t,[e])=>Si(e.evaluate(t),t.featureState||{})],properties:[we,[],t=>t.properties()],"geometry-type":[ve,[],t=>t.geometryType()],id:[Me,[],t=>t.id()],zoom:[xe,[],t=>t.globals.zoom],pitch:[xe,[],t=>t.globals.pitch||0],"distance-from-center":[xe,[],t=>t.distanceFromCenter()],"measure-light":[xe,[ve],(t,[e])=>t.measureLight(e.evaluate(t))],"heatmap-density":[xe,[],t=>t.globals.heatmapDensity||0],"line-progress":[xe,[],t=>t.globals.lineProgress||0],"raster-value":[xe,[],t=>t.globals.rasterValue||0],"raster-particle-speed":[xe,[],t=>t.globals.rasterParticleSpeed||0],"sky-radial-progress":[xe,[],t=>t.globals.skyRadialProgress||0],accumulated:[Me,[],t=>void 0===t.globals.accumulated?null:t.globals.accumulated],"+":[xe,Ii(xe),(t,e)=>{let r=0;for(const n of e)r+=n.evaluate(t);return r}],"*":[xe,Ii(xe),(t,e)=>{let r=1;for(const n of e)r*=n.evaluate(t);return r}],"-":{type:xe,overloads:[[[xe,xe],(t,[e,r])=>e.evaluate(t)-r.evaluate(t)],[[xe],(t,[e])=>-e.evaluate(t)]]},"/":[xe,[xe,xe],(t,[e,r])=>e.evaluate(t)/r.evaluate(t)],"%":[xe,[xe,xe],(t,[e,r])=>e.evaluate(t)%r.evaluate(t)],ln2:[xe,[],()=>Math.LN2],pi:[xe,[],()=>Math.PI],e:[xe,[],()=>Math.E],"^":[xe,[xe,xe],(t,[e,r])=>Math.pow(e.evaluate(t),r.evaluate(t))],sqrt:[xe,[xe],(t,[e])=>Math.sqrt(e.evaluate(t))],log10:[xe,[xe],(t,[e])=>Math.log(e.evaluate(t))/Math.LN10],ln:[xe,[xe],(t,[e])=>Math.log(e.evaluate(t))],log2:[xe,[xe],(t,[e])=>Math.log(e.evaluate(t))/Math.LN2],sin:[xe,[xe],(t,[e])=>Math.sin(e.evaluate(t))],cos:[xe,[xe],(t,[e])=>Math.cos(e.evaluate(t))],tan:[xe,[xe],(t,[e])=>Math.tan(e.evaluate(t))],asin:[xe,[xe],(t,[e])=>Math.asin(e.evaluate(t))],acos:[xe,[xe],(t,[e])=>Math.acos(e.evaluate(t))],atan:[xe,[xe],(t,[e])=>Math.atan(e.evaluate(t))],min:[xe,Ii(xe),(t,e)=>Math.min(...e.map((e=>e.evaluate(t))))],max:[xe,Ii(xe),(t,e)=>Math.max(...e.map((e=>e.evaluate(t))))],abs:[xe,[xe],(t,[e])=>Math.abs(e.evaluate(t))],round:[xe,[xe],(t,[e])=>{const r=e.evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[xe,[xe],(t,[e])=>Math.floor(e.evaluate(t))],ceil:[xe,[xe],(t,[e])=>Math.ceil(e.evaluate(t))],"filter-==":[be,[ve,Me],(t,[e,r])=>t.properties()[e.value]===r.value],"filter-id-==":[be,[Me],(t,[e])=>t.id()===e.value],"filter-type-==":[be,[ve],(t,[e])=>t.geometryType()===e.value],"filter-<":[be,[ve,Me],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[be,[Me],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r<n}],"filter->":[be,[ve,Me],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[be,[Me],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r>n}],"filter-<=":[be,[ve,Me],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[be,[Me],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r<=n}],"filter->=":[be,[ve,Me],(t,[e,r])=>{const n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[be,[Me],(t,[e])=>{const r=t.id(),n=e.value;return typeof r==typeof n&&r>=n}],"filter-has":[be,[Me],(t,[e])=>e.value in t.properties()],"filter-has-id":[be,[],t=>null!==t.id()&&void 0!==t.id()],"filter-type-in":[be,[ke(ve)],(t,[e])=>e.value.indexOf(t.geometryType())>=0],"filter-id-in":[be,[ke(Me)],(t,[e])=>e.value.indexOf(t.id())>=0],"filter-in-small":[be,[ve,ke(Me)],(t,[e,r])=>r.value.indexOf(t.properties()[e.value])>=0],"filter-in-large":[be,[ve,ke(Me)],(t,[e,r])=>function(t,e,r,n){for(;r<=n;){const i=r+n>>1;if(e[i]===t)return !0;e[i]>t?n=i-1:r=i+1;}return !1}(t.properties()[e.value],r.value,0,r.value.length-1)],all:{type:be,overloads:[[[be,be],(t,[e,r])=>e.evaluate(t)&&r.evaluate(t)],[Ii(be),(t,e)=>{for(const r of e)if(!r.evaluate(t))return !1;return !0}]]},any:{type:be,overloads:[[[be,be],(t,[e,r])=>e.evaluate(t)||r.evaluate(t)],[Ii(be),(t,e)=>{for(const r of e)if(r.evaluate(t))return !0;return !1}]]},"!":[be,[be],(t,[e])=>!e.evaluate(t)],"is-supported-script":[be,[ve],(t,[e])=>{const r=t.globals&&t.globals.isSupportedScript;return !r||r(e.evaluate(t))}],upcase:[ve,[ve],(t,[e])=>e.evaluate(t).toUpperCase()],downcase:[ve,[ve],(t,[e])=>e.evaluate(t).toLowerCase()],concat:[ve,Ii(Me),(t,e)=>e.map((e=>Oe(e.evaluate(t)))).join("")],"resolved-locale":[ve,[Ae],(t,[e])=>e.evaluate(t).resolvedLocale()],random:[xe,[xe,xe,Me],(t,e)=>{const[r,n,i]=e.map((e=>e.evaluate(t)));if(r>n)return r;if(r===n)return r;let a;if("string"==typeof i)a=function(t){let e=0;if(0===t.length)return e;for(let r=0;r<t.length;r++)e=(e<<5)-e+t.charCodeAt(r),e|=0;return e}(i);else {if("number"!=typeof i)throw new qe(`Invalid seed input: ${i}`);a=i;}return r+bi(a)()*(n-r)}]});var ki=_i;function Pi(t){return {result:"success",value:t}}function Ei(t){return {result:"error",value:t}}function zi(t,e){return !!t&&!!t.parameters&&t.parameters.indexOf(e)>-1}function Ti(t){return "data-driven"===t["property-type"]}function Bi(t){return zi(t.expression,"measure-light")}function Ci(t){return zi(t.expression,"zoom")}function Ri(t){return !!t.expression&&t.expression.interpolated}function Di(t){return "object"==typeof t&&null!==t&&!Array.isArray(t)}function Vi(t){return t}function Li(t,e){const r="color"===e.type,n=t.stops&&"object"==typeof t.stops[0][0],i=n||!(n||void 0!==t.property),a=t.type||(Ri(e)?"exponential":"interval");if(r&&((t=pe({},t)).stops&&(t.stops=t.stops.map((t=>[t[0],le.parse(t[1])]))),t.default=le.parse(t.default?t.default:e.default)),t.colorSpace&&"rgb"!==t.colorSpace&&!qn[t.colorSpace])throw new Error(`Unknown color space: ${t.colorSpace}`);let s,o,l;if("exponential"===a)s=Ui;else if("interval"===a)s=Oi;else if("categorical"===a){s=Ni,o=Object.create(null);for(const e of t.stops)o[e[0]]=e[1];l=typeof t.stops[0][0];}else {if("identity"!==a)throw new Error(`Unknown function type "${a}"`);s=ji;}if(n){const r={},n=[];for(let e=0;e<t.stops.length;e++){const i=t.stops[e],a=i[0].zoom;void 0===r[a]&&(r[a]={zoom:a,type:t.type,property:t.property,default:t.default,stops:[]},n.push(a)),r[a].stops.push([i[0].value,i[1]]);}const i=[];for(const t of n)i.push([r[t].zoom,Li(r[t],e)]);const a={name:"linear"};return {kind:"composite",interpolationType:a,interpolationFactor:Yn.interpolationFactor.bind(void 0,a),zoomStops:i.map((t=>t[0])),evaluate:({zoom:r},n)=>Ui({stops:i,base:t.base},e,r).evaluate(r,n)}}if(i){const r="exponential"===a?{name:"exponential",base:void 0!==t.base?t.base:1}:null;return {kind:"camera",interpolationType:r,interpolationFactor:Yn.interpolationFactor.bind(void 0,r),zoomStops:t.stops.map((t=>t[0])),evaluate:({zoom:r})=>s(t,e,r,o,l)}}return {kind:"source",evaluate(r,n){const i=n&&n.properties?n.properties[t.property]:void 0;return void 0===i?Fi(t.default,e.default):s(t,e,i,o,l)}}}function Fi(t,e,r){return void 0!==t?t:void 0!==e?e:void 0!==r?r:void 0}function Ni(t,e,r,n,i){return Fi(typeof r===i?n[r]:void 0,t.default,e.default)}function Oi(t,e,r){if("number"!==Ke(r))return Fi(t.default,e.default);const n=t.stops.length;if(1===n)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];const i=Mn(t.stops.map((t=>t[0])),r);return t.stops[i][1]}function Ui(t,e,r){const n=void 0!==t.base?t.base:1;if("number"!==Ke(r))return Fi(t.default,e.default);const i=t.stops.length;if(1===i)return t.stops[0][1];if(r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];const a=Mn(t.stops.map((t=>t[0])),r),s=function(t,e,r,n){const i=n-r,a=t-r;return 0===i?0:1===e?a/i:(Math.pow(e,a)-1)/(Math.pow(e,i)-1)}(r,n,t.stops[a][0],t.stops[a+1][0]),o=t.stops[a][1],l=t.stops[a+1][1];let u=he[e.type]||Vi;if(t.colorSpace&&"rgb"!==t.colorSpace){const e=qn[t.colorSpace];u=(t,r)=>e.reverse(e.interpolate(e.forward(t),e.forward(r),s));}return "function"==typeof o.evaluate?{evaluate(...t){const e=o.evaluate.apply(void 0,t),r=l.evaluate.apply(void 0,t);if(void 0!==e&&void 0!==r)return u(e,r,s)}}:u(o,l,s)}function ji(t,e,r){return "color"===e.type?r=le.parse(r):"formatted"===e.type?r=De.fromString(r.toString()):"resolvedImage"===e.type?r=Ve.fromString(r.toString()):Ke(r)===e.type||"enum"===e.type&&e.values[r]||(r=void 0),Fi(r,t.default,e.default)}class qi{constructor(t,e,r,n){this.expression=t,this._warningHistory={},this._evaluator=new tr(r,n),this._defaultValue=e?function(t){return "color"===t.type&&(Di(t.default)||Array.isArray(t.default))?new le(0,0,0,0):"color"===t.type?le.parse(t.default)||null:void 0===t.default?null:t.default}(e):null,this._enumValues=e&&"enum"===e.type?e.values:null;}evaluateWithoutErrorHandling(t,e,r,n,i,a,s,o){return this._evaluator.globals=t,this._evaluator.feature=e,this._evaluator.featureState=r,this._evaluator.canonical=n||null,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=a,this._evaluator.featureTileCoord=s||null,this._evaluator.featureDistanceData=o||null,this.expression.evaluate(this._evaluator)}evaluate(t,e,r,n,i,a,s,o){this._evaluator.globals=t,this._evaluator.feature=e||null,this._evaluator.featureState=r||null,this._evaluator.canonical=n||null,this._evaluator.availableImages=i||null,this._evaluator.formattedSection=a||null,this._evaluator.featureTileCoord=s||null,this._evaluator.featureDistanceData=o||null;try{const t=this.expression.evaluate(this._evaluator);if(null==t||"number"==typeof t&&t!=t)return this._defaultValue;if(this._enumValues&&!(t in this._enumValues))throw new qe(`Expected value to be one of ${Object.keys(this._enumValues).map((t=>JSON.stringify(t))).join(", ")}, but found ${JSON.stringify(t)} instead.`);return t}catch(t){return this._warningHistory[t.message]||(this._warningHistory[t.message]=!0,"undefined"!=typeof console&&console.warn(t.message)),this._defaultValue}}}function $i(t){return Array.isArray(t)&&t.length>0&&"string"==typeof t[0]&&t[0]in ki}function Gi(t,e,r,n){const i=new _n(ki,[],e?function(t){const e={color:_e,string:ve,number:xe,enum:ve,boolean:be,formatted:Se,resolvedImage:Ie};return "array"===t.type?ke(e[t.value]||Me,t.length):e[t.type]}(e):void 0,void 0,void 0,r,n),a=i.parse(t,void 0,void 0,void 0,e&&"string"===e.type?{typeAnnotation:"coerce"}:void 0);return a?Pi(new qi(a,e,r,n)):Ei(i.errors)}class Yi{constructor(t,e,r){this.kind=t,this._styleExpression=e,this.isLightConstant=r,this.isStateDependent="constant"!==t&&!mn(e.expression),this.isConfigDependent=!yn(e.expression);}evaluateWithoutErrorHandling(t,e,r,n,i,a){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,a)}evaluate(t,e,r,n,i,a){return this._styleExpression.evaluate(t,e,r,n,i,a)}}class Xi{constructor(t,e,r,n,i){this.kind=t,this.zoomStops=r,this._styleExpression=e,this.isStateDependent="camera"!==t&&!mn(e.expression),this.isLightConstant=i,this.isConfigDependent=!yn(e.expression),this.interpolationType=n;}evaluateWithoutErrorHandling(t,e,r,n,i,a){return this._styleExpression.evaluateWithoutErrorHandling(t,e,r,n,i,a)}evaluate(t,e,r,n,i,a){return this._styleExpression.evaluate(t,e,r,n,i,a)}interpolationFactor(t,e,r){return this.interpolationType?Yn.interpolationFactor(this.interpolationType,t,e,r):0}}function Zi(t,e,r,n){if("error"===(t=Gi(t,e,r,n)).result)return t;const i=t.value.expression,a=dn(i);if(!a&&!Ti(e))return Ei([new de("","data expressions not supported")]);const s=gn(i,["zoom","pitch","distance-from-center"]);if(!s&&!Ci(e))return Ei([new de("","zoom expressions not supported")]);const o=gn(i,["measure-light"]);if(!o&&!Bi(e))return Ei([new de("","measure-light expression not supported")]);const l=e.expression&&e.expression.relaxZoomRestriction,u=Hi(i);return u||s||l?u instanceof de?Ei([u]):u instanceof Yn&&!Ri(e)?Ei([new de("",'"interpolate" expressions cannot be used with this property')]):Pi(u?new Xi(a?"camera":"composite",t.value,u.labels,u instanceof Yn?u.interpolation:void 0,o):new Yi(a?"constant":"source",t.value,o)):Ei([new de("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')])}class Ki{constructor(t,e){this._parameters=t,this._specification=e,pe(this,Li(this._parameters,this._specification));}static deserialize(t){return new Ki(t._parameters,t._specification)}static serialize(t){return {_parameters:t._parameters,_specification:t._specification}}}function Hi(t){let e=null;if(t instanceof Hn)e=Hi(t.result);else if(t instanceof Zn){for(const r of t.args)if(e=Hi(r),e)break}else (t instanceof Sn||t instanceof Yn)&&t.input instanceof nr&&"zoom"===t.input.name&&(e=t);return e instanceof de||t.eachChild((t=>{const r=Hi(t);r instanceof de?e=r:e&&r&&e!==r&&(e=new de("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));})),e}var Wi=Qi,Ji=3;function Qi(t,e,r){var n=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;var i=new Int32Array(this.arrayBuffer);t=i[0],this.d=(e=i[1])+2*(r=i[2]);for(var a=0;a<this.d*this.d;a++){var s=i[Ji+a],o=i[Ji+a+1];n.push(s===o?null:i.subarray(s,o));}var l=i[Ji+n.length+1];this.keys=i.subarray(i[Ji+n.length],l),this.bboxes=i.subarray(l),this.insert=this._insertReadonly;}else {this.d=e+2*r;for(var u=0;u<this.d*this.d;u++)n.push([]);this.keys=[],this.bboxes=[];}this.n=e,this.extent=t,this.padding=r,this.scale=e/t,this.uid=0;var c=r/e*t;this.min=-c,this.max=t+c;}Qi.prototype.insert=function(t,e,r,n,i){this._forEachCell(e,r,n,i,this._insertCell,this.uid++),this.keys.push(t),this.bboxes.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i);},Qi.prototype._insertReadonly=function(){throw "Cannot insert into a GridIndex created from an ArrayBuffer."},Qi.prototype._insertCell=function(t,e,r,n,i,a){this.cells[i].push(a);},Qi.prototype.query=function(t,e,r,n,i){var a=this.min,s=this.max;if(t<=a&&e<=a&&s<=r&&s<=n&&!i)return Array.prototype.slice.call(this.keys);var o=[];return this._forEachCell(t,e,r,n,this._queryCell,o,{},i),o},Qi.prototype._queryCell=function(t,e,r,n,i,a,s,o){var l=this.cells[i];if(null!==l)for(var u=this.keys,c=this.bboxes,h=0;h<l.length;h++){var p=l[h];if(void 0===s[p]){var f=4*p;(o?o(c[f+0],c[f+1],c[f+2],c[f+3]):t<=c[f+2]&&e<=c[f+3]&&r>=c[f+0]&&n>=c[f+1])?(s[p]=!0,a.push(u[p])):s[p]=!1;}}},Qi.prototype._forEachCell=function(t,e,r,n,i,a,s,o){for(var l=this._convertToCellCoord(t),u=this._convertToCellCoord(e),c=this._convertToCellCoord(r),h=this._convertToCellCoord(n),p=l;p<=c;p++)for(var f=u;f<=h;f++){var d=this.d*f+p;if((!o||o(this._convertFromCellCoord(p),this._convertFromCellCoord(f),this._convertFromCellCoord(p+1),this._convertFromCellCoord(f+1)))&&i.call(this,t,e,r,n,d,a,s,o))return}},Qi.prototype._convertFromCellCoord=function(t){return (t-this.padding)/this.scale},Qi.prototype._convertToCellCoord=function(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))},Qi.prototype.toArrayBuffer=function(){if(this.arrayBuffer)return this.arrayBuffer;for(var t=this.cells,e=Ji+this.cells.length+1+1,r=0,n=0;n<this.cells.length;n++)r+=this.cells[n].length;var i=new Int32Array(e+r+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;for(var a=e,s=0;s<t.length;s++){var o=t[s];i[Ji+s]=a,i.set(o,a),a+=o.length;}return i[Ji+t.length]=a,i.set(this.keys,a),i[Ji+t.length+1]=a+=this.keys.length,i.set(this.bboxes,a),a+=this.bboxes.length,i.buffer};var ta=h(Wi);const ea={};function ra(t,e,r={}){Object.defineProperty(t,"_classRegistryKey",{value:e,writeable:!1}),ea[e]={klass:t,omit:r.omit||[]};}ra(Object,"Object"),ta.serialize=function(t,e){const r=t.toArrayBuffer();return e&&e.add(r),{buffer:r}},ta.deserialize=function(t){return new ta(t.buffer)},Object.defineProperty(ta,"name",{value:"Grid"}),ra(ta,"Grid"),ra(le,"Color"),ra(Error,"Error"),ra(De,"Formatted"),ra(Re,"FormattedSection"),ra(St,"AJAXError"),ra(Ve,"ResolvedImage"),ra(Ki,"StylePropertyFunction"),ra(qi,"StyleExpression",{omit:["_evaluator"]}),ra(Xi,"ZoomDependentExpression"),ra(Yi,"ZoomConstantExpression"),ra(nr,"CompoundExpression",{omit:["_evaluate"]});for(const t in ki)ea[ki[t]._classRegistryKey]||ra(ki[t],`Expression${t}`);function na(t){return t&&"undefined"!=typeof ArrayBuffer&&(t instanceof ArrayBuffer||t.constructor&&"ArrayBuffer"===t.constructor.name)}function ia(t){return self.ImageBitmap&&t instanceof ImageBitmap}function aa(t,e){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp)return t;if(na(t)||ia(t))return e&&e.add(t),t;if(ArrayBuffer.isView(t)){const r=t;return e&&e.add(r.buffer),r}if(t instanceof ImageData)return e&&e.add(t.data.buffer),t;if(Array.isArray(t)){const r=[];for(const n of t)r.push(aa(n,e));return r}if(t instanceof Map){const e={$name:"Map"};for(const[r,n]of t.entries())e[r]=aa(n);return e}if("object"==typeof t){const r=t.constructor,n=r._classRegistryKey;if(!n)throw new Error(`can't serialize object of unregistered class ${n}`);const i=r.serialize?r.serialize(t,e):{};if(!r.serialize){for(const r in t)t.hasOwnProperty(r)&&(ea[n].omit.indexOf(r)>=0||(i[r]=aa(t[r],e)));t instanceof Error&&(i.message=t.message);}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return "Object"!==n&&(i.$name=n),i}throw new Error("can't serialize object of type "+typeof t)}function sa(t){if(null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||na(t)||ia(t)||ArrayBuffer.isView(t)||t instanceof ImageData)return t;if(Array.isArray(t))return t.map(sa);if("object"==typeof t){const e=t.$name||"Object";if("Map"===e){const e=new Map;for(const r of Object.keys(t))"$name"!==r&&e.set(r,sa(t[r]));return e}const{klass:r}=ea[e];if(!r)throw new Error(`can't deserialize unregistered class ${e}`);if(r.deserialize)return r.deserialize(t);const n=Object.create(r.prototype);for(const e of Object.keys(t))"$name"!==e&&(n[e]=sa(t[e]));return n}throw new Error("can't deserialize object of type "+typeof t)}const oa={"Latin-1 Supplement":t=>t>=128&&t<=255,Arabic:t=>t>=1536&&t<=1791,"Arabic Supplement":t=>t>=1872&&t<=1919,"Arabic Extended-A":t=>t>=2208&&t<=2303,"Hangul Jamo":t=>t>=4352&&t<=4607,"Unified Canadian Aboriginal Syllabics":t=>t>=5120&&t<=5759,Khmer:t=>t>=6016&&t<=6143,"Unified Canadian Aboriginal Syllabics Extended":t=>t>=6320&&t<=6399,"General Punctuation":t=>t>=8192&&t<=8303,"Letterlike Symbols":t=>t>=8448&&t<=8527,"Number Forms":t=>t>=8528&&t<=8591,"Miscellaneous Technical":t=>t>=8960&&t<=9215,"Control Pictures":t=>t>=9216&&t<=9279,"Optical Character Recognition":t=>t>=9280&&t<=9311,"Enclosed Alphanumerics":t=>t>=9312&&t<=9471,"Geometric Shapes":t=>t>=9632&&t<=9727,"Miscellaneous Symbols":t=>t>=9728&&t<=9983,"Miscellaneous Symbols and Arrows":t=>t>=11008&&t<=11263,"CJK Radicals Supplement":t=>t>=11904&&t<=12031,"Kangxi Radicals":t=>t>=12032&&t<=12255,"Ideographic Description Characters":t=>t>=12272&&t<=12287,"CJK Symbols and Punctuation":t=>t>=12288&&t<=12351,Hiragana:t=>t>=12352&&t<=12447,Katakana:t=>t>=12448&&t<=12543,Bopomofo:t=>t>=12544&&t<=12591,"Hangul Compatibility Jamo":t=>t>=12592&&t<=12687,Kanbun:t=>t>=12688&&t<=12703,"Bopomofo Extended":t=>t>=12704&&t<=12735,"CJK Strokes":t=>t>=12736&&t<=12783,"Katakana Phonetic Extensions":t=>t>=12784&&t<=12799,"Enclosed CJK Letters and Months":t=>t>=12800&&t<=13055,"CJK Compatibility":t=>t>=13056&&t<=13311,"CJK Unified Ideographs Extension A":t=>t>=13312&&t<=19903,"Yijing Hexagram Symbols":t=>t>=19904&&t<=19967,"CJK Unified Ideographs":t=>t>=19968&&t<=40959,"Yi Syllables":t=>t>=40960&&t<=42127,"Yi Radicals":t=>t>=42128&&t<=42191,"Hangul Jamo Extended-A":t=>t>=43360&&t<=43391,"Hangul Syllables":t=>t>=44032&&t<=55215,"Hangul Jamo Extended-B":t=>t>=55216&&t<=55295,"Private Use Area":t=>t>=57344&&t<=63743,"CJK Compatibility Ideographs":t=>t>=63744&&t<=64255,"Arabic Presentation Forms-A":t=>t>=64336&&t<=65023,"Vertical Forms":t=>t>=65040&&t<=65055,"CJK Compatibility Forms":t=>t>=65072&&t<=65103,"Small Form Variants":t=>t>=65104&&t<=65135,"Arabic Presentation Forms-B":t=>t>=65136&&t<=65279,"Halfwidth and Fullwidth Forms":t=>t>=65280&&t<=65519,"CJK Unified Ideographs Extension B":t=>t>=131072&&t<=173791};function la(t){for(const e of t)if(ha(e.charCodeAt(0)))return !0;return !1}function ua(t){for(const e of t)if(!ca(e.charCodeAt(0)))return !1;return !0}function ca(t){return !(oa.Arabic(t)||oa["Arabic Supplement"](t)||oa["Arabic Extended-A"](t)||oa["Arabic Presentation Forms-A"](t)||oa["Arabic Presentation Forms-B"](t))}function ha(t){return !(746!==t&&747!==t&&(t<4352||!(oa["Bopomofo Extended"](t)||oa.Bopomofo(t)||oa["CJK Compatibility Forms"](t)&&!(t>=65097&&t<=65103)||oa["CJK Compatibility Ideographs"](t)||oa["CJK Compatibility"](t)||oa["CJK Radicals Supplement"](t)||oa["CJK Strokes"](t)||!(!oa["CJK Symbols and Punctuation"](t)||t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||oa["CJK Unified Ideographs Extension A"](t)||oa["CJK Unified Ideographs"](t)||oa["Enclosed CJK Letters and Months"](t)||oa["Hangul Compatibility Jamo"](t)||oa["Hangul Jamo Extended-A"](t)||oa["Hangul Jamo Extended-B"](t)||oa["Hangul Jamo"](t)||oa["Hangul Syllables"](t)||oa.Hiragana(t)||oa["Ideographic Description Characters"](t)||oa.Kanbun(t)||oa["Kangxi Radicals"](t)||oa["Katakana Phonetic Extensions"](t)||oa.Katakana(t)&&12540!==t||!(!oa["Halfwidth and Fullwidth Forms"](t)||65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||!(!oa["Small Form Variants"](t)||t>=65112&&t<=65118||t>=65123&&t<=65126)||oa["Unified Canadian Aboriginal Syllabics"](t)||oa["Unified Canadian Aboriginal Syllabics Extended"](t)||oa["Vertical Forms"](t)||oa["Yijing Hexagram Symbols"](t)||oa["Yi Syllables"](t)||oa["Yi Radicals"](t))))}function pa(t){return !(ha(t)||function(t){return !!(oa["Latin-1 Supplement"](t)&&(167===t||169===t||174===t||177===t||188===t||189===t||190===t||215===t||247===t)||oa["General Punctuation"](t)&&(8214===t||8224===t||8225===t||8240===t||8241===t||8251===t||8252===t||8258===t||8263===t||8264===t||8265===t||8273===t)||oa["Letterlike Symbols"](t)||oa["Number Forms"](t)||oa["Miscellaneous Technical"](t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||9003===t||t>=9085&&t<=9114||t>=9150&&t<=9165||9167===t||t>=9169&&t<=9179||t>=9186&&t<=9215)||oa["Control Pictures"](t)&&9251!==t||oa["Optical Character Recognition"](t)||oa["Enclosed Alphanumerics"](t)||oa["Geometric Shapes"](t)||oa["Miscellaneous Symbols"](t)&&!(t>=9754&&t<=9759)||oa["Miscellaneous Symbols and Arrows"](t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||oa["CJK Symbols and Punctuation"](t)||oa.Katakana(t)||oa["Private Use Area"](t)||oa["CJK Compatibility Forms"](t)||oa["Small Form Variants"](t)||oa["Halfwidth and Fullwidth Forms"](t)||8734===t||8756===t||8757===t||t>=9984&&t<=10087||t>=10102&&t<=10131||65532===t||65533===t)}(t))}function fa(t){return t>=1424&&t<=2303||oa["Arabic Presentation Forms-A"](t)||oa["Arabic Presentation Forms-B"](t)}function da(t,e){return !(!e&&fa(t)||t>=2304&&t<=3583||t>=3840&&t<=4255||oa.Khmer(t))}function ma(t){for(const e of t)if(fa(e.charCodeAt(0)))return !0;return !1}const ya="deferred",ga="loading",xa="loaded";let va=null,ba="unavailable",_a=null;const wa=function(t){t&&"string"==typeof t&&t.indexOf("NetworkError")>-1&&(ba="error"),va&&va(t);};function Ma(){Aa.fire(new Qt("pluginStateChange",{pluginStatus:ba,pluginURL:_a}));}const Aa=new ee,Sa=function(){return ba},Ia=function(){if(ba!==ya||!_a)throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");ba=ga,Ma(),_a&&Pt({url:_a},(t=>{t?wa(t):(ba=xa,Ma());}));},ka={applyArabicShaping:null,processBidirectionalText:null,processStyledBidirectionalText:null,isLoaded:()=>ba===xa||null!=ka.applyArabicShaping,isLoading:()=>ba===ga,setState(t){ba=t.pluginStatus,_a=t.pluginURL;},isParsed:()=>null!=ka.applyArabicShaping&&null!=ka.processBidirectionalText&&null!=ka.processStyledBidirectionalText,getPluginURL:()=>_a};class Pa{constructor(t,e){this.zoom=t,e?(this.now=e.now,this.fadeDuration=e.fadeDuration,this.transition=e.transition,this.pitch=e.pitch,this.brightness=e.brightness):(this.now=0,this.fadeDuration=0,this.transition={},this.pitch=0,this.brightness=0);}isSupportedScript(t){return function(t,e){for(const r of t)if(!da(r.charCodeAt(0),e))return !1;return !0}(t,ka.isLoaded())}}class Ea{constructor(t,e,r,n){this.property=t,this.value=e,this.expression=function(t,e,r,n){if(Di(t))return new Ki(t,e);if($i(t)||Array.isArray(t)&&t.length>0){const i=Zi(t,e,r,n);if("error"===i.result)throw new Error(i.value.map((t=>`${t.key}: ${t.message}`)).join(", "));return i.value}{let r=t;return "string"==typeof t&&"color"===e.type&&(r=le.parse(t)),{kind:"constant",isConfigDependent:!1,evaluate:()=>r}}}(void 0===e?t.specification.default:e,t.specification,r,n);}isDataDriven(){return "source"===this.expression.kind||"composite"===this.expression.kind}possiblyEvaluate(t,e,r){return this.property.possiblyEvaluate(this,t,e,r)}}class za{constructor(t,e,r){this.property=t,this.value=new Ea(t,void 0,e,r);}transitioned(t,e){return new Ba(this.property,this.value,e,z({},t.transition,this.transition),t.now)}untransitioned(){return new Ba(this.property,this.value,null,{},0)}}class Ta{constructor(t,e,r){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues),this._scope=e,this._options=r,this.isConfigDependent=!1;}getValue(t){return O(this._values[t].value.value)}setValue(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new za(this._values[t].property,this._scope,this._options)),this._values[t].value=new Ea(this._values[t].property,null===e?void 0:O(e),this._scope,this._options),this.isConfigDependent=this.isConfigDependent||this._values[t].value.expression.isConfigDependent;}setTransitionOrValue(t,e){e&&(this._options=e);const r=this._properties.properties;if(t)for(const e in t){const n=t[e];if(L(e,"-transition")){const t=e.slice(0,-11);r[t]&&this.setTransition(t,n);}else r[e]&&this.setValue(e,n);}}getTransition(t){return O(this._values[t].transition)}setTransition(t,e){this._values.hasOwnProperty(t)||(this._values[t]=new za(this._values[t].property)),this._values[t].transition=O(e)||void 0;}serialize(){const t={};for(const e of Object.keys(this._values)){const r=this.getValue(e);void 0!==r&&(t[e]=r);const n=this.getTransition(e);void 0!==n&&(t[`${e}-transition`]=n);}return t}transitioned(t,e){const r=new Ca(this._properties);for(const n of Object.keys(this._values))r._values[n]=this._values[n].transitioned(t,e._values[n]);return r}untransitioned(){const t=new Ca(this._properties);for(const e of Object.keys(this._values))t._values[e]=this._values[e].untransitioned();return t}}class Ba{constructor(t,e,r,n,i){const a=n.delay||0,s=n.duration||0;i=i||0,this.property=t,this.value=e,this.begin=i+a,this.end=this.begin+s,t.specification.transition&&(n.delay||n.duration)&&(this.prior=r);}possiblyEvaluate(t,e,r){const n=t.now||0,i=this.value.possiblyEvaluate(t,e,r),a=this.prior;if(a){if(n>this.end)return this.prior=null,i;if(this.value.isDataDriven())return this.prior=null,i;if(n<this.begin)return a.possiblyEvaluate(t,e,r);{const s=(n-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(t,e,r),i,M(s))}}return i}}class Ca{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues);}possiblyEvaluate(t,e,r){const n=new Va(this._properties);for(const i of Object.keys(this._values))n._values[i]=this._values[i].possiblyEvaluate(t,e,r);return n}hasTransition(){for(const t of Object.keys(this._values))if(this._values[t].prior)return !0;return !1}}class Ra{constructor(t,e,r){this._properties=t,this._values=Object.create(t.defaultPropertyValues),this._scope=e,this._options=r,this.isConfigDependent=!1;}getValue(t){return O(this._values[t].value)}setValue(t,e){this._values[t]=new Ea(this._values[t].property,null===e?void 0:O(e),this._scope,this._options),this.isConfigDependent=this.isConfigDependent||this._values[t].expression.isConfigDependent;}serialize(){const t={};for(const e of Object.keys(this._values)){const r=this.getValue(e);void 0!==r&&(t[e]=r);}return t}possiblyEvaluate(t,e,r){const n=new Va(this._properties);for(const i of Object.keys(this._values))n._values[i]=this._values[i].possiblyEvaluate(t,e,r);return n}}class Da{constructor(t,e,r){this.property=t,this.value=e,this.parameters=r;}isConstant(){return "constant"===this.value.kind}constantOr(t){return "constant"===this.value.kind?this.value.value:t}evaluate(t,e,r,n){return this.property.evaluate(this.value,this.parameters,t,e,r,n)}}class Va{constructor(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues);}get(t){return this._values[t]}}class La{constructor(t){this.specification=t;}possiblyEvaluate(t,e){return t.expression.evaluate(e)}interpolate(t,e,r){const n=he[this.specification.type];return n?n(t,e,r):t}}class Fa{constructor(t,e){this.specification=t,this.overrides=e;}possiblyEvaluate(t,e,r,n){return new Da(this,"constant"===t.expression.kind||"camera"===t.expression.kind?{kind:"constant",value:t.expression.evaluate(e,null,{},r,n)}:t.expression,e)}interpolate(t,e,r){if("constant"!==t.value.kind||"constant"!==e.value.kind)return t;if(void 0===t.value.value||void 0===e.value.value)return new Da(this,{kind:"constant",value:void 0},t.parameters);const n=he[this.specification.type];return n?new Da(this,{kind:"constant",value:n(t.value.value,e.value.value,r)},t.parameters):t}evaluate(t,e,r,n,i,a){return "constant"===t.kind?t.value:t.evaluate(e,r,n,i,a)}}class Na{constructor(t){this.specification=t;}possiblyEvaluate(t,e,r,n){return !!t.expression.evaluate(e,null,{},r,n)}interpolate(){return !1}}class Oa{constructor(t){this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];const e=new Pa(0,{});for(const r in t){const n=t[r];n.specification.overridable&&this.overridableProperties.push(r);const i=this.defaultPropertyValues[r]=new Ea(n,void 0),a=this.defaultTransitionablePropertyValues[r]=new za(n);this.defaultTransitioningPropertyValues[r]=a.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate(e);}}}function Ua(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}function ja(t){if(Array.isArray(t))return t.map(ja);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){const e={};for(const r in t)e[r]=ja(t[r]);return e}return Ua(t)}ra(Fa,"DataDrivenProperty"),ra(La,"DataConstantProperty"),ra(Na,"ColorRampProperty");var qa=JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');function $a(t){if(!0===t||!1===t)return !0;if(!Array.isArray(t)||0===t.length)return !1;switch(t[0]){case"has":return t.length>=2&&"$id"!==t[1]&&"$type"!==t[1];case"in":return t.length>=3&&("string"!=typeof t[1]||Array.isArray(t[2]));case"!in":case"!has":case"none":return !1;case"==":case"!=":case">":case">=":case"<":case"<=":return 3!==t.length||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(const e of t.slice(1))if(!$a(e)&&"boolean"!=typeof e)return !1;return !0;default:return !0}}function Ga(t,e="fill"){if(null==t)return {filter:()=>!0,needGeometry:!1,needFeature:!1};$a(t)||(t=Ja(t));const r=t;let n=!0;try{n=function(t){if(!Za(t))return t;let e=ja(t);return Xa(e),e=Ya(e),e}(r);}catch(t){console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r,null,2)}\n        `);}const i=qa[`filter_${e}`],a=Gi(n,i);let s=null;if("error"===a.result)throw new Error(a.value.map((t=>`${t.key}: ${t.message}`)).join(", "));s=(t,e,r)=>a.value.evaluate(t,e,{},r);let o=null,l=null;if(n!==r){const t=Gi(r,i);if("error"===t.result)throw new Error(t.value.map((t=>`${t.key}: ${t.message}`)).join(", "));o=(e,r,n,i,a)=>t.value.evaluate(e,r,{},n,void 0,void 0,i,a),l=!dn(t.value.expression);}return {filter:s,dynamicFilter:o||void 0,needGeometry:Wa(n),needFeature:!!l}}function Ya(t){if(!Array.isArray(t))return t;const e=function(t){if(Ka.has(t[0]))for(let e=1;e<t.length;e++)if(Za(t[e]))return !0;return t}(t);return !0===e?e:e.map((t=>Ya(t)))}function Xa(t){let e=!1;const r=[];if("case"===t[0]){for(let n=1;n<t.length-1;n+=2)e=e||Za(t[n]),r.push(t[n+1]);r.push(t[t.length-1]);}else if("match"===t[0]){e=e||Za(t[1]);for(let e=2;e<t.length-1;e+=2)r.push(t[e+1]);r.push(t[t.length-1]);}else if("step"===t[0]){e=e||Za(t[1]);for(let e=1;e<t.length-1;e+=2)r.push(t[e+1]);}e&&(t.length=0,t.push("any",...r));for(let e=1;e<t.length;e++)Xa(t[e]);}function Za(t){if(!Array.isArray(t))return !1;if("pitch"===(e=t[0])||"distance-from-center"===e)return !0;var e;for(let e=1;e<t.length;e++)if(Za(t[e]))return !0;return !1}const Ka=new Set(["in","==","!=",">",">=","<","<=","to-boolean"]);function Ha(t,e){return t<e?-1:t>e?1:0}function Wa(t){if(!Array.isArray(t))return !1;if("within"===t[0]||"distance"===t[0])return !0;for(let e=1;e<t.length;e++)if(Wa(t[e]))return !0;return !1}function Ja(t){if(!t)return !0;const e=t[0];return t.length<=1?"any"!==e:"=="===e?Qa(t[1],t[2],"=="):"!="===e?rs(Qa(t[1],t[2],"==")):"<"===e||">"===e||"<="===e||">="===e?Qa(t[1],t[2],e):"any"===e?(r=t.slice(1),["any"].concat(r.map(Ja))):"all"===e?["all"].concat(t.slice(1).map(Ja)):"none"===e?["all"].concat(t.slice(1).map(Ja).map(rs)):"in"===e?ts(t[1],t.slice(2)):"!in"===e?rs(ts(t[1],t.slice(2))):"has"===e?es(t[1]):"!has"!==e||rs(es(t[1]));var r;}function Qa(t,e,r){switch(t){case"$type":return [`filter-type-${r}`,e];case"$id":return [`filter-id-${r}`,e];default:return [`filter-${r}`,t,e]}}function ts(t,e){if(0===e.length)return !1;switch(t){case"$type":return ["filter-type-in",["literal",e]];case"$id":return ["filter-id-in",["literal",e]];default:return e.length>200&&!e.some((t=>typeof t!=typeof e[0]))?["filter-in-large",t,["literal",e.sort(Ha)]]:["filter-in-small",t,["literal",e]]}}function es(t){switch(t){case"$type":return !0;case"$id":return ["filter-has-id"];default:return ["filter-has",t]}}function rs(t){return ["!",t]}const ns="";function is(t,e){return e?`${t}${ns}${e}`:t}const as="-transition";class ss extends ee{constructor(t,e,r,n){if(super(),this.id=t.id,this.fqid=is(this.id,r),this.type=t.type,this.scope=r,this.options=n,this._featureFilter={filter:()=>!0,needGeometry:!1,needFeature:!1},this._filterCompiled=!1,this.isConfigDependent=!1,"custom"!==t.type&&(this.metadata=t.metadata,this.minzoom=t.minzoom,this.maxzoom=t.maxzoom,"background"!==t.type&&"sky"!==t.type&&"slot"!==t.type&&(this.source=t.source,this.sourceLayer=t["source-layer"],this.filter=t.filter),t.slot&&(this.slot=t.slot),e.layout&&(this._unevaluatedLayout=new Ra(e.layout,this.scope,n),this.isConfigDependent=this.isConfigDependent||this._unevaluatedLayout.isConfigDependent),e.paint)){this._transitionablePaint=new Ta(e.paint,this.scope,n);for(const e in t.paint)this.setPaintProperty(e,t.paint[e]);for(const e in t.layout)this.setLayoutProperty(e,t.layout[e]);this.isConfigDependent=this.isConfigDependent||this._transitionablePaint.isConfigDependent,this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new Va(e.paint);}}getLayoutProperty(t){return "visibility"===t?this.visibility:this._unevaluatedLayout.getValue(t)}setLayoutProperty(t,e){if("custom"===this.type&&"visibility"===t)return void(this.visibility=e);const r=this._unevaluatedLayout;r._properties.properties[t]&&(r.setValue(t,e),this.isConfigDependent=this.isConfigDependent||r.isConfigDependent,"visibility"===t&&this.possiblyEvaluateVisibility());}possiblyEvaluateVisibility(){this.visibility=this._unevaluatedLayout._values.visibility.possiblyEvaluate({zoom:0});}getPaintProperty(t){return L(t,as)?this._transitionablePaint.getTransition(t.slice(0,-11)):this._transitionablePaint.getValue(t)}setPaintProperty(t,e){const r=this._transitionablePaint,n=r._properties.properties;if(L(t,as)){const i=t.slice(0,-11);return n[i]&&r.setTransition(i,e||void 0),!1}if(!n[t])return !1;const i=r._values[t],a=i.value.isDataDriven(),s=i.value;r.setValue(t,e),this.isConfigDependent=this.isConfigDependent||r.isConfigDependent,this._handleSpecialPaintPropertyUpdate(t);const o=r._values[t].value,l=o.isDataDriven(),u=L(t,"pattern")||"line-dasharray"===t;return l||a||u||this._handleOverridablePaintPropertyUpdate(t,s,o)}_handleSpecialPaintPropertyUpdate(t){}getProgramIds(){return null}getDefaultProgramParams(t,e){return null}_handleOverridablePaintPropertyUpdate(t,e,r){return !1}isHidden(t){return !!(this.minzoom&&t<this.minzoom)||!!(this.maxzoom&&t>=this.maxzoom)||"none"===this.visibility}updateTransitions(t){this._transitioningPaint=this._transitionablePaint.transitioned(t,this._transitioningPaint);}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(t,e){this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(t,void 0,e)),this.paint=this._transitioningPaint.possiblyEvaluate(t,void 0,e);}serialize(){return N({id:this.id,type:this.type,slot:this.slot,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()},((t,e)=>!(void 0===t||"layout"===e&&!Object.keys(t).length||"paint"===e&&!Object.keys(t).length)))}is3D(){return !1}isSky(){return !1}isTileClipped(){return !1}hasOffscreenPass(){return !1}hasShadowPass(){return !1}canCastShadows(){return !1}hasLightBeamPass(){return !1}cutoffRange(){return 0}tileCoverLift(){return 0}resize(){}isStateDependent(){for(const t in this.paint._values){const e=this.paint.get(t);if(e instanceof Da&&Ti(e.property.specification)&&("source"===e.value.kind||"composite"===e.value.kind)&&e.value.isStateDependent)return !0}return !1}compileFilter(){this._filterCompiled||(this._featureFilter=Ga(this.filter),this._filterCompiled=!0);}invalidateCompiledFilter(){this._filterCompiled=!1;}dynamicFilter(){return this._featureFilter.dynamicFilter}dynamicFilterNeedsFeature(){return this._featureFilter.needFeature}getLayerRenderingStats(){return this._stats}resetLayerRenderingStats(t){this._stats&&("shadow"===t.renderPass?this._stats.numRenderedVerticesInShadowPass=0:this._stats.numRenderedVerticesInTransparentPass=0);}}const os={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array};class ls{constructor(t,e){this._structArray=t,this._pos1=e*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8;}}class us{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0);}static serialize(t,e){return t._trim(),e&&(t.isTransferred=!0,e.add(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}}static deserialize(t){const e=Object.create(this.prototype);return e.arrayBuffer=t.arrayBuffer,e.length=t.length,e.capacity=t.arrayBuffer.byteLength/e.bytesPerElement,e._refreshViews(),e}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews());}clear(){this.length=0;}resize(t){this.reserve(t),this.length=t;}reserve(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(5*this.capacity),128),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);const e=this.uint8;this._refreshViews(),e&&this.uint8.set(e);}}_refreshViews(){throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout")}emplace(...t){throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout")}emplaceBack(...t){throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout")}destroy(){this.int8=this.uint8=this.int16=this.uint16=this.int32=this.uint32=this.float32=null,this.arrayBuffer=null;}}function cs(t,e=1){let r=0,n=0;return {members:t.map((t=>{const i=os[t.type].BYTES_PER_ELEMENT,a=r=hs(r,Math.max(e,i)),s=t.components||1;return n=Math.max(n,i),r+=i*s,{name:t.name,type:t.type,components:s,offset:a}})),size:hs(r,Math.max(n,e)),alignment:e}}function hs(t,e){return Math.ceil(t/e)*e}class ps extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e){const r=this.length;return this.resize(r+1),this.emplace(r,t,e)}emplace(t,e,r){const n=2*t;return this.int16[n+0]=e,this.int16[n+1]=r,t}}ps.prototype.bytesPerElement=4,ra(ps,"StructArrayLayout2i4");class fs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r){const n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)}emplace(t,e,r,n){const i=3*t;return this.int16[i+0]=e,this.int16[i+1]=r,this.int16[i+2]=n,t}}fs.prototype.bytesPerElement=6,ra(fs,"StructArrayLayout3i6");class ds extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const a=4*t;return this.int16[a+0]=e,this.int16[a+1]=r,this.int16[a+2]=n,this.int16[a+3]=i,t}}ds.prototype.bytesPerElement=8,ra(ds,"StructArrayLayout4i8");class ms extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i)}emplace(t,e,r,n,i,a){const s=5*t;return this.int16[s+0]=e,this.int16[s+1]=r,this.int16[s+2]=n,this.int16[s+3]=i,this.int16[s+4]=a,t}}ms.prototype.bytesPerElement=10,ra(ms,"StructArrayLayout5i10");class ys extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s){const o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a,s)}emplace(t,e,r,n,i,a,s,o){const l=6*t,u=12*t,c=3*t;return this.int16[l+0]=e,this.int16[l+1]=r,this.uint8[u+4]=n,this.uint8[u+5]=i,this.uint8[u+6]=a,this.uint8[u+7]=s,this.float32[c+2]=o,t}}ys.prototype.bytesPerElement=12,ra(ys,"StructArrayLayout2i4ub1f12");class gs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const a=4*t;return this.float32[a+0]=e,this.float32[a+1]=r,this.float32[a+2]=n,this.float32[a+3]=i,t}}gs.prototype.bytesPerElement=16,ra(gs,"StructArrayLayout4f16");class xs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i)}emplace(t,e,r,n,i,a){const s=6*t,o=3*t;return this.uint16[s+0]=e,this.uint16[s+1]=r,this.uint16[s+2]=n,this.uint16[s+3]=i,this.float32[o+2]=a,t}}xs.prototype.bytesPerElement=12,ra(xs,"StructArrayLayout4ui1f12");class vs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const a=4*t;return this.uint16[a+0]=e,this.uint16[a+1]=r,this.uint16[a+2]=n,this.uint16[a+3]=i,t}}vs.prototype.bytesPerElement=8,ra(vs,"StructArrayLayout4ui8");class bs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a){const s=this.length;return this.resize(s+1),this.emplace(s,t,e,r,n,i,a)}emplace(t,e,r,n,i,a,s){const o=6*t;return this.int16[o+0]=e,this.int16[o+1]=r,this.int16[o+2]=n,this.int16[o+3]=i,this.int16[o+4]=a,this.int16[o+5]=s,t}}bs.prototype.bytesPerElement=12,ra(bs,"StructArrayLayout6i12");class _s extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s,o,l,u,c,h){const p=this.length;return this.resize(p+1),this.emplace(p,t,e,r,n,i,a,s,o,l,u,c,h)}emplace(t,e,r,n,i,a,s,o,l,u,c,h,p){const f=12*t;return this.int16[f+0]=e,this.int16[f+1]=r,this.int16[f+2]=n,this.int16[f+3]=i,this.uint16[f+4]=a,this.uint16[f+5]=s,this.uint16[f+6]=o,this.uint16[f+7]=l,this.int16[f+8]=u,this.int16[f+9]=c,this.int16[f+10]=h,this.int16[f+11]=p,t}}_s.prototype.bytesPerElement=24,ra(_s,"StructArrayLayout4i4ui4i24");class ws extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a){const s=this.length;return this.resize(s+1),this.emplace(s,t,e,r,n,i,a)}emplace(t,e,r,n,i,a,s){const o=10*t,l=5*t;return this.int16[o+0]=e,this.int16[o+1]=r,this.int16[o+2]=n,this.float32[l+2]=i,this.float32[l+3]=a,this.float32[l+4]=s,t}}ws.prototype.bytesPerElement=20,ra(ws,"StructArrayLayout3i3f20");class Ms extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.uint32[1*t+0]=e,t}}Ms.prototype.bytesPerElement=4,ra(Ms,"StructArrayLayout1ul4");class As extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e){const r=this.length;return this.resize(r+1),this.emplace(r,t,e)}emplace(t,e,r){const n=2*t;return this.uint16[n+0]=e,this.uint16[n+1]=r,t}}As.prototype.bytesPerElement=4,ra(As,"StructArrayLayout2ui4");class Ss extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s,o,l,u,c,h,p){const f=this.length;return this.resize(f+1),this.emplace(f,t,e,r,n,i,a,s,o,l,u,c,h,p)}emplace(t,e,r,n,i,a,s,o,l,u,c,h,p,f){const d=20*t,m=10*t;return this.int16[d+0]=e,this.int16[d+1]=r,this.int16[d+2]=n,this.int16[d+3]=i,this.int16[d+4]=a,this.float32[m+3]=s,this.float32[m+4]=o,this.float32[m+5]=l,this.float32[m+6]=u,this.int16[d+14]=c,this.uint32[m+8]=h,this.uint16[d+18]=p,this.uint16[d+19]=f,t}}Ss.prototype.bytesPerElement=40,ra(Ss,"StructArrayLayout5i4f1i1ul2ui40");class Is extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s){const o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a,s)}emplace(t,e,r,n,i,a,s,o){const l=8*t;return this.int16[l+0]=e,this.int16[l+1]=r,this.int16[l+2]=n,this.int16[l+4]=i,this.int16[l+5]=a,this.int16[l+6]=s,this.int16[l+7]=o,t}}Is.prototype.bytesPerElement=16,ra(Is,"StructArrayLayout3i2i2i16");class ks extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i)}emplace(t,e,r,n,i,a){const s=4*t,o=8*t;return this.float32[s+0]=e,this.float32[s+1]=r,this.float32[s+2]=n,this.int16[o+6]=i,this.int16[o+7]=a,t}}ks.prototype.bytesPerElement=16,ra(ks,"StructArrayLayout2f1f2i16");class Ps extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const a=12*t,s=3*t;return this.uint8[a+0]=e,this.uint8[a+1]=r,this.float32[s+1]=n,this.float32[s+2]=i,t}}Ps.prototype.bytesPerElement=12,ra(Ps,"StructArrayLayout2ub2f12");class Es extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r){const n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)}emplace(t,e,r,n){const i=3*t;return this.uint16[i+0]=e,this.uint16[i+1]=r,this.uint16[i+2]=n,t}}Es.prototype.bytesPerElement=6,ra(Es,"StructArrayLayout3ui6");class zs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b){const _=this.length;return this.resize(_+1),this.emplace(_,t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b)}emplace(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b,_){const w=30*t,M=15*t,A=60*t;return this.int16[w+0]=e,this.int16[w+1]=r,this.int16[w+2]=n,this.float32[M+2]=i,this.float32[M+3]=a,this.uint16[w+8]=s,this.uint16[w+9]=o,this.uint32[M+5]=l,this.uint32[M+6]=u,this.uint32[M+7]=c,this.uint16[w+16]=h,this.uint16[w+17]=p,this.uint16[w+18]=f,this.float32[M+10]=d,this.float32[M+11]=m,this.uint8[A+48]=y,this.uint8[A+49]=g,this.uint8[A+50]=x,this.uint32[M+13]=v,this.int16[w+28]=b,this.uint8[A+58]=_,t}}zs.prototype.bytesPerElement=60,ra(zs,"StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");class Ts extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b,_,w,M,A,S,I,k,P,E,z,T){const B=this.length;return this.resize(B+1),this.emplace(B,t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b,_,w,M,A,S,I,k,P,E,z,T)}emplace(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b,_,w,M,A,S,I,k,P,E,z,T,B){const C=20*t,R=40*t,D=80*t;return this.float32[C+0]=e,this.float32[C+1]=r,this.int16[R+4]=n,this.int16[R+5]=i,this.int16[R+6]=a,this.int16[R+7]=s,this.int16[R+8]=o,this.int16[R+9]=l,this.int16[R+10]=u,this.int16[R+11]=c,this.int16[R+12]=h,this.uint16[R+13]=p,this.uint16[R+14]=f,this.uint16[R+15]=d,this.uint16[R+16]=m,this.uint16[R+17]=y,this.uint16[R+18]=g,this.uint16[R+19]=x,this.uint16[R+20]=v,this.uint16[R+21]=b,this.uint16[R+22]=_,this.uint16[R+23]=w,this.uint16[R+24]=M,this.uint16[R+25]=A,this.uint16[R+26]=S,this.uint16[R+27]=I,this.uint32[C+14]=k,this.float32[C+15]=P,this.float32[C+16]=E,this.float32[C+17]=z,this.float32[C+18]=T,this.uint8[D+76]=B,t}}Ts.prototype.bytesPerElement=80,ra(Ts,"StructArrayLayout2f9i15ui1ul4f1ub80");class Bs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.float32[1*t+0]=e,t}}Bs.prototype.bytesPerElement=4,ra(Bs,"StructArrayLayout1f4");class Cs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i){const a=this.length;return this.resize(a+1),this.emplace(a,t,e,r,n,i)}emplace(t,e,r,n,i,a){const s=5*t;return this.float32[s+0]=e,this.float32[s+1]=r,this.float32[s+2]=n,this.float32[s+3]=i,this.float32[s+4]=a,t}}Cs.prototype.bytesPerElement=20,ra(Cs,"StructArrayLayout5f20");class Rs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s){const o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a,s)}emplace(t,e,r,n,i,a,s,o){const l=7*t;return this.float32[l+0]=e,this.float32[l+1]=r,this.float32[l+2]=n,this.float32[l+3]=i,this.float32[l+4]=a,this.float32[l+5]=s,this.float32[l+6]=o,t}}Rs.prototype.bytesPerElement=28,ra(Rs,"StructArrayLayout7f28");class Ds extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t,e,r,n){const i=this.length;return this.resize(i+1),this.emplace(i,t,e,r,n)}emplace(t,e,r,n,i){const a=6*t;return this.uint32[3*t+0]=e,this.uint16[a+2]=r,this.uint16[a+3]=n,this.uint16[a+4]=i,t}}Ds.prototype.bytesPerElement=12,ra(Ds,"StructArrayLayout1ul3ui12");class Vs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.uint16[1*t+0]=e,t}}Vs.prototype.bytesPerElement=2,ra(Vs,"StructArrayLayout1ui2");class Ls extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r){const n=this.length;return this.resize(n+1),this.emplace(n,t,e,r)}emplace(t,e,r,n){const i=3*t;return this.float32[i+0]=e,this.float32[i+1]=r,this.float32[i+2]=n,t}}Ls.prototype.bytesPerElement=12,ra(Ls,"StructArrayLayout3f12");class Fs extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e){const r=this.length;return this.resize(r+1),this.emplace(r,t,e)}emplace(t,e,r){const n=2*t;return this.float32[n+0]=e,this.float32[n+1]=r,t}}Fs.prototype.bytesPerElement=8,ra(Fs,"StructArrayLayout2f8");class Ns extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m){const y=this.length;return this.resize(y+1),this.emplace(y,t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m)}emplace(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y){const g=16*t;return this.float32[g+0]=e,this.float32[g+1]=r,this.float32[g+2]=n,this.float32[g+3]=i,this.float32[g+4]=a,this.float32[g+5]=s,this.float32[g+6]=o,this.float32[g+7]=l,this.float32[g+8]=u,this.float32[g+9]=c,this.float32[g+10]=h,this.float32[g+11]=p,this.float32[g+12]=f,this.float32[g+13]=d,this.float32[g+14]=m,this.float32[g+15]=y,t}}Ns.prototype.bytesPerElement=64,ra(Ns,"StructArrayLayout16f64");class Os extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer);}emplaceBack(t,e,r,n,i,a,s){const o=this.length;return this.resize(o+1),this.emplace(o,t,e,r,n,i,a,s)}emplace(t,e,r,n,i,a,s,o){const l=10*t,u=5*t;return this.uint16[l+0]=e,this.uint16[l+1]=r,this.uint16[l+2]=n,this.uint16[l+3]=i,this.float32[u+2]=a,this.float32[u+3]=s,this.float32[u+4]=o,t}}Os.prototype.bytesPerElement=20,ra(Os,"StructArrayLayout4ui3f20");class Us extends us{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer);}emplaceBack(t){const e=this.length;return this.resize(e+1),this.emplace(e,t)}emplace(t,e){return this.uint8[1*t+0]=e,t}}Us.prototype.bytesPerElement=1,ra(Us,"StructArrayLayout1ub1");class js extends ls{get projectedAnchorX(){return this._structArray.int16[this._pos2+0]}get projectedAnchorY(){return this._structArray.int16[this._pos2+1]}get projectedAnchorZ(){return this._structArray.int16[this._pos2+2]}get tileAnchorX(){return this._structArray.int16[this._pos2+3]}get tileAnchorY(){return this._structArray.int16[this._pos2+4]}get x1(){return this._structArray.float32[this._pos4+3]}get y1(){return this._structArray.float32[this._pos4+4]}get x2(){return this._structArray.float32[this._pos4+5]}get y2(){return this._structArray.float32[this._pos4+6]}get padding(){return this._structArray.int16[this._pos2+14]}get featureIndex(){return this._structArray.uint32[this._pos4+8]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+18]}get bucketIndex(){return this._structArray.uint16[this._pos2+19]}}js.prototype.size=40;class qs extends Ss{get(t){return new js(this,t)}}ra(qs,"CollisionBoxArray");class $s extends ls{get projectedAnchorX(){return this._structArray.int16[this._pos2+0]}get projectedAnchorY(){return this._structArray.int16[this._pos2+1]}get projectedAnchorZ(){return this._structArray.int16[this._pos2+2]}get tileAnchorX(){return this._structArray.float32[this._pos4+2]}get tileAnchorY(){return this._structArray.float32[this._pos4+3]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+8]}get numGlyphs(){return this._structArray.uint16[this._pos2+9]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+5]}get lineStartIndex(){return this._structArray.uint32[this._pos4+6]}get lineLength(){return this._structArray.uint32[this._pos4+7]}get segment(){return this._structArray.uint16[this._pos2+16]}get lowerSize(){return this._structArray.uint16[this._pos2+17]}get upperSize(){return this._structArray.uint16[this._pos2+18]}get lineOffsetX(){return this._structArray.float32[this._pos4+10]}get lineOffsetY(){return this._structArray.float32[this._pos4+11]}get writingMode(){return this._structArray.uint8[this._pos1+48]}get placedOrientation(){return this._structArray.uint8[this._pos1+49]}set placedOrientation(t){this._structArray.uint8[this._pos1+49]=t;}get hidden(){return this._structArray.uint8[this._pos1+50]}set hidden(t){this._structArray.uint8[this._pos1+50]=t;}get crossTileID(){return this._structArray.uint32[this._pos4+13]}set crossTileID(t){this._structArray.uint32[this._pos4+13]=t;}get associatedIconIndex(){return this._structArray.int16[this._pos2+28]}get flipState(){return this._structArray.uint8[this._pos1+58]}set flipState(t){this._structArray.uint8[this._pos1+58]=t;}}$s.prototype.size=60;class Gs extends zs{get(t){return new $s(this,t)}}ra(Gs,"PlacedSymbolArray");class Ys extends ls{get tileAnchorX(){return this._structArray.float32[this._pos4+0]}get tileAnchorY(){return this._structArray.float32[this._pos4+1]}get projectedAnchorX(){return this._structArray.int16[this._pos2+4]}get projectedAnchorY(){return this._structArray.int16[this._pos2+5]}get projectedAnchorZ(){return this._structArray.int16[this._pos2+6]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+7]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+8]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+9]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+10]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+11]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+12]}get key(){return this._structArray.uint16[this._pos2+13]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+14]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+15]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+16]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+17]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+18]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+19]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+20]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+21]}get featureIndex(){return this._structArray.uint16[this._pos2+22]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+23]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+24]}get numIconVertices(){return this._structArray.uint16[this._pos2+25]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+26]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+27]}get crossTileID(){return this._structArray.uint32[this._pos4+14]}set crossTileID(t){this._structArray.uint32[this._pos4+14]=t;}get textOffset0(){return this._structArray.float32[this._pos4+15]}get textOffset1(){return this._structArray.float32[this._pos4+16]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+17]}get zOffset(){return this._structArray.float32[this._pos4+18]}set zOffset(t){this._structArray.float32[this._pos4+18]=t;}get hasIconTextFit(){return this._structArray.uint8[this._pos1+76]}}Ys.prototype.size=80;class Xs extends Ts{get(t){return new Ys(this,t)}}ra(Xs,"SymbolInstanceArray");class Zs extends Bs{getoffsetX(t){return this.float32[1*t+0]}}ra(Zs,"GlyphOffsetArray");class Ks extends ps{getx(t){return this.int16[2*t+0]}gety(t){return this.int16[2*t+1]}}ra(Ks,"SymbolLineVertexArray");class Hs extends ls{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}get layoutVertexArrayOffset(){return this._structArray.uint16[this._pos2+4]}}Hs.prototype.size=12;class Ws extends Ds{get(t){return new Hs(this,t)}}ra(Ws,"FeatureIndexArray");class Js extends As{geta_centroid_pos0(t){return this.uint16[2*t+0]}geta_centroid_pos1(t){return this.uint16[2*t+1]}}ra(Js,"FillExtrusionCentroidArray");const Qs=cs([{name:"a_pos",components:2,type:"Int16"}],4),to=cs([{name:"a_pos_3",components:3,type:"Int16"},{name:"a_pos_normal_3",components:3,type:"Int16"}]);class eo{constructor(t=[]){this.segments=t;}_prepareSegment(t,e,r,n){let i=this.segments[this.segments.length-1];return t>eo.MAX_VERTEX_ARRAY_LENGTH&&j(`Max vertices per segment is ${eo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`),(!i||i.vertexLength+t>eo.MAX_VERTEX_ARRAY_LENGTH||i.sortKey!==n)&&(i={vertexOffset:e,primitiveOffset:r,vertexLength:0,primitiveLength:0},void 0!==n&&(i.sortKey=n),this.segments.push(i)),i}prepareSegment(t,e,r,n){return this._prepareSegment(t,e.length,r.length,n)}get(){return this.segments}destroy(){for(const t of this.segments)for(const e in t.vaos)t.vaos[e].destroy();}static simpleSegment(t,e,r,n){return new eo([{vertexOffset:t,primitiveOffset:e,vertexLength:r,primitiveLength:n,vaos:{},sortKey:0}])}}function ro(t,e){return 256*(t=I(Math.floor(t),0,255))+I(Math.floor(e),0,255)}eo.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1,ra(eo,"SegmentVector");const no=cs([{name:"a_pattern",components:4,type:"Uint16"},{name:"a_pixel_ratio",components:1,type:"Float32"}]),io=cs([{name:"a_dash",components:4,type:"Uint16"}]);var ao={exports:{}},so={exports:{}};!function(t){t.exports=function(t,e){var r,n,i,a,s,o,l,u;for(n=t.length-(r=3&t.length),i=e,s=3432918353,o=461845907,u=0;u<n;)l=255&t.charCodeAt(u)|(255&t.charCodeAt(++u))<<8|(255&t.charCodeAt(++u))<<16|(255&t.charCodeAt(++u))<<24,++u,i=27492+(65535&(a=5*(65535&(i=(i^=l=(65535&(l=(l=(65535&l)*s+(((l>>>16)*s&65535)<<16)&4294967295)<<15|l>>>17))*o+(((l>>>16)*o&65535)<<16)&4294967295)<<13|i>>>19))+((5*(i>>>16)&65535)<<16)&4294967295))+((58964+(a>>>16)&65535)<<16);switch(l=0,r){case 3:l^=(255&t.charCodeAt(u+2))<<16;case 2:l^=(255&t.charCodeAt(u+1))<<8;case 1:i^=l=(65535&(l=(l=(65535&(l^=255&t.charCodeAt(u)))*s+(((l>>>16)*s&65535)<<16)&4294967295)<<15|l>>>17))*o+(((l>>>16)*o&65535)<<16)&4294967295;}return i^=t.length,i=2246822507*(65535&(i^=i>>>16))+((2246822507*(i>>>16)&65535)<<16)&4294967295,i=3266489909*(65535&(i^=i>>>13))+((3266489909*(i>>>16)&65535)<<16)&4294967295,(i^=i>>>16)>>>0};}(so);var oo=so.exports,lo={exports:{}};!function(t){t.exports=function(t,e){for(var r,n=t.length,i=e^n,a=0;n>=4;)r=1540483477*(65535&(r=255&t.charCodeAt(a)|(255&t.charCodeAt(++a))<<8|(255&t.charCodeAt(++a))<<16|(255&t.charCodeAt(++a))<<24))+((1540483477*(r>>>16)&65535)<<16),i=1540483477*(65535&i)+((1540483477*(i>>>16)&65535)<<16)^(r=1540483477*(65535&(r^=r>>>24))+((1540483477*(r>>>16)&65535)<<16)),n-=4,++a;switch(n){case 3:i^=(255&t.charCodeAt(a+2))<<16;case 2:i^=(255&t.charCodeAt(a+1))<<8;case 1:i=1540483477*(65535&(i^=255&t.charCodeAt(a)))+((1540483477*(i>>>16)&65535)<<16);}return i=1540483477*(65535&(i^=i>>>13))+((1540483477*(i>>>16)&65535)<<16),(i^=i>>>15)>>>0};}(lo);var uo=oo,co=lo.exports;ao.exports=uo,ao.exports.murmur3=uo,ao.exports.murmur2=co;var ho=h(ao.exports);class po{constructor(){this.ids=[],this.uniqueIds=[],this.positions=[],this.indexed=!1;}add(t,e,r,n){this.ids.push(fo(t)),this.positions.push(e,r,n);}eachPosition(t,e){const r=fo(t);let n=0,i=this.ids.length-1;for(;n<i;){const t=n+i>>1;this.ids[t]>=r?i=t:n=t+1;}for(;this.ids[n]===r;)e(this.positions[3*n],this.positions[3*n+1],this.positions[3*n+2]),n++;}static serialize(t,e){const r=new Float64Array(t.ids),n=new Uint32Array(t.positions);return mo(r,n,0,r.length-1),e&&(e.add(r.buffer),e.add(n.buffer)),{ids:r,positions:n}}static deserialize(t){const e=new po;let r;e.ids=t.ids,e.positions=t.positions;for(const t of e.ids)t!==r&&e.uniqueIds.push(t),r=t;return e.indexed=!0,e}}function fo(t){const e=+t;return !isNaN(e)&&Number.MIN_SAFE_INTEGER<=e&&e<=Number.MAX_SAFE_INTEGER?e:ho(String(t))}function mo(t,e,r,n){for(;r<n;){const i=t[r+n>>1];let a=r-1,s=n+1;for(;;){do{a++;}while(t[a]<i);do{s--;}while(t[s]>i);if(a>=s)break;yo(t,a,s),yo(e,3*a,3*s),yo(e,3*a+1,3*s+1),yo(e,3*a+2,3*s+2);}s-r<n-s?(mo(t,e,r,s),r=s+1):(mo(t,e,s+1,n),n=s);}}function yo(t,e,r){const n=t[e];t[e]=t[r],t[r]=n;}ra(po,"FeaturePositionMap");class go{constructor(t){this.gl=t.gl,this.initialized=!1;}fetchUniformLocation(t,e){return this.location||this.initialized||(this.location=this.gl.getUniformLocation(t,e),this.initialized=!0),!!this.location}}class xo extends go{constructor(t){super(t),this.current=0;}set(t,e,r){this.fetchUniformLocation(t,e)&&this.current!==r&&(this.current=r,this.gl.uniform1i(this.location,r));}}class vo extends go{constructor(t){super(t),this.current=0;}set(t,e,r){this.fetchUniformLocation(t,e)&&this.current!==r&&(this.current=r,this.gl.uniform1f(this.location,r));}}class bo extends go{constructor(t){super(t),this.current=[0,0];}set(t,e,r){this.fetchUniformLocation(t,e)&&(r[0]===this.current[0]&&r[1]===this.current[1]||(this.current=r,this.gl.uniform2f(this.location,r[0],r[1])));}}class _o extends go{constructor(t){super(t),this.current=[0,0,0];}set(t,e,r){this.fetchUniformLocation(t,e)&&(r[0]===this.current[0]&&r[1]===this.current[1]&&r[2]===this.current[2]||(this.current=r,this.gl.uniform3f(this.location,r[0],r[1],r[2])));}}class wo extends go{constructor(t){super(t),this.current=[0,0,0,0];}set(t,e,r){this.fetchUniformLocation(t,e)&&(r[0]===this.current[0]&&r[1]===this.current[1]&&r[2]===this.current[2]&&r[3]===this.current[3]||(this.current=r,this.gl.uniform4f(this.location,r[0],r[1],r[2],r[3])));}}class Mo extends go{constructor(t){super(t),this.current=le.transparent;}set(t,e,r){this.fetchUniformLocation(t,e)&&(r.r===this.current.r&&r.g===this.current.g&&r.b===this.current.b&&r.a===this.current.a||(this.current=r,this.gl.uniform4f(this.location,r.r,r.g,r.b,r.a)));}}const Ao=new Float32Array(16);class So extends go{constructor(t){super(t),this.current=Ao;}set(t,e,r){if(this.fetchUniformLocation(t,e)){if(r[12]!==this.current[12]||r[0]!==this.current[0])return this.current=r,void this.gl.uniformMatrix4fv(this.location,!1,r);for(let t=1;t<16;t++)if(r[t]!==this.current[t]){this.current=r,this.gl.uniformMatrix4fv(this.location,!1,r);break}}}}const Io=new Float32Array(9),ko=new Float32Array(4);class Po extends go{constructor(t){super(t),this.current=ko;}set(t,e,r){if(this.fetchUniformLocation(t,e))for(let t=0;t<4;t++)if(r[t]!==this.current[t]){this.current=r,this.gl.uniformMatrix2fv(this.location,!1,r);break}}}function Eo(t){return [ro(255*t.r,255*t.g),ro(255*t.b,255*t.a)]}class zo{constructor(t,e,r){this.value=t,this.uniformNames=e.map((t=>`u_${t}`)),this.type=r;}setUniform(t,e,r,n,i){e.set(t,i,n.constantOr(this.value));}getBinding(t,e){return "color"===this.type?new Mo(t):new vo(t)}}class To{constructor(t,e){this.uniformNames=e.map((t=>`u_${t}`)),this.pattern=null,this.pixelRatio=1;}setConstantPatternPositions(t){this.pixelRatio=t.pixelRatio||1,this.pattern=t.tl.concat(t.br);}setUniform(t,e,r,n,i){const a="u_pattern"===i||"u_dash"===i?this.pattern:"u_pixel_ratio"===i?this.pixelRatio:null;a&&e.set(t,i,a);}getBinding(t,e){return "u_pattern"===e||"u_dash"===e?new wo(t):new vo(t)}}class Bo{constructor(t,e,r,n){this.expression=t,this.type=r,this.maxValue=0,this.paintVertexAttributes=e.map((t=>({name:`a_${t}`,type:"Float32",components:"color"===r?2:1,offset:0}))),this.paintVertexArray=new n;}populatePaintArray(t,e,r,n,i,a,s){const o=this.paintVertexArray.length,l=this.expression.evaluate(new Pa(0,{brightness:a}),e,{},i,n,s);this.paintVertexArray.resize(t),this._setPaintValue(o,t,l);}updatePaintArray(t,e,r,n,i,a,s){const o=this.expression.evaluate({zoom:0,brightness:s},r,n,void 0,i);this._setPaintValue(t,e,o);}_setPaintValue(t,e,r){if("color"===this.type){const n=Eo(r);for(let r=t;r<e;r++)this.paintVertexArray.emplace(r,n[0],n[1]);}else {for(let n=t;n<e;n++)this.paintVertexArray.emplace(n,r);this.maxValue=Math.max(this.maxValue,Math.abs(r));}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent||!this.expression.isLightConstant));}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();}}class Co{constructor(t,e,r,n,i,a){this.expression=t,this.uniformNames=e.map((t=>`u_${t}_t`)),this.type=r,this.useIntegerZoom=n,this.zoom=i,this.maxValue=0,this.paintVertexAttributes=e.map((t=>({name:`a_${t}`,type:"Float32",components:"color"===r?4:2,offset:0}))),this.paintVertexArray=new a;}populatePaintArray(t,e,r,n,i,a,s){const o=this.expression.evaluate(new Pa(this.zoom,{brightness:a}),e,{},i,n,s),l=this.expression.evaluate(new Pa(this.zoom+1,{brightness:a}),e,{},i,n,s),u=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(u,t,o,l);}updatePaintArray(t,e,r,n,i,a,s){const o=this.expression.evaluate({zoom:this.zoom,brightness:s},r,n,void 0,i),l=this.expression.evaluate({zoom:this.zoom+1,brightness:s},r,n,void 0,i);this._setPaintValue(t,e,o,l);}_setPaintValue(t,e,r,n){if("color"===this.type){const i=Eo(r),a=Eo(n);for(let r=t;r<e;r++)this.paintVertexArray.emplace(r,i[0],i[1],a[0],a[1]);}else {for(let i=t;i<e;i++)this.paintVertexArray.emplace(i,r,n);this.maxValue=Math.max(this.maxValue,Math.abs(r),Math.abs(n));}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent||!this.expression.isLightConstant));}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();}setUniform(t,e,r,n,i){const a=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,s=I(this.expression.interpolationFactor(a,this.zoom,this.zoom+1),0,1);e.set(t,i,s);}getBinding(t,e){return new vo(t)}}class Ro{constructor(t,e,r,n,i){this.expression=t,this.layerId=i,this.paintVertexAttributes=("array"===r?io:no).members;for(let t=0;t<e.length;++t);this.paintVertexArray=new n;}populatePaintArray(t,e,r){const n=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValues(n,t,e.patterns&&e.patterns[this.layerId],r);}updatePaintArray(t,e,r,n,i,a,s){this._setPaintValues(t,e,r.patterns&&r.patterns[this.layerId],a);}_setPaintValues(t,e,r,n){if(!n||!r)return;const i=n[r];if(!i)return;const{tl:a,br:s,pixelRatio:o}=i;for(let r=t;r<e;r++)this.paintVertexArray.emplace(r,a[0],a[1],s[0],s[1],o);}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent||!this.expression.isLightConstant));}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy();}}class Do{constructor(t,e,r=(()=>!0)){this.binders={},this._buffers=[];const n=[];for(const i in t.paint._values){const a=t.paint.get(i);if(!r(i))continue;if(!(a instanceof Da&&Ti(a.property.specification)))continue;const s=Fo(i,t.type),o=a.value,l=a.property.specification.type,u=!!a.property.useIntegerZoom,c="line-dasharray"===i||i.endsWith("pattern"),h="line-dasharray"===i&&"constant"!==t.layout.get("line-cap").value.kind;if("constant"!==o.kind||h)if("source"===o.kind||h||c){const e=Uo(i,l,"source");this.binders[i]=c?new Ro(o,s,l,e,t.id):new Bo(o,s,l,e),n.push(`/a_${i}`);}else {const t=Uo(i,l,"composite");this.binders[i]=new Co(o,s,l,u,e,t),n.push(`/z_${i}`);}else this.binders[i]=c?new To(o.value,s):new zo(o.value,s,l),n.push(`/u_${i}`);}this.cacheKey=n.sort().join("");}getMaxValue(t){const e=this.binders[t];return e instanceof Bo||e instanceof Co?e.maxValue:0}populatePaintArrays(t,e,r,n,i,a,s){for(const o in this.binders){const l=this.binders[o];(l instanceof Bo||l instanceof Co||l instanceof Ro)&&l.populatePaintArray(t,e,r,n,i,a,s);}}setConstantPatternPositions(t){for(const e in this.binders){const r=this.binders[e];r instanceof To&&r.setConstantPatternPositions(t);}}updatePaintArrays(t,e,r,n,i,a,s,o){let l=!1;const u=Object.keys(t),c=0!==u.length,h=c?u:e.uniqueIds;for(const u in this.binders){const p=this.binders[u];if((p instanceof Bo||p instanceof Co||p instanceof Ro)&&(!0===p.expression.isStateDependent||!1===p.expression.isLightConstant)){const f=i.paint.get(u);p.expression=f.value;for(const r of h){const i=t[r.toString()];e.eachPosition(r,((t,e,r)=>{const l=n.feature(t);p.updatePaintArray(e,r,l,i,a,s,o);}));}if(!c)for(const e of r.uniqueIds){const i=t[e.toString()];r.eachPosition(e,((t,e,r)=>{const l=n.feature(t);p.updatePaintArray(e,r,l,i,a,s,o);}));}l=!0;}}return l}defines(){const t=[];for(const e in this.binders){const r=this.binders[e];(r instanceof zo||r instanceof To)&&t.push(...r.uniformNames.map((t=>`#define HAS_UNIFORM_${t}`)));}return t}getBinderAttributes(){const t=[];for(const e in this.binders){const r=this.binders[e];if(r instanceof Bo||r instanceof Co||r instanceof Ro)for(let e=0;e<r.paintVertexAttributes.length;e++)t.push(r.paintVertexAttributes[e].name);}return t}getBinderUniforms(){const t=[];for(const e in this.binders){const r=this.binders[e];if(r instanceof zo||r instanceof To||r instanceof Co)for(const e of r.uniformNames)t.push(e);}return t}getPaintVertexBuffers(){return this._buffers}getUniforms(t){const e=[];for(const r in this.binders){const n=this.binders[r];if(n instanceof zo||n instanceof To||n instanceof Co)for(const i of n.uniformNames)e.push({name:i,property:r,binding:n.getBinding(t,i)});}return e}setUniforms(t,e,r,n,i){for(const{name:e,property:a,binding:s}of r)this.binders[a].setUniform(t,s,i,n.get(a),e);}updatePaintBuffers(){this._buffers=[];for(const t in this.binders){const e=this.binders[t];(e instanceof Bo||e instanceof Co||e instanceof Ro)&&e.paintVertexBuffer&&this._buffers.push(e.paintVertexBuffer);}}upload(t){for(const e in this.binders){const r=this.binders[e];(r instanceof Bo||r instanceof Co||r instanceof Ro)&&r.upload(t);}this.updatePaintBuffers();}destroy(){for(const t in this.binders){const e=this.binders[t];(e instanceof Bo||e instanceof Co||e instanceof Ro)&&e.destroy();}}}class Vo{constructor(t,e,r=(()=>!0)){this.programConfigurations={};for(const n of t)this.programConfigurations[n.id]=new Do(n,e,r);this.needsUpload=!1,this._featureMap=new po,this._featureMapWithoutIds=new po,this._bufferOffset=0,this._idlessCounter=0;}populatePaintArrays(t,e,r,n,i,a,s,o){for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t,e,n,i,a,s,o);void 0!==e.id?this._featureMap.add(e.id,r,this._bufferOffset,t):(this._featureMapWithoutIds.add(this._idlessCounter,r,this._bufferOffset,t),this._idlessCounter+=1),this._bufferOffset=t,this.needsUpload=!0;}updatePaintArrays(t,e,r,n,i,a){for(const s of r)this.needsUpload=this.programConfigurations[s.id].updatePaintArrays(t,this._featureMap,this._featureMapWithoutIds,e,s,n,i,a||0)||this.needsUpload;}get(t){return this.programConfigurations[t]}upload(t){if(this.needsUpload){for(const e in this.programConfigurations)this.programConfigurations[e].upload(t);this.needsUpload=!1;}}destroy(){for(const t in this.programConfigurations)this.programConfigurations[t].destroy();}}const Lo={"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-emissive-strength":["emissive_strength"],"icon-emissive-strength":["emissive_strength"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern","pixel_ratio"],"fill-pattern":["pattern","pixel_ratio"],"fill-extrusion-pattern":["pattern","pixel_ratio"],"line-dasharray":["dash"]};function Fo(t,e){return Lo[t]||[t.replace(`${e}-`,"").replace(/-/g,"_")]}const No={"line-pattern":{source:xs,composite:xs},"fill-pattern":{source:xs,composite:xs},"fill-extrusion-pattern":{source:xs,composite:xs},"line-dasharray":{source:vs,composite:vs}},Oo={color:{source:Fs,composite:gs},number:{source:Bs,composite:Fs}};function Uo(t,e,r){const n=No[t];return n&&n[r]||Oo[e][r]}ra(zo,"ConstantBinder"),ra(To,"PatternConstantBinder"),ra(Bo,"SourceExpressionBinder"),ra(Ro,"PatternCompositeBinder"),ra(Co,"CompositeExpressionBinder"),ra(Do,"ProgramConfiguration",{omit:["_buffers"]}),ra(Vo,"ProgramConfigurationSet");const jo=Tr/Math.PI/2,qo=5,$o=6,Go=16383,Yo=64,Xo=[Yo,32,16],Zo=-jo,Ko=jo;function Ho(t,e,r,n=jo){return r=b(r),[t*Math.sin(r)*n,-e*n,t*Math.cos(r)*n]}function Wo(t,e,r){return Ho(Math.cos(b(t)),Math.sin(b(t)),e,r)}const Jo=6371008.8,Qo=2*Math.PI*Jo;class tl{constructor(t,e){if(isNaN(t)||isNaN(e))throw new Error(`Invalid LngLat object: (${t}, ${e})`);if(this.lng=+t,this.lat=+e,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new tl(P(this.lng,-180,180),this.lat)}toArray(){return [this.lng,this.lat]}toString(){return `LngLat(${this.lng}, ${this.lat})`}distanceTo(t){const e=Math.PI/180,r=this.lat*e,n=t.lat*e,i=Math.sin(r)*Math.sin(n)+Math.cos(r)*Math.cos(n)*Math.cos((t.lng-this.lng)*e);return Jo*Math.acos(Math.min(i,1))}toBounds(t=0){const e=360*t/40075017,r=e/Math.cos(Math.PI/180*this.lat);return new el({lng:this.lng-r,lat:this.lat-e},{lng:this.lng+r,lat:this.lat+e})}toEcef(t){return Wo(this.lat,this.lng,jo+t*jo/Jo)}static convert(t){if(t instanceof tl)return t;if(Array.isArray(t)&&(2===t.length||3===t.length))return new tl(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&"object"==typeof t&&null!==t)return new tl(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}}class el{constructor(t,e){t&&(e?this.setSouthWest(t).setNorthEast(e):4===t.length?this.setSouthWest([t[0],t[1]]).setNorthEast([t[2],t[3]]):this.setSouthWest(t[0]).setNorthEast(t[1]));}setNorthEast(t){return this._ne=t instanceof tl?new tl(t.lng,t.lat):tl.convert(t),this}setSouthWest(t){return this._sw=t instanceof tl?new tl(t.lng,t.lat):tl.convert(t),this}extend(t){const e=this._sw,r=this._ne;let n,i;if(t instanceof tl)n=t,i=t;else {if(!(t instanceof el))return Array.isArray(t)?4===t.length||t.every(Array.isArray)?this.extend(el.convert(t)):this.extend(tl.convert(t)):"object"==typeof t&&null!==t&&t.hasOwnProperty("lat")&&(t.hasOwnProperty("lon")||t.hasOwnProperty("lng"))?this.extend(tl.convert(t)):this;if(n=t._sw,i=t._ne,!n||!i)return this}return e||r?(e.lng=Math.min(n.lng,e.lng),e.lat=Math.min(n.lat,e.lat),r.lng=Math.max(i.lng,r.lng),r.lat=Math.max(i.lat,r.lat)):(this._sw=new tl(n.lng,n.lat),this._ne=new tl(i.lng,i.lat)),this}getCenter(){return new tl((this._sw.lng+this._ne.lng)/2,(this._sw.lat+this._ne.lat)/2)}getSouthWest(){return this._sw}getNorthEast(){return this._ne}getNorthWest(){return new tl(this.getWest(),this.getNorth())}getSouthEast(){return new tl(this.getEast(),this.getSouth())}getWest(){return this._sw.lng}getSouth(){return this._sw.lat}getEast(){return this._ne.lng}getNorth(){return this._ne.lat}toArray(){return [this._sw.toArray(),this._ne.toArray()]}toString(){return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`}isEmpty(){return !(this._sw&&this._ne)}contains(t){const{lng:e,lat:r}=tl.convert(t);let n=this._sw.lng<=e&&e<=this._ne.lng;return this._sw.lng>this._ne.lng&&(n=this._sw.lng>=e&&e>=this._ne.lng),this._sw.lat<=r&&r<=this._ne.lat&&n}static convert(t){return !t||t instanceof el?t:new el(t)}}var rl={};!function(t,e){!function(t){function e(t,e,n){var i=r(256*t,256*(e=Math.pow(2,n)-e-1),n),a=r(256*(t+1),256*(e+1),n);return i[0]+","+i[1]+","+a[0]+","+a[1]}function r(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r);return [t*n-2*Math.PI*6378137/2,e*n-2*Math.PI*6378137/2]}t.getURL=function(t,r,n,i,a,s){return s=s||{},t+"?"+["bbox="+e(n,i,a),"format="+(s.format||"image/png"),"service="+(s.service||"WMS"),"version="+(s.version||"1.1.1"),"request="+(s.request||"GetMap"),"srs="+(s.srs||"EPSG:3857"),"width="+(s.width||256),"height="+(s.height||256),"layers="+r].join("&")},t.getTileBBox=e,t.getMercCoords=r,Object.defineProperty(t,"__esModule",{value:!0});}(e);}(0,rl);var nl=rl;class il{constructor(t,e,r){this.z=t,this.x=e,this.y=r,this.key=ol(0,t,t,e,r);}equals(t){return this.z===t.z&&this.x===t.x&&this.y===t.y}url(t,e){const r=nl.getTileBBox(this.x,this.y,this.z),n=function(t,e,r){let n,i="";for(let a=t;a>0;a--)n=1<<a-1,i+=(e&n?1:0)+(r&n?2:0);return i}(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace("{prefix}",(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String("tms"===e?Math.pow(2,this.z)-this.y-1:this.y)).replace("{quadkey}",n).replace("{bbox-epsg-3857}",r)}toString(){return `${this.z}/${this.x}/${this.y}`}}class al{constructor(t,e){this.wrap=t,this.canonical=e,this.key=ol(t,e.z,e.z,e.x,e.y);}}class sl{constructor(t,e,r,n,i){this.overscaledZ=t,this.wrap=e,this.canonical=new il(r,+n,+i),this.key=0===e&&t===r?this.canonical.key:ol(e,t,r,n,i);}equals(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)}scaledTo(t){const e=this.canonical.z-t;return t>this.canonical.z?new sl(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new sl(t,this.wrap,t,this.canonical.x>>e,this.canonical.y>>e)}calculateScaledKey(t,e=!0){if(this.overscaledZ===t&&e)return this.key;if(t>this.canonical.z)return ol(this.wrap*+e,t,this.canonical.z,this.canonical.x,this.canonical.y);{const r=this.canonical.z-t;return ol(this.wrap*+e,t,t,this.canonical.x>>r,this.canonical.y>>r)}}isChildOf(t){if(t.wrap!==this.wrap)return !1;const e=this.canonical.z-t.canonical.z;return 0===t.overscaledZ||t.overscaledZ<this.overscaledZ&&t.canonical.z<this.canonical.z&&t.canonical.x===this.canonical.x>>e&&t.canonical.y===this.canonical.y>>e}children(t){if(this.overscaledZ>=t)return [new sl(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];const e=this.canonical.z+1,r=2*this.canonical.x,n=2*this.canonical.y;return [new sl(e,this.wrap,e,r,n),new sl(e,this.wrap,e,r+1,n),new sl(e,this.wrap,e,r,n+1),new sl(e,this.wrap,e,r+1,n+1)]}isLessThan(t){return this.wrap<t.wrap||!(this.wrap>t.wrap)&&(this.overscaledZ<t.overscaledZ||!(this.overscaledZ>t.overscaledZ)&&(this.canonical.x<t.canonical.x||!(this.canonical.x>t.canonical.x)&&this.canonical.y<t.canonical.y))}wrapped(){return new sl(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(t){return new sl(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new al(this.wrap,this.canonical)}toString(){return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`}}function ol(t,e,r,n,i){const a=1<<Math.min(r,22);let s=a*(i%a)+n%a;return t&&r<22&&(s+=a*a*((t<0?-2*t-1:2*t)%(1<<2*(22-r)))),16*(32*s+r)+(e-r)}const ll=[t=>{let e=t.canonical.x-1,r=t.wrap;return e<0&&(e=(1<<t.canonical.z)-1,r--),new sl(t.overscaledZ,r,t.canonical.z,e,t.canonical.y)},t=>{let e=t.canonical.x+1,r=t.wrap;return e===1<<t.canonical.z&&(e=0,r++),new sl(t.overscaledZ,r,t.canonical.z,e,t.canonical.y)},t=>new sl(t.overscaledZ,t.wrap,t.canonical.z,t.canonical.x,(0===t.canonical.y?1<<t.canonical.z:t.canonical.y)-1),t=>new sl(t.overscaledZ,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y===(1<<t.canonical.z)-1?0:t.canonical.y+1)];ra(il,"CanonicalTileID"),ra(sl,"OverscaledTileID",{omit:["projMatrix","expandedProjMatrix"]});const ul=0,cl=25.5;function hl(t){return Qo*Math.cos(t*Math.PI/180)}function pl(t){return (180+t)/360}function fl(t){return (180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function dl(t,e){return t/hl(e)}function ml(t){return 360*t-180}function yl(t){return 360/Math.PI*Math.atan(Math.exp((180-360*t)*Math.PI/180))-90}function gl(t,e){return t*hl(yl(e))}const xl=85.051129;function vl(t){return Math.cos(b(I(t,-xl,xl)))}function bl(t,e){const r=I(e,ul,cl),n=Math.pow(2,r);return vl(t)*Qo/(512*n)}function _l(t){return 1/Math.cos(t*Math.PI/180)}function wl(t,e=0){const r=Math.exp(Math.PI*(1-(t.y+e/Tr)/(1<<t.z)*2));return 80150034*r/(r*r+1)/Tr/(1<<t.z)}class Ml{constructor(t,e,r=0){this.x=+t,this.y=+e,this.z=+r;}static fromLngLat(t,e=0){const r=tl.convert(t);return new Ml(pl(r.lng),fl(r.lat),dl(e,r.lat))}toLngLat(){return new tl(ml(this.x),yl(this.y))}toAltitude(){return gl(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/Qo*_l(yl(this.y))}}function Al(t,e,r,n,i,a,s,o,l){const u=(e+n)/2,c=(r+i)/2,h=new g(u,c);o(h),function(t,e,r,n,i,a){const s=r-i,o=n-a;return Math.abs((n-e)*s-(r-t)*o)/Math.hypot(s,o)}(h.x,h.y,a.x,a.y,s.x,s.y)>=l?(Al(t,e,r,u,c,a,h,o,l),Al(t,u,c,n,i,h,s,o,l)):t.push(s);}function Sl(t,e,r){let n=t[0],i=n.x,a=n.y;e(n);const s=[n];for(let o=1;o<t.length;o++){const l=t[o],{x:u,y:c}=l;e(l),Al(s,i,a,u,c,n,l,e,r),i=u,a=c,n=l;}return s}function Il(t,e,r,n){if(n(e,r)){const i=e.add(r)._mult(.5);Il(t,e,i,n),Il(t,i,r,n);}else t.push(r);}function kl(t,e){let r=t[0];const n=[r];for(let i=1;i<t.length;i++){const a=t[i];Il(n,r,a,e),r=a;}return n}const Pl=Math.pow(2,14)-1,El=-Pl-1;function zl(t,e){const r=Math.round(t.x*e),n=Math.round(t.y*e);return t.x=I(r,El,Pl),t.y=I(n,El,Pl),(r<t.x||r>t.x+1||n<t.y||n>t.y+1)&&j("Geometry exceeds allowed extent, reduce your vector tile buffer size"),t}function Tl(t,e,r){const n=t.loadGeometry(),i=t.extent,a=Tr/i;if(e&&r&&r.projection.isReprojectedInTileSpace){const a=1<<e.z,{scale:s,x:o,y:l,projection:u}=r,c=t=>{const r=ml((e.x+t.x/i)/a),n=yl((e.y+t.y/i)/a),c=u.project(r,n);t.x=(c.x*s-o)*i,t.y=(c.y*s-l)*i;};for(let e=0;e<n.length;e++)if(1!==t.type)n[e]=Sl(n[e],c,1);else {const t=[];for(const r of n[e])r.x<0||r.x>=i||r.y<0||r.y>=i||(c(r),t.push(r));n[e]=t;}}for(const t of n)for(const e of t)zl(e,a);return n}function Bl(t,e){return {type:t.type,id:t.id,properties:t.properties,geometry:e?Tl(t):[]}}function Cl(t,e,r,n,i){t.emplaceBack(2*e+(n+1)/2,2*r+(i+1)/2);}function Rl(t,e,r){const n=16384;t.emplaceBack(e.x,e.y,e.z,r[0]*n,r[1]*n,r[2]*n);}class Dl{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.fqid)),this.index=t.index,this.hasPattern=!1,this.projection=t.projection,this.layoutVertexArray=new ps,this.indexArray=new Es,this.segments=new eo,this.programConfigurations=new Vo(t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id));}populate(t,e,r,n){const i=this.layers[0],a=[];let s=null;"circle"===i.type&&(s=i.layout.get("circle-sort-key"));for(const{feature:e,id:i,index:o,sourceLayerIndex:l}of t){const t=this.layers[0]._featureFilter.needGeometry,u=Bl(e,t);if(!this.layers[0]._featureFilter.filter(new Pa(this.zoom),u,r))continue;const c=s?s.evaluate(u,{},r):void 0,h={id:i,properties:e.properties,type:e.type,sourceLayerIndex:l,index:o,geometry:t?u.geometry:Tl(e,r,n),patterns:{},sortKey:c};a.push(h);}s&&a.sort(((t,e)=>t.sortKey-e.sortKey));let o=null;"globe"===n.projection.name&&(this.globeExtVertexArray=new bs,o=n.projection);for(const n of a){const{geometry:i,index:a,sourceLayerIndex:s}=n,l=t[a].feature;this.addFeature(n,i,a,e.availableImages,r,o,e.brightness),e.featureIndex.insert(l,i,a,s,this.index);}}update(t,e,r,n,i){const a=0!==Object.keys(t).length;a&&!this.stateDependentLayers.length||this.programConfigurations.updatePaintArrays(t,e,a?this.stateDependentLayers:this.layers,r,n,i);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Qs.members),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.globeExtVertexArray&&(this.globeExtVertexBuffer=t.createVertexBuffer(this.globeExtVertexArray,to.members))),this.programConfigurations.upload(t),this.uploaded=!0;}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.globeExtVertexBuffer&&this.globeExtVertexBuffer.destroy());}addFeature(t,e,r,n,i,a,s){for(const r of e)for(const e of r){const r=e.x,n=e.y;if(r<0||r>=Tr||n<0||n>=Tr)continue;if(a){const t=a.projectTilePoint(r,n,i),e=a.upVector(i,r,n),s=this.globeExtVertexArray;Rl(s,t,e),Rl(s,t,e),Rl(s,t,e),Rl(s,t,e);}const s=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),o=s.vertexLength;Cl(this.layoutVertexArray,r,n,-1,-1),Cl(this.layoutVertexArray,r,n,1,-1),Cl(this.layoutVertexArray,r,n,1,1),Cl(this.layoutVertexArray,r,n,-1,1),this.indexArray.emplaceBack(o,o+1,o+2),this.indexArray.emplaceBack(o,o+2,o+3),s.vertexLength+=4,s.primitiveLength+=2;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,{},n,i,s);}}function Vl(t,e){for(let r=0;r<t.length;r++)if(Gl(e,t[r]))return !0;for(let r=0;r<e.length;r++)if(Gl(t,e[r]))return !0;return !!Ol(t,e)}function Ll(t,e,r){return !!Gl(t,e)||!!jl(e,t,r)}function Fl(t,e){if(1===t.length)return $l(e,t[0]);for(let r=0;r<e.length;r++){const n=e[r];for(let e=0;e<n.length;e++)if(Gl(t,n[e]))return !0}for(let r=0;r<t.length;r++)if($l(e,t[r]))return !0;for(let r=0;r<e.length;r++)if(Ol(t,e[r]))return !0;return !1}function Nl(t,e,r){if(t.length>1){if(Ol(t,e))return !0;for(let n=0;n<e.length;n++)if(jl(e[n],t,r))return !0}for(let n=0;n<t.length;n++)if(jl(t[n],e,r))return !0;return !1}function Ol(t,e){if(0===t.length||0===e.length)return !1;for(let r=0;r<t.length-1;r++){const n=t[r],i=t[r+1];for(let t=0;t<e.length-1;t++)if(Ul(n,i,e[t],e[t+1]))return !0}return !1}function Ul(t,e,r,n){return q(t,r,n)!==q(e,r,n)&&q(t,e,r)!==q(t,e,n)}function jl(t,e,r){const n=r*r;if(1===e.length)return t.distSqr(e[0])<n;for(let r=1;r<e.length;r++)if(ql(t,e[r-1],e[r])<n)return !0;return !1}function ql(t,e,r){const n=e.distSqr(r);if(0===n)return t.distSqr(e);const i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return t.distSqr(i<0?e:i>1?r:r.sub(e)._mult(i)._add(e))}function $l(t,e){let r,n,i,a=!1;for(let s=0;s<t.length;s++){r=t[s];for(let t=0,s=r.length-1;t<r.length;s=t++)n=r[t],i=r[s],n.y>e.y!=i.y>e.y&&e.x<(i.x-n.x)*(e.y-n.y)/(i.y-n.y)+n.x&&(a=!a);}return a}function Gl(t,e){let r=!1;for(let n=0,i=t.length-1;n<t.length;i=n++){const a=t[n],s=t[i];a.y>e.y!=s.y>e.y&&e.x<(s.x-a.x)*(e.y-a.y)/(s.y-a.y)+a.x&&(r=!r);}return r}function Yl(t,e,r,n,i){for(const a of t)if(e<=a.x&&r<=a.y&&n>=a.x&&i>=a.y)return !0;const a=[new g(e,r),new g(e,i),new g(n,i),new g(n,r)];if(t.length>2)for(const e of a)if(Gl(t,e))return !0;for(let e=0;e<t.length-1;e++)if(Xl(t[e],t[e+1],a))return !0;return !1}function Xl(t,e,r){const n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return !1;const a=q(t,e,r[0]);return a!==q(t,e,r[1])||a!==q(t,e,r[2])||a!==q(t,e,r[3])}function Zl(t,e,r,n,i,a){let s=e.y-t.y,o=t.x-e.x;if(a=a||0){const t=s*s+o*o;if(0===t)return !0;const e=Math.sqrt(t);s/=e,o/=e;}return !((r.x-t.x)*s+(r.y-t.y)*o-a<0||(n.x-t.x)*s+(n.y-t.y)*o-a<0||(i.x-t.x)*s+(i.y-t.y)*o-a<0)}function Kl(t,e,r,n,i,a,s){return !(Zl(t,e,n,i,a,s)||Zl(e,r,n,i,a,s)||Zl(r,t,n,i,a,s)||Zl(n,i,t,e,r,s)||Zl(i,a,t,e,r,s)||Zl(a,n,t,e,r,s))}function Hl(t,e,r){const n=e.paint.get(t).value;return "constant"===n.kind?n.value:r.programConfigurations.get(e.id).getMaxValue(t)}function Wl(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function Jl(t,e,r,n,i){if(!e[0]&&!e[1])return t;const a=g.convert(e)._mult(i);"viewport"===r&&a._rotate(-n);const s=[];for(let e=0;e<t.length;e++)s.push(t[e].sub(a));return s}function Ql(t,e,r,n){const i=g.convert(t)._mult(n);return "viewport"===e&&i._rotate(-r),i}ra(Dl,"CircleBucket",{omit:["layers"]});const tu=new Oa({"circle-sort-key":new Fa(qa.layout_circle["circle-sort-key"]),visibility:new La(qa.layout_circle.visibility)});var eu={paint:new Oa({"circle-radius":new Fa(qa.paint_circle["circle-radius"]),"circle-color":new Fa(qa.paint_circle["circle-color"]),"circle-blur":new Fa(qa.paint_circle["circle-blur"]),"circle-opacity":new Fa(qa.paint_circle["circle-opacity"]),"circle-translate":new La(qa.paint_circle["circle-translate"]),"circle-translate-anchor":new La(qa.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new La(qa.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new La(qa.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new Fa(qa.paint_circle["circle-stroke-width"]),"circle-stroke-color":new Fa(qa.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new Fa(qa.paint_circle["circle-stroke-opacity"]),"circle-emissive-strength":new La(qa.paint_circle["circle-emissive-strength"])}),layout:tu},ru={},nu={};Object.defineProperty(nu,"__esModule",{value:!0}),nu.setMatrixArrayType=function(t){nu.ARRAY_TYPE=au=t;},nu.toRadian=function(t){return t*ou},nu.equals=function(t,e){return Math.abs(t-e)<=iu*Math.max(1,Math.abs(t),Math.abs(e))},nu.RANDOM=nu.ARRAY_TYPE=nu.EPSILON=void 0;var iu=1e-6;nu.EPSILON=iu;var au="undefined"!=typeof Float32Array?Float32Array:Array;nu.ARRAY_TYPE=au;var su=Math.random;nu.RANDOM=su;var ou=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var lu={};function uu(t){return uu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},uu(t)}Object.defineProperty(lu,"__esModule",{value:!0}),lu.create=function(){var t=new cu.ARRAY_TYPE(4);return cu.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t},lu.clone=function(t){var e=new cu.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},lu.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},lu.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},lu.fromValues=function(t,e,r,n){var i=new cu.ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i},lu.set=function(t,e,r,n,i){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t},lu.transpose=function(t,e){if(t===e){var r=e[1];t[1]=e[2],t[2]=r;}else t[0]=e[0],t[1]=e[2],t[2]=e[1],t[3]=e[3];return t},lu.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=r*a-i*n;return s?(t[0]=a*(s=1/s),t[1]=-n*s,t[2]=-i*s,t[3]=r*s,t):null},lu.adjoint=function(t,e){var r=e[0];return t[0]=e[3],t[1]=-e[1],t[2]=-e[2],t[3]=r,t},lu.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},lu.multiply=pu,lu.rotate=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l+a*o,t[1]=i*l+s*o,t[2]=n*-o+a*l,t[3]=i*-o+s*l,t},lu.scale=function(t,e,r){var n=e[1],i=e[2],a=e[3],s=r[0],o=r[1];return t[0]=e[0]*s,t[1]=n*s,t[2]=i*o,t[3]=a*o,t},lu.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=-r,t[3]=n,t},lu.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t},lu.str=function(t){return "mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},lu.frob=function(t){return Math.hypot(t[0],t[1],t[2],t[3])},lu.LDU=function(t,e,r,n){return t[2]=n[2]/n[0],r[0]=n[0],r[1]=n[1],r[3]=n[3]-t[2]*r[1],[t,e,r]},lu.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t},lu.subtract=fu,lu.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]},lu.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],s=e[0],o=e[1],l=e[2],u=e[3];return Math.abs(r-s)<=cu.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(n-o)<=cu.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(i-l)<=cu.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(a-u)<=cu.EPSILON*Math.max(1,Math.abs(a),Math.abs(u))},lu.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t},lu.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t},lu.sub=lu.mul=void 0;var cu=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==uu(t)&&"function"!=typeof t)return {default:t};var r=hu(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function hu(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (hu=function(t){return t?r:e})(t)}function pu(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=r[0],l=r[1],u=r[2],c=r[3];return t[0]=n*o+a*l,t[1]=i*o+s*l,t[2]=n*u+a*c,t[3]=i*u+s*c,t}function fu(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t}lu.mul=pu,lu.sub=fu;var du={};function mu(t){return mu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},mu(t)}Object.defineProperty(du,"__esModule",{value:!0}),du.create=function(){var t=new yu.ARRAY_TYPE(6);return yu.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t},du.clone=function(t){var e=new yu.ARRAY_TYPE(6);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},du.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},du.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},du.fromValues=function(t,e,r,n,i,a){var s=new yu.ARRAY_TYPE(6);return s[0]=t,s[1]=e,s[2]=r,s[3]=n,s[4]=i,s[5]=a,s},du.set=function(t,e,r,n,i,a,s){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t[4]=a,t[5]=s,t},du.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=r*a-n*i;return l?(t[0]=a*(l=1/l),t[1]=-n*l,t[2]=-i*l,t[3]=r*l,t[4]=(i*o-a*s)*l,t[5]=(n*s-r*o)*l,t):null},du.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},du.multiply=xu,du.rotate=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=Math.sin(r),c=Math.cos(r);return t[0]=n*c+a*u,t[1]=i*c+s*u,t[2]=n*-u+a*c,t[3]=i*-u+s*c,t[4]=o,t[5]=l,t},du.scale=function(t,e,r){var n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=r[0],u=r[1];return t[0]=e[0]*l,t[1]=n*l,t[2]=i*u,t[3]=a*u,t[4]=s,t[5]=o,t},du.translate=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=r[0],c=r[1];return t[0]=n,t[1]=i,t[2]=a,t[3]=s,t[4]=n*u+a*c+o,t[5]=i*u+s*c+l,t},du.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=-r,t[3]=n,t[4]=0,t[5]=0,t},du.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=e[1],t[4]=0,t[5]=0,t},du.fromTranslation=function(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=e[0],t[5]=e[1],t},du.str=function(t){return "mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},du.frob=function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],1)},du.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t},du.subtract=vu,du.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t},du.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t},du.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]},du.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],s=t[4],o=t[5],l=e[0],u=e[1],c=e[2],h=e[3],p=e[4],f=e[5];return Math.abs(r-l)<=yu.EPSILON*Math.max(1,Math.abs(r),Math.abs(l))&&Math.abs(n-u)<=yu.EPSILON*Math.max(1,Math.abs(n),Math.abs(u))&&Math.abs(i-c)<=yu.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))&&Math.abs(a-h)<=yu.EPSILON*Math.max(1,Math.abs(a),Math.abs(h))&&Math.abs(s-p)<=yu.EPSILON*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(o-f)<=yu.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))},du.sub=du.mul=void 0;var yu=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==mu(t)&&"function"!=typeof t)return {default:t};var r=gu(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function gu(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (gu=function(t){return t?r:e})(t)}function xu(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=r[0],c=r[1],h=r[2],p=r[3],f=r[4],d=r[5];return t[0]=n*u+a*c,t[1]=i*u+s*c,t[2]=n*h+a*p,t[3]=i*h+s*p,t[4]=n*f+a*d+o,t[5]=i*f+s*d+l,t}function vu(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t}du.mul=xu,du.sub=vu;var bu={};function _u(t){return _u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_u(t)}Object.defineProperty(bu,"__esModule",{value:!0}),bu.create=function(){var t=new wu.ARRAY_TYPE(9);return wu.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t},bu.fromMat4=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10],t},bu.clone=function(t){var e=new wu.ARRAY_TYPE(9);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},bu.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},bu.fromValues=function(t,e,r,n,i,a,s,o,l){var u=new wu.ARRAY_TYPE(9);return u[0]=t,u[1]=e,u[2]=r,u[3]=n,u[4]=i,u[5]=a,u[6]=s,u[7]=o,u[8]=l,u},bu.set=function(t,e,r,n,i,a,s,o,l,u){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t[4]=a,t[5]=s,t[6]=o,t[7]=l,t[8]=u,t},bu.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},bu.transpose=function(t,e){if(t===e){var r=e[1],n=e[2],i=e[5];t[1]=e[3],t[2]=e[6],t[3]=r,t[5]=e[7],t[6]=n,t[7]=i;}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8];return t},bu.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=e[6],u=e[7],c=e[8],h=c*s-o*u,p=-c*a+o*l,f=u*a-s*l,d=r*h+n*p+i*f;return d?(t[0]=h*(d=1/d),t[1]=(-c*n+i*u)*d,t[2]=(o*n-i*s)*d,t[3]=p*d,t[4]=(c*r-i*l)*d,t[5]=(-o*r+i*a)*d,t[6]=f*d,t[7]=(-u*r+n*l)*d,t[8]=(s*r-n*a)*d,t):null},bu.adjoint=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=e[6],u=e[7],c=e[8];return t[0]=s*c-o*u,t[1]=i*u-n*c,t[2]=n*o-i*s,t[3]=o*l-a*c,t[4]=r*c-i*l,t[5]=i*a-r*o,t[6]=a*u-s*l,t[7]=n*l-r*u,t[8]=r*s-n*a,t},bu.determinant=function(t){var e=t[3],r=t[4],n=t[5],i=t[6],a=t[7],s=t[8];return t[0]*(s*r-n*a)+t[1]*(-s*e+n*i)+t[2]*(a*e-r*i)},bu.multiply=Au,bu.translate=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=r[0],f=r[1];return t[0]=n,t[1]=i,t[2]=a,t[3]=s,t[4]=o,t[5]=l,t[6]=p*n+f*s+u,t[7]=p*i+f*o+c,t[8]=p*a+f*l+h,t},bu.rotate=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=Math.sin(r),f=Math.cos(r);return t[0]=f*n+p*s,t[1]=f*i+p*o,t[2]=f*a+p*l,t[3]=f*s-p*n,t[4]=f*o-p*i,t[5]=f*l-p*a,t[6]=u,t[7]=c,t[8]=h,t},bu.scale=function(t,e,r){var n=r[0],i=r[1];return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=i*e[3],t[4]=i*e[4],t[5]=i*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},bu.fromTranslation=function(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=e[0],t[7]=e[1],t[8]=1,t},bu.fromRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=-r,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},bu.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=e[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},bu.fromMat2d=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=0,t[3]=e[2],t[4]=e[3],t[5]=0,t[6]=e[4],t[7]=e[5],t[8]=1,t},bu.fromQuat=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=r+r,o=n+n,l=i+i,u=r*s,c=n*s,h=n*o,p=i*s,f=i*o,d=i*l,m=a*s,y=a*o,g=a*l;return t[0]=1-h-d,t[3]=c-g,t[6]=p+y,t[1]=c+g,t[4]=1-u-d,t[7]=f-m,t[2]=p-y,t[5]=f+m,t[8]=1-u-h,t},bu.normalFromMat4=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=e[6],u=e[7],c=e[8],h=e[9],p=e[10],f=e[11],d=e[12],m=e[13],y=e[14],g=e[15],x=r*o-n*s,v=r*l-i*s,b=r*u-a*s,_=n*l-i*o,w=n*u-a*o,M=i*u-a*l,A=c*m-h*d,S=c*y-p*d,I=c*g-f*d,k=h*y-p*m,P=h*g-f*m,E=p*g-f*y,z=x*E-v*P+b*k+_*I-w*S+M*A;return z?(t[0]=(o*E-l*P+u*k)*(z=1/z),t[1]=(l*I-s*E-u*S)*z,t[2]=(s*P-o*I+u*A)*z,t[3]=(i*P-n*E-a*k)*z,t[4]=(r*E-i*I+a*S)*z,t[5]=(n*I-r*P-a*A)*z,t[6]=(m*M-y*w+g*_)*z,t[7]=(y*b-d*M-g*v)*z,t[8]=(d*w-m*b+g*x)*z,t):null},bu.projection=function(t,e,r){return t[0]=2/e,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/r,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t},bu.str=function(t){return "mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},bu.frob=function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])},bu.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t[8]=e[8]+r[8],t},bu.subtract=Su,bu.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*r,t},bu.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t[6]=e[6]+r[6]*n,t[7]=e[7]+r[7]*n,t[8]=e[8]+r[8]*n,t},bu.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]},bu.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],s=t[4],o=t[5],l=t[6],u=t[7],c=t[8],h=e[0],p=e[1],f=e[2],d=e[3],m=e[4],y=e[5],g=e[6],x=e[7],v=e[8];return Math.abs(r-h)<=wu.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(n-p)<=wu.EPSILON*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(i-f)<=wu.EPSILON*Math.max(1,Math.abs(i),Math.abs(f))&&Math.abs(a-d)<=wu.EPSILON*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(s-m)<=wu.EPSILON*Math.max(1,Math.abs(s),Math.abs(m))&&Math.abs(o-y)<=wu.EPSILON*Math.max(1,Math.abs(o),Math.abs(y))&&Math.abs(l-g)<=wu.EPSILON*Math.max(1,Math.abs(l),Math.abs(g))&&Math.abs(u-x)<=wu.EPSILON*Math.max(1,Math.abs(u),Math.abs(x))&&Math.abs(c-v)<=wu.EPSILON*Math.max(1,Math.abs(c),Math.abs(v))},bu.sub=bu.mul=void 0;var wu=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==_u(t)&&"function"!=typeof t)return {default:t};var r=Mu(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function Mu(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (Mu=function(t){return t?r:e})(t)}function Au(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=r[0],f=r[1],d=r[2],m=r[3],y=r[4],g=r[5],x=r[6],v=r[7],b=r[8];return t[0]=p*n+f*s+d*u,t[1]=p*i+f*o+d*c,t[2]=p*a+f*l+d*h,t[3]=m*n+y*s+g*u,t[4]=m*i+y*o+g*c,t[5]=m*a+y*l+g*h,t[6]=x*n+v*s+b*u,t[7]=x*i+v*o+b*c,t[8]=x*a+v*l+b*h,t}function Su(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t[6]=e[6]-r[6],t[7]=e[7]-r[7],t[8]=e[8]-r[8],t}bu.mul=Au,bu.sub=Su;var Iu={};function ku(t){return ku="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ku(t)}Object.defineProperty(Iu,"__esModule",{value:!0}),Iu.create=function(){var t=new Pu.ARRAY_TYPE(16);return Pu.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},Iu.clone=function(t){var e=new Pu.ARRAY_TYPE(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},Iu.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},Iu.fromValues=function(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m){var y=new Pu.ARRAY_TYPE(16);return y[0]=t,y[1]=e,y[2]=r,y[3]=n,y[4]=i,y[5]=a,y[6]=s,y[7]=o,y[8]=l,y[9]=u,y[10]=c,y[11]=h,y[12]=p,y[13]=f,y[14]=d,y[15]=m,y},Iu.set=function(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t[4]=a,t[5]=s,t[6]=o,t[7]=l,t[8]=u,t[9]=c,t[10]=h,t[11]=p,t[12]=f,t[13]=d,t[14]=m,t[15]=y,t},Iu.identity=zu,Iu.transpose=function(t,e){if(t===e){var r=e[1],n=e[2],i=e[3],a=e[6],s=e[7],o=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=r,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=a,t[11]=e[14],t[12]=i,t[13]=s,t[14]=o;}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t},Iu.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=e[6],u=e[7],c=e[8],h=e[9],p=e[10],f=e[11],d=e[12],m=e[13],y=e[14],g=e[15],x=r*o-n*s,v=r*l-i*s,b=r*u-a*s,_=n*l-i*o,w=n*u-a*o,M=i*u-a*l,A=c*m-h*d,S=c*y-p*d,I=c*g-f*d,k=h*y-p*m,P=h*g-f*m,E=p*g-f*y,z=x*E-v*P+b*k+_*I-w*S+M*A;return z?(t[0]=(o*E-l*P+u*k)*(z=1/z),t[1]=(i*P-n*E-a*k)*z,t[2]=(m*M-y*w+g*_)*z,t[3]=(p*w-h*M-f*_)*z,t[4]=(l*I-s*E-u*S)*z,t[5]=(r*E-i*I+a*S)*z,t[6]=(y*b-d*M-g*v)*z,t[7]=(c*M-p*b+f*v)*z,t[8]=(s*P-o*I+u*A)*z,t[9]=(n*I-r*P-a*A)*z,t[10]=(d*w-m*b+g*x)*z,t[11]=(h*b-c*w-f*x)*z,t[12]=(o*S-s*k-l*A)*z,t[13]=(r*k-n*S+i*A)*z,t[14]=(m*v-d*_-y*x)*z,t[15]=(c*_-h*v+p*x)*z,t):null},Iu.adjoint=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=e[6],u=e[7],c=e[8],h=e[9],p=e[10],f=e[11],d=e[12],m=e[13],y=e[14],g=e[15];return t[0]=o*(p*g-f*y)-h*(l*g-u*y)+m*(l*f-u*p),t[1]=-(n*(p*g-f*y)-h*(i*g-a*y)+m*(i*f-a*p)),t[2]=n*(l*g-u*y)-o*(i*g-a*y)+m*(i*u-a*l),t[3]=-(n*(l*f-u*p)-o*(i*f-a*p)+h*(i*u-a*l)),t[4]=-(s*(p*g-f*y)-c*(l*g-u*y)+d*(l*f-u*p)),t[5]=r*(p*g-f*y)-c*(i*g-a*y)+d*(i*f-a*p),t[6]=-(r*(l*g-u*y)-s*(i*g-a*y)+d*(i*u-a*l)),t[7]=r*(l*f-u*p)-s*(i*f-a*p)+c*(i*u-a*l),t[8]=s*(h*g-f*m)-c*(o*g-u*m)+d*(o*f-u*h),t[9]=-(r*(h*g-f*m)-c*(n*g-a*m)+d*(n*f-a*h)),t[10]=r*(o*g-u*m)-s*(n*g-a*m)+d*(n*u-a*o),t[11]=-(r*(o*f-u*h)-s*(n*f-a*h)+c*(n*u-a*o)),t[12]=-(s*(h*y-p*m)-c*(o*y-l*m)+d*(o*p-l*h)),t[13]=r*(h*y-p*m)-c*(n*y-i*m)+d*(n*p-i*h),t[14]=-(r*(o*y-l*m)-s*(n*y-i*m)+d*(n*l-i*o)),t[15]=r*(o*p-l*h)-s*(n*p-i*h)+c*(n*l-i*o),t},Iu.determinant=function(t){var e=t[0],r=t[1],n=t[2],i=t[3],a=t[4],s=t[5],o=t[6],l=t[7],u=t[8],c=t[9],h=t[10],p=t[11],f=t[12],d=t[13],m=t[14],y=t[15];return (e*s-r*a)*(h*y-p*m)-(e*o-n*a)*(c*y-p*d)+(e*l-i*a)*(c*m-h*d)+(r*o-n*s)*(u*y-p*f)-(r*l-i*s)*(u*m-h*f)+(n*l-i*o)*(u*d-c*f)},Iu.multiply=Tu,Iu.translate=function(t,e,r){var n,i,a,s,o,l,u,c,h,p,f,d,m=r[0],y=r[1],g=r[2];return e===t?(t[12]=e[0]*m+e[4]*y+e[8]*g+e[12],t[13]=e[1]*m+e[5]*y+e[9]*g+e[13],t[14]=e[2]*m+e[6]*y+e[10]*g+e[14],t[15]=e[3]*m+e[7]*y+e[11]*g+e[15]):(i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=e[9],f=e[10],d=e[11],t[0]=n=e[0],t[1]=i,t[2]=a,t[3]=s,t[4]=o,t[5]=l,t[6]=u,t[7]=c,t[8]=h,t[9]=p,t[10]=f,t[11]=d,t[12]=n*m+o*y+h*g+e[12],t[13]=i*m+l*y+p*g+e[13],t[14]=a*m+u*y+f*g+e[14],t[15]=s*m+c*y+d*g+e[15]),t},Iu.scale=function(t,e,r){var n=r[0],i=r[1],a=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*a,t[9]=e[9]*a,t[10]=e[10]*a,t[11]=e[11]*a,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},Iu.rotate=function(t,e,r,n){var i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b,_,w,M,A,S,I,k,P=n[0],E=n[1],z=n[2],T=Math.hypot(P,E,z);return T<Pu.EPSILON?null:(P*=T=1/T,E*=T,z*=T,i=Math.sin(r),a=Math.cos(r),l=e[1],u=e[2],c=e[3],p=e[5],f=e[6],d=e[7],y=e[9],g=e[10],x=e[11],v=P*P*(s=1-a)+a,w=P*E*s-z*i,M=E*E*s+a,A=z*E*s+P*i,S=P*z*s+E*i,I=E*z*s-P*i,k=z*z*s+a,t[0]=(o=e[0])*v+(h=e[4])*(b=E*P*s+z*i)+(m=e[8])*(_=z*P*s-E*i),t[1]=l*v+p*b+y*_,t[2]=u*v+f*b+g*_,t[3]=c*v+d*b+x*_,t[4]=o*w+h*M+m*A,t[5]=l*w+p*M+y*A,t[6]=u*w+f*M+g*A,t[7]=c*w+d*M+x*A,t[8]=o*S+h*I+m*k,t[9]=l*S+p*I+y*k,t[10]=u*S+f*I+g*k,t[11]=c*S+d*I+x*k,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)},Iu.rotateX=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[4],s=e[5],o=e[6],l=e[7],u=e[8],c=e[9],h=e[10],p=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=a*i+u*n,t[5]=s*i+c*n,t[6]=o*i+h*n,t[7]=l*i+p*n,t[8]=u*i-a*n,t[9]=c*i-s*n,t[10]=h*i-o*n,t[11]=p*i-l*n,t},Iu.rotateY=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[0],s=e[1],o=e[2],l=e[3],u=e[8],c=e[9],h=e[10],p=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*i-u*n,t[1]=s*i-c*n,t[2]=o*i-h*n,t[3]=l*i-p*n,t[8]=a*n+u*i,t[9]=s*n+c*i,t[10]=o*n+h*i,t[11]=l*n+p*i,t},Iu.rotateZ=function(t,e,r){var n=Math.sin(r),i=Math.cos(r),a=e[0],s=e[1],o=e[2],l=e[3],u=e[4],c=e[5],h=e[6],p=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*i+u*n,t[1]=s*i+c*n,t[2]=o*i+h*n,t[3]=l*i+p*n,t[4]=u*i-a*n,t[5]=c*i-s*n,t[6]=h*i-o*n,t[7]=p*i-l*n,t},Iu.fromTranslation=function(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t},Iu.fromScaling=function(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Iu.fromRotation=function(t,e,r){var n,i,a,s=r[0],o=r[1],l=r[2],u=Math.hypot(s,o,l);return u<Pu.EPSILON?null:(s*=u=1/u,o*=u,l*=u,n=Math.sin(e),i=Math.cos(e),t[0]=s*s*(a=1-i)+i,t[1]=o*s*a+l*n,t[2]=l*s*a-o*n,t[3]=0,t[4]=s*o*a-l*n,t[5]=o*o*a+i,t[6]=l*o*a+s*n,t[7]=0,t[8]=s*l*a+o*n,t[9]=o*l*a-s*n,t[10]=l*l*a+i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},Iu.fromXRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Iu.fromYRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Iu.fromZRotation=function(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Iu.fromRotationTranslation=Bu,Iu.fromQuat2=function(t,e){var r=new Pu.ARRAY_TYPE(3),n=-e[0],i=-e[1],a=-e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=n*n+i*i+a*a+s*s;return h>0?(r[0]=2*(o*s+c*n+l*a-u*i)/h,r[1]=2*(l*s+c*i+u*n-o*a)/h,r[2]=2*(u*s+c*a+o*i-l*n)/h):(r[0]=2*(o*s+c*n+l*a-u*i),r[1]=2*(l*s+c*i+u*n-o*a),r[2]=2*(u*s+c*a+o*i-l*n)),Bu(t,e,r),t},Iu.getTranslation=function(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t},Iu.getScaling=Cu,Iu.getRotation=function(t,e){var r=new Pu.ARRAY_TYPE(3);Cu(r,e);var n=1/r[0],i=1/r[1],a=1/r[2],s=e[0]*n,o=e[1]*i,l=e[2]*a,u=e[4]*n,c=e[5]*i,h=e[6]*a,p=e[8]*n,f=e[9]*i,d=e[10]*a,m=s+c+d,y=0;return m>0?(y=2*Math.sqrt(m+1),t[3]=.25*y,t[0]=(h-f)/y,t[1]=(p-l)/y,t[2]=(o-u)/y):s>c&&s>d?(y=2*Math.sqrt(1+s-c-d),t[3]=(h-f)/y,t[0]=.25*y,t[1]=(o+u)/y,t[2]=(p+l)/y):c>d?(y=2*Math.sqrt(1+c-s-d),t[3]=(p-l)/y,t[0]=(o+u)/y,t[1]=.25*y,t[2]=(h+f)/y):(y=2*Math.sqrt(1+d-s-c),t[3]=(o-u)/y,t[0]=(p+l)/y,t[1]=(h+f)/y,t[2]=.25*y),t},Iu.fromRotationTranslationScale=function(t,e,r,n){var i=e[0],a=e[1],s=e[2],o=e[3],l=i+i,u=a+a,c=s+s,h=i*l,p=i*u,f=i*c,d=a*u,m=a*c,y=s*c,g=o*l,x=o*u,v=o*c,b=n[0],_=n[1],w=n[2];return t[0]=(1-(d+y))*b,t[1]=(p+v)*b,t[2]=(f-x)*b,t[3]=0,t[4]=(p-v)*_,t[5]=(1-(h+y))*_,t[6]=(m+g)*_,t[7]=0,t[8]=(f+x)*w,t[9]=(m-g)*w,t[10]=(1-(h+d))*w,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},Iu.fromRotationTranslationScaleOrigin=function(t,e,r,n,i){var a=e[0],s=e[1],o=e[2],l=e[3],u=a+a,c=s+s,h=o+o,p=a*u,f=a*c,d=a*h,m=s*c,y=s*h,g=o*h,x=l*u,v=l*c,b=l*h,_=n[0],w=n[1],M=n[2],A=i[0],S=i[1],I=i[2],k=(1-(m+g))*_,P=(f+b)*_,E=(d-v)*_,z=(f-b)*w,T=(1-(p+g))*w,B=(y+x)*w,C=(d+v)*M,R=(y-x)*M,D=(1-(p+m))*M;return t[0]=k,t[1]=P,t[2]=E,t[3]=0,t[4]=z,t[5]=T,t[6]=B,t[7]=0,t[8]=C,t[9]=R,t[10]=D,t[11]=0,t[12]=r[0]+A-(k*A+z*S+C*I),t[13]=r[1]+S-(P*A+T*S+R*I),t[14]=r[2]+I-(E*A+B*S+D*I),t[15]=1,t},Iu.fromQuat=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=r+r,o=n+n,l=i+i,u=r*s,c=n*s,h=n*o,p=i*s,f=i*o,d=i*l,m=a*s,y=a*o,g=a*l;return t[0]=1-h-d,t[1]=c+g,t[2]=p-y,t[3]=0,t[4]=c-g,t[5]=1-u-d,t[6]=f+m,t[7]=0,t[8]=p+y,t[9]=f-m,t[10]=1-u-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Iu.frustum=function(t,e,r,n,i,a,s){var o=1/(r-e),l=1/(i-n),u=1/(a-s);return t[0]=2*a*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*a*l,t[6]=0,t[7]=0,t[8]=(r+e)*o,t[9]=(i+n)*l,t[10]=(s+a)*u,t[11]=-1,t[12]=0,t[13]=0,t[14]=s*a*2*u,t[15]=0,t},Iu.perspectiveNO=Ru,Iu.perspectiveZO=function(t,e,r,n,i){var a,s=1/Math.tan(e/2);return t[0]=s/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(t[10]=i*(a=1/(n-i)),t[14]=i*n*a):(t[10]=-1,t[14]=-n),t},Iu.perspectiveFromFieldOfView=function(t,e,r,n){var i=Math.tan(e.upDegrees*Math.PI/180),a=Math.tan(e.downDegrees*Math.PI/180),s=Math.tan(e.leftDegrees*Math.PI/180),o=Math.tan(e.rightDegrees*Math.PI/180),l=2/(s+o),u=2/(i+a);return t[0]=l,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=-(s-o)*l*.5,t[9]=(i-a)*u*.5,t[10]=n/(r-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*r/(r-n),t[15]=0,t},Iu.orthoNO=Du,Iu.orthoZO=function(t,e,r,n,i,a,s){var o=1/(e-r),l=1/(n-i),u=1/(a-s);return t[0]=-2*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=u,t[11]=0,t[12]=(e+r)*o,t[13]=(i+n)*l,t[14]=a*u,t[15]=1,t},Iu.lookAt=function(t,e,r,n){var i,a,s,o,l,u,c,h,p,f,d=e[0],m=e[1],y=e[2],g=n[0],x=n[1],v=n[2],b=r[0],_=r[1],w=r[2];return Math.abs(d-b)<Pu.EPSILON&&Math.abs(m-_)<Pu.EPSILON&&Math.abs(y-w)<Pu.EPSILON?zu(t):(c=d-b,h=m-_,p=y-w,i=x*(p*=f=1/Math.hypot(c,h,p))-v*(h*=f),a=v*(c*=f)-g*p,s=g*h-x*c,(f=Math.hypot(i,a,s))?(i*=f=1/f,a*=f,s*=f):(i=0,a=0,s=0),o=h*s-p*a,l=p*i-c*s,u=c*a-h*i,(f=Math.hypot(o,l,u))?(o*=f=1/f,l*=f,u*=f):(o=0,l=0,u=0),t[0]=i,t[1]=o,t[2]=c,t[3]=0,t[4]=a,t[5]=l,t[6]=h,t[7]=0,t[8]=s,t[9]=u,t[10]=p,t[11]=0,t[12]=-(i*d+a*m+s*y),t[13]=-(o*d+l*m+u*y),t[14]=-(c*d+h*m+p*y),t[15]=1,t)},Iu.targetTo=function(t,e,r,n){var i=e[0],a=e[1],s=e[2],o=n[0],l=n[1],u=n[2],c=i-r[0],h=a-r[1],p=s-r[2],f=c*c+h*h+p*p;f>0&&(c*=f=1/Math.sqrt(f),h*=f,p*=f);var d=l*p-u*h,m=u*c-o*p,y=o*h-l*c;return (f=d*d+m*m+y*y)>0&&(d*=f=1/Math.sqrt(f),m*=f,y*=f),t[0]=d,t[1]=m,t[2]=y,t[3]=0,t[4]=h*y-p*m,t[5]=p*d-c*y,t[6]=c*m-h*d,t[7]=0,t[8]=c,t[9]=h,t[10]=p,t[11]=0,t[12]=i,t[13]=a,t[14]=s,t[15]=1,t},Iu.str=function(t){return "mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},Iu.frob=function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])},Iu.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t[8]=e[8]+r[8],t[9]=e[9]+r[9],t[10]=e[10]+r[10],t[11]=e[11]+r[11],t[12]=e[12]+r[12],t[13]=e[13]+r[13],t[14]=e[14]+r[14],t[15]=e[15]+r[15],t},Iu.subtract=Vu,Iu.multiplyScalar=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*r,t[9]=e[9]*r,t[10]=e[10]*r,t[11]=e[11]*r,t[12]=e[12]*r,t[13]=e[13]*r,t[14]=e[14]*r,t[15]=e[15]*r,t},Iu.multiplyScalarAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t[6]=e[6]+r[6]*n,t[7]=e[7]+r[7]*n,t[8]=e[8]+r[8]*n,t[9]=e[9]+r[9]*n,t[10]=e[10]+r[10]*n,t[11]=e[11]+r[11]*n,t[12]=e[12]+r[12]*n,t[13]=e[13]+r[13]*n,t[14]=e[14]+r[14]*n,t[15]=e[15]+r[15]*n,t},Iu.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]},Iu.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],s=t[4],o=t[5],l=t[6],u=t[7],c=t[8],h=t[9],p=t[10],f=t[11],d=t[12],m=t[13],y=t[14],g=t[15],x=e[0],v=e[1],b=e[2],_=e[3],w=e[4],M=e[5],A=e[6],S=e[7],I=e[8],k=e[9],P=e[10],E=e[11],z=e[12],T=e[13],B=e[14],C=e[15];return Math.abs(r-x)<=Pu.EPSILON*Math.max(1,Math.abs(r),Math.abs(x))&&Math.abs(n-v)<=Pu.EPSILON*Math.max(1,Math.abs(n),Math.abs(v))&&Math.abs(i-b)<=Pu.EPSILON*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(a-_)<=Pu.EPSILON*Math.max(1,Math.abs(a),Math.abs(_))&&Math.abs(s-w)<=Pu.EPSILON*Math.max(1,Math.abs(s),Math.abs(w))&&Math.abs(o-M)<=Pu.EPSILON*Math.max(1,Math.abs(o),Math.abs(M))&&Math.abs(l-A)<=Pu.EPSILON*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(u-S)<=Pu.EPSILON*Math.max(1,Math.abs(u),Math.abs(S))&&Math.abs(c-I)<=Pu.EPSILON*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(h-k)<=Pu.EPSILON*Math.max(1,Math.abs(h),Math.abs(k))&&Math.abs(p-P)<=Pu.EPSILON*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-E)<=Pu.EPSILON*Math.max(1,Math.abs(f),Math.abs(E))&&Math.abs(d-z)<=Pu.EPSILON*Math.max(1,Math.abs(d),Math.abs(z))&&Math.abs(m-T)<=Pu.EPSILON*Math.max(1,Math.abs(m),Math.abs(T))&&Math.abs(y-B)<=Pu.EPSILON*Math.max(1,Math.abs(y),Math.abs(B))&&Math.abs(g-C)<=Pu.EPSILON*Math.max(1,Math.abs(g),Math.abs(C))},Iu.sub=Iu.mul=Iu.ortho=Iu.perspective=void 0;var Pu=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==ku(t)&&"function"!=typeof t)return {default:t};var r=Eu(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function Eu(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (Eu=function(t){return t?r:e})(t)}function zu(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Tu(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=e[8],p=e[9],f=e[10],d=e[11],m=e[12],y=e[13],g=e[14],x=e[15],v=r[0],b=r[1],_=r[2],w=r[3];return t[0]=v*n+b*o+_*h+w*m,t[1]=v*i+b*l+_*p+w*y,t[2]=v*a+b*u+_*f+w*g,t[3]=v*s+b*c+_*d+w*x,t[4]=(v=r[4])*n+(b=r[5])*o+(_=r[6])*h+(w=r[7])*m,t[5]=v*i+b*l+_*p+w*y,t[6]=v*a+b*u+_*f+w*g,t[7]=v*s+b*c+_*d+w*x,t[8]=(v=r[8])*n+(b=r[9])*o+(_=r[10])*h+(w=r[11])*m,t[9]=v*i+b*l+_*p+w*y,t[10]=v*a+b*u+_*f+w*g,t[11]=v*s+b*c+_*d+w*x,t[12]=(v=r[12])*n+(b=r[13])*o+(_=r[14])*h+(w=r[15])*m,t[13]=v*i+b*l+_*p+w*y,t[14]=v*a+b*u+_*f+w*g,t[15]=v*s+b*c+_*d+w*x,t}function Bu(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=n+n,l=i+i,u=a+a,c=n*o,h=n*l,p=n*u,f=i*l,d=i*u,m=a*u,y=s*o,g=s*l,x=s*u;return t[0]=1-(f+m),t[1]=h+x,t[2]=p-g,t[3]=0,t[4]=h-x,t[5]=1-(c+m),t[6]=d+y,t[7]=0,t[8]=p+g,t[9]=d-y,t[10]=1-(c+f),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function Cu(t,e){var r=e[4],n=e[5],i=e[6],a=e[8],s=e[9],o=e[10];return t[0]=Math.hypot(e[0],e[1],e[2]),t[1]=Math.hypot(r,n,i),t[2]=Math.hypot(a,s,o),t}function Ru(t,e,r,n,i){var a,s=1/Math.tan(e/2);return t[0]=s/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=i&&i!==1/0?(t[10]=(i+n)*(a=1/(n-i)),t[14]=2*i*n*a):(t[10]=-1,t[14]=-2*n),t}function Du(t,e,r,n,i,a,s){var o=1/(e-r),l=1/(n-i),u=1/(a-s);return t[0]=-2*o,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*u,t[11]=0,t[12]=(e+r)*o,t[13]=(i+n)*l,t[14]=(s+a)*u,t[15]=1,t}function Vu(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t[6]=e[6]-r[6],t[7]=e[7]-r[7],t[8]=e[8]-r[8],t[9]=e[9]-r[9],t[10]=e[10]-r[10],t[11]=e[11]-r[11],t[12]=e[12]-r[12],t[13]=e[13]-r[13],t[14]=e[14]-r[14],t[15]=e[15]-r[15],t}Iu.perspective=Ru,Iu.ortho=Du,Iu.mul=Tu,Iu.sub=Vu;var Lu={},Fu={};function Nu(t){return Nu="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Nu(t)}Object.defineProperty(Fu,"__esModule",{value:!0}),Fu.create=ju,Fu.clone=function(t){var e=new Ou.ARRAY_TYPE(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},Fu.length=qu,Fu.fromValues=function(t,e,r){var n=new Ou.ARRAY_TYPE(3);return n[0]=t,n[1]=e,n[2]=r,n},Fu.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},Fu.set=function(t,e,r,n){return t[0]=e,t[1]=r,t[2]=n,t},Fu.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t},Fu.subtract=$u,Fu.multiply=Gu,Fu.divide=Yu,Fu.ceil=function(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t},Fu.floor=function(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t},Fu.min=function(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t},Fu.max=function(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t},Fu.round=function(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t},Fu.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t},Fu.scaleAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t},Fu.distance=Xu,Fu.squaredDistance=Zu,Fu.squaredLength=Ku,Fu.negate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t},Fu.inverse=function(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t},Fu.normalize=function(t,e){var r=e[0],n=e[1],i=e[2],a=r*r+n*n+i*i;return a>0&&(a=1/Math.sqrt(a)),t[0]=e[0]*a,t[1]=e[1]*a,t[2]=e[2]*a,t},Fu.dot=Hu,Fu.cross=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=r[0],o=r[1],l=r[2];return t[0]=i*l-a*o,t[1]=a*s-n*l,t[2]=n*o-i*s,t},Fu.lerp=function(t,e,r,n){var i=e[0],a=e[1],s=e[2];return t[0]=i+n*(r[0]-i),t[1]=a+n*(r[1]-a),t[2]=s+n*(r[2]-s),t},Fu.hermite=function(t,e,r,n,i,a){var s=a*a,o=s*(2*a-3)+1,l=s*(a-2)+a,u=s*(a-1),c=s*(3-2*a);return t[0]=e[0]*o+r[0]*l+n[0]*u+i[0]*c,t[1]=e[1]*o+r[1]*l+n[1]*u+i[1]*c,t[2]=e[2]*o+r[2]*l+n[2]*u+i[2]*c,t},Fu.bezier=function(t,e,r,n,i,a){var s=1-a,o=s*s,l=a*a,u=o*s,c=3*a*o,h=3*l*s,p=l*a;return t[0]=e[0]*u+r[0]*c+n[0]*h+i[0]*p,t[1]=e[1]*u+r[1]*c+n[1]*h+i[1]*p,t[2]=e[2]*u+r[2]*c+n[2]*h+i[2]*p,t},Fu.random=function(t,e){e=e||1;var r=2*Ou.RANDOM()*Math.PI,n=2*Ou.RANDOM()-1,i=Math.sqrt(1-n*n)*e;return t[0]=Math.cos(r)*i,t[1]=Math.sin(r)*i,t[2]=n*e,t},Fu.transformMat4=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=r[3]*n+r[7]*i+r[11]*a+r[15];return t[0]=(r[0]*n+r[4]*i+r[8]*a+r[12])/(s=s||1),t[1]=(r[1]*n+r[5]*i+r[9]*a+r[13])/s,t[2]=(r[2]*n+r[6]*i+r[10]*a+r[14])/s,t},Fu.transformMat3=function(t,e,r){var n=e[0],i=e[1],a=e[2];return t[0]=n*r[0]+i*r[3]+a*r[6],t[1]=n*r[1]+i*r[4]+a*r[7],t[2]=n*r[2]+i*r[5]+a*r[8],t},Fu.transformQuat=function(t,e,r){var n=r[0],i=r[1],a=r[2],s=e[0],o=e[1],l=e[2],u=i*l-a*o,c=a*s-n*l,h=n*o-i*s,p=i*h-a*c,f=a*u-n*h,d=n*c-i*u,m=2*r[3];return c*=m,h*=m,f*=2,d*=2,t[0]=s+(u*=m)+(p*=2),t[1]=o+c+f,t[2]=l+h+d,t},Fu.rotateX=function(t,e,r,n){var i=[],a=[];return i[0]=e[0]-r[0],i[1]=e[1]-r[1],i[2]=e[2]-r[2],a[0]=i[0],a[1]=i[1]*Math.cos(n)-i[2]*Math.sin(n),a[2]=i[1]*Math.sin(n)+i[2]*Math.cos(n),t[0]=a[0]+r[0],t[1]=a[1]+r[1],t[2]=a[2]+r[2],t},Fu.rotateY=function(t,e,r,n){var i=[],a=[];return i[0]=e[0]-r[0],i[1]=e[1]-r[1],i[2]=e[2]-r[2],a[0]=i[2]*Math.sin(n)+i[0]*Math.cos(n),a[1]=i[1],a[2]=i[2]*Math.cos(n)-i[0]*Math.sin(n),t[0]=a[0]+r[0],t[1]=a[1]+r[1],t[2]=a[2]+r[2],t},Fu.rotateZ=function(t,e,r,n){var i=[],a=[];return i[0]=e[0]-r[0],i[1]=e[1]-r[1],i[2]=e[2]-r[2],a[0]=i[0]*Math.cos(n)-i[1]*Math.sin(n),a[1]=i[0]*Math.sin(n)+i[1]*Math.cos(n),a[2]=i[2],t[0]=a[0]+r[0],t[1]=a[1]+r[1],t[2]=a[2]+r[2],t},Fu.angle=function(t,e){var r=t[0],n=t[1],i=t[2],a=e[0],s=e[1],o=e[2],l=Math.sqrt(r*r+n*n+i*i)*Math.sqrt(a*a+s*s+o*o),u=l&&Hu(t,e)/l;return Math.acos(Math.min(Math.max(u,-1),1))},Fu.zero=function(t){return t[0]=0,t[1]=0,t[2]=0,t},Fu.str=function(t){return "vec3("+t[0]+", "+t[1]+", "+t[2]+")"},Fu.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},Fu.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=e[0],s=e[1],o=e[2];return Math.abs(r-a)<=Ou.EPSILON*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=Ou.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-o)<=Ou.EPSILON*Math.max(1,Math.abs(i),Math.abs(o))},Fu.forEach=Fu.sqrLen=Fu.len=Fu.sqrDist=Fu.dist=Fu.div=Fu.mul=Fu.sub=void 0;var Ou=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==Nu(t)&&"function"!=typeof t)return {default:t};var r=Uu(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function Uu(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (Uu=function(t){return t?r:e})(t)}function ju(){var t=new Ou.ARRAY_TYPE(3);return Ou.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function qu(t){return Math.hypot(t[0],t[1],t[2])}function $u(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t}function Gu(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t}function Yu(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t}function Xu(t,e){return Math.hypot(e[0]-t[0],e[1]-t[1],e[2]-t[2])}function Zu(t,e){var r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2];return r*r+n*n+i*i}function Ku(t){var e=t[0],r=t[1],n=t[2];return e*e+r*r+n*n}function Hu(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}Fu.sub=$u,Fu.mul=Gu,Fu.div=Yu,Fu.dist=Xu,Fu.sqrDist=Zu,Fu.len=qu,Fu.sqrLen=Ku;var Wu,Ju=(Wu=ju(),function(t,e,r,n,i,a){var s,o;for(e||(e=3),r||(r=0),o=n?Math.min(n*e+r,t.length):t.length,s=r;s<o;s+=e)Wu[0]=t[s],Wu[1]=t[s+1],Wu[2]=t[s+2],i(Wu,Wu,a),t[s]=Wu[0],t[s+1]=Wu[1],t[s+2]=Wu[2];return t});Fu.forEach=Ju;var Qu={};function tc(t){return tc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},tc(t)}Object.defineProperty(Qu,"__esModule",{value:!0}),Qu.create=nc,Qu.clone=function(t){var e=new ec.ARRAY_TYPE(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},Qu.fromValues=function(t,e,r,n){var i=new ec.ARRAY_TYPE(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i},Qu.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},Qu.set=function(t,e,r,n,i){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t},Qu.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t},Qu.subtract=ic,Qu.multiply=ac,Qu.divide=sc,Qu.ceil=function(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t},Qu.floor=function(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t},Qu.min=function(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t[3]=Math.min(e[3],r[3]),t},Qu.max=function(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t[3]=Math.max(e[3],r[3]),t},Qu.round=function(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t},Qu.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t},Qu.scaleAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t},Qu.distance=oc,Qu.squaredDistance=lc,Qu.length=uc,Qu.squaredLength=cc,Qu.negate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t},Qu.inverse=function(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t},Qu.normalize=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=r*r+n*n+i*i+a*a;return s>0&&(s=1/Math.sqrt(s)),t[0]=r*s,t[1]=n*s,t[2]=i*s,t[3]=a*s,t},Qu.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]},Qu.cross=function(t,e,r,n){var i=r[0]*n[1]-r[1]*n[0],a=r[0]*n[2]-r[2]*n[0],s=r[0]*n[3]-r[3]*n[0],o=r[1]*n[2]-r[2]*n[1],l=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],c=e[0],h=e[1],p=e[2],f=e[3];return t[0]=h*u-p*l+f*o,t[1]=-c*u+p*s-f*a,t[2]=c*l-h*s+f*i,t[3]=-c*o+h*a-p*i,t},Qu.lerp=function(t,e,r,n){var i=e[0],a=e[1],s=e[2],o=e[3];return t[0]=i+n*(r[0]-i),t[1]=a+n*(r[1]-a),t[2]=s+n*(r[2]-s),t[3]=o+n*(r[3]-o),t},Qu.random=function(t,e){var r,n,i,a,s,o;e=e||1;do{s=(r=2*ec.RANDOM()-1)*r+(n=2*ec.RANDOM()-1)*n;}while(s>=1);do{o=(i=2*ec.RANDOM()-1)*i+(a=2*ec.RANDOM()-1)*a;}while(o>=1);var l=Math.sqrt((1-s)/o);return t[0]=e*r,t[1]=e*n,t[2]=e*i*l,t[3]=e*a*l,t},Qu.transformMat4=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*a+r[12]*s,t[1]=r[1]*n+r[5]*i+r[9]*a+r[13]*s,t[2]=r[2]*n+r[6]*i+r[10]*a+r[14]*s,t[3]=r[3]*n+r[7]*i+r[11]*a+r[15]*s,t},Qu.transformQuat=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=r[0],o=r[1],l=r[2],u=r[3],c=u*n+o*a-l*i,h=u*i+l*n-s*a,p=u*a+s*i-o*n,f=-s*n-o*i-l*a;return t[0]=c*u+f*-s+h*-l-p*-o,t[1]=h*u+f*-o+p*-s-c*-l,t[2]=p*u+f*-l+c*-o-h*-s,t[3]=e[3],t},Qu.zero=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},Qu.str=function(t){return "vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},Qu.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]},Qu.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],s=e[0],o=e[1],l=e[2],u=e[3];return Math.abs(r-s)<=ec.EPSILON*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(n-o)<=ec.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(i-l)<=ec.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(a-u)<=ec.EPSILON*Math.max(1,Math.abs(a),Math.abs(u))},Qu.forEach=Qu.sqrLen=Qu.len=Qu.sqrDist=Qu.dist=Qu.div=Qu.mul=Qu.sub=void 0;var ec=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==tc(t)&&"function"!=typeof t)return {default:t};var r=rc(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function rc(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (rc=function(t){return t?r:e})(t)}function nc(){var t=new ec.ARRAY_TYPE(4);return ec.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function ic(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t}function ac(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t[3]=e[3]*r[3],t}function sc(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t[3]=e[3]/r[3],t}function oc(t,e){return Math.hypot(e[0]-t[0],e[1]-t[1],e[2]-t[2],e[3]-t[3])}function lc(t,e){var r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2],a=e[3]-t[3];return r*r+n*n+i*i+a*a}function uc(t){return Math.hypot(t[0],t[1],t[2],t[3])}function cc(t){var e=t[0],r=t[1],n=t[2],i=t[3];return e*e+r*r+n*n+i*i}Qu.sub=ic,Qu.mul=ac,Qu.div=sc,Qu.dist=oc,Qu.sqrDist=lc,Qu.len=uc,Qu.sqrLen=cc;var hc=function(){var t=nc();return function(e,r,n,i,a,s){var o,l;for(r||(r=4),n||(n=0),l=i?Math.min(i*r+n,e.length):e.length,o=n;o<l;o+=r)t[0]=e[o],t[1]=e[o+1],t[2]=e[o+2],t[3]=e[o+3],a(t,t,s),e[o]=t[0],e[o+1]=t[1],e[o+2]=t[2],e[o+3]=t[3];return e}}();function pc(t){return pc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},pc(t)}Qu.forEach=hc,Object.defineProperty(Lu,"__esModule",{value:!0}),Lu.create=vc,Lu.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},Lu.setAxisAngle=bc,Lu.getAxisAngle=function(t,e){var r=2*Math.acos(e[3]),n=Math.sin(r/2);return n>fc.EPSILON?(t[0]=e[0]/n,t[1]=e[1]/n,t[2]=e[2]/n):(t[0]=1,t[1]=0,t[2]=0),r},Lu.getAngle=function(t,e){var r=kc(t,e);return Math.acos(2*r*r-1)},Lu.multiply=_c,Lu.rotateX=function(t,e,r){r*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l+s*o,t[1]=i*l+a*o,t[2]=a*l-i*o,t[3]=s*l-n*o,t},Lu.rotateY=function(t,e,r){r*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l-a*o,t[1]=i*l+s*o,t[2]=a*l+n*o,t[3]=s*l-i*o,t},Lu.rotateZ=function(t,e,r){r*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(r),l=Math.cos(r);return t[0]=n*l+i*o,t[1]=i*l-n*o,t[2]=a*l+s*o,t[3]=s*l-a*o,t},Lu.calculateW=function(t,e){var r=e[0],n=e[1],i=e[2];return t[0]=r,t[1]=n,t[2]=i,t[3]=Math.sqrt(Math.abs(1-r*r-n*n-i*i)),t},Lu.exp=wc,Lu.ln=Mc,Lu.pow=function(t,e,r){return Mc(t,e),Ic(t,t,r),wc(t,t),t},Lu.slerp=Ac,Lu.random=function(t){var e=fc.RANDOM(),r=fc.RANDOM(),n=fc.RANDOM(),i=Math.sqrt(1-e),a=Math.sqrt(e);return t[0]=i*Math.sin(2*Math.PI*r),t[1]=i*Math.cos(2*Math.PI*r),t[2]=a*Math.sin(2*Math.PI*n),t[3]=a*Math.cos(2*Math.PI*n),t},Lu.invert=function(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=r*r+n*n+i*i+a*a,o=s?1/s:0;return t[0]=-r*o,t[1]=-n*o,t[2]=-i*o,t[3]=a*o,t},Lu.conjugate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t},Lu.fromMat3=Sc,Lu.fromEuler=function(t,e,r,n){var i=.5*Math.PI/180;e*=i,r*=i,n*=i;var a=Math.sin(e),s=Math.cos(e),o=Math.sin(r),l=Math.cos(r),u=Math.sin(n),c=Math.cos(n);return t[0]=a*l*c-s*o*u,t[1]=s*o*c+a*l*u,t[2]=s*l*u-a*o*c,t[3]=s*l*c+a*o*u,t},Lu.str=function(t){return "quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},Lu.setAxes=Lu.sqlerp=Lu.rotationTo=Lu.equals=Lu.exactEquals=Lu.normalize=Lu.sqrLen=Lu.squaredLength=Lu.len=Lu.length=Lu.lerp=Lu.dot=Lu.scale=Lu.mul=Lu.add=Lu.set=Lu.copy=Lu.fromValues=Lu.clone=void 0;var fc=xc(nu),dc=xc(bu),mc=xc(Fu),yc=xc(Qu);function gc(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (gc=function(t){return t?r:e})(t)}function xc(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!==pc(t)&&"function"!=typeof t)return {default:t};var r=gc(e);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}function vc(){var t=new fc.ARRAY_TYPE(4);return fc.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function bc(t,e,r){r*=.5;var n=Math.sin(r);return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=Math.cos(r),t}function _c(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=r[0],l=r[1],u=r[2],c=r[3];return t[0]=n*c+s*o+i*u-a*l,t[1]=i*c+s*l+a*o-n*u,t[2]=a*c+s*u+n*l-i*o,t[3]=s*c-n*o-i*l-a*u,t}function wc(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=Math.sqrt(r*r+n*n+i*i),o=Math.exp(a),l=s>0?o*Math.sin(s)/s:0;return t[0]=r*l,t[1]=n*l,t[2]=i*l,t[3]=o*Math.cos(s),t}function Mc(t,e){var r=e[0],n=e[1],i=e[2],a=e[3],s=Math.sqrt(r*r+n*n+i*i),o=s>0?Math.atan2(s,a)/s:0;return t[0]=r*o,t[1]=n*o,t[2]=i*o,t[3]=.5*Math.log(r*r+n*n+i*i+a*a),t}function Ac(t,e,r,n){var i,a,s,o,l,u=e[0],c=e[1],h=e[2],p=e[3],f=r[0],d=r[1],m=r[2],y=r[3];return (a=u*f+c*d+h*m+p*y)<0&&(a=-a,f=-f,d=-d,m=-m,y=-y),1-a>fc.EPSILON?(i=Math.acos(a),s=Math.sin(i),o=Math.sin((1-n)*i)/s,l=Math.sin(n*i)/s):(o=1-n,l=n),t[0]=o*u+l*f,t[1]=o*c+l*d,t[2]=o*h+l*m,t[3]=o*p+l*y,t}function Sc(t,e){var r,n=e[0]+e[4]+e[8];if(n>0)r=Math.sqrt(n+1),t[3]=.5*r,t[0]=(e[5]-e[7])*(r=.5/r),t[1]=(e[6]-e[2])*r,t[2]=(e[1]-e[3])*r;else {var i=0;e[4]>e[0]&&(i=1),e[8]>e[3*i+i]&&(i=2);var a=(i+1)%3,s=(i+2)%3;r=Math.sqrt(e[3*i+i]-e[3*a+a]-e[3*s+s]+1),t[i]=.5*r,t[3]=(e[3*a+s]-e[3*s+a])*(r=.5/r),t[a]=(e[3*a+i]+e[3*i+a])*r,t[s]=(e[3*s+i]+e[3*i+s])*r;}return t}Lu.clone=yc.clone,Lu.fromValues=yc.fromValues,Lu.copy=yc.copy,Lu.set=yc.set,Lu.add=yc.add,Lu.mul=_c;var Ic=yc.scale;Lu.scale=Ic;var kc=yc.dot;Lu.dot=kc,Lu.lerp=yc.lerp;var Pc=yc.length;Lu.length=Pc,Lu.len=Pc;var Ec=yc.squaredLength;Lu.squaredLength=Ec,Lu.sqrLen=Ec;var zc=yc.normalize;Lu.normalize=zc,Lu.exactEquals=yc.exactEquals,Lu.equals=yc.equals;var Tc,Bc,Cc,Rc=(Tc=mc.create(),Bc=mc.fromValues(1,0,0),Cc=mc.fromValues(0,1,0),function(t,e,r){var n=mc.dot(e,r);return n<-.999999?(mc.cross(Tc,Bc,e),mc.len(Tc)<1e-6&&mc.cross(Tc,Cc,e),mc.normalize(Tc,Tc),bc(t,Tc,Math.PI),t):n>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(mc.cross(Tc,e,r),t[0]=Tc[0],t[1]=Tc[1],t[2]=Tc[2],t[3]=1+n,zc(t,t))});Lu.rotationTo=Rc;var Dc,Vc,Lc=(Dc=vc(),Vc=vc(),function(t,e,r,n,i,a){return Ac(Dc,e,i,a),Ac(Vc,r,n,a),Ac(t,Dc,Vc,2*a*(1-a)),t});Lu.sqlerp=Lc;var Fc,Nc=(Fc=dc.create(),function(t,e,r,n){return Fc[0]=r[0],Fc[3]=r[1],Fc[6]=r[2],Fc[1]=n[0],Fc[4]=n[1],Fc[7]=n[2],Fc[2]=-e[0],Fc[5]=-e[1],Fc[8]=-e[2],zc(t,Sc(t,Fc))});Lu.setAxes=Nc;var Oc={};function Uc(t){return Uc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Uc(t)}Object.defineProperty(Oc,"__esModule",{value:!0}),Oc.create=function(){var t=new jc.ARRAY_TYPE(8);return jc.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0),t[3]=1,t},Oc.clone=function(t){var e=new jc.ARRAY_TYPE(8);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e},Oc.fromValues=function(t,e,r,n,i,a,s,o){var l=new jc.ARRAY_TYPE(8);return l[0]=t,l[1]=e,l[2]=r,l[3]=n,l[4]=i,l[5]=a,l[6]=s,l[7]=o,l},Oc.fromRotationTranslationValues=function(t,e,r,n,i,a,s){var o=new jc.ARRAY_TYPE(8);o[0]=t,o[1]=e,o[2]=r,o[3]=n;var l=.5*i,u=.5*a,c=.5*s;return o[4]=l*n+u*r-c*e,o[5]=u*n+c*t-l*r,o[6]=c*n+l*e-u*t,o[7]=-l*t-u*e-c*r,o},Oc.fromRotationTranslation=Xc,Oc.fromTranslation=function(t,e){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*e[0],t[5]=.5*e[1],t[6]=.5*e[2],t[7]=0,t},Oc.fromRotation=function(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},Oc.fromMat4=function(t,e){var r=qc.create();$c.getRotation(r,e);var n=new jc.ARRAY_TYPE(3);return $c.getTranslation(n,e),Xc(t,r,n),t},Oc.copy=Zc,Oc.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},Oc.set=function(t,e,r,n,i,a,s,o,l){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t[4]=a,t[5]=s,t[6]=o,t[7]=l,t},Oc.getDual=function(t,e){return t[0]=e[4],t[1]=e[5],t[2]=e[6],t[3]=e[7],t},Oc.setDual=function(t,e){return t[4]=e[0],t[5]=e[1],t[6]=e[2],t[7]=e[3],t},Oc.getTranslation=function(t,e){var r=e[4],n=e[5],i=e[6],a=e[7],s=-e[0],o=-e[1],l=-e[2],u=e[3];return t[0]=2*(r*u+a*s+n*l-i*o),t[1]=2*(n*u+a*o+i*s-r*l),t[2]=2*(i*u+a*l+r*o-n*s),t},Oc.translate=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=.5*r[0],l=.5*r[1],u=.5*r[2],c=e[4],h=e[5],p=e[6],f=e[7];return t[0]=n,t[1]=i,t[2]=a,t[3]=s,t[4]=s*o+i*u-a*l+c,t[5]=s*l+a*o-n*u+h,t[6]=s*u+n*l-i*o+p,t[7]=-n*o-i*l-a*u+f,t},Oc.rotateX=function(t,e,r){var n=-e[0],i=-e[1],a=-e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=o*s+c*n+l*a-u*i,p=l*s+c*i+u*n-o*a,f=u*s+c*a+o*i-l*n,d=c*s-o*n-l*i-u*a;return qc.rotateX(t,e,r),t[4]=h*(s=t[3])+d*(n=t[0])+p*(a=t[2])-f*(i=t[1]),t[5]=p*s+d*i+f*n-h*a,t[6]=f*s+d*a+h*i-p*n,t[7]=d*s-h*n-p*i-f*a,t},Oc.rotateY=function(t,e,r){var n=-e[0],i=-e[1],a=-e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=o*s+c*n+l*a-u*i,p=l*s+c*i+u*n-o*a,f=u*s+c*a+o*i-l*n,d=c*s-o*n-l*i-u*a;return qc.rotateY(t,e,r),t[4]=h*(s=t[3])+d*(n=t[0])+p*(a=t[2])-f*(i=t[1]),t[5]=p*s+d*i+f*n-h*a,t[6]=f*s+d*a+h*i-p*n,t[7]=d*s-h*n-p*i-f*a,t},Oc.rotateZ=function(t,e,r){var n=-e[0],i=-e[1],a=-e[2],s=e[3],o=e[4],l=e[5],u=e[6],c=e[7],h=o*s+c*n+l*a-u*i,p=l*s+c*i+u*n-o*a,f=u*s+c*a+o*i-l*n,d=c*s-o*n-l*i-u*a;return qc.rotateZ(t,e,r),t[4]=h*(s=t[3])+d*(n=t[0])+p*(a=t[2])-f*(i=t[1]),t[5]=p*s+d*i+f*n-h*a,t[6]=f*s+d*a+h*i-p*n,t[7]=d*s-h*n-p*i-f*a,t},Oc.rotateByQuatAppend=function(t,e,r){var n=r[0],i=r[1],a=r[2],s=r[3],o=e[0],l=e[1],u=e[2],c=e[3];return t[0]=o*s+c*n+l*a-u*i,t[1]=l*s+c*i+u*n-o*a,t[2]=u*s+c*a+o*i-l*n,t[3]=c*s-o*n-l*i-u*a,t[4]=(o=e[4])*s+(c=e[7])*n+(l=e[5])*a-(u=e[6])*i,t[5]=l*s+c*i+u*n-o*a,t[6]=u*s+c*a+o*i-l*n,t[7]=c*s-o*n-l*i-u*a,t},Oc.rotateByQuatPrepend=function(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=r[0],l=r[1],u=r[2],c=r[3];return t[0]=n*c+s*o+i*u-a*l,t[1]=i*c+s*l+a*o-n*u,t[2]=a*c+s*u+n*l-i*o,t[3]=s*c-n*o-i*l-a*u,t[4]=n*(c=r[7])+s*(o=r[4])+i*(u=r[6])-a*(l=r[5]),t[5]=i*c+s*l+a*o-n*u,t[6]=a*c+s*u+n*l-i*o,t[7]=s*c-n*o-i*l-a*u,t},Oc.rotateAroundAxis=function(t,e,r,n){if(Math.abs(n)<jc.EPSILON)return Zc(t,e);var i=Math.hypot(r[0],r[1],r[2]);n*=.5;var a=Math.sin(n),s=a*r[0]/i,o=a*r[1]/i,l=a*r[2]/i,u=Math.cos(n),c=e[0],h=e[1],p=e[2],f=e[3];t[0]=c*u+f*s+h*l-p*o,t[1]=h*u+f*o+p*s-c*l,t[2]=p*u+f*l+c*o-h*s,t[3]=f*u-c*s-h*o-p*l;var d=e[4],m=e[5],y=e[6],g=e[7];return t[4]=d*u+g*s+m*l-y*o,t[5]=m*u+g*o+y*s-d*l,t[6]=y*u+g*l+d*o-m*s,t[7]=g*u-d*s-m*o-y*l,t},Oc.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t},Oc.multiply=Kc,Oc.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t},Oc.lerp=function(t,e,r,n){var i=1-n;return Hc(e,r)<0&&(n=-n),t[0]=e[0]*i+r[0]*n,t[1]=e[1]*i+r[1]*n,t[2]=e[2]*i+r[2]*n,t[3]=e[3]*i+r[3]*n,t[4]=e[4]*i+r[4]*n,t[5]=e[5]*i+r[5]*n,t[6]=e[6]*i+r[6]*n,t[7]=e[7]*i+r[7]*n,t},Oc.invert=function(t,e){var r=Jc(e);return t[0]=-e[0]/r,t[1]=-e[1]/r,t[2]=-e[2]/r,t[3]=e[3]/r,t[4]=-e[4]/r,t[5]=-e[5]/r,t[6]=-e[6]/r,t[7]=e[7]/r,t},Oc.conjugate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t[4]=-e[4],t[5]=-e[5],t[6]=-e[6],t[7]=e[7],t},Oc.normalize=function(t,e){var r=Jc(e);if(r>0){r=Math.sqrt(r);var n=e[0]/r,i=e[1]/r,a=e[2]/r,s=e[3]/r,o=e[4],l=e[5],u=e[6],c=e[7],h=n*o+i*l+a*u+s*c;t[0]=n,t[1]=i,t[2]=a,t[3]=s,t[4]=(o-n*h)/r,t[5]=(l-i*h)/r,t[6]=(u-a*h)/r,t[7]=(c-s*h)/r;}return t},Oc.str=function(t){return "quat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+")"},Oc.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]},Oc.equals=function(t,e){var r=t[0],n=t[1],i=t[2],a=t[3],s=t[4],o=t[5],l=t[6],u=t[7],c=e[0],h=e[1],p=e[2],f=e[3],d=e[4],m=e[5],y=e[6],g=e[7];return Math.abs(r-c)<=jc.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(n-h)<=jc.EPSILON*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(i-p)<=jc.EPSILON*Math.max(1,Math.abs(i),Math.abs(p))&&Math.abs(a-f)<=jc.EPSILON*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(s-d)<=jc.EPSILON*Math.max(1,Math.abs(s),Math.abs(d))&&Math.abs(o-m)<=jc.EPSILON*Math.max(1,Math.abs(o),Math.abs(m))&&Math.abs(l-y)<=jc.EPSILON*Math.max(1,Math.abs(l),Math.abs(y))&&Math.abs(u-g)<=jc.EPSILON*Math.max(1,Math.abs(u),Math.abs(g))},Oc.sqrLen=Oc.squaredLength=Oc.len=Oc.length=Oc.dot=Oc.mul=Oc.setReal=Oc.getReal=void 0;var jc=Yc(nu),qc=Yc(Lu),$c=Yc(Iu);function Gc(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (Gc=function(t){return t?r:e})(t)}function Yc(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!==Uc(t)&&"function"!=typeof t)return {default:t};var r=Gc(e);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}function Xc(t,e,r){var n=.5*r[0],i=.5*r[1],a=.5*r[2],s=e[0],o=e[1],l=e[2],u=e[3];return t[0]=s,t[1]=o,t[2]=l,t[3]=u,t[4]=n*u+i*l-a*o,t[5]=i*u+a*s-n*l,t[6]=a*u+n*o-i*s,t[7]=-n*s-i*o-a*l,t}function Zc(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t}function Kc(t,e,r){var n=e[0],i=e[1],a=e[2],s=e[3],o=r[4],l=r[5],u=r[6],c=r[7],h=e[4],p=e[5],f=e[6],d=e[7],m=r[0],y=r[1],g=r[2],x=r[3];return t[0]=n*x+s*m+i*g-a*y,t[1]=i*x+s*y+a*m-n*g,t[2]=a*x+s*g+n*y-i*m,t[3]=s*x-n*m-i*y-a*g,t[4]=n*c+s*o+i*u-a*l+h*x+d*m+p*g-f*y,t[5]=i*c+s*l+a*o-n*u+p*x+d*y+f*m-h*g,t[6]=a*c+s*u+n*l-i*o+f*x+d*g+h*y-p*m,t[7]=s*c-n*o-i*l-a*u+d*x-h*m-p*y-f*g,t}Oc.getReal=qc.copy,Oc.setReal=qc.copy,Oc.mul=Kc;var Hc=qc.dot;Oc.dot=Hc;var Wc=qc.length;Oc.length=Wc,Oc.len=Wc;var Jc=qc.squaredLength;Oc.squaredLength=Jc,Oc.sqrLen=Jc;var Qc={};function th(t){return th="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},th(t)}Object.defineProperty(Qc,"__esModule",{value:!0}),Qc.create=nh,Qc.clone=function(t){var e=new eh.ARRAY_TYPE(2);return e[0]=t[0],e[1]=t[1],e},Qc.fromValues=function(t,e){var r=new eh.ARRAY_TYPE(2);return r[0]=t,r[1]=e,r},Qc.copy=function(t,e){return t[0]=e[0],t[1]=e[1],t},Qc.set=function(t,e,r){return t[0]=e,t[1]=r,t},Qc.add=function(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t},Qc.subtract=ih,Qc.multiply=ah,Qc.divide=sh,Qc.ceil=function(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t},Qc.floor=function(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t},Qc.min=function(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t},Qc.max=function(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t},Qc.round=function(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t},Qc.scale=function(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t},Qc.scaleAndAdd=function(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t},Qc.distance=oh,Qc.squaredDistance=lh,Qc.length=uh,Qc.squaredLength=ch,Qc.negate=function(t,e){return t[0]=-e[0],t[1]=-e[1],t},Qc.inverse=function(t,e){return t[0]=1/e[0],t[1]=1/e[1],t},Qc.normalize=function(t,e){var r=e[0],n=e[1],i=r*r+n*n;return i>0&&(i=1/Math.sqrt(i)),t[0]=e[0]*i,t[1]=e[1]*i,t},Qc.dot=function(t,e){return t[0]*e[0]+t[1]*e[1]},Qc.cross=function(t,e,r){var n=e[0]*r[1]-e[1]*r[0];return t[0]=t[1]=0,t[2]=n,t},Qc.lerp=function(t,e,r,n){var i=e[0],a=e[1];return t[0]=i+n*(r[0]-i),t[1]=a+n*(r[1]-a),t},Qc.random=function(t,e){e=e||1;var r=2*eh.RANDOM()*Math.PI;return t[0]=Math.cos(r)*e,t[1]=Math.sin(r)*e,t},Qc.transformMat2=function(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[2]*i,t[1]=r[1]*n+r[3]*i,t},Qc.transformMat2d=function(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[2]*i+r[4],t[1]=r[1]*n+r[3]*i+r[5],t},Qc.transformMat3=function(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[3]*i+r[6],t[1]=r[1]*n+r[4]*i+r[7],t},Qc.transformMat4=function(t,e,r){var n=e[0],i=e[1];return t[0]=r[0]*n+r[4]*i+r[12],t[1]=r[1]*n+r[5]*i+r[13],t},Qc.rotate=function(t,e,r,n){var i=e[0]-r[0],a=e[1]-r[1],s=Math.sin(n),o=Math.cos(n);return t[0]=i*o-a*s+r[0],t[1]=i*s+a*o+r[1],t},Qc.angle=function(t,e){var r=t[0],n=t[1],i=e[0],a=e[1],s=Math.sqrt(r*r+n*n)*Math.sqrt(i*i+a*a);return Math.acos(Math.min(Math.max(s&&(r*i+n*a)/s,-1),1))},Qc.zero=function(t){return t[0]=0,t[1]=0,t},Qc.str=function(t){return "vec2("+t[0]+", "+t[1]+")"},Qc.exactEquals=function(t,e){return t[0]===e[0]&&t[1]===e[1]},Qc.equals=function(t,e){var r=t[0],n=t[1],i=e[0],a=e[1];return Math.abs(r-i)<=eh.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(n-a)<=eh.EPSILON*Math.max(1,Math.abs(n),Math.abs(a))},Qc.forEach=Qc.sqrLen=Qc.sqrDist=Qc.dist=Qc.div=Qc.mul=Qc.sub=Qc.len=void 0;var eh=function(t,e){if(t&&t.__esModule)return t;if(null===t||"object"!==th(t)&&"function"!=typeof t)return {default:t};var r=rh(void 0);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}(nu);function rh(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (rh=function(t){return t?r:e})(t)}function nh(){var t=new eh.ARRAY_TYPE(2);return eh.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0),t}function ih(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t}function ah(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t}function sh(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t}function oh(t,e){return Math.hypot(e[0]-t[0],e[1]-t[1])}function lh(t,e){var r=e[0]-t[0],n=e[1]-t[1];return r*r+n*n}function uh(t){return Math.hypot(t[0],t[1])}function ch(t){var e=t[0],r=t[1];return e*e+r*r}Qc.len=uh,Qc.sub=ih,Qc.mul=ah,Qc.div=sh,Qc.dist=oh,Qc.sqrDist=lh,Qc.sqrLen=ch;var hh=function(){var t=nh();return function(e,r,n,i,a,s){var o,l;for(r||(r=2),n||(n=0),l=i?Math.min(i*r+n,e.length):e.length,o=n;o<l;o+=r)t[0]=e[o],t[1]=e[o+1],a(t,t,s),e[o]=t[0],e[o+1]=t[1];return e}}();function ph(t){return ph="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ph(t)}Qc.forEach=hh,Object.defineProperty(ru,"__esModule",{value:!0}),t.a7=ru.vec4=t.N=ru.vec3=ru.vec2=ru.quat2=t.bi=ru.quat=t.a6=ru.mat4=t.co=ru.mat3=ru.mat2d=t.b4=ru.mat2=ru.glMatrix=void 0;var fh=Ah(nu);ru.glMatrix=fh;var dh=Ah(lu);t.b4=ru.mat2=dh;var mh=Ah(du);ru.mat2d=mh;var yh=Ah(bu);t.co=ru.mat3=yh;var gh=Ah(Iu);t.a6=ru.mat4=gh;var xh=Ah(Lu);t.bi=ru.quat=xh;var vh=Ah(Oc);ru.quat2=vh;var bh=Ah(Qc);ru.vec2=bh;var _h=Ah(Fu);t.N=ru.vec3=_h;var wh=Ah(Qu);function Mh(t){if("function"!=typeof WeakMap)return null;var e=new WeakMap,r=new WeakMap;return (Mh=function(t){return t?r:e})(t)}function Ah(t,e){if(!e&&t&&t.__esModule)return t;if(null===t||"object"!==ph(t)&&"function"!=typeof t)return {default:t};var r=Mh(e);if(r&&r.has(t))return r.get(t);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if("default"!==a&&Object.prototype.hasOwnProperty.call(t,a)){var s=i?Object.getOwnPropertyDescriptor(t,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=t[a];}return n.default=t,r&&r.set(t,n),n}t.a7=ru.vec4=wh;class Sh{constructor(t,e){this.pos=t,this.dir=e;}intersectsPlane(e,r,n){const i=t.N.dot(r,this.dir);if(Math.abs(i)<1e-6)return !1;const a=((e[0]-this.pos[0])*r[0]+(e[1]-this.pos[1])*r[1]+(e[2]-this.pos[2])*r[2])/i;return n[0]=this.pos[0]+this.dir[0]*a,n[1]=this.pos[1]+this.dir[1]*a,n[2]=this.pos[2]+this.dir[2]*a,!0}closestPointOnSphere(e,r,n){if(t.N.equals(this.pos,e)||0===r)return n[0]=n[1]=n[2]=0,!1;const[i,a,s]=this.dir,o=this.pos[0]-e[0],l=this.pos[1]-e[1],u=this.pos[2]-e[2],c=i*i+a*a+s*s,h=2*(o*i+l*a+u*s),p=h*h-4*c*(o*o+l*l+u*u-r*r);if(p<0){const t=Math.max(-h/2,0),e=o+i*t,c=l+a*t,p=u+s*t,f=Math.hypot(e,c,p);return n[0]=e*r/f,n[1]=c*r/f,n[2]=p*r/f,!1}{const t=(-h-Math.sqrt(p))/(2*c);if(t<0){const t=Math.hypot(o,l,u);return n[0]=o*r/t,n[1]=l*r/t,n[2]=u*r/t,!1}return n[0]=o+i*t,n[1]=l+a*t,n[2]=u+s*t,!0}}}class Ih{constructor(t,e,r,n,i){this.TL=t,this.TR=e,this.BR=r,this.BL=n,this.horizon=i;}static fromInvProjectionMatrix(e,r,n){const i=[-1,1,1],a=[1,1,1],s=[1,-1,1],o=[-1,-1,1],l=t.N.transformMat4(i,i,e),u=t.N.transformMat4(a,a,e),c=t.N.transformMat4(s,s,e),h=t.N.transformMat4(o,o,e);return new Ih(l,u,c,h,r/n)}}function kh(e,r,n){let i=1/0,a=-1/0;const s=[];for(const o of e){t.N.sub(s,o,r);const e=t.N.dot(s,n);i=Math.min(i,e),a=Math.max(a,e);}return [i,a]}function Ph(e,r){let n=!0;for(let i=0;i<e.planes.length;i++){const a=e.planes[i];let s=0;for(let e=0;e<r.length;e++)s+=t.N.dot(a,r[e])+a[3]>=0;if(0===s)return 0;s!==r.length&&(n=!1);}return n?2:1}function Eh(t,e){for(const r of t.projections){const n=kh(e,t.points[0],r.axis);if(r.projection[1]<n[0]||r.projection[0]>n[1])return 0}return 1}function zh(e,r){let n=0;const i=[0,0,0,0];for(let a=0;a<e.length;a++)i[0]=e[a][0],i[1]=e[a][1],i[2]=e[a][2],i[3]=1,t.a7.dot(i,r)>=0&&n++;return n}class Th{constructor(e,r){this.points=e||new Array(8).fill([0,0,0]),this.planes=r||new Array(6).fill([0,0,0,0]),this.bounds=Bh.fromPoints(this.points),this.projections=[],this.frustumEdges=[t.N.sub([],this.points[2],this.points[3]),t.N.sub([],this.points[0],this.points[3]),t.N.sub([],this.points[4],this.points[0]),t.N.sub([],this.points[5],this.points[1]),t.N.sub([],this.points[6],this.points[2]),t.N.sub([],this.points[7],this.points[3])];for(const t of this.frustumEdges){const e=[0,-t[2],t[1]],r=[t[2],0,-t[0]];this.projections.push({axis:e,projection:kh(this.points,this.points[0],e)}),this.projections.push({axis:r,projection:kh(this.points,this.points[0],r)});}}static fromInvProjectionMatrix(e,r,n,i){const a=Math.pow(2,n),s=[[-1,1,-1,1],[1,1,-1,1],[1,-1,-1,1],[-1,-1,-1,1],[-1,1,1,1],[1,1,1,1],[1,-1,1,1],[-1,-1,1,1]].map((n=>{const s=t.a7.transformMat4([],n,e),o=1/s[3]/r*a;return t.a7.mul(s,s,[o,o,i?1/s[3]:o,o])})),o=[[0,1,2],[6,5,4],[0,3,7],[2,1,5],[3,2,6],[0,4,5]].map((e=>{const r=t.N.sub([],s[e[0]],s[e[1]]),n=t.N.sub([],s[e[2]],s[e[1]]),i=t.N.normalize([],t.N.cross([],r,n)),a=-t.N.dot(i,s[e[1]]);return i.concat(a)})),l=[];for(let t=0;t<s.length;t++)l.push([s[t][0],s[t][1],s[t][2]]);return new Th(l,o)}intersectsPrecise(e,r,n){for(let t=0;t<r.length;t++)if(!zh(e,r[t]))return 0;for(let t=0;t<this.planes.length;t++)if(!zh(e,this.planes[t]))return 0;for(const r of n)for(const n of this.frustumEdges){const i=t.N.cross([],r,n),a=t.N.length(i);if(0===a)continue;t.N.scale(i,i,1/a);const s=kh(this.points,this.points[0],i),o=kh(e,this.points[0],i);if(s[0]>o[1]||o[0]>s[1])return 0}return 1}}class Bh{static fromPoints(e){const r=[1/0,1/0,1/0],n=[-1/0,-1/0,-1/0];for(const i of e)t.N.min(r,r,i),t.N.max(n,n,i);return new Bh(r,n)}static fromTileIdAndHeight(t,e,r){const n=1<<t.canonical.z,i=t.canonical.x,a=t.canonical.y;return new Bh([i/n,a/n,e],[(i+1)/n,(a+1)/n,r])}static applyTransform(e,r){const n=e.getCorners();for(let e=0;e<n.length;++e)t.N.transformMat4(n[e],n[e],r);return Bh.fromPoints(n)}static projectAabbCorners(e,r){const n=e.getCorners();for(let e=0;e<n.length;++e)t.N.transformMat4(n[e],n[e],r);return n}constructor(e,r){this.min=e,this.max=r,this.center=t.N.scale([],t.N.add([],this.min,this.max),.5);}quadrant(e){const r=[e%2==0,e<2],n=t.N.clone(this.min),i=t.N.clone(this.max);for(let t=0;t<r.length;t++)n[t]=r[t]?this.min[t]:this.center[t],i[t]=r[t]?this.center[t]:this.max[t];return i[2]=this.max[2],new Bh(n,i)}distanceX(t){return Math.max(Math.min(this.max[0],t[0]),this.min[0])-t[0]}distanceY(t){return Math.max(Math.min(this.max[1],t[1]),this.min[1])-t[1]}distanceZ(t){return Math.max(Math.min(this.max[2],t[2]),this.min[2])-t[2]}getCorners(){const t=this.min,e=this.max;return [[t[0],t[1],t[2]],[e[0],t[1],t[2]],[e[0],e[1],t[2]],[t[0],e[1],t[2]],[t[0],t[1],e[2]],[e[0],t[1],e[2]],[e[0],e[1],e[2]],[t[0],e[1],e[2]]]}intersects(t){return this.intersectsAabb(t.bounds)?Ph(t,this.getCorners()):0}intersectsFlat(t){return this.intersectsAabb(t.bounds)?Ph(t,[[this.min[0],this.min[1],0],[this.max[0],this.min[1],0],[this.max[0],this.max[1],0],[this.min[0],this.max[1],0]]):0}intersectsPrecise(t,e){return e||this.intersects(t)?Eh(t,this.getCorners()):0}intersectsPreciseFlat(t,e){return e||this.intersectsFlat(t)?Eh(t,[[this.min[0],this.min[1],0],[this.max[0],this.min[1],0],[this.max[0],this.max[1],0],[this.min[0],this.max[1],0]]):0}intersectsAabb(t){for(let e=0;e<3;++e)if(this.min[e]>t.max[e]||t.min[e]>this.max[e])return !1;return !0}intersectsAabbXY(t){return !(this.min[0]>t.max[0]||t.min[0]>this.max[0]||this.min[1]>t.max[1]||t.min[1]>this.max[1])}encapsulate(t){for(let e=0;e<3;e++)this.min[e]=Math.min(this.min[e],t.min[e]),this.max[e]=Math.max(this.max[e],t.max[e]);}encapsulatePoint(t){for(let e=0;e<3;e++)this.min[e]=Math.min(this.min[e],t[e]),this.max[e]=Math.max(this.max[e],t[e]);}closestPoint(t){return [Math.max(Math.min(this.max[0],t[0]),this.min[0]),Math.max(Math.min(this.max[1],t[1]),this.min[1]),Math.max(Math.min(this.max[2],t[2]),this.min[2])]}}ra(Bh,"Aabb");const Ch=cs([{type:"Float32",name:"a_globe_pos",components:3},{type:"Float32",name:"a_uv",components:2}]),{members:Rh}=Ch,Dh=cs([{name:"a_pos_3",components:3,type:"Int16"}]);var Vh=cs([{name:"a_pos",type:"Int16",components:2}]);function Lh(t){return t*jo/Jo}const Fh=[new Bh([Zo,Zo,Zo],[Ko,Ko,Ko]),new Bh([Zo,Zo,Zo],[0,0,Ko]),new Bh([0,Zo,Zo],[Ko,0,Ko]),new Bh([Zo,0,Zo],[0,Ko,Ko]),new Bh([0,0,Zo],[Ko,Ko,Ko])];function Nh(e,r,n,i=!0){const a=t.N.scale([],e._camera.position,e.worldSize),s=[r,n,1,1];t.a7.transformMat4(s,s,e.pixelMatrixInverse),t.a7.scale(s,s,1/s[3]);const o=t.N.sub([],s,a),l=t.N.normalize([],o),u=e.globeMatrix,c=[u[12],u[13],u[14]],h=t.N.sub([],c,a),p=t.N.length(h),f=t.N.normalize([],h),d=e.worldSize/(2*Math.PI),m=t.N.dot(f,l),y=Math.asin(d/p);if(y<Math.acos(m)){if(!i)return null;const e=[],r=[];t.N.scale(e,l,p/m),t.N.normalize(r,t.N.sub(r,e,h)),t.N.normalize(l,t.N.add(l,h,t.N.scale(l,r,Math.tan(y)*p)));}const g=[];new Sh(a,l).closestPointOnSphere(c,d,g);const x=t.N.normalize([],rt(u,0)),v=t.N.normalize([],rt(u,1)),b=t.N.normalize([],rt(u,2)),w=t.N.dot(x,g),M=t.N.dot(v,g),A=t.N.dot(b,g),S=_(Math.asin(-M/d));let k=_(Math.atan2(w,A));k=e.center.lng+function(t,e){const r=(e-t+180)%360-180;return r<-180?r+360:r}(e.center.lng,k);const P=pl(k),E=I(fl(S),0,1);return new Ml(P,E)}class Oh{constructor(e,r,n){this.a=t.N.sub([],e,n),this.b=t.N.sub([],r,n),this.center=n;const i=t.N.normalize([],this.a),a=t.N.normalize([],this.b);this.angle=Math.acos(t.N.dot(i,a));}}function Uh(t,e){if(0===t.angle)return null;let r;return r=0===t.a[e]?1/t.angle*.5*Math.PI:1/t.angle*Math.atan(t.b[e]/t.a[e]/Math.sin(t.angle)-1/Math.tan(t.angle)),r<0||r>1?null:function(t,e,r,n){const i=Math.sin(r);return t*(Math.sin((1-n)*r)/i)+e*(Math.sin(n*r)/i)}(t.a[e],t.b[e],t.angle,I(r,0,1))+t.center[e]}function jh(t){if(t.z<=1)return Fh[t.z+2*t.y+t.x];const e=Xh(Yh(t));return Bh.fromPoints(e)}function qh(e,r,n){return t.N.scale(e,e,1-n),t.N.scaleAndAdd(e,e,r,n)}function $h(e,r,n){for(const i of e)t.N.transformMat4(i,i,r),t.N.scale(i,i,n);}function Gh(e,r,n,i){const a=r/e.worldSize,s=e.globeMatrix;if(n.z<=1){const t=jh(n).getCorners();return $h(t,s,a),Bh.fromPoints(t)}const o=Yh(n,i),l=Xh(o,jo+Lh(e._tileCoverLift));$h(l,s,a);const u=Number.MAX_VALUE,c=[-u,-u,-u],h=[u,u,u];if(o.contains(e.center)){for(const e of l)t.N.min(h,h,e),t.N.max(c,c,e);c[2]=0;const r=e.point,n=[r.x*a,r.y*a,0];return t.N.min(h,h,n),t.N.max(c,c,n),new Bh(h,c)}if(e._tileCoverLift>0){for(const e of l)t.N.min(h,h,e),t.N.max(c,c,e);return new Bh(h,c)}const p=[s[12]*a,s[13]*a,s[14]*a],f=o.getCenter(),d=I(e.center.lat,-xl,xl),m=I(f.lat,-xl,xl),y=pl(e.center.lng),g=fl(d);let x=y-pl(f.lng);const v=g-fl(m);x>.5?x-=1:x<-.5&&(x+=1);let _=0;if(Math.abs(x)>Math.abs(v))_=x>=0?1:3;else {_=v>=0?0:2;const e=[s[4]*a,s[5]*a,s[6]*a],r=-Math.sin(b(v>=0?o.getSouth():o.getNorth()))*jo;t.N.scaleAndAdd(p,p,e,r);}const w=l[_],M=l[(_+1)%4],A=new Oh(w,M,p),S=[Uh(A,0)||w[0],Uh(A,1)||w[1],Uh(A,2)||w[2]],k=rp(e.zoom);if(k>0){const i=function({x:t,y:e,z:r},n,i,a,s){const o=1/(1<<r);let l=t*o,u=l+o,c=e*o,h=c+o,p=0;const f=(l+u)/2-a;return f>.5?p=-1:f<-.5&&(p=1),l=((l+p)*n-(a*=n))*i+a,u=((u+p)*n-a)*i+a,c=(c*n-(s*=n))*i+s,h=(h*n-s)*i+s,[[l,h,0],[u,h,0],[u,c,0],[l,c,0]]}(n,r,e._pixelsPerMercatorPixel,y,g);for(let t=0;t<l.length;t++)qh(l[t],i[t],k);const a=t.N.add([],i[_],i[(_+1)%4]);t.N.scale(a,a,.5),qh(S,a,k);}for(const e of l)t.N.min(h,h,e),t.N.max(c,c,e);return h[2]=Math.min(w[2],M[2]),t.N.min(h,h,S),t.N.max(c,c,S),new Bh(h,c)}function Yh({x:t,y:e,z:r},n=!1){const i=1/(1<<r),a=new tl(ml(t*i),e===(1<<r)-1&&n?-90:yl((e+1)*i)),s=new tl(ml((t+1)*i),0===e&&n?90:yl(e*i));return new el(a,s)}function Xh(t,e=jo){const r=b(t.getNorth()),n=b(t.getSouth()),i=Math.cos(r),a=Math.cos(n),s=Math.sin(r),o=Math.sin(n),l=t.getWest(),u=t.getEast();return [Ho(a,o,l,e),Ho(a,o,u,e),Ho(i,s,u,e),Ho(i,s,l,e)]}function Zh(t,e,r,n){const i=1<<r.z,a=(t/Tr+r.x)/i;return Wo(yl((e/Tr+r.y)/i),ml(a),n)}function Kh({min:t,max:e}){return Go/Math.max(e[0]-t[0],e[1]-t[1],e[2]-t[2])}const Hh=new Float64Array(16);function Wh(e){const r=Kh(e),n=t.a6.fromScaling(Hh,[r,r,r]);return t.a6.translate(n,n,t.N.negate([],e.min))}function Jh(e){const r=t.a6.fromTranslation(Hh,e.min),n=1/Kh(e);return t.a6.scale(r,r,[n,n,n])}function Qh(t){const e=Tr/(2*Math.PI);return t/(2*Math.PI)/e}function tp(t,e){return Tr/(512*Math.pow(2,t))*Kh(jh(e))}function ep(e,r,n,i,a){const s=Qh(n),o=[e,r,-n/(2*Math.PI)],l=t.a6.identity(new Float64Array(16));return t.a6.translate(l,l,o),t.a6.scale(l,l,[s,s,s]),t.a6.rotateX(l,l,b(-a)),t.a6.rotateY(l,l,b(-i)),l}function rp(t){return k(qo,$o,t)}function np(e,r){const n=Wo(r.lat,r.lng),i=function(e){const r=Wo(e._center.lat,e._center.lng),n=t.N.fromValues(0,1,0);let i=t.N.cross([],n,r);const a=t.a6.fromRotation([],-e.angle,r);i=t.N.transformMat4(i,i,a),t.a6.fromRotation(a,-e._pitch,i);const s=t.N.normalize([],r);return t.N.scale(s,s,Lh(e.cameraToCenterDistance/e.pixelsPerMeter)),t.N.transformMat4(s,s,a),t.N.add([],r,s)}(e),a=t.N.subtract([],i,n);return t.N.angle(a,n)}function ip(t,e){return np(t,e)>Math.PI/2*1.01}const ap=b(85),sp=Math.cos(ap),op=Math.sin(ap),lp=t.a6.create(),up=t=>{const e=[];return "map"===t.paint.get("circle-pitch-alignment")&&e.push("PITCH_WITH_MAP"),"map"===t.paint.get("circle-pitch-scale")&&e.push("SCALE_WITH_MAP"),e};function cp(e,r,n,i,a,s,o,l,u){if(s&&e.queryGeometry.isAboveHorizon)return !1;s&&(u*=e.pixelToTileUnitsFactor);const c=e.tileID.canonical,h=n.projection.upVectorScale(c,n.center.lat,n.worldSize).metersToTile;for(const p of r)for(const r of p){const p=r.add(l),f=a&&n.elevation?n.elevation.exaggeration()*a.getElevationAt(p.x,p.y,!0):0,d=n.projection.projectTilePoint(p.x,p.y,c);if(f>0){const t=n.projection.upVector(c,p.x,p.y);d.x+=t[0]*h*f,d.y+=t[1]*h*f,d.z+=t[2]*h*f;}const m=s?p:hp(d.x,d.y,d.z,i),y=s?e.tilespaceRays.map((t=>dp(t,f))):e.queryGeometry.screenGeometry,g=t.a7.transformMat4([],[d.x,d.y,d.z,1],i);if(!o&&s?u*=g[3]/n.cameraToCenterDistance:o&&!s&&(u*=n.cameraToCenterDistance/g[3]),s){const t=yl((r.y/Tr+c.y)/(1<<c.z));u/=n.projection.pixelsPerMeter(t,1)/dl(1,t);}if(Ll(y,m,u))return !0}return !1}function hp(e,r,n,i){const a=t.a7.transformMat4([],[e,r,n,1],i);return new g(a[0]/a[3],a[1]/a[3])}const pp=t.N.fromValues(0,0,0),fp=t.N.fromValues(0,0,1);function dp(e,r){const n=t.N.create();return pp[2]=r,e.intersectsPlane(pp,fp,n),new g(n[0],n[1])}class mp extends Dl{}function yp(t,{width:e,height:r},n,i){if(i){if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==e*r*n)throw new RangeError("mismatched image size")}else i=new Uint8Array(e*r*n);return t.width=e,t.height=r,t.data=i,t}function gp(t,e,r){const{width:n,height:i}=e;n===t.width&&i===t.height||(xp(t,e,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,n),height:Math.min(t.height,i)},r),t.width=n,t.height=i,t.data=e.data);}function xp(t,e,r,n,i,a,s){if(0===i.width||0===i.height)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");const o=t.data,l=e.data,u=4===a&&s;for(let s=0;s<i.height;s++){const c=((r.y+s)*t.width+r.x)*a,h=((n.y+s)*e.width+n.x)*a;if(u)for(let t=0;t<i.width;t++){const e=c+t*a+3,r=h+t*a;l[r+0]=255,l[r+1]=255,l[r+2]=255,l[r+3]=o[e];}else for(let t=0;t<i.width*a;t++)l[h+t]=o[c+t];}return e}ra(mp,"HeatmapBucket",{omit:["layers"]});class vp{constructor(t,e){yp(this,t,1,e);}resize(t){gp(this,new vp(t),1);}clone(){return new vp({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,e,r,n,i){xp(t,e,r,n,i,1);}}class bp{constructor(t,e){yp(this,t,4,e);}resize(t){gp(this,new bp(t),4);}replace(t,e){e?this.data.set(t):this.data=t instanceof Uint8ClampedArray?new Uint8Array(t.buffer):t;}clone(){return new bp({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,e,r,n,i,a){xp(t,e,r,n,i,4,a);}}class _p{constructor(t,e){this.width=t.width,this.height=t.height,this.data=e instanceof Uint8Array?new Float32Array(e.buffer):e;}}ra(vp,"AlphaImage"),ra(bp,"RGBAImage");const wp=new Oa({visibility:new La(qa.layout_heatmap.visibility)});var Mp={paint:new Oa({"heatmap-radius":new Fa(qa.paint_heatmap["heatmap-radius"]),"heatmap-weight":new Fa(qa.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new La(qa.paint_heatmap["heatmap-intensity"]),"heatmap-color":new Na(qa.paint_heatmap["heatmap-color"]),"heatmap-opacity":new La(qa.paint_heatmap["heatmap-opacity"])}),layout:wp};function Ap(t){const e={},r=t.resolution||256,n=t.clips?t.clips.length:1,i=t.image||new bp({width:r,height:n}),a=(r,n,a)=>{e[t.evaluationKey]=a;const s=t.expression.evaluate(e);s&&(i.data[r+n+0]=Math.floor(255*s.r/s.a),i.data[r+n+1]=Math.floor(255*s.g/s.a),i.data[r+n+2]=Math.floor(255*s.b/s.a),i.data[r+n+3]=Math.floor(255*s.a));};if(t.clips)for(let e=0,i=0;e<n;++e,i+=4*r)for(let n=0,s=0;n<r;n++,s+=4){const o=n/(r-1),{start:l,end:u}=t.clips[e];a(i,s,l*(1-o)+u*o);}else for(let t=0,e=0;t<r;t++,e+=4)a(0,e,t/(r-1));return i}const Sp=new Oa({visibility:new La(qa.layout_hillshade.visibility)});var Ip={paint:new Oa({"hillshade-illumination-direction":new La(qa.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new La(qa.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new La(qa.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new La(qa.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new La(qa.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new La(qa.paint_hillshade["hillshade-accent-color"]),"hillshade-emissive-strength":new La(qa.paint_hillshade["hillshade-emissive-strength"])}),layout:Sp};const kp=cs([{name:"a_pos",components:2,type:"Int16"}],4),{members:Pp}=kp;var Ep={exports:{}};function zp(t,e,r){r=r||2;var n,i,a,s,o,l,u,c=e&&e.length,h=c?e[0]*r:t.length,p=Tp(t,0,h,r,!0),f=[];if(!p||p.next===p.prev)return f;if(c&&(p=function(t,e,r,n){var i,a,s,o=[];for(i=0,a=e.length;i<a;i++)(s=Tp(t,e[i]*n,i<a-1?e[i+1]*n:t.length,n,!1))===s.next&&(s.steiner=!0),o.push(jp(s));for(o.sort(Fp),i=0;i<o.length;i++)r=Np(o[i],r);return r}(t,e,p,r)),t.length>80*r){n=a=t[0],i=s=t[1];for(var d=r;d<h;d+=r)(o=t[d])<n&&(n=o),(l=t[d+1])<i&&(i=l),o>a&&(a=o),l>s&&(s=l);u=0!==(u=Math.max(a-n,s-i))?32767/u:0;}return Cp(p,f,r,n,i,u,0),f}function Tp(t,e,r,n,i){var a,s;if(i===ef(t,e,r,n)>0)for(a=e;a<r;a+=n)s=Jp(a,t[a],t[a+1],s);else for(a=r-n;a>=e;a-=n)s=Jp(a,t[a],t[a+1],s);return s&&Yp(s,s.next)&&(Qp(s),s=s.next),s}function Bp(t,e){if(!t)return t;e||(e=t);var r,n=t;do{if(r=!1,n.steiner||!Yp(n,n.next)&&0!==Gp(n.prev,n,n.next))n=n.next;else {if(Qp(n),(n=e=n.prev)===n.next)break;r=!0;}}while(r||n!==e);return e}function Cp(t,e,r,n,i,a,s){if(t){!s&&a&&function(t,e,r,n){var i=t;do{0===i.z&&(i.z=Up(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var e,r,n,i,a,s,o,l,u=1;do{for(r=t,t=null,a=null,s=0;r;){for(s++,n=r,o=0,e=0;e<u&&(o++,n=n.nextZ);e++);for(l=u;o>0||l>0&&n;)0!==o&&(0===l||!n||r.z<=n.z)?(i=r,r=r.nextZ,o--):(i=n,n=n.nextZ,l--),a?a.nextZ=i:t=i,i.prevZ=a,a=i;r=n;}a.nextZ=null,u*=2;}while(s>1)}(i);}(t,n,i,a);for(var o,l,u=t;t.prev!==t.next;)if(o=t.prev,l=t.next,a?Dp(t,n,i,a):Rp(t))e.push(o.i/r|0),e.push(t.i/r|0),e.push(l.i/r|0),Qp(t),t=l.next,u=l.next;else if((t=l)===u){s?1===s?Cp(t=Vp(Bp(t),e,r),e,r,n,i,a,2):2===s&&Lp(t,e,r,n,i,a):Cp(Bp(t),e,r,n,i,a,1);break}}}function Rp(t){var e=t.prev,r=t,n=t.next;if(Gp(e,r,n)>=0)return !1;for(var i=e.x,a=r.x,s=n.x,o=e.y,l=r.y,u=n.y,c=i<a?i<s?i:s:a<s?a:s,h=o<l?o<u?o:u:l<u?l:u,p=i>a?i>s?i:s:a>s?a:s,f=o>l?o>u?o:u:l>u?l:u,d=n.next;d!==e;){if(d.x>=c&&d.x<=p&&d.y>=h&&d.y<=f&&qp(i,o,a,l,s,u,d.x,d.y)&&Gp(d.prev,d,d.next)>=0)return !1;d=d.next;}return !0}function Dp(t,e,r,n){var i=t.prev,a=t,s=t.next;if(Gp(i,a,s)>=0)return !1;for(var o=i.x,l=a.x,u=s.x,c=i.y,h=a.y,p=s.y,f=o<l?o<u?o:u:l<u?l:u,d=c<h?c<p?c:p:h<p?h:p,m=o>l?o>u?o:u:l>u?l:u,y=c>h?c>p?c:p:h>p?h:p,g=Up(f,d,e,r,n),x=Up(m,y,e,r,n),v=t.prevZ,b=t.nextZ;v&&v.z>=g&&b&&b.z<=x;){if(v.x>=f&&v.x<=m&&v.y>=d&&v.y<=y&&v!==i&&v!==s&&qp(o,c,l,h,u,p,v.x,v.y)&&Gp(v.prev,v,v.next)>=0)return !1;if(v=v.prevZ,b.x>=f&&b.x<=m&&b.y>=d&&b.y<=y&&b!==i&&b!==s&&qp(o,c,l,h,u,p,b.x,b.y)&&Gp(b.prev,b,b.next)>=0)return !1;b=b.nextZ;}for(;v&&v.z>=g;){if(v.x>=f&&v.x<=m&&v.y>=d&&v.y<=y&&v!==i&&v!==s&&qp(o,c,l,h,u,p,v.x,v.y)&&Gp(v.prev,v,v.next)>=0)return !1;v=v.prevZ;}for(;b&&b.z<=x;){if(b.x>=f&&b.x<=m&&b.y>=d&&b.y<=y&&b!==i&&b!==s&&qp(o,c,l,h,u,p,b.x,b.y)&&Gp(b.prev,b,b.next)>=0)return !1;b=b.nextZ;}return !0}function Vp(t,e,r){var n=t;do{var i=n.prev,a=n.next.next;!Yp(i,a)&&Xp(i,n,n.next,a)&&Hp(i,a)&&Hp(a,i)&&(e.push(i.i/r|0),e.push(n.i/r|0),e.push(a.i/r|0),Qp(n),Qp(n.next),n=t=a),n=n.next;}while(n!==t);return Bp(n)}function Lp(t,e,r,n,i,a){var s=t;do{for(var o=s.next.next;o!==s.prev;){if(s.i!==o.i&&$p(s,o)){var l=Wp(s,o);return s=Bp(s,s.next),l=Bp(l,l.next),Cp(s,e,r,n,i,a,0),void Cp(l,e,r,n,i,a,0)}o=o.next;}s=s.next;}while(s!==t)}function Fp(t,e){return t.x-e.x}function Np(t,e){var r=function(t,e){var r,n=e,i=t.x,a=t.y,s=-1/0;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){var o=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(o<=i&&o>s&&(s=o,r=n.x<n.next.x?n:n.next,o===i))return r}n=n.next;}while(n!==e);if(!r)return null;var l,u=r,c=r.x,h=r.y,p=1/0;n=r;do{i>=n.x&&n.x>=c&&i!==n.x&&qp(a<h?i:s,a,c,h,a<h?s:i,a,n.x,n.y)&&(l=Math.abs(a-n.y)/(i-n.x),Hp(n,t)&&(l<p||l===p&&(n.x>r.x||n.x===r.x&&Op(r,n)))&&(r=n,p=l)),n=n.next;}while(n!==u);return r}(t,e);if(!r)return e;var n=Wp(r,t);return Bp(n,n.next),Bp(r,r.next)}function Op(t,e){return Gp(t.prev,t,e.prev)<0&&Gp(e.next,t,t.next)<0}function Up(t,e,r,n,i){return (t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function jp(t){var e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;}while(e!==t);return r}function qp(t,e,r,n,i,a,s,o){return (i-s)*(e-o)>=(t-s)*(a-o)&&(t-s)*(n-o)>=(r-s)*(e-o)&&(r-s)*(a-o)>=(i-s)*(n-o)}function $p(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&Xp(r,r.next,t,e))return !0;r=r.next;}while(r!==t);return !1}(t,e)&&(Hp(t,e)&&Hp(e,t)&&function(t,e){var r=t,n=!1,i=(t.x+e.x)/2,a=(t.y+e.y)/2;do{r.y>a!=r.next.y>a&&r.next.y!==r.y&&i<(r.next.x-r.x)*(a-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;}while(r!==t);return n}(t,e)&&(Gp(t.prev,t,e.prev)||Gp(t,e.prev,e))||Yp(t,e)&&Gp(t.prev,t,t.next)>0&&Gp(e.prev,e,e.next)>0)}function Gp(t,e,r){return (e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function Yp(t,e){return t.x===e.x&&t.y===e.y}function Xp(t,e,r,n){var i=Kp(Gp(t,e,r)),a=Kp(Gp(t,e,n)),s=Kp(Gp(r,n,t)),o=Kp(Gp(r,n,e));return i!==a&&s!==o||!(0!==i||!Zp(t,r,e))||!(0!==a||!Zp(t,n,e))||!(0!==s||!Zp(r,t,n))||!(0!==o||!Zp(r,e,n))}function Zp(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function Kp(t){return t>0?1:t<0?-1:0}function Hp(t,e){return Gp(t.prev,t,t.next)<0?Gp(t,e,t.next)>=0&&Gp(t,t.prev,e)>=0:Gp(t,e,t.prev)<0||Gp(t,t.next,e)<0}function Wp(t,e){var r=new tf(t.i,t.x,t.y),n=new tf(e.i,e.x,e.y),i=t.next,a=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,a.next=n,n.prev=a,n}function Jp(t,e,r,n){var i=new tf(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Qp(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ);}function tf(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1;}function ef(t,e,r,n){for(var i=0,a=e,s=r-n;a<r;a+=n)i+=(t[s]-t[a])*(t[a+1]+t[s+1]),s=a;return i}Ep.exports=zp,Ep.exports.default=zp,zp.deviation=function(t,e,r,n){var i=e&&e.length,a=Math.abs(ef(t,0,i?e[0]*r:t.length,r));if(i)for(var s=0,o=e.length;s<o;s++)a-=Math.abs(ef(t,e[s]*r,s<o-1?e[s+1]*r:t.length,r));var l=0;for(s=0;s<n.length;s+=3){var u=n[s]*r,c=n[s+1]*r,h=n[s+2]*r;l+=Math.abs((t[u]-t[h])*(t[c+1]-t[u+1])-(t[u]-t[c])*(t[h+1]-t[u+1]));}return 0===a&&0===l?0:Math.abs((l-a)/a)},zp.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var s=0;s<e;s++)r.vertices.push(t[i][a][s]);i>0&&r.holes.push(n+=t[i-1].length);}return r};var rf=h(Ep.exports);function nf(t,e){const r=t.length;if(r<=1)return [t];const n=[];let i,a;for(let e=0;e<r;e++){const r=$(t[e]);0!==r&&(t[e].area=Math.abs(r),void 0===a&&(a=r<0),a===r<0?(i&&n.push(i),i=[t[e]]):i.push(t[e]));}if(i&&n.push(i),e>1)for(let t=0;t<n.length;t++)n[t].length<=e||(sr(n[t],e,1,n[t].length-1,af),n[t]=n[t].slice(0,e));return n}function af(t,e){return e.area-t.area}function sf(t,e,r){const n=r.patternDependencies;let i=!1;for(const r of e){const e=r.paint.get(`${t}-pattern`);e.isConstant()||(i=!0);const a=e.constantOr(null);a&&(i=!0,n[a]=!0);}return i}function of(t,e,r,n,i){const a=i.patternDependencies;for(const s of e){const e=s.paint.get(`${t}-pattern`).value;if("constant"!==e.kind){let t=e.evaluate({zoom:n},r,{},i.availableImages);t=t&&t.name?t.name:t,a[t]=!0,r.patterns[s.id]=t;}}return r}class lf{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.fqid)),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new ps,this.indexArray=new Es,this.indexArray2=new As,this.programConfigurations=new Vo(t.layers,t.zoom),this.segments=new eo,this.segments2=new eo,this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.projection=t.projection;}populate(t,e,r,n){this.hasPattern=sf("fill",this.layers,e);const i=this.layers[0].layout.get("fill-sort-key"),a=[];for(const{feature:s,id:o,index:l,sourceLayerIndex:u}of t){const t=this.layers[0]._featureFilter.needGeometry,c=Bl(s,t);if(!this.layers[0]._featureFilter.filter(new Pa(this.zoom),c,r))continue;const h=i?i.evaluate(c,{},r,e.availableImages):void 0,p={id:o,properties:s.properties,type:s.type,sourceLayerIndex:u,index:l,geometry:t?c.geometry:Tl(s,r,n),patterns:{},sortKey:h};a.push(p);}i&&a.sort(((t,e)=>t.sortKey-e.sortKey));for(const n of a){const{geometry:i,index:a,sourceLayerIndex:s}=n;if(this.hasPattern){const t=of("fill",this.layers,n,this.zoom,e);this.patternFeatures.push(t);}else this.addFeature(n,i,a,r,{},e.availableImages,e.brightness);e.featureIndex.insert(t[a].feature,i,a,s,this.index);}}update(t,e,r,n,i){const a=0!==Object.keys(t).length;a&&!this.stateDependentLayers.length||this.programConfigurations.updatePaintArrays(t,e,a?this.stateDependentLayers:this.layers,r,n,i);}addFeatures(t,e,r,n,i,a){for(const t of this.patternFeatures)this.addFeature(t,t.geometry,t.index,e,r,n,a);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Pp),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0;}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy());}addFeature(t,e,r,n,i,a=[],s){for(const t of nf(e,500)){let e=0;for(const r of t)e+=r.length;const r=this.segments.prepareSegment(e,this.layoutVertexArray,this.indexArray),n=r.vertexLength,i=[],a=[];for(const e of t){if(0===e.length)continue;e!==t[0]&&a.push(i.length/2);const r=this.segments2.prepareSegment(e.length,this.layoutVertexArray,this.indexArray2),n=r.vertexLength;this.layoutVertexArray.emplaceBack(e[0].x,e[0].y),this.indexArray2.emplaceBack(n+e.length-1,n),i.push(e[0].x),i.push(e[0].y);for(let t=1;t<e.length;t++)this.layoutVertexArray.emplaceBack(e[t].x,e[t].y),this.indexArray2.emplaceBack(n+t-1,n+t),i.push(e[t].x),i.push(e[t].y);r.vertexLength+=e.length,r.primitiveLength+=e.length;}const s=rf(i,a);for(let t=0;t<s.length;t+=3)this.indexArray.emplaceBack(n+s[t],n+s[t+1],n+s[t+2]);r.vertexLength+=e,r.primitiveLength+=s.length/3;}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,a,n,s);}}ra(lf,"FillBucket",{omit:["layers","patternFeatures"]});const uf=new Oa({"fill-sort-key":new Fa(qa.layout_fill["fill-sort-key"]),visibility:new La(qa.layout_fill.visibility)});var cf={paint:new Oa({"fill-antialias":new La(qa.paint_fill["fill-antialias"]),"fill-opacity":new Fa(qa.paint_fill["fill-opacity"]),"fill-color":new Fa(qa.paint_fill["fill-color"]),"fill-outline-color":new Fa(qa.paint_fill["fill-outline-color"]),"fill-translate":new La(qa.paint_fill["fill-translate"]),"fill-translate-anchor":new La(qa.paint_fill["fill-translate-anchor"]),"fill-pattern":new Fa(qa.paint_fill["fill-pattern"]),"fill-emissive-strength":new La(qa.paint_fill["fill-emissive-strength"])}),layout:uf};const hf=cs([{name:"a_pos_normal_ed",components:4,type:"Int16"}]),pf=cs([{name:"a_pos_end",components:4,type:"Int16"},{name:"a_angular_offset_factor",components:1,type:"Int16"}]),ff=cs([{name:"a_centroid_pos",components:2,type:"Uint16"}]),df=cs([{name:"a_hidden_by_landmark",components:1,type:"Uint8"}]),mf=cs([{name:"a_pos_3",components:3,type:"Int16"},{name:"a_pos_normal_3",components:3,type:"Int16"}]),{members:yf}=hf;var gf={},xf=m,vf=bf;function bf(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(_f,this,e);}function _f(t,e,r){1==t?e.id=r.readVarint():2==t?function(t,e){for(var r=t.readVarint()+t.pos;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i;}}(r,e):3==t?e.type=r.readVarint():4==t&&(e._geometry=r.pos);}function wf(t){for(var e,r,n=0,i=0,a=t.length,s=a-1;i<a;s=i++)n+=((r=t[s]).x-(e=t[i]).x)*(e.y+r.y);return n}bf.types=["Unknown","Point","LineString","Polygon"],bf.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,r=t.readVarint()+t.pos,n=1,i=0,a=0,s=0,o=[];t.pos<r;){if(i<=0){var l=t.readVarint();n=7&l,i=l>>3;}if(i--,1===n||2===n)a+=t.readSVarint(),s+=t.readSVarint(),1===n&&(e&&o.push(e),e=[]),e.push(new xf(a,s));else {if(7!==n)throw new Error("unknown command "+n);e&&e.push(e[0].clone());}}return e&&o.push(e),o},bf.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,a=0,s=1/0,o=-1/0,l=1/0,u=-1/0;t.pos<e;){if(n<=0){var c=t.readVarint();r=7&c,n=c>>3;}if(n--,1===r||2===r)(i+=t.readSVarint())<s&&(s=i),i>o&&(o=i),(a+=t.readSVarint())<l&&(l=a),a>u&&(u=a);else if(7!==r)throw new Error("unknown command "+r)}return [s,l,o,u]},bf.prototype.toGeoJSON=function(t,e,r){var n,i,a=this.extent*Math.pow(2,r),s=this.extent*t,o=this.extent*e,l=this.loadGeometry(),u=bf.types[this.type];function c(t){for(var e=0;e<t.length;e++){var r=t[e];t[e]=[360*(r.x+s)/a-180,360/Math.PI*Math.atan(Math.exp((180-360*(r.y+o)/a)*Math.PI/180))-90];}}switch(this.type){case 1:var h=[];for(n=0;n<l.length;n++)h[n]=l[n][0];c(l=h);break;case 2:for(n=0;n<l.length;n++)c(l[n]);break;case 3:for(l=function(t){var e=t.length;if(e<=1)return [t];for(var r,n,i=[],a=0;a<e;a++){var s=wf(t[a]);0!==s&&(void 0===n&&(n=s<0),n===s<0?(r&&i.push(r),r=[t[a]]):r.push(t[a]));}return r&&i.push(r),i}(l),n=0;n<l.length;n++)for(i=0;i<l[n].length;i++)c(l[n][i]);}1===l.length?l=l[0]:u="Multi"+u;var p={type:"Feature",geometry:{type:u,coordinates:l},properties:this.properties};return "id"in this&&(p.id=this.id),p};var Mf=vf,Af=Sf;function Sf(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(If,this,e),this.length=this._features.length;}function If(t,e,r){15===t?e.version=r.readVarint():1===t?e.name=r.readString():5===t?e.extent=r.readVarint():2===t?e._features.push(r.pos):3===t?e._keys.push(r.readString()):4===t&&e._values.push(function(t){for(var e=null,r=t.readVarint()+t.pos;t.pos<r;){var n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null;}return e}(r));}Sf.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new Mf(this._pbf,e,this.extent,this._keys,this._values)};var kf=Af;function Pf(t,e,r){if(3===t){var n=new kf(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n);}}var Ef=gf.VectorTile=function(t,e){this.layers=t.readFields(Pf,{},e);},zf=gf.VectorTileFeature=vf;function Tf(t,e,r,n){const i=[],a=0===n?(t,e,r,n,i,a)=>{t.push(new g(a,r+(a-e)/(n-e)*(i-r)));}:(t,e,r,n,i,a)=>{t.push(new g(e+(a-r)/(i-r)*(n-e),a));};for(const s of t){const t=[];for(const i of s){if(i.length<=2)continue;const s=[];for(let t=0;t<i.length-1;t++){const o=i[t].x,l=i[t].y,u=i[t+1].x,c=i[t+1].y,h=0===n?o:l,p=0===n?u:c;h<e?p>e&&a(s,o,l,u,c,e):h>r?p<r&&a(s,o,l,u,c,r):s.push(i[t]),p<e&&h>=e&&a(s,o,l,u,c,e),p>r&&h<=r&&a(s,o,l,u,c,r);}let o=i[i.length-1];const l=0===n?o.x:o.y;l>=e&&l<=r&&s.push(o),s.length&&(o=s[s.length-1],s[0].x===o.x&&s[0].y===o.y||s.push(s[0]),t.push(s));}t.length&&i.push(t);}return i}function Bf(t,e){return t.x-e.x||t.y-e.y}function Cf(t,e){return 0===Bf(t.min,e.min)&&0===Bf(t.max,e.max)}function Rf(t,e){return !(t.min.x>e.max.x||t.max.x<e.min.x||t.min.y>e.max.y||t.max.y<e.min.y)}function Df(t,e,r){const n=1/Tr,i=1/(1<<r.canonical.z),a=(e.x*n+r.canonical.x)*i+r.wrap,s=(e.y*n+r.canonical.y)*i;return {min:new g((t.x*n+r.canonical.x)*i+r.wrap,(t.y*n+r.canonical.y)*i),max:new g(a,s)}}function Vf(t,e,r){const n=1<<r.canonical.z,i=((e.x-r.wrap)*n-r.canonical.x)*Tr,a=(e.y*n-r.canonical.y)*Tr;return {min:new g(((t.x-r.wrap)*n-r.canonical.x)*Tr,(t.y*n-r.canonical.y)*Tr),max:new g(i,a)}}function Lf(t,e,r,n,i,a,s){const o=t.indices,l=t.vertices,u=[];for(let c=n;c<n+i;c+=3){const n=e[r[c+0]+a],i=e[r[c+1]+a],h=e[r[c+2]+a],p=Math.min(n.x,i.x,h.x),f=Math.max(n.x,i.x,h.x),d=Math.min(n.y,i.y,h.y),m=Math.max(n.y,i.y,h.y);u.length=0,t.grid.query(new g(p,d),new g(f,m),u);for(let t=0;t<u.length;t++){const e=u[t];if(Kl(l[o[3*e+0]],l[o[3*e+1]],l[o[3*e+2]],n,i,h,s))return !0}}return !1}function Ff(t,e,r,n){if(!t||!r)return !1;let i=t.vertices;if(!e.canonical.equals(n.canonical)||e.wrap!==n.wrap){if(r.vertices.length<t.vertices.length)return Ff(r,n,t,e);const a=e.canonical,s=n.canonical,o=Math.pow(2,s.z-a.z);i=t.vertices.map((t=>new g(t.x*a.x*Tr*o-s.x*Tr,t.y*a.y*Tr*o-s.y*Tr)));}return Lf(r,i,t.indices,0,t.indices.length,0,0)}gf.VectorTileLayer=Af;class Nf{constructor(t){this.size=t,this.minimums=[],this.maximums=[],this.leaves=[];}getElevation(t,e){const r=this.toIdx(t,e);return {min:this.minimums[r],max:this.maximums[r]}}isLeaf(t,e){return this.leaves[this.toIdx(t,e)]}toIdx(t,e){return e*this.size+t}}function Of(t,e,r,n){let i=0,a=Number.MAX_VALUE;for(let s=0;s<3;s++)if(Math.abs(n[s])<1e-15){if(r[s]<t[s]||r[s]>e[s])return null}else {const o=1/n[s];let l=(t[s]-r[s])*o,u=(e[s]-r[s])*o;if(l>u){const t=l;l=u,u=t;}if(l>i&&(i=l),u<a&&(a=u),i>a)return null}return i}function Uf(t,e,r,n,i,a,s,o,l,u,c){const h=n-t,p=i-e,f=a-r,d=s-t,m=o-e,y=l-r,g=c[1]*y-c[2]*m,x=c[2]*d-c[0]*y,v=c[0]*m-c[1]*d,b=h*g+p*x+f*v;if(Math.abs(b)<1e-15)return null;const _=1/b,w=u[0]-t,M=u[1]-e,A=u[2]-r,S=(w*g+M*x+A*v)*_;if(S<0||S>1)return null;const I=M*f-A*p,k=A*h-w*f,P=w*p-M*h,E=(c[0]*I+c[1]*k+c[2]*P)*_;return E<0||S+E>1?null:(d*I+m*k+y*P)*_}function jf(t,e,r){return (t-e)/(r-e)}function qf(t,e,r,n,i,a,s,o,l){const u=1<<r,c=a-n,h=s-i,p=(t+1)/u*c+n,f=(e+0)/u*h+i,d=(e+1)/u*h+i;o[0]=(t+0)/u*c+n,o[1]=f,l[0]=p,l[1]=d;}class $f{constructor(t){if(this.maximums=[],this.minimums=[],this.leaves=[],this.childOffsets=[],this.nodeCount=0,this.dem=t,this._siblingOffset=[[0,0],[1,0],[0,1],[1,1]],!this.dem)return;const e=function(t){const e=Math.ceil(Math.log2(t.dim/8)),r=[];let n=Math.ceil(Math.pow(2,e));const i=1/n,a=(t,e,r,n,i)=>{const a=n?1:0,s=(t+1)*r-a,o=e*r,l=(e+1)*r-a;i[0]=t*r,i[1]=o,i[2]=s,i[3]=l;};let s=new Nf(n);const o=[];for(let e=0;e<n*n;e++){a(e%n,Math.floor(e/n),i,!1,o);const r=Yf(o[0],o[1],t),l=Yf(o[2],o[1],t),u=Yf(o[2],o[3],t),c=Yf(o[0],o[3],t);s.minimums.push(Math.min(r,l,u,c)),s.maximums.push(Math.max(r,l,u,c)),s.leaves.push(1);}for(r.push(s),n/=2;n>=1;n/=2){const t=r[r.length-1];s=new Nf(n);for(let e=0;e<n*n;e++){a(e%n,Math.floor(e/n),2,!0,o);const r=t.getElevation(o[0],o[1]),i=t.getElevation(o[2],o[1]),l=t.getElevation(o[2],o[3]),u=t.getElevation(o[0],o[3]),c=t.isLeaf(o[0],o[1]),h=t.isLeaf(o[2],o[1]),p=t.isLeaf(o[2],o[3]),f=t.isLeaf(o[0],o[3]),d=Math.min(r.min,i.min,l.min,u.min),m=Math.max(r.max,i.max,l.max,u.max),y=c&&h&&p&&f;s.maximums.push(m),s.minimums.push(d),s.leaves.push(m-d<=5&&y?1:0);}r.push(s);}return r}(this.dem),r=e.length-1,n=e[r];this._addNode(n.minimums[0],n.maximums[0],n.leaves[0]),this._construct(e,0,0,r,0);}raycastRoot(t,e,r,n,i,a,s=1){return Of([t,e,-100],[r,n,this.maximums[0]*s],i,a)}raycast(e,r,n,i,a,s,o=1){if(!this.nodeCount)return null;const l=this.raycastRoot(e,r,n,i,a,s,o);if(null==l)return null;const u=[],c=[],h=[],p=[],f=[{idx:0,t:l,nodex:0,nodey:0,depth:0}];for(;f.length>0;){const{idx:l,t:d,nodex:m,nodey:y,depth:g}=f.pop();if(this.leaves[l]){qf(m,y,g,e,r,n,i,h,p);const l=1<<g,u=(m+0)/l,c=(m+1)/l,f=(y+0)/l,x=(y+1)/l,v=Yf(u,f,this.dem)*o,b=Yf(c,f,this.dem)*o,_=Yf(c,x,this.dem)*o,w=Yf(u,x,this.dem)*o,M=Uf(h[0],h[1],v,p[0],h[1],b,p[0],p[1],_,a,s),A=Uf(p[0],p[1],_,h[0],p[1],w,h[0],h[1],v,a,s),S=Math.min(null!==M?M:Number.MAX_VALUE,null!==A?A:Number.MAX_VALUE);if(S!==Number.MAX_VALUE)return S;{const e=t.N.scaleAndAdd([],a,s,d);if(Gf(v,b,w,_,jf(e[0],h[0],p[0]),jf(e[1],h[1],p[1]))>=e[2])return d}continue}let x=0;for(let t=0;t<this._siblingOffset.length;t++){qf((m<<1)+this._siblingOffset[t][0],(y<<1)+this._siblingOffset[t][1],g+1,e,r,n,i,h,p),h[2]=-100,p[2]=this.maximums[this.childOffsets[l]+t]*o;const f=Of(h,p,a,s);if(null!=f){const e=f;u[t]=e;let r=!1;for(let n=0;n<x&&!r;n++)e>=u[c[n]]&&(c.splice(n,0,t),r=!0);r||(c[x]=t),x++;}}for(let t=0;t<x;t++){const e=c[t];f.push({idx:this.childOffsets[l]+e,t:u[e],nodex:(m<<1)+this._siblingOffset[e][0],nodey:(y<<1)+this._siblingOffset[e][1],depth:g+1});}}return null}_addNode(t,e,r){return this.minimums.push(t),this.maximums.push(e),this.leaves.push(r),this.childOffsets.push(0),this.nodeCount++}_construct(t,e,r,n,i){if(1===t[n].isLeaf(e,r))return;this.childOffsets[i]||(this.childOffsets[i]=this.nodeCount);const a=n-1,s=t[a];let o=0,l=0;for(let t=0;t<this._siblingOffset.length;t++){const n=2*e+this._siblingOffset[t][0],i=2*r+this._siblingOffset[t][1],a=s.getElevation(n,i),u=s.isLeaf(n,i),c=this._addNode(a.min,a.max,u);u&&(o|=1<<t),l||(l=c);}for(let n=0;n<this._siblingOffset.length;n++)o&1<<n||this._construct(t,2*e+this._siblingOffset[n][0],2*r+this._siblingOffset[n][1],a,l+n);}}function Gf(t,e,r,n,i,a){return ue(ue(t,r,a),ue(e,n,a),i)}function Yf(t,e,r){const n=r.dim,i=I(t*n-.5,0,n-1),a=I(e*n-.5,0,n-1),s=Math.floor(i),o=Math.floor(a),l=Math.min(s+1,n-1),u=Math.min(o+1,n-1);return Gf(r.get(s,o),r.get(l,o),r.get(s,u),r.get(l,u),i-s,a-o)}const Xf={mapbox:[6553.6,25.6,.1,1e4],terrarium:[256,1,1/256,32768]};function Zf(t,e,r){return (256*t*256+256*e+r)/10-1e4}function Kf(t,e,r){return 256*t+e+r/256-32768}class Hf{get tree(){return this._tree||this._buildQuadTree(),this._tree}constructor(t,e,r,n=!1){if(this.uid=t,e.height!==e.width)throw new RangeError("DEM tiles must be square");if(r&&"mapbox"!==r&&"terrarium"!==r)return j(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);this.stride=e.height;const i=this.dim=e.height-2,a=new Uint32Array(e.data.buffer);if(this.pixels=new Uint8Array(e.data.buffer),this.floatView=new Float32Array(e.data.buffer),this.borderReady=n,this._modifiedForSources={},!n){for(let t=0;t<i;t++)a[this._idx(-1,t)]=a[this._idx(0,t)],a[this._idx(i,t)]=a[this._idx(i-1,t)],a[this._idx(t,-1)]=a[this._idx(t,0)],a[this._idx(t,i)]=a[this._idx(t,i-1)];a[this._idx(-1,-1)]=a[this._idx(0,0)],a[this._idx(i,-1)]=a[this._idx(i-1,0)],a[this._idx(-1,i)]=a[this._idx(0,i-1)],a[this._idx(i,i)]=a[this._idx(i-1,i-1)];}const s="terrarium"===r?Kf:Zf;for(let t=0;t<a.length;++t){const e=4*t;this.floatView[t]=s(this.pixels[e],this.pixels[e+1],this.pixels[e+2]);}this._timestamp=st.now();}_buildQuadTree(){this._tree=new $f(this);}get(t,e,r=!1){r&&(t=I(t,-1,this.dim),e=I(e,-1,this.dim));const n=this._idx(t,e);return this.floatView[n]}set(t,e,r){const n=this._idx(t,e),i=this.floatView[n];return this.floatView[n]=r,r-i}static getUnpackVector(t){return Xf[t]}_idx(t,e){if(t<-1||t>=this.dim+1||e<-1||e>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return (e+1)*this.stride+(t+1)}static pack(t,e){const r=[0,0,0,0],n=Hf.getUnpackVector(e);let i=Math.floor((t+n[3])/n[2]);return r[2]=i%256,i=Math.floor(i/256),r[1]=i%256,i=Math.floor(i/256),r[0]=i,r}getPixels(){return new _p({width:this.stride,height:this.stride},this.pixels)}backfillBorder(t,e,r){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");let n=e*this.dim,i=e*this.dim+this.dim,a=r*this.dim,s=r*this.dim+this.dim;switch(e){case-1:n=i-1;break;case 1:i=n+1;}switch(r){case-1:a=s-1;break;case 1:s=a+1;}const o=-e*this.dim,l=-r*this.dim;for(let e=a;e<s;e++)for(let r=n;r<i;r++){const n=4*this._idx(r,e),i=4*this._idx(r+o,e+l);this.pixels[n+0]=t.pixels[i+0],this.pixels[n+1]=t.pixels[i+1],this.pixels[n+2]=t.pixels[i+2],this.pixels[n+3]=t.pixels[i+3];}}onDeserialize(){this._tree&&(this._tree.dem=this);}}ra(Hf,"DEMData"),ra($f,"DemMinMaxQuadTree",{omit:["dem"]});class Wf{constructor(t,e,r){this._demTile=t,this._dem=this._demTile.dem,this._scale=e,this._offset=r;}static create(t,e,r){const n=r||t.findDEMTileFor(e);if(!n||!n.dem)return;const i=n.dem,a=n.tileID,s=1<<e.canonical.z-a.canonical.z;return new Wf(n,i.dim/Tr/s,[(e.canonical.x/s-a.canonical.x)*i.dim,(e.canonical.y/s-a.canonical.y)*i.dim])}tileCoordToPixel(t,e){const r=e*this._scale+this._offset[1],n=Math.floor(t*this._scale+this._offset[0]),i=Math.floor(r);return new g(n,i)}getElevationAt(t,e,r,n){const i=t*this._scale+this._offset[0],a=e*this._scale+this._offset[1],s=Math.floor(i),o=Math.floor(a),l=this._dem;return n=!!n,r?ue(ue(l.get(s,o,n),l.get(s,o+1,n),a-o),ue(l.get(s+1,o,n),l.get(s+1,o+1,n),a-o),i-s):l.get(s,o,n)}getElevationAtPixel(t,e,r){return this._dem.get(t,e,!!r)}getMeterToDEM(t){return (1<<this._demTile.tileID.canonical.z)*dl(1,t)*this._dem.stride}}const Jf=zf.types,Qf=["fill-extrusion-base","fill-extrusion-height","fill-extrusion-color","fill-extrusion-pattern","fill-extrusion-flood-light-wall-radius"],td=["fill-extrusion-flood-light-ground-radius"],ed=Math.pow(2,13),rd=Math.pow(2,15)-1,nd=new g(0,1),id=2147483648;function ad(t,e,r,n,i,a,s,o){t.emplaceBack((e<<1)+s,(r<<1)+a,(Math.floor(n*ed)<<1)+i,Math.round(o));}function sd(t,e,r,n,i,a){t.emplaceBack(e.x,e.y,(r.x<<1)+n,(r.y<<1)+i,a);}function od(t,e,r){const n=16384;t.emplaceBack(e.x,e.y,e.z,r[0]*n,r[1]*n,r[2]*n);}class ld{constructor(){this.vertexOffset=0,this.vertexCount=0,this.indexOffset=0,this.indexCount=0;}}class ud{constructor(){this.centroidXY=new g(0,0),this.vertexArrayOffset=0,this.vertexCount=0,this.groundVertexArrayOffset=0,this.groundVertexCount=0,this.flags=0,this.footprintSegIdx=-1,this.footprintSegLen=0,this.polygonSegIdx=-1,this.polygonSegLen=0,this.min=new g(Number.MAX_VALUE,Number.MAX_VALUE),this.max=new g(-Number.MAX_VALUE,-Number.MAX_VALUE),this.height=0;}span(){return new g(this.max.x-this.min.x,this.max.y-this.min.y)}}class cd{constructor(){this.acc=new g(0,0),this.accCount=0,this.centroidDataIndex=0;}startRing(t,e){t.min.x===Number.MAX_VALUE&&(t.min.x=t.max.x=e.x,t.min.y=t.max.y=e.y);}appendEdge(t,e,r){this.accCount++,this.acc._add(e);let n=!!this.borders;e.x<t.min.x?(t.min.x=e.x,n=!0):e.x>t.max.x&&(t.max.x=e.x,n=!0),e.y<t.min.y?(t.min.y=e.y,n=!0):e.y>t.max.y&&(t.max.y=e.y,n=!0),((0===e.x||e.x===Tr)&&e.x===r.x)!=((0===e.y||e.y===Tr)&&e.y===r.y)&&this.processBorderOverlap(e,r),n&&this.checkBorderIntersection(e,r);}checkBorderIntersection(t,e){e.x<0!=t.x<0&&this.addBorderIntersection(0,ue(e.y,t.y,(0-e.x)/(t.x-e.x))),e.x>Tr!=t.x>Tr&&this.addBorderIntersection(1,ue(e.y,t.y,(Tr-e.x)/(t.x-e.x))),e.y<0!=t.y<0&&this.addBorderIntersection(2,ue(e.x,t.x,(0-e.y)/(t.y-e.y))),e.y>Tr!=t.y>Tr&&this.addBorderIntersection(3,ue(e.x,t.x,(Tr-e.y)/(t.y-e.y)));}addBorderIntersection(t,e){this.borders||(this.borders=[[Number.MAX_VALUE,-Number.MAX_VALUE],[Number.MAX_VALUE,-Number.MAX_VALUE],[Number.MAX_VALUE,-Number.MAX_VALUE],[Number.MAX_VALUE,-Number.MAX_VALUE]]);const r=this.borders[t];e<r[0]&&(r[0]=e),e>r[1]&&(r[1]=e);}processBorderOverlap(t,e){if(t.x===e.x){if(t.y===e.y)return;const r=0===t.x?0:1;this.addBorderIntersection(r,e.y),this.addBorderIntersection(r,t.y);}else {const r=0===t.y?2:3;this.addBorderIntersection(r,e.x),this.addBorderIntersection(r,t.x);}}centroid(){return 0===this.accCount?new g(0,0):new g(Math.floor(Math.max(0,this.acc.x)/this.accCount),Math.floor(Math.max(0,this.acc.y)/this.accCount))}intersectsCount(){return this.borders?this.borders.reduce(((t,e)=>t+ +(e[0]!==Number.MAX_VALUE)),0):0}}function hd(t,e){const r=t.add(e)._unit(),n=I(t.x*r.x+t.y*r.y,-1,1);var i,a,s;return i=Math.acos(n),Math.min(4,Math.max(-4,Math.tan(i)))/4*rd*((a=t).x*(s=e).y-a.y*s.x<0?-1:1)}const pd=[t=>t.x<0,t=>t.x>Tr,t=>t.y<0,t=>t.y>Tr];function fd(t,e,r,n){const i=[4];if(0===n)return i;r._mult(n);const a=t.sub(r),s=e.sub(r),o=[t,e,a,s];for(let t=0;t<4;t++)for(const e of o)if(pd[t](e)){i.push(t);break}return i}class dd{constructor(t){this.vertexArray=new ms,this.indexArray=new Es,this.programConfigurations=new Vo(t.layers,t.zoom,(t=>td.includes(t))),this._segments=new eo,this.hiddenByLandmarkVertexArray=new Us,this._segmentToGroundQuads={},this._segmentToGroundQuads[0]=[],this._segmentToRegionTriCounts={},this._segmentToRegionTriCounts[0]=[0,0,0,0,0],this.regionSegments={},this.regionSegments[4]=new eo;}getDefaultSegment(){return this.regionSegments[4]}hasData(){return 0!==this.vertexArray.length}addData(t,e,r,n=!1){const i=t.length;if(i>2){let a=Math.max(0,this._segments.get().length-1);const s=this._segments._prepareSegment(4*i,this.vertexArray.length,2*this._segmentToGroundQuads[a].length);let o;a!==this._segments.get().length-1&&(a++,this._segmentToGroundQuads[a]=[],this._segmentToRegionTriCounts[a]=[0,0,0,0,0]);{const e=t[0],r=t[1];o=hd(e.sub(t[i-1])._perp()._unit(),r.sub(e)._perp()._unit());}for(let l=0;l<i;l++){const u=l===i-1?0:l+1,c=t[l],h=t[u],p=t[u===i-1?0:u+1],f=h.sub(c)._perp()._unit(),d=hd(f,p.sub(h)._perp()._unit()),m=o,y=d;if(vd(c,h,e)||n&&bd(c,e)&&bd(h,e)){o=d;continue}const g=s.vertexLength;sd(this.vertexArray,c,h,1,1,m),sd(this.vertexArray,c,h,1,0,m),sd(this.vertexArray,c,h,0,1,y),sd(this.vertexArray,c,h,0,0,y),s.vertexLength+=4;const x=fd(c,h,f,r);for(const t of x)this._segmentToGroundQuads[a].push({id:g,region:t}),this._segmentToRegionTriCounts[a][t]+=2,s.primitiveLength+=2;o=d;}}}prepareBorderSegments(){if(!this.hasData())return;const t=this._segments.get(),e=t.length;for(let t=0;t<e;t++)this._segmentToGroundQuads[t].sort(((t,e)=>t.region-e.region));for(let r=0;r<e;r++){const e=this._segmentToGroundQuads[r],n=t[r],i=this._segmentToRegionTriCounts[r];i.reduce(((t,e)=>t+e),0);let a=0;for(let t=0;t<=4;t++){const e=i[t];if(0!==e){let r=this.regionSegments[t];r||(r=this.regionSegments[t]=new eo);const i={vertexOffset:n.vertexOffset,primitiveOffset:n.primitiveOffset+a,vertexLength:n.vertexLength,primitiveLength:e};r.get().push(i);}a+=e;}for(let t=0;t<e.length;t++){const r=e[t].id;this.indexArray.emplaceBack(r,r+1,r+3),this.indexArray.emplaceBack(r,r+3,r+2);}}this._segmentToGroundQuads=null,this._segmentToRegionTriCounts=null,this._segments.destroy(),this._segments=null;}addPaintPropertiesData(t,e,r,n,i,a){this.hasData()&&this.programConfigurations.populatePaintArrays(this.vertexArray.length,t,e,r,n,i,a);}upload(t){this.hasData()&&(this.vertexBuffer=t.createVertexBuffer(this.vertexArray,pf.members),this.indexBuffer=t.createIndexBuffer(this.indexArray));}uploadPaintProperties(t){this.hasData()&&this.programConfigurations.upload(t);}update(t,e,r,n,i,a){this.hasData()&&this.programConfigurations.updatePaintArrays(t,e,r,n,i,a);}updateHiddenByLandmark(t){if(!this.hasData())return;const e=t.groundVertexCount+t.groundVertexArrayOffset;if(0===t.groundVertexCount)return;const r=t.flags&id?1:0;for(let n=t.groundVertexArrayOffset;n<e;++n)this.hiddenByLandmarkVertexArray.emplace(n,r);this._needsHiddenByLandmarkUpdate=!0;}uploadHiddenByLandmark(t){this.hasData()&&this._needsHiddenByLandmarkUpdate&&(!this.hiddenByLandmarkVertexBuffer&&this.hiddenByLandmarkVertexArray.length>0?this.hiddenByLandmarkVertexBuffer=t.createVertexBuffer(this.hiddenByLandmarkVertexArray,df.members,!0):this.hiddenByLandmarkVertexBuffer&&this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray),this._needsHiddenByLandmarkUpdate=!1);}destroy(){if(this.vertexBuffer){this.vertexBuffer.destroy(),this.indexBuffer.destroy(),this.hiddenByLandmarkVertexBuffer&&this.hiddenByLandmarkVertexBuffer.destroy(),this._segments&&this._segments.destroy(),this.programConfigurations.destroy();for(let t=0;t<=4;t++){const e=this.regionSegments[t];e&&e.destroy();}}}}class md{constructor(t){this.zoom=t.zoom,this.canonical=t.canonical,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.fqid)),this.index=t.index,this.hasPattern=!1,this.edgeRadius=0,this.projection=t.projection,this.activeReplacements=[],this.replacementUpdateTime=0,this.centroidData=[],this.footprintIndices=new Es,this.footprintVertices=new ps,this.footprintSegments=[],this.layoutVertexArray=new ds,this.centroidVertexArray=new Js,this.indexArray=new Es,this.programConfigurations=new Vo(t.layers,t.zoom,(t=>Qf.includes(t))),this.segments=new eo,this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.groundEffect=new dd(t),this.maxHeight=0,this.partLookup={},this.triangleSubSegments=[],this.polygonSegments=[];}populate(t,e,r,n){this.features=[],this.hasPattern=sf("fill-extrusion",this.layers,e),this.featuresOnBorder=[],this.borderFeatureIndices=[[],[],[],[]],this.borderDoneWithNeighborZ=[-1,-1,-1,-1],this.tileToMeter=wl(r),this.edgeRadius=this.layers[0].layout.get("fill-extrusion-edge-radius")/this.tileToMeter;for(const{feature:i,id:a,index:s,sourceLayerIndex:o}of t){const t=this.layers[0]._featureFilter.needGeometry,l=Bl(i,t);if(!this.layers[0]._featureFilter.filter(new Pa(this.zoom),l,r))continue;const u={id:a,sourceLayerIndex:o,index:s,geometry:t?l.geometry:Tl(i,r,n),properties:i.properties,type:i.type,patterns:{}},c=this.layoutVertexArray.length;this.hasPattern?this.features.push(of("fill-extrusion",this.layers,u,this.zoom,e)):this.addFeature(u,u.geometry,s,r,{},e.availableImages,n,e.brightness),e.featureIndex.insert(i,u.geometry,s,o,this.index,c);}this.sortBorders(),"mercator"===this.projection.name&&this.splitToSubtiles(),this.groundEffect.prepareBorderSegments(),this.polygonSegments.length=0;}addFeatures(t,e,r,n,i,a){for(const t of this.features){const{geometry:s}=t;this.addFeature(t,s,t.index,e,r,n,i,a);}this.sortBorders(),"mercator"===this.projection.name&&this.splitToSubtiles();}update(t,e,r,n,i){const a=0!==Object.keys(t).length;if(a&&!this.stateDependentLayers.length)return;const s=a?this.stateDependentLayers:this.layers;this.programConfigurations.updatePaintArrays(t,e,s,r,n,i),this.groundEffect.update(t,e,s,r,n,i);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload||this.groundEffect.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,yf),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.layoutVertexExtArray&&(this.layoutVertexExtBuffer=t.createVertexBuffer(this.layoutVertexExtArray,mf.members,!0)),this.groundEffect.upload(t)),this.groundEffect.uploadPaintProperties(t),this.programConfigurations.upload(t),this.uploaded=!0;}uploadCentroid(t){this.groundEffect.uploadHiddenByLandmark(t),this.needsCentroidUpdate&&(!this.centroidVertexBuffer&&this.centroidVertexArray.length>0?this.centroidVertexBuffer=t.createVertexBuffer(this.centroidVertexArray,ff.members,!0):this.centroidVertexBuffer&&this.centroidVertexBuffer.updateData(this.centroidVertexArray),this.needsCentroidUpdate=!1);}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.centroidVertexBuffer&&this.centroidVertexBuffer.destroy(),this.layoutVertexExtBuffer&&this.layoutVertexExtBuffer.destroy(),this.groundEffect.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());}addFeature(t,e,r,n,i,a,s,o){const l=this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t,{})/this.tileToMeter,u=[new g(0,0),new g(Tr,Tr)],c=s.projection,h="globe"===c.name,p="Polygon"===Jf[t.type],f=new cd;f.centroidDataIndex=this.centroidData.length;const d=new ud,m=this.layers[0].paint.get("fill-extrusion-base").evaluate(t,{},n)<=0,y=this.layers[0].paint.get("fill-extrusion-height").evaluate(t,{},n);d.height=y,d.vertexArrayOffset=this.layoutVertexArray.length,d.groundVertexArrayOffset=this.groundEffect.vertexArray.length,h&&!this.layoutVertexExtArray&&(this.layoutVertexExtArray=new bs);const x=nf(e,500);for(let t=x.length-1;t>=0;t--){const e=x[t];(0===e.length||(v=e[0]).every((t=>t.x<=0))||v.every((t=>t.x>=Tr))||v.every((t=>t.y<=0))||v.every((t=>t.y>=Tr)))&&x.splice(t,1);}var v;let b;if(h)b=Ad(x,u,n);else {b=[];for(const t of x)b.push({polygon:t,bounds:u});}const _=p?this.edgeRadius:0,w=_>0&&this.zoom<17,M=(t,e)=>{if(0===t.length)return !1;const r=t[t.length-1];return e.x===r.x&&e.y===r.y};for(const{polygon:t,bounds:e}of b){let r=0,i=0;for(const e of t)p&&!e[0].equals(e[e.length-1])&&e.push(e[0]),i+=p?e.length-1:e.length;const a=this.segments.prepareSegment((p?5:4)*i,this.layoutVertexArray,this.indexArray);d.footprintSegIdx<0&&(d.footprintSegIdx=this.footprintSegments.length),d.polygonSegIdx<0&&(d.polygonSegIdx=this.polygonSegments.length);const s={triangleArrayOffset:this.indexArray.length,triangleCount:0,triangleSegIdx:this.segments.segments.length-1},o=new ld;if(o.vertexOffset=this.footprintVertices.length,o.indexOffset=3*this.footprintIndices.length,o.ringIndices=[],p){const i=[],s=[];r=a.vertexLength;for(let r=0;r<t.length;r++){const u=t[r];u.length&&0!==r&&s.push(i.length/2);const p=[];let f,d;f=u[1].sub(u[0])._perp()._unit(),o.ringIndices.push(u.length-1);for(let t=1;t<u.length;t++){const e=u[t],r=u[t===u.length-1?1:t+1],s=e.clone();if(_){d=r.sub(e)._perp()._unit();const t=f.add(d)._unit(),n=_*Math.min(4,1/(f.x*t.x+f.y*t.y));s.x+=n*t.x,s.y+=n*t.y,s.x=Math.round(s.x),s.y=Math.round(s.y),f=d;}!m||0!==_&&!w||M(p,s)||p.push(s),ad(this.layoutVertexArray,s.x,s.y,0,0,1,1,0),a.vertexLength++,this.footprintVertices.emplaceBack(e.x,e.y),i.push(e.x,e.y),h&&od(this.layoutVertexExtArray,c.projectTilePoint(s.x,s.y,n),c.upVector(n,s.x,s.y));}m&&(0===_||w)&&(0!==p.length&&M(p,p[0])&&p.pop(),this.groundEffect.addData(p,e,l));}const u=rf(i,s);for(let t=0;t<u.length;t+=3)this.footprintIndices.emplaceBack(o.vertexOffset+u[t+0],o.vertexOffset+u[t+1],o.vertexOffset+u[t+2]),this.indexArray.emplaceBack(r+u[t],r+u[t+2],r+u[t+1]),a.primitiveLength++;o.indexCount+=u.length,o.vertexCount+=this.footprintVertices.length-o.vertexOffset;}for(let i=0;i<t.length;i++){const s=t[i];f.startRing(d,s[0]);let o=s.length>4&&_d(s[s.length-2],s[0],s[1]),u=_?gd(s[s.length-2],s[0],s[1],_):0;const y=[];let g,x,v;x=s[1].sub(s[0])._perp()._unit();let b=!0;for(let t=1,i=0;t<s.length;t++){let l=s[t-1],p=s[t];const w=s[t===s.length-1?1:t+1];if(f.appendEdge(d,p,l),vd(p,l,e)){_&&(x=w.sub(p)._perp()._unit(),b=!b);continue}const A=p.sub(l)._perp(),S=A.x/(Math.abs(A.x)+Math.abs(A.y)),I=A.y>0?1:0,k=l.dist(p);if(i+k>32768&&(i=0),_){v=w.sub(p)._perp()._unit();let t=xd(l,p,w,yd(x,v),_);isNaN(t)&&(t=0);const e=p.sub(l)._unit();l=l.add(e.mult(u))._round(),p=p.add(e.mult(-t))._round(),u=t,x=v,m&&this.zoom>=17&&(M(y,l)||y.push(l),M(y,p)||y.push(p));}const P=a.vertexLength,E=s.length>4&&_d(l,p,w);let z=wd(i,o,b);if(ad(this.layoutVertexArray,l.x,l.y,S,I,0,0,z),ad(this.layoutVertexArray,l.x,l.y,S,I,0,1,z),i+=k,z=wd(i,E,!b),o=E,ad(this.layoutVertexArray,p.x,p.y,S,I,0,0,z),ad(this.layoutVertexArray,p.x,p.y,S,I,0,1,z),a.vertexLength+=4,this.indexArray.emplaceBack(P+0,P+1,P+2),this.indexArray.emplaceBack(P+1,P+3,P+2),a.primitiveLength+=2,_){const n=r+(1===t?s.length-2:t-2),i=1===t?r:n+1;if(this.indexArray.emplaceBack(P+1,n,P+3),this.indexArray.emplaceBack(n,i,P+3),a.primitiveLength+=2,void 0===g&&(g=P),!vd(w,s[t],e)){const e=t===s.length-1?g:a.vertexLength;this.indexArray.emplaceBack(P+2,P+3,e),this.indexArray.emplaceBack(P+3,e+1,e),this.indexArray.emplaceBack(P+3,i,e+1),a.primitiveLength+=3;}b=!b;}if(h){const t=this.layoutVertexExtArray,e=c.projectTilePoint(l.x,l.y,n),r=c.projectTilePoint(p.x,p.y,n),i=c.upVector(n,l.x,l.y),a=c.upVector(n,p.x,p.y);od(t,e,i),od(t,e,i),od(t,r,a),od(t,r,a);}}p&&(r+=s.length-1),m&&_&&this.zoom>=17&&(0!==y.length&&M(y,y[0])&&y.pop(),this.groundEffect.addData(y,e,l,_>0));}this.footprintSegments.push(o),s.triangleCount=this.indexArray.length-s.triangleArrayOffset,this.polygonSegments.push(s),++d.footprintSegLen,++d.polygonSegLen;}if(d.vertexCount=this.layoutVertexArray.length-d.vertexArrayOffset,d.groundVertexCount=this.groundEffect.vertexArray.length-d.groundVertexArrayOffset,0!==d.vertexCount){if(d.centroidXY=f.borders?nd:this.encodeCentroid(f,d),this.centroidData.push(d),f.borders){this.featuresOnBorder.push(f);const t=this.featuresOnBorder.length-1;for(let e=0;e<f.borders.length;e++)f.borders[e][0]!==Number.MAX_VALUE&&this.borderFeatureIndices[e].push(t);}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,a,n,o),this.groundEffect.addPaintPropertiesData(t,r,i,a,n,o),this.maxHeight=Math.max(this.maxHeight,y);}}sortBorders(){for(let t=0;t<this.borderFeatureIndices.length;t++)this.borderFeatureIndices[t].sort(((e,r)=>this.featuresOnBorder[e].borders[t][0]-this.featuresOnBorder[r].borders[t][0]));}splitToSubtiles(){const t=[];for(let e=0;e<this.centroidData.length;e++){const r=this.centroidData[e],n=+(r.min.y+r.max.y>Tr),i=2*n+(+(r.min.x+r.max.x>Tr)^n);for(let n=0;n<r.polygonSegLen;n++){const a=r.polygonSegIdx+n;t.push({centroidIdx:e,subtile:i,polygonSegmentIdx:a,triangleSegmentIdx:this.polygonSegments[a].triangleSegIdx});}}const e=new Es;t.sort(((t,e)=>t.triangleSegmentIdx===e.triangleSegmentIdx?t.subtile-e.subtile:t.triangleSegmentIdx-e.triangleSegmentIdx));let r=0,n=0,i=0;for(const e of t){if(e.triangleSegmentIdx!==r)break;i++;}const a=t.length;for(;n!==t.length;){r=t[n].triangleSegmentIdx;let s=0,o=n,l=n;for(let e=o;e<i&&t[e].subtile===s;e++)l++;for(;o!==i;){const n=t[o];s=n.subtile;const a=this.centroidData[n.centroidIdx].min.clone(),u=this.centroidData[n.centroidIdx].max.clone(),c={vertexOffset:this.segments.segments[r].vertexOffset,primitiveOffset:e.length,vertexLength:this.segments.segments[r].vertexLength,primitiveLength:0,sortKey:void 0,vaos:{}};for(let r=o;r<l;r++){const n=t[r],i=this.polygonSegments[n.polygonSegmentIdx],s=this.centroidData[n.centroidIdx].min,o=this.centroidData[n.centroidIdx].max,l=this.indexArray.uint16;for(let t=i.triangleArrayOffset;t<i.triangleArrayOffset+i.triangleCount;t++)e.emplaceBack(l[3*t],l[3*t+1],l[3*t+2]);c.primitiveLength+=i.triangleCount,a.x=Math.min(a.x,s.x),a.y=Math.min(a.y,s.y),u.x=Math.max(u.x,o.x),u.y=Math.max(u.y,o.y);}c.primitiveLength>0&&this.triangleSubSegments.push({segment:c,min:a,max:u}),o=l;for(let e=o;e<i&&t[e].subtile===t[o].subtile;e++)l++;}n=i;for(let e=n;e<a&&t[e].triangleSegmentIdx===t[n].triangleSegmentIdx;e++)i++;}e._trim(),this.indexArray=e;}getVisibleSegments(t,e,r){let n=0,i=0;const a=1<<t.canonical.z;if(e){const r=e.getMinMaxForTile(t);r&&(n=r.min,i=r.max);}i+=this.maxHeight;const s=t.toUnwrapped();let o;const l=[s.canonical.x/a+s.wrap,s.canonical.y/a],u=[(s.canonical.x+1)/a+s.wrap,(s.canonical.y+1)/a],c=new eo,h=(t,e,r)=>[t[0]*(1-r[0])+e[0]*r[0],t[1]*(1-r[1])+e[1]*r[1]],p=[],f=[];for(const t of this.triangleSubSegments){p[0]=t.min.x/Tr,p[1]=t.min.y/Tr,f[0]=t.max.x/Tr,f[1]=t.max.y/Tr;const e=h(l,u,p),a=h(l,u,f);if(0===new Bh([e[0],e[1],n],[a[0],a[1],i]).intersectsPrecise(r)){o&&(c.segments.push(o),o=void 0);continue}const s=t.segment;o&&o.vertexOffset!==s.vertexOffset&&(c.segments.push(o),o=void 0),o?(o.vertexLength+=s.vertexLength,o.primitiveLength+=s.primitiveLength):o={vertexOffset:s.vertexOffset,primitiveLength:s.primitiveLength,vertexLength:s.vertexLength,primitiveOffset:s.primitiveOffset,sortKey:void 0,vaos:{}};}return o&&c.segments.push(o),c}encodeCentroid(t,e){const r=t.centroid(),n=e.span(),i=Math.min(7,Math.round(n.x*this.tileToMeter/10)),a=Math.min(7,Math.round(n.y*this.tileToMeter/10));return new g(I(r.x,1,Tr-1)<<3|i,I(r.y,1,Tr-1)<<3|a)}encodeBorderCentroid(t){if(!t.borders)return new g(0,0);const e=t.borders,r=Number.MAX_VALUE;if(e[0][0]!==r||e[1][0]!==r){const t=e[0][0]!==r?0:1;return new g(6|(e[0][0]!==r?0:65528),(e[t][0]+e[t][1])/2<<3|6)}{const t=e[2][0]!==r?2:3;return new g((e[t][0]+e[t][1])/2<<3|6,6|(e[2][0]!==r?0:65528))}}showCentroid(t){const e=this.centroidData[t.centroidDataIndex];e.flags&=id,e.centroidXY.x=0,e.centroidXY.y=0,this.writeCentroidToBuffer(e);}writeCentroidToBuffer(t){this.groundEffect.updateHiddenByLandmark(t);const e=t.vertexArrayOffset,r=t.vertexCount+t.vertexArrayOffset,n=t.flags&id?nd:t.centroidXY,i=this.centroidVertexArray.geta_centroid_pos0(e);if(this.centroidVertexArray.geta_centroid_pos1(e)!==n.y||i!==n.x){for(let t=e;t<r;++t)this.centroidVertexArray.emplace(t,n.x,n.y);this.needsCentroidUpdate=!0;}}createCentroidsBuffer(){this.centroidVertexArray.resize(this.layoutVertexArray.length),this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);for(const t of this.centroidData)this.writeCentroidToBuffer(t);}updateReplacement(t,e){if(e.updateTime===this.replacementUpdateTime)return;this.replacementUpdateTime=e.updateTime;const r=e.getReplacementRegionsForTile(t.toUnwrapped());if(function(t,e){if(t.length!==e.length)return !1;for(let r=0;r<t.length;r++)if(t[r].sourceId!==e[r].sourceId||!Cf(t[r],e[r]))return !1;return !0}(this.activeReplacements,r))return;if(this.activeReplacements=r,0===this.centroidVertexArray.length)this.createCentroidsBuffer();else for(const t of this.centroidData)t.flags&=2147483647;const n=[];for(const e of this.activeReplacements){const r=Math.pow(2,e.footprintTileId.canonical.z-t.canonical.z);for(const i of this.centroidData)if(!(i.flags&id||e.min.x>i.max.x||i.min.x>e.max.x||e.min.y>i.max.y||i.min.y>e.max.y))for(let a=0;a<i.footprintSegLen;a++){const s=this.footprintSegments[i.footprintSegIdx+a];if(n.length=0,Sd(this.footprintVertices,s.vertexOffset,s.vertexCount,e.footprintTileId.canonical,t.canonical,n),Lf(e.footprint,n,this.footprintIndices.uint16,s.indexOffset,s.indexCount,-s.vertexOffset,-r)){i.flags|=id;break}}}for(const t of this.centroidData)this.writeCentroidToBuffer(t);this.borderDoneWithNeighborZ=[-1,-1,-1,-1];}footprintContainsPoint(t,e,r){let n=!1;for(let i=0;i<r.footprintSegLen;i++){const a=this.footprintSegments[r.footprintSegIdx+i];let s=0;for(const r of a.ringIndices){for(let i=s,o=r+s-1;i<r+s;o=i++){const r=this.footprintVertices.int16[2*(i+a.vertexOffset)+0],s=this.footprintVertices.int16[2*(i+a.vertexOffset)+1],l=this.footprintVertices.int16[2*(o+a.vertexOffset)+1];s>e!=l>e&&t<(this.footprintVertices.int16[2*(o+a.vertexOffset)+0]-r)*(e-s)/(l-s)+r&&(n=!n);}s=r;}}return n}getHeightAtTileCoord(t,e){let r=Number.NEGATIVE_INFINITY,n=!0;const i=4*(t+Tr)*Tr+(e+Tr);if(this.partLookup.hasOwnProperty(i)){const t=this.partLookup[i];return t?{height:t.height,hidden:!!(t.flags&id)}:void 0}for(const a of this.centroidData)t>a.max.x||a.min.x>t||e>a.max.y||a.min.y>e||this.footprintContainsPoint(t,e,a)&&a&&a.height>r&&(r=a.height,this.partLookup[i]=a,n=!!(a.flags&id));if(r!==Number.NEGATIVE_INFINITY)return {height:r,hidden:n};this.partLookup[i]=void 0;}}function yd(t,e){const r=t.add(e)._unit();return t.x*r.x+t.y*r.y}function gd(t,e,r,n){const i=e.sub(t)._perp()._unit(),a=r.sub(e)._perp()._unit();return xd(t,e,r,yd(i,a),n)}function xd(t,e,r,n,i){const a=Math.sqrt(1-n*n);return Math.min(t.dist(e)/3,e.dist(r)/3,i*a/n)}function vd(t,e,r){return t.x<r[0].x&&e.x<r[0].x||t.x>r[1].x&&e.x>r[1].x||t.y<r[0].y&&e.y<r[0].y||t.y>r[1].y&&e.y>r[1].y}function bd(t,e){return t.x<e[0].x||t.x>e[1].x||t.y<e[0].y||t.y>e[1].y}function _d(t,e,r){if(t.x<0||t.x>=Tr||e.x<0||e.x>=Tr||r.x<0||r.x>=Tr)return !1;const n=r.sub(e),i=n.perp(),a=t.sub(e);return (n.x*a.x+n.y*a.y)/Math.sqrt((n.x*n.x+n.y*n.y)*(a.x*a.x+a.y*a.y))>-.866&&i.x*a.x+i.y*a.y<0}function wd(t,e,r){const n=e?2|t:-3&t;return r?1|n:-2&n}function Md(){const t=Math.PI/32,e=Math.tan(t),r=Jo;return r*Math.sqrt(1+2*e*e)-r}function Ad(t,e,r){const n=1<<r.z,i=ml(r.x/n),a=ml((r.x+1)/n),s=yl(r.y/n),o=yl((r.y+1)/n);return function(t,e,r,n,i=0,a){const s=[];if(!t.length||!r||!n)return s;const o=(t,e)=>{for(const r of t)s.push({polygon:r,bounds:e});},l=Math.ceil(Math.log2(r)),u=Math.ceil(Math.log2(n)),c=l-u,h=[];for(let t=0;t<Math.abs(c);t++)h.push(c>0?0:1);for(let t=0;t<Math.min(l,u);t++)h.push(0),h.push(1);let p=t;if(p=Tf(p,e[0].y-i,e[1].y+i,1),p=Tf(p,e[0].x-i,e[1].x+i,0),!p.length)return s;const f=[];for(h.length?f.push({polygons:p,bounds:e,depth:0}):o(p,e);f.length;){const t=f.pop(),e=t.depth,r=h[e],n=t.bounds[0],s=t.bounds[1],l=0===r?n.x:n.y,u=0===r?s.x:s.y,c=a?a(r,l,u):.5*(l+u),p=Tf(t.polygons,l-i,c+i,r),d=Tf(t.polygons,c-i,u+i,r);if(p.length){const t=[n,new g(0===r?c:s.x,1===r?c:s.y)];h.length>e+1?f.push({polygons:p,bounds:t,depth:e+1}):o(p,t);}if(d.length){const t=[new g(0===r?c:n.x,1===r?c:n.y),s];h.length>e+1?f.push({polygons:d,bounds:t,depth:e+1}):o(d,t);}}return s}(t,e,Math.ceil((a-i)/11.25),Math.ceil((s-o)/11.25),1,((t,e,i)=>{if(0===t)return .5*(e+i);{const t=yl((r.y+e/Tr)/n);return (fl(.5*(yl((r.y+i/Tr)/n)+t))*n-r.y)*Tr}}))}function Sd(t,e,r,n,i,a){const s=Math.pow(2,n.z-i.z);for(let o=0;o<r;o++){let r=t.int16[2*(o+e)+0],l=t.int16[2*(o+e)+1];r=(r+i.x*Tr)*s-n.x*Tr,l=(l+i.y*Tr)*s-n.y*Tr,a.push(new g(r,l));}}ra(md,"FillExtrusionBucket",{omit:["layers","features"]}),ra(ud,"PartData"),ra(ld,"FootprintSegment"),ra(cd,"BorderCentroidData"),ra(dd,"GroundEffect");const Id=new Oa({visibility:new La(qa["layout_fill-extrusion"].visibility),"fill-extrusion-edge-radius":new La(qa["layout_fill-extrusion"]["fill-extrusion-edge-radius"])});var kd={paint:new Oa({"fill-extrusion-opacity":new La(qa["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new Fa(qa["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new La(qa["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new La(qa["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new Fa(qa["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new Fa(qa["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new Fa(qa["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new La(qa["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),"fill-extrusion-ambient-occlusion-intensity":new La(qa["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),"fill-extrusion-ambient-occlusion-radius":new La(qa["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),"fill-extrusion-ambient-occlusion-wall-radius":new La(qa["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),"fill-extrusion-ambient-occlusion-ground-radius":new La(qa["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),"fill-extrusion-ambient-occlusion-ground-attenuation":new La(qa["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),"fill-extrusion-flood-light-color":new La(qa["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),"fill-extrusion-flood-light-intensity":new La(qa["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),"fill-extrusion-flood-light-wall-radius":new Fa(qa["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),"fill-extrusion-flood-light-ground-radius":new Fa(qa["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),"fill-extrusion-flood-light-ground-attenuation":new La(qa["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),"fill-extrusion-vertical-scale":new La(qa["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),"fill-extrusion-rounded-roof":new La(qa["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),"fill-extrusion-cutoff-fade-range":new La(qa["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),"fill-extrusion-emissive-strength":new La(qa["paint_fill-extrusion"]["fill-extrusion-emissive-strength"])}),layout:Id};class Pd extends g{constructor(t,e,r){super(t,e),this.z=r;}}function Ed(t,e){return t.x*e.x+t.y*e.y}function zd(t,e){if(1===t.length){let r=0;const n=e[r++];let i;for(;!i||n.equals(i);)if(i=e[r++],!i)return 1/0;for(;r<e.length;r++){const a=e[r],s=t[0],o=i.sub(n),l=a.sub(n),u=s.sub(n),c=Ed(o,o),h=Ed(o,l),p=Ed(l,l),f=Ed(u,o),d=Ed(u,l),m=c*p-h*h,y=(p*f-h*d)/m,g=(c*d-h*f)/m,x=n.z*(1-y-g)+i.z*y+a.z*g;if(isFinite(x))return x}return 1/0}{let t=1/0;for(const r of e)t=Math.min(t,r.z);return t}}function Td(t,e,r,n,i,a,s,o){const l=s*i.getElevationAt(t,e,!0,!0),u=0!==a[0],c=u?0===a[1]?s*(a[0]/7-450):s*function(t,e,r){const n=Math.floor(e[0]/8),i=Math.floor(e[1]/8),a=10*(e[0]-8*n),s=10*(e[1]-8*i),o=t.getElevationAt(n,i,!0,!0),l=t.getMeterToDEM(r),u=Math.floor(.5*(a*l-1)),c=Math.floor(.5*(s*l-1)),h=t.tileCoordToPixel(n,i),p=2*u+1,f=2*c+1,d=function(t,e,r,n,i){return [t.getElevationAtPixel(e,r,!0),t.getElevationAtPixel(e+i,r,!0),t.getElevationAtPixel(e,r+i,!0),t.getElevationAtPixel(e+n,r+i,!0)]}(t,h.x-u,h.y-c,p,f),m=Math.abs(d[0]-d[1]),y=Math.abs(d[2]-d[3]),g=Math.abs(d[0]-d[2])+Math.abs(d[1]-d[3]),x=Math.min(.25,.5*l*(m+y)/p),v=Math.min(.25,.5*l*g/f);return o+Math.max(x*a,v*s)}(i,a,o):l;return {base:l+(0===r)?-1:r,top:u?Math.max(c+n,l+r+2):l+n}}const Bd=cs([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"},{name:"a_linesofar",components:1,type:"Float32"}],4),{members:Cd}=Bd,Rd=cs([{name:"a_packed",components:4,type:"Float32"}]),{members:Dd}=Rd;class Vd{constructor(t,e){this.width=t,this.height=e,this.nextRow=0,this.image=new vp({width:t,height:e}),this.positions={},this.uploaded=!1;}getDash(t,e){const r=this.getKey(t,e);return this.positions[r]}trim(){const t=this.width,e=this.height=R(this.nextRow);this.image.resize({width:t,height:e});}getKey(t,e){return t.join(",")+e}getDashRanges(t,e,r){const n=[];let i=t.length%2==1?-t[t.length-1]*r:0,a=t[0]*r,s=!0;n.push({left:i,right:a,isDash:s,zeroLength:0===t[0]});let o=t[0];for(let e=1;e<t.length;e++){s=!s;const l=t[e];i=o*r,o+=l,a=o*r,n.push({left:i,right:a,isDash:s,zeroLength:0===l});}return n}addRoundDash(t,e,r){const n=e/2;for(let e=-r;e<=r;e++){const i=this.width*(this.nextRow+r+e);let a=0,s=t[a];for(let o=0;o<this.width;o++){o/s.right>1&&(s=t[++a]);const l=Math.abs(o-s.left),u=Math.abs(o-s.right),c=Math.min(l,u);let h;const p=e/r*(n+1);if(s.isDash){const t=n-Math.abs(p);h=Math.sqrt(c*c+t*t);}else h=n-Math.sqrt(c*c+p*p);this.image.data[i+o]=Math.max(0,Math.min(255,h+128));}}}addRegularDash(t,e){for(let e=t.length-1;e>=0;--e){const r=t[e],n=t[e+1];r.zeroLength?t.splice(e,1):n&&n.isDash===r.isDash&&(n.left=r.left,t.splice(e,1));}const r=t[0],n=t[t.length-1];r.isDash===n.isDash&&(r.left=n.left-this.width,n.right=r.right+this.width);const i=this.width*this.nextRow;let a=0,s=t[a];for(let r=0;r<this.width;r++){r/s.right>1&&(s=t[++a]);const n=Math.abs(r-s.left),o=Math.abs(r-s.right),l=Math.min(n,o);this.image.data[i+r]=Math.max(0,Math.min(255,(s.isDash?l:-l)+e+128));}}addDash(t,e){const r=this.getKey(t,e);if(this.positions[r])return this.positions[r];const n="round"===e,i=n?7:0,a=2*i+1;if(this.nextRow+a>this.height)return j("LineAtlas out of space"),null;0===t.length&&t.push(1);let s=0;for(let e=0;e<t.length;e++)t[e]<0&&(j("Negative value is found in line dasharray, replacing values with 0"),t[e]=0),s+=t[e];if(0!==s){const r=this.width/s,a=this.getDashRanges(t,this.width,r);n?this.addRoundDash(a,r,i):this.addRegularDash(a,"square"===e?.5*r:0);}const o=this.nextRow+i;this.nextRow+=a;const l={tl:[o,i],br:[s,0]};return this.positions[r]=l,l}}ra(Vd,"LineAtlas");const Ld=zf.types,Fd=Math.cos(Math.PI/180*37.5);class Nd{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.fqid)),this.index=t.index,this.projection=t.projection,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach((t=>{this.gradients[t.id]={};})),this.layoutVertexArray=new ys,this.layoutVertexArray2=new gs,this.indexArray=new Es,this.programConfigurations=new Vo(t.layers,t.zoom),this.segments=new eo,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id));}populate(t,e,r,n){this.hasPattern=sf("line",this.layers,e);const i=this.layers[0].layout.get("line-sort-key"),a=[];for(const{feature:e,id:s,index:o,sourceLayerIndex:l}of t){const t=this.layers[0]._featureFilter.needGeometry,u=Bl(e,t);if(!this.layers[0]._featureFilter.filter(new Pa(this.zoom),u,r))continue;const c=i?i.evaluate(u,{},r):void 0,h={id:s,properties:e.properties,type:e.type,sourceLayerIndex:l,index:o,geometry:t?u.geometry:Tl(e,r,n),patterns:{},sortKey:c};a.push(h);}i&&a.sort(((t,e)=>t.sortKey-e.sortKey));const{lineAtlas:s,featureIndex:o}=e,l=this.addConstantDashes(s);for(const n of a){const{geometry:i,index:a,sourceLayerIndex:u}=n;if(l&&this.addFeatureDashes(n,s),this.hasPattern){const t=of("line",this.layers,n,this.zoom,e);this.patternFeatures.push(t);}else this.addFeature(n,i,a,r,s.positions,e.availableImages,e.brightness);o.insert(t[a].feature,i,a,u,this.index);}}addConstantDashes(t){let e=!1;for(const r of this.layers){const n=r.paint.get("line-dasharray").value,i=r.layout.get("line-cap").value;if("constant"!==n.kind||"constant"!==i.kind)e=!0;else {const e=i.value,r=n.value;if(!r)continue;t.addDash(r,e);}}return e}addFeatureDashes(t,e){const r=this.zoom;for(const n of this.layers){const i=n.paint.get("line-dasharray").value,a=n.layout.get("line-cap").value;if("constant"===i.kind&&"constant"===a.kind)continue;let s,o;if("constant"===i.kind){if(s=i.value,!s)continue}else s=i.evaluate({zoom:r},t);o="constant"===a.kind?a.value:a.evaluate({zoom:r},t),e.addDash(s,o),t.patterns[n.id]=e.getKey(s,o);}}update(t,e,r,n,i){const a=0!==Object.keys(t).length;a&&!this.stateDependentLayers.length||this.programConfigurations.updatePaintArrays(t,e,a?this.stateDependentLayers:this.layers,r,n,i);}addFeatures(t,e,r,n,i,a){for(const t of this.patternFeatures)this.addFeature(t,t.geometry,t.index,e,r,n,a);}isEmpty(){return 0===this.layoutVertexArray.length}uploadPending(){return !this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(0!==this.layoutVertexArray2.length&&(this.layoutVertexBuffer2=t.createVertexBuffer(this.layoutVertexArray2,Dd)),this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Cd),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0;}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy());}lineFeatureClips(t){if(t.properties&&t.properties.hasOwnProperty("mapbox_clip_start")&&t.properties.hasOwnProperty("mapbox_clip_end"))return {start:+t.properties.mapbox_clip_start,end:+t.properties.mapbox_clip_end}}addFeature(t,e,r,n,i,a,s){const o=this.layers[0].layout,l=o.get("line-join").evaluate(t,{}),u=o.get("line-cap").evaluate(t,{}),c=o.get("line-miter-limit"),h=o.get("line-round-limit");this.lineClips=this.lineFeatureClips(t);for(const r of e)this.addLine(r,t,l,u,c,h);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,r,i,a,n,s);}addLine(t,e,r,n,i,a){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineSoFar=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(let e=0;e<t.length-1;e++)this.totalDistance+=t[e].dist(t[e+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance);}const s="Polygon"===Ld[e.type];let o=t.length;for(;o>=2&&t[o-1].equals(t[o-2]);)o--;let l=0;for(;l<o-1&&t[l].equals(t[l+1]);)l++;if(o<(s?3:2))return;"bevel"===r&&(i=1.05);const u=this.overscaling<=16?15*Tr/(512*this.overscaling):0,c=this.segments.prepareSegment(10*o,this.layoutVertexArray,this.indexArray);let h,p,f,d,m;this.e1=this.e2=-1,s&&(h=t[o-2],m=t[l].sub(h)._unit()._perp());for(let e=l;e<o;e++){if(f=e===o-1?s?t[l+1]:void 0:t[e+1],f&&t[e].equals(f))continue;m&&(d=m),h&&(p=h),h=t[e],m=f?f.sub(h)._unit()._perp():d,d=d||m;let y=d.add(m);0===y.x&&0===y.y||y._unit();const g=d.x*m.x+d.y*m.y,x=y.x*m.x+y.y*m.y,v=0!==x?1/x:1/0,b=2*Math.sqrt(2-2*x),_=x<Fd&&p&&f,w=d.x*m.y-d.y*m.x>0;if(_&&e>l){const t=h.dist(p);if(t>2*u){const e=h.sub(h.sub(p)._mult(u/t)._round());this.updateDistance(p,e),this.addCurrentVertex(e,d,0,0,c),p=e;}}const M=p&&f;let A=M?r:s?"butt":n;if(M&&"round"===A&&(v<a?A="miter":v<=2&&(A="fakeround")),"miter"===A&&v>i&&(A="bevel"),"bevel"===A&&(v>2&&(A="flipbevel"),v<i&&(A="miter")),p&&this.updateDistance(p,h),"miter"===A)y._mult(v),this.addCurrentVertex(h,y,0,0,c);else if("flipbevel"===A){if(v>100)y=m.mult(-1);else {const t=v*d.add(m).mag()/d.sub(m).mag();y._perp()._mult(t*(w?-1:1));}this.addCurrentVertex(h,y,0,0,c),this.addCurrentVertex(h,y.mult(-1),0,0,c);}else if("bevel"===A||"fakeround"===A){const t=-Math.sqrt(v*v-1),e=w?t:0,r=w?0:t;if(p&&this.addCurrentVertex(h,d,e,r,c),"fakeround"===A){const t=Math.round(180*b/Math.PI/20);for(let e=1;e<t;e++){let r=e/t;if(.5!==r){const t=r-.5;r+=r*t*(r-1)*((1.0904+g*(g*(3.55645-1.43519*g)-3.2452))*t*t+(.848013+g*(.215638*g-1.06021)));}const n=m.sub(d)._mult(r)._add(d)._unit()._mult(w?-1:1);this.addHalfVertex(h,n.x,n.y,!1,w,0,c);}}f&&this.addCurrentVertex(h,m,-e,-r,c);}else if("butt"===A)this.addCurrentVertex(h,y,0,0,c);else if("square"===A){const t=p?1:-1;p||this.addCurrentVertex(h,y,t,t,c),this.addCurrentVertex(h,y,0,0,c),p&&this.addCurrentVertex(h,y,t,t,c);}else "round"===A&&(p&&(this.addCurrentVertex(h,d,0,0,c),this.addCurrentVertex(h,d,1,1,c,!0)),f&&(this.addCurrentVertex(h,m,-1,-1,c,!0),this.addCurrentVertex(h,m,0,0,c)));if(_&&e<o-1){const t=h.dist(f);if(t>2*u){const e=h.add(f.sub(h)._mult(u/t)._round());this.updateDistance(h,e),this.addCurrentVertex(e,m,0,0,c),h=e;}}}}addCurrentVertex(t,e,r,n,i,a=!1){const s=e.y*n-e.x,o=-e.y-e.x*n;this.addHalfVertex(t,e.x+e.y*r,e.y-e.x*r,a,!1,r,i),this.addHalfVertex(t,s,o,a,!0,-n,i);}addHalfVertex({x:t,y:e},r,n,i,a,s,o){this.layoutVertexArray.emplaceBack((t<<1)+(i?1:0),(e<<1)+(a?1:0),Math.round(63*r)+128,Math.round(63*n)+128,1+(0===s?0:s<0?-1:1),0,this.lineSoFar),this.lineClips&&this.layoutVertexArray2.emplaceBack(this.scaledDistance,this.lineClipsArray.length,this.lineClips.start,this.lineClips.end);const l=o.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,l),o.primitiveLength++),a?this.e2=l:this.e1=l;}updateScaledDistance(){if(this.lineClips){const t=this.totalDistance/(this.lineClips.end-this.lineClips.start);this.scaledDistance=this.distance/this.totalDistance,this.lineSoFar=t*this.lineClips.start+this.distance;}else this.lineSoFar=this.distance;}updateDistance(t,e){this.distance+=t.dist(e),this.updateScaledDistance();}}ra(Nd,"LineBucket",{omit:["layers","patternFeatures"]});const Od=new Oa({"line-cap":new Fa(qa.layout_line["line-cap"]),"line-join":new Fa(qa.layout_line["line-join"]),"line-miter-limit":new La(qa.layout_line["line-miter-limit"]),"line-round-limit":new La(qa.layout_line["line-round-limit"]),"line-sort-key":new Fa(qa.layout_line["line-sort-key"]),visibility:new La(qa.layout_line.visibility)});var Ud={paint:new Oa({"line-opacity":new Fa(qa.paint_line["line-opacity"]),"line-color":new Fa(qa.paint_line["line-color"]),"line-translate":new La(qa.paint_line["line-translate"]),"line-translate-anchor":new La(qa.paint_line["line-translate-anchor"]),"line-width":new Fa(qa.paint_line["line-width"]),"line-gap-width":new Fa(qa.paint_line["line-gap-width"]),"line-offset":new Fa(qa.paint_line["line-offset"]),"line-blur":new Fa(qa.paint_line["line-blur"]),"line-dasharray":new Fa(qa.paint_line["line-dasharray"]),"line-pattern":new Fa(qa.paint_line["line-pattern"]),"line-gradient":new Na(qa.paint_line["line-gradient"]),"line-trim-offset":new La(qa.paint_line["line-trim-offset"]),"line-emissive-strength":new La(qa.paint_line["line-emissive-strength"]),"line-border-width":new Fa(qa.paint_line["line-border-width"]),"line-border-color":new Fa(qa.paint_line["line-border-color"])}),layout:Od};function jd(t,e,r){return e*(Tr/(t.tileSize*Math.pow(2,r-t.tileID.overscaledZ)))}function qd(t,e){return 1/jd(t,1,e.tileZoom)}function $d(t,e,r,n){return t.translatePosMatrix(n||e.tileID.projMatrix,e,r.paint.get("line-translate"),r.paint.get("line-translate-anchor"))}const Gd=t=>{const e=[];Yd(t)&&e.push("RENDER_LINE_DASH"),t.paint.get("line-gradient")&&e.push("RENDER_LINE_GRADIENT");const r=t.paint.get("line-trim-offset");return 0===r[0]&&0===r[1]||e.push("RENDER_LINE_TRIM_OFFSET"),0!==t.paint.get("line-border-width").constantOr(1)&&e.push("RENDER_LINE_BORDER"),e};function Yd(t){const e=t.paint.get("line-dasharray").value;return e.value||"constant"!==e.kind}const Xd=new class extends Fa{possiblyEvaluate(t,e){return e=new Pa(Math.floor(e.zoom),{now:e.now,fadeDuration:e.fadeDuration,transition:e.transition}),super.possiblyEvaluate(t,e)}evaluate(t,e,r,n){return e=z({},e,{zoom:Math.floor(e.zoom)}),super.evaluate(t,e,r,n)}}(Ud.paint.properties["line-width"].specification);function Zd(t,e){return e>0?e+2*t:t}Xd.useIntegerZoom=!0;const Kd=cs([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_tex_size",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),Hd=cs([{name:"a_globe_anchor",components:3,type:"Int16"},{name:"a_globe_normal",components:3,type:"Float32"}],4),Wd=cs([{name:"a_projected_pos",components:4,type:"Float32"}],4);cs([{name:"a_fade_opacity",components:1,type:"Uint32"}],4);const Jd=cs([{name:"a_z_offset",components:1,type:"Float32"}],4),Qd=cs([{name:"a_texb",components:2,type:"Uint16"}]),tm=cs([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}]),em=cs([{name:"a_size_scale",components:1,type:"Float32"},{name:"a_padding",components:2,type:"Float32"},{name:"a_z_offset",components:1,type:"Float32"}]);cs([{type:"Int16",name:"projectedAnchorX"},{type:"Int16",name:"projectedAnchorY"},{type:"Int16",name:"projectedAnchorZ"},{type:"Int16",name:"tileAnchorX"},{type:"Int16",name:"tileAnchorY"},{type:"Float32",name:"x1"},{type:"Float32",name:"y1"},{type:"Float32",name:"x2"},{type:"Float32",name:"y2"},{type:"Int16",name:"padding"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]);const rm=cs([{name:"a_pos",components:3,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),nm=cs([{name:"a_pos_2f",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4);cs([{name:"triangle",components:3,type:"Uint16"}]),cs([{type:"Int16",name:"projectedAnchorX"},{type:"Int16",name:"projectedAnchorY"},{type:"Int16",name:"projectedAnchorZ"},{type:"Float32",name:"tileAnchorX"},{type:"Float32",name:"tileAnchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"},{type:"Uint8",name:"flipState"}]),cs([{type:"Float32",name:"tileAnchorX"},{type:"Float32",name:"tileAnchorY"},{type:"Int16",name:"projectedAnchorX"},{type:"Int16",name:"projectedAnchorY"},{type:"Int16",name:"projectedAnchorZ"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",components:2,name:"textOffset"},{type:"Float32",name:"collisionCircleDiameter"},{type:"Float32",name:"zOffset"},{type:"Uint8",name:"hasIconTextFit"}]),cs([{type:"Float32",name:"offsetX"}]),cs([{type:"Int16",name:"x"},{type:"Int16",name:"y"}]);var im=24;const am=128;function sm(t,e){const{expression:r}=e;if("constant"===r.kind)return {kind:"constant",layoutSize:r.evaluate(new Pa(t+1))};if("source"===r.kind)return {kind:"source"};{const{zoomStops:e,interpolationType:n}=r;let i=0;for(;i<e.length&&e[i]<=t;)i++;i=Math.max(0,i-1);let a=i;for(;a<e.length&&e[a]<t+1;)a++;a=Math.min(e.length-1,a);const s=e[i],o=e[a];return "composite"===r.kind?{kind:"composite",minZoom:s,maxZoom:o,interpolationType:n}:{kind:"camera",minZoom:s,maxZoom:o,minSize:r.evaluate(new Pa(s)),maxSize:r.evaluate(new Pa(o)),interpolationType:n}}}function om(t,{uSize:e,uSizeT:r},{lowerSize:n,upperSize:i}){return "source"===t.kind?n/am:"composite"===t.kind?ue(n/am,i/am,r):e}function lm(t,e){let r=0,n=0;if("constant"===t.kind)n=t.layoutSize;else if("source"!==t.kind){const{interpolationType:i,minZoom:a,maxZoom:s}=t,o=i?I(Yn.interpolationFactor(i,e,a,s),0,1):0;"camera"===t.kind?n=ue(t.minSize,t.maxSize,o):r=o;}return {uSizeT:r,uSize:n}}var um=Object.freeze({__proto__:null,SIZE_PACK_FACTOR:am,evaluateSizeForFeature:om,evaluateSizeForZoom:lm,getSizeData:sm});function cm(t,e,r){return t.sections.forEach((t=>{t.text=function(t,e,r){const n=e.layout.get("text-transform").evaluate(r,{});return "uppercase"===n?t=t.toLocaleUpperCase():"lowercase"===n&&(t=t.toLocaleLowerCase()),ka.applyArabicShaping&&(t=ka.applyArabicShaping(t)),t}(t.text,e,r);})),t}const hm={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\":"＼","]":"﹈","^":"＾",_:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂","←":"↑","→":"↓"};function pm(t){return "︶"===t||"﹈"===t||"︸"===t||"﹄"===t||"﹂"===t||"︾"===t||"︼"===t||"︺"===t||"︘"===t||"﹀"===t||"︐"===t||"︓"===t||"︔"===t||"｀"===t||"￣"===t||"︑"===t||"︒"===t}function fm(t){return "︵"===t||"﹇"===t||"︷"===t||"﹃"===t||"﹁"===t||"︽"===t||"︻"===t||"︹"===t||"︗"===t||"︿"===t}var dm={
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    read:function(t,e,r,n,i){var a,s,o=8*i-n-1,l=(1<<o)-1,u=l>>1,c=-7,h=r?i-1:0,p=r?-1:1,f=t[e+h];for(h+=p,a=f&(1<<-c)-1,f>>=-c,c+=o;c>0;a=256*a+t[e+h],h+=p,c-=8);for(s=a&(1<<-c)-1,a>>=-c,c+=n;c>0;s=256*s+t[e+h],h+=p,c-=8);if(0===a)a=1-u;else {if(a===l)return s?NaN:1/0*(f?-1:1);s+=Math.pow(2,n),a-=u;}return (f?-1:1)*s*Math.pow(2,a-n)},write:function(t,e,r,n,i,a){var s,o,l,u=8*a-i-1,c=(1<<u)-1,h=c>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:a-1,d=n?1:-1,m=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(o=isNaN(e)?1:0,s=c):(s=Math.floor(Math.log(e)/Math.LN2),e*(l=Math.pow(2,-s))<1&&(s--,l*=2),(e+=s+h>=1?p/l:p*Math.pow(2,1-h))*l>=2&&(s++,l/=2),s+h>=c?(o=0,s=c):s+h>=1?(o=(e*l-1)*Math.pow(2,i),s+=h):(o=e*Math.pow(2,h-1)*Math.pow(2,i),s=0));i>=8;t[r+f]=255&o,f+=d,o/=256,i-=8);for(s=s<<i|o,u+=i;u>0;t[r+f]=255&s,f+=d,s/=256,u-=8);t[r+f-d]|=128*m;}},mm=gm,ym=dm;function gm(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length;}gm.Varint=0,gm.Fixed64=1,gm.Bytes=2,gm.Fixed32=5;var xm=4294967296,vm=1/xm,bm="undefined"==typeof TextDecoder?null:new TextDecoder("utf8");function _m(t){return t.type===gm.Bytes?t.readVarint()+t.pos:t.pos+1}function wm(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function Mm(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(7*Math.LN2));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i];}function Am(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r]);}function Sm(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r]);}function Im(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r]);}function km(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r]);}function Pm(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r]);}function Em(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r]);}function zm(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r]);}function Tm(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r]);}function Bm(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r]);}function Cm(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function Rm(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24;}function Dm(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}gm.prototype={destroy:function(){this.buf=null;},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,a=this.pos;this.type=7&n,t(i,e,this),this.pos===a&&this.skip(n);}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=Cm(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=Dm(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=Cm(this.buf,this.pos)+Cm(this.buf,this.pos+4)*xm;return this.pos+=8,t},readSFixed64:function(){var t=Cm(this.buf,this.pos)+Dm(this.buf,this.pos+4)*xm;return this.pos+=8,t},readFloat:function(){var t=ym.read(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=ym.read(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,r,n=this.buf;return e=127&(r=n[this.pos++]),r<128?e:(e|=(127&(r=n[this.pos++]))<<7,r<128?e:(e|=(127&(r=n[this.pos++]))<<14,r<128?e:(e|=(127&(r=n[this.pos++]))<<21,r<128?e:function(t,e,r){var n,i,a=r.buf;if(n=(112&(i=a[r.pos++]))>>4,i<128)return wm(t,n,e);if(n|=(127&(i=a[r.pos++]))<<3,i<128)return wm(t,n,e);if(n|=(127&(i=a[r.pos++]))<<10,i<128)return wm(t,n,e);if(n|=(127&(i=a[r.pos++]))<<17,i<128)return wm(t,n,e);if(n|=(127&(i=a[r.pos++]))<<24,i<128)return wm(t,n,e);if(n|=(1&(i=a[r.pos++]))<<31,i<128)return wm(t,n,e);throw new Error("Expected varint not more than 10 bytes")}(e|=(15&(r=n[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=12&&bm?function(t,e,r){return bm.decode(t.subarray(e,r))}(this.buf,e,t):function(t,e,r){for(var n="",i=e;i<r;){var a,s,o,l=t[i],u=null,c=l>239?4:l>223?3:l>191?2:1;if(i+c>r)break;1===c?l<128&&(u=l):2===c?128==(192&(a=t[i+1]))&&(u=(31&l)<<6|63&a)<=127&&(u=null):3===c?(s=t[i+2],128==(192&(a=t[i+1]))&&128==(192&s)&&((u=(15&l)<<12|(63&a)<<6|63&s)<=2047||u>=55296&&u<=57343)&&(u=null)):4===c&&(s=t[i+2],o=t[i+3],128==(192&(a=t[i+1]))&&128==(192&s)&&128==(192&o)&&((u=(15&l)<<18|(63&a)<<12|(63&s)<<6|63&o)<=65535||u>=1114112)&&(u=null)),null===u?(u=65533,c=1):u>65535&&(u-=65536,n+=String.fromCharCode(u>>>10&1023|55296),u=56320|1023&u),n+=String.fromCharCode(u),i+=c;}return n}(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==gm.Bytes)return t.push(this.readVarint(e));var r=_m(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==gm.Bytes)return t.push(this.readSVarint());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==gm.Bytes)return t.push(this.readBoolean());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==gm.Bytes)return t.push(this.readFloat());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==gm.Bytes)return t.push(this.readDouble());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==gm.Bytes)return t.push(this.readFixed32());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==gm.Bytes)return t.push(this.readSFixed32());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==gm.Bytes)return t.push(this.readFixed64());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==gm.Bytes)return t.push(this.readSFixed64());var e=_m(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===gm.Varint)for(;this.buf[this.pos++]>127;);else if(e===gm.Bytes)this.pos=this.readVarint()+this.pos;else if(e===gm.Fixed32)this.pos+=4;else {if(e!==gm.Fixed64)throw new Error("Unimplemented type: "+e);this.pos+=8;}},writeTag:function(t,e){this.writeVarint(t<<3|e);},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e;}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),Rm(this.buf,t,this.pos),this.pos+=4;},writeSFixed32:function(t){this.realloc(4),Rm(this.buf,t,this.pos),this.pos+=4;},writeFixed64:function(t){this.realloc(8),Rm(this.buf,-1&t,this.pos),Rm(this.buf,Math.floor(t*vm),this.pos+4),this.pos+=8;},writeSFixed64:function(t){this.realloc(8),Rm(this.buf,-1&t,this.pos),Rm(this.buf,Math.floor(t*vm),this.pos+4),this.pos+=8;},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,e){var r,n;if(t>=0?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:(r=0,n=n+1|0)),t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),function(t,e,r){r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,r.buf[r.pos]=127&(t>>>=7);}(r,0,e),function(t,e){var r=(7&t)<<4;e.buf[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=127&t)))));}(n,e);}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))));},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t);},writeBoolean:function(t){this.writeVarint(Boolean(t));},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function(t,e,r){for(var n,i,a=0;a<e.length;a++){if((n=e.charCodeAt(a))>55295&&n<57344){if(!i){n>56319||a+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):i=n;continue}if(n<56320){t[r++]=239,t[r++]=191,t[r++]=189,i=n;continue}n=i-55296<<10|n-56320|65536,i=null;}else i&&(t[r++]=239,t[r++]=191,t[r++]=189,i=null);n<128?t[r++]=n:(n<2048?t[r++]=n>>6|192:(n<65536?t[r++]=n>>12|224:(t[r++]=n>>18|240,t[r++]=n>>12&63|128),t[r++]=n>>6&63|128),t[r++]=63&n|128);}return r}(this.buf,t,this.pos);var r=this.pos-e;r>=128&&Mm(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r;},writeFloat:function(t){this.realloc(4),ym.write(this.buf,t,this.pos,!0,23,4),this.pos+=4;},writeDouble:function(t){this.realloc(8),ym.write(this.buf,t,this.pos,!0,52,8),this.pos+=8;},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r];},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&Mm(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n;},writeMessage:function(t,e,r){this.writeTag(t,gm.Bytes),this.writeRawMessage(e,r);},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,Am,e);},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,Sm,e);},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,Pm,e);},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,Im,e);},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,km,e);},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,Em,e);},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,zm,e);},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,Tm,e);},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,Bm,e);},writeBytesField:function(t,e){this.writeTag(t,gm.Bytes),this.writeBytes(e);},writeFixed32Field:function(t,e){this.writeTag(t,gm.Fixed32),this.writeFixed32(e);},writeSFixed32Field:function(t,e){this.writeTag(t,gm.Fixed32),this.writeSFixed32(e);},writeFixed64Field:function(t,e){this.writeTag(t,gm.Fixed64),this.writeFixed64(e);},writeSFixed64Field:function(t,e){this.writeTag(t,gm.Fixed64),this.writeSFixed64(e);},writeVarintField:function(t,e){this.writeTag(t,gm.Varint),this.writeVarint(e);},writeSVarintField:function(t,e){this.writeTag(t,gm.Varint),this.writeSVarint(e);},writeStringField:function(t,e){this.writeTag(t,gm.Bytes),this.writeString(e);},writeFloatField:function(t,e){this.writeTag(t,gm.Fixed32),this.writeFloat(e);},writeDoubleField:function(t,e){this.writeTag(t,gm.Fixed64),this.writeDouble(e);},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e));}};var Vm=h(mm);const Lm=3;function Fm(t,e,r){e.glyphs=[],1===t&&r.readMessage(Nm,e);}function Nm(t,e,r){if(3===t){const{id:t,bitmap:n,width:i,height:a,left:s,top:o,advance:l}=r.readMessage(Om,{});e.glyphs.push({id:t,bitmap:new vp({width:i+2*Lm,height:a+2*Lm},n),metrics:{width:i,height:a,left:s,top:o,advance:l}});}else 4===t?e.ascender=r.readSVarint():5===t&&(e.descender=r.readSVarint());}function Om(t,e,r){1===t?e.id=r.readVarint():2===t?e.bitmap=r.readBytes():3===t?e.width=r.readVarint():4===t?e.height=r.readVarint():5===t?e.left=r.readSVarint():6===t?e.top=r.readSVarint():7===t&&(e.advance=r.readVarint());}const Um=Lm,jm={horizontal:1,vertical:2,horizontalOnly:3};class qm{constructor(){this.scale=1,this.fontStack="",this.imageName=null;}static forText(t,e){const r=new qm;return r.scale=t||1,r.fontStack=e,r}static forImage(t){const e=new qm;return e.imageName=t,e}}class $m{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null;}static fromFeature(t,e){const r=new $m;for(let n=0;n<t.sections.length;n++){const i=t.sections[n];i.image?r.addImageSection(i):r.addTextSection(i,e);}return r}length(){return this.text.length}getSection(t){return this.sections[this.sectionIndex[t]]}getSections(){return this.sections}getSectionIndex(t){return this.sectionIndex[t]}getCodePoint(t){return this.text.codePointAt(t)}verticalizePunctuation(t){this.text=function(t,e){let r="";for(let n=0;n<t.length;n++){const i=t.charCodeAt(n+1)||null,a=t.charCodeAt(n-1)||null;r+=!e&&(i&&pa(i)&&!hm[t[n+1]]||a&&pa(a)&&!hm[t[n-1]])||!hm[t[n]]?t[n]:hm[t[n]];}return r}(this.text,t);}trim(){let t=0;for(let e=0;e<this.text.length&&Ym[this.text.charCodeAt(e)];e++)t++;let e=this.text.length;for(let r=this.text.length-1;r>=0&&r>=t&&Ym[this.text.charCodeAt(r)];r--)e--;this.text=this.text.substring(t,e),this.sectionIndex=this.sectionIndex.slice(t,e);}substring(t,e){const r=new $m;return r.text=this.text.substring(t,e),r.sectionIndex=this.sectionIndex.slice(t,e),r.sections=this.sections,r}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce(((t,e)=>Math.max(t,this.sections[e].scale)),0)}addTextSection(t,e){this.text+=t.text,this.sections.push(qm.forText(t.scale,t.fontStack||e));const r=this.sections.length-1;for(let e=0;e<t.text.length;++e)this.sectionIndex.push(r);}addImageSection(t){const e=t.image?t.image.namePrimary:"";if(0===e.length)return void j("Can't add FormattedSection with an empty image.");const r=this.getNextImageSectionCharCode();r?(this.text+=String.fromCodePoint(r),this.sections.push(qm.forImage(e)),this.sectionIndex.push(this.sections.length-1)):j("Reached maximum number of images 6401");}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=63743?null:++this.imageSectionID:(this.imageSectionID=57344,this.imageSectionID)}}function Gm(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d){const m=$m.fromFeature(t,i);h===jm.vertical&&m.verticalizePunctuation(p);let y=[];const g=function(t,e,r,n,i,a){if(!t)return [];const s=[],o=function(t,e,r,n,i,a){let s=0;for(let r=0;r<t.length();r++){const o=t.getSection(r);s+=Zm(t.getCodePoint(r),o,n,i,e,a);}return s/Math.max(1,Math.ceil(s/r))}(t,e,r,n,i,a),l=t.text.indexOf("​")>=0;let u=0;for(let r=0;r<t.length();r++){const h=t.getSection(r),p=t.getCodePoint(r);if(Ym[p]||(u+=Zm(p,h,n,i,e,a)),r<t.length()-1){const e=!((c=p)<11904||!(oa["Bopomofo Extended"](c)||oa.Bopomofo(c)||oa["CJK Compatibility Forms"](c)||oa["CJK Compatibility Ideographs"](c)||oa["CJK Compatibility"](c)||oa["CJK Radicals Supplement"](c)||oa["CJK Strokes"](c)||oa["CJK Symbols and Punctuation"](c)||oa["CJK Unified Ideographs Extension A"](c)||oa["CJK Unified Ideographs"](c)||oa["Enclosed CJK Letters and Months"](c)||oa["Halfwidth and Fullwidth Forms"](c)||oa.Hiragana(c)||oa["Ideographic Description Characters"](c)||oa["Kangxi Radicals"](c)||oa["Katakana Phonetic Extensions"](c)||oa.Katakana(c)||oa["Vertical Forms"](c)||oa["Yi Radicals"](c)||oa["Yi Syllables"](c)));(Xm[p]||e||h.imageName)&&s.push(Wm(r+1,u,o,s,Hm(p,t.getCodePoint(r+1),e&&l),!1));}}var c;return Jm(Wm(t.length(),u,o,s,0,!0))}(m,u,a,e,n,f),{processBidirectionalText:x,processStyledBidirectionalText:v}=ka;if(x&&1===m.sections.length){const t=x(m.toString(),g);for(const e of t){const t=new $m;t.text=e,t.sections=m.sections;for(let r=0;r<e.length;r++)t.sectionIndex.push(0);y.push(t);}}else if(v){const t=v(m.text,m.sectionIndex,g);for(const e of t){const t=new $m;t.text=e[0],t.sectionIndex=e[1],t.sections=m.sections,y.push(t);}}else y=function(t,e){const r=[],n=t.text;let i=0;for(const n of e)r.push(t.substring(i,n)),i=n;return i<n.length&&r.push(t.substring(i,n.length)),r}(m,g);const b=[],_={positionedLines:b,text:m.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:h,iconsInText:!1,verticalizable:!1,hasBaseline:!1};return function(t,e,r,n,i,a,s,o,l,u,c,h){let p=0,f=0,d=0;const m="right"===o?1:"left"===o?0:.5;let y=!1;for(const t of i){const r=t.getSections();for(const t of r){if(t.imageName)continue;const r=e[t.fontStack];if(r&&(y=void 0!==r.ascender&&void 0!==r.descender,!y))break}if(!y)break}let g=0;for(const s of i){s.trim();const i=s.getMaxScale(),o=(i-1)*im,v={positionedGlyphs:[],lineOffset:0};t.positionedLines[g]=v;const b=v.positionedGlyphs;let _=0;if(!s.length()){f+=a,++g;continue}let w=0,M=0;for(let a=0;a<s.length();a++){const o=s.getSection(a),d=s.getSectionIndex(a),m=s.getCodePoint(a);let g=o.scale,v=null,A=null,S=null,I=im,k=0;const P=!(l===jm.horizontal||!c&&!ha(m)||c&&(Ym[m]||(x=m,oa.Arabic(x)||oa["Arabic Supplement"](x)||oa["Arabic Extended-A"](x)||oa["Arabic Presentation Forms-A"](x)||oa["Arabic Presentation Forms-B"](x))));if(o.imageName){const e=n[o.imageName];if(!e)continue;S=o.imageName,t.iconsInText=t.iconsInText||!0,A=e.paddedRect;const r=e.displaySize;g=g*im/h,v={width:r[0],height:r[1],left:0,top:-Um,advance:P?r[1]:r[0],localGlyph:!1},k=y?-v.height*g:i*im-17-r[1]*g,I=v.advance;const a=(P?r[0]:r[1])*g-im*i;a>0&&a>_&&(_=a);}else {const t=r[o.fontStack];if(!t)continue;t[m]&&(A=t[m]);const n=e[o.fontStack];if(!n)continue;const a=n.glyphs[m];if(!a)continue;if(v=a.metrics,I=8203!==m?im:0,y){const t=void 0!==n.ascender?Math.abs(n.ascender):0,e=void 0!==n.descender?Math.abs(n.descender):0,r=(t+e)*g;w<r&&(w=r,M=(t-e)/2*g),k=-t*g;}else k=(i-g)*im-17;}P?(t.verticalizable=!0,b.push({glyph:m,imageName:S,x:p,y:f+k,vertical:P,scale:g,localGlyph:v.localGlyph,fontStack:o.fontStack,sectionIndex:d,metrics:v,rect:A}),p+=I*g+u):(b.push({glyph:m,imageName:S,x:p,y:f+k,vertical:P,scale:g,localGlyph:v.localGlyph,fontStack:o.fontStack,sectionIndex:d,metrics:v,rect:A}),p+=v.advance*g+u);}0!==b.length&&(d=Math.max(p-u,d),y?ty(b,m,_,M,a*i/2):ty(b,m,_,0,a/2)),p=0;const A=a*i+_;v.lineOffset=Math.max(_,o),f+=A,++g;}var x;const v=f,{horizontalAlign:b,verticalAlign:_}=Qm(s);(((function(t,e,r,n,i,a){const s=(e-r)*i,o=-a*n;for(const e of t)for(const t of e.positionedGlyphs)t.x+=s,t.y+=o;})))(t.positionedLines,m,b,_,d,v),t.top+=-_*v,t.bottom=t.top+v,t.left+=-b*d,t.right=t.left+d,t.hasBaseline=y;}(_,e,r,n,y,s,o,l,h,u,p,d),!function(t){for(const e of t)if(0!==e.positionedGlyphs.length)return !1;return !0}(b)&&_}const Ym={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Xm={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function Zm(t,e,r,n,i,a){if(e.imageName){const t=n[e.imageName];return t?t.displaySize[0]*e.scale*im/a+i:0}{const n=r[e.fontStack],a=n&&n.glyphs[t];return a?a.metrics.advance*e.scale+i:0}}function Km(t,e,r,n){const i=Math.pow(t-e,2);return n?t<e?i/2:2*i:i+Math.abs(r)*r}function Hm(t,e,r){let n=0;return 10===t&&(n-=1e4),r&&(n+=150),40!==t&&65288!==t||(n+=50),41!==e&&65289!==e||(n+=50),n}function Wm(t,e,r,n,i,a){let s=null,o=Km(e,r,i,a);for(const t of n){const n=Km(e-t.x,r,i,a)+t.badness;n<=o&&(s=t,o=n);}return {index:t,x:e,priorBreak:s,badness:o}}function Jm(t){return t?Jm(t.priorBreak).concat(t.index):[]}function Qm(t){let e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;}return {horizontalAlign:e,verticalAlign:r}}function ty(t,e,r,n,i){if(!(e||r||n||i))return;const a=t.length-1,s=t[a],o=(s.x+s.metrics.advance*s.scale)*e;for(let e=0;e<=a;e++)t[e].x-=o,t[e].y+=r+n+i;}function ey(t,e,r,n){const{horizontalAlign:i,verticalAlign:a}=Qm(n),s=r[0]-t.displaySize[0]*i,o=r[1]-t.displaySize[1]*a;return {imagePrimary:t,imageSecondary:e,top:o,bottom:o+t.displaySize[1],left:s,right:s+t.displaySize[0]}}function ry(t,e,r,n,i,a){const s=t.imagePrimary;let o;if(s.content){const t=s.content,e=s.pixelRatio||1;o=[t[0]/e,t[1]/e,s.displaySize[0]-t[2]/e,s.displaySize[1]-t[3]/e];}const l=e.left*a,u=e.right*a;let c,h,p,f;"width"===r||"both"===r?(f=i[0]+l-n[3],h=i[0]+u+n[1]):(f=i[0]+(l+u-s.displaySize[0])/2,h=f+s.displaySize[0]);const d=e.top*a,m=e.bottom*a;return "height"===r||"both"===r?(c=i[1]+d-n[0],p=i[1]+m+n[2]):(c=i[1]+(d+m-s.displaySize[1])/2,p=c+s.displaySize[1]),{imagePrimary:s,imageSecondary:void 0,top:c,right:h,bottom:p,left:f,collisionPadding:o}}class ny extends g{constructor(t,e,r,n,i){super(t,e),this.angle=n,this.z=r,void 0!==i&&(this.segment=i);}clone(){return new ny(this.x,this.y,this.z,this.angle,this.segment)}}function iy(t,e,r,n,i){if(void 0===e.segment)return !0;let a=e,s=e.segment+1,o=0;for(;o>-r/2;){if(s--,s<0)return !1;o-=t[s].dist(a),a=t[s];}o+=t[s].dist(t[s+1]),s++;const l=[];let u=0;for(;o<r/2;){const e=t[s],r=t[s+1];if(!r)return !1;let a=t[s-1].angleTo(e)-e.angleTo(r);for(a=Math.abs((a+3*Math.PI)%(2*Math.PI)-Math.PI),l.push({distance:o,angleDelta:a}),u+=a;o-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return !1;s++,o+=e.dist(r);}return !0}function ay(t){let e=0;for(let r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function sy(t,e,r){return t?.6*e*r:0}function oy(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function ly(t,e,r,n,i,a){const s=sy(r,i,a),o=oy(r,n)*a;let l=0;const u=ay(t)/2;for(let r=0;r<t.length-1;r++){const n=t[r],i=t[r+1],a=n.dist(i);if(l+a>u){const c=(u-l)/a,h=ue(n.x,i.x,c),p=ue(n.y,i.y,c),f=new ny(h,p,0,i.angleTo(n),r);return !s||iy(t,f,o,s,e)?f:void 0}l+=a;}}function uy(t,e,r,n,i,a,s,o,l){const u=sy(n,a,s),c=oy(n,i),h=c*s,p=0===t[0].x||t[0].x===l||0===t[0].y||t[0].y===l;return e-h<e/4&&(e=h+e/4),cy(t,p?e/2*o%e:(c/2+2*a)*s*o%e,e,u,r,h,p,!1,l)}function cy(t,e,r,n,i,a,s,o,l){const u=a/2,c=ay(t);let h=0,p=e-r,f=[];for(let e=0;e<t.length-1;e++){const s=t[e],o=t[e+1],d=s.dist(o),m=o.angleTo(s);for(;p+r<h+d;){p+=r;const y=(p-h)/d,g=ue(s.x,o.x,y),x=ue(s.y,o.y,y);if(g>=0&&g<l&&x>=0&&x<l&&p-u>=0&&p+u<=c){const r=new ny(g,x,0,m,e);n&&!iy(t,r,a,n,i)||f.push(r);}}h+=d;}return o||f.length||s||(f=cy(t,h/2,r,n,i,a,s,!0,l)),f}function hy(t,e,r,n,i){const a=[];for(let s=0;s<t.length;s++){const o=t[s];let l;for(let t=0;t<o.length-1;t++){let s=o[t],u=o[t+1];s.x<e&&u.x<e||(s.x<e?s=new g(e,s.y+(e-s.x)/(u.x-s.x)*(u.y-s.y))._round():u.x<e&&(u=new g(e,s.y+(e-s.x)/(u.x-s.x)*(u.y-s.y))._round()),s.y<r&&u.y<r||(s.y<r?s=new g(s.x+(r-s.y)/(u.y-s.y)*(u.x-s.x),r)._round():u.y<r&&(u=new g(s.x+(r-s.y)/(u.y-s.y)*(u.x-s.x),r)._round()),s.x>=n&&u.x>=n||(s.x>=n?s=new g(n,s.y+(n-s.x)/(u.x-s.x)*(u.y-s.y))._round():u.x>=n&&(u=new g(n,s.y+(n-s.x)/(u.x-s.x)*(u.y-s.y))._round()),s.y>=i&&u.y>=i||(s.y>=i?s=new g(s.x+(i-s.y)/(u.y-s.y)*(u.x-s.x),i)._round():u.y>=i&&(u=new g(s.x+(i-s.y)/(u.y-s.y)*(u.x-s.x),i)._round()),l&&s.equals(l[l.length-1])||(l=[s],a.push(l)),l.push(u)))));}}return a}function py(t){let e=0,r=0;for(const n of t)e+=n.w*n.h,r=Math.max(r,n.w);t.sort(((t,e)=>e.h-t.h));const n=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}];let i=0,a=0;for(const e of t)for(let t=n.length-1;t>=0;t--){const r=n[t];if(!(e.w>r.w||e.h>r.h)){if(e.x=r.x,e.y=r.y,a=Math.max(a,e.y+e.h),i=Math.max(i,e.x+e.w),e.w===r.w&&e.h===r.h){const e=n.pop();t<n.length&&(n[t]=e);}else e.h===r.h?(r.x+=e.w,r.w-=e.w):e.w===r.w?(r.y+=e.h,r.h-=e.h):(n.push({x:r.x+e.w,y:r.y,w:r.w-e.w,h:e.h}),r.y+=e.h,r.h-=e.h);break}}return {w:i,h:a,fill:e/(i*a)||0}}ra(ny,"Anchor");const fy=1;class dy{constructor(t,{pixelRatio:e,version:r,stretchX:n,stretchY:i,content:a}){this.paddedRect=t,this.pixelRatio=e,this.stretchX=n,this.stretchY=i,this.content=a,this.version=r;}get tl(){return [this.paddedRect.x+fy,this.paddedRect.y+fy]}get br(){return [this.paddedRect.x+this.paddedRect.w-fy,this.paddedRect.y+this.paddedRect.h-fy]}get displaySize(){return [(this.paddedRect.w-2*fy)/this.pixelRatio,(this.paddedRect.h-2*fy)/this.pixelRatio]}}class my{constructor(t,e){const r={},n={};this.haveRenderCallbacks=[];const i=[];this.addImages(t,r,i),this.addImages(e,n,i);const{w:a,h:s}=py(i),o=new bp({width:a||1,height:s||1});for(const e in t){const n=t[e],i=r[e].paddedRect;bp.copy(n.data,o,{x:0,y:0},{x:i.x+fy,y:i.y+fy},n.data,n.sdf);}for(const t in e){const r=e[t],i=n[t].paddedRect,a=i.x+fy,s=i.y+fy,l=r.data.width,u=r.data.height;bp.copy(r.data,o,{x:0,y:0},{x:a,y:s},r.data),bp.copy(r.data,o,{x:0,y:u-1},{x:a,y:s-1},{width:l,height:1}),bp.copy(r.data,o,{x:0,y:0},{x:a,y:s+u},{width:l,height:1}),bp.copy(r.data,o,{x:l-1,y:0},{x:a-1,y:s},{width:1,height:u}),bp.copy(r.data,o,{x:0,y:0},{x:a+l,y:s},{width:1,height:u});}this.image=o,this.iconPositions=r,this.patternPositions=n;}addImages(t,e,r){for(const n in t){const i=t[n],a={x:0,y:0,w:i.data.width+2*fy,h:i.data.height+2*fy};r.push(a),e[n]=new dy(a,i),i.hasRenderCallback&&this.haveRenderCallbacks.push(n);}}patchUpdatedImages(t,e,r){this.haveRenderCallbacks=this.haveRenderCallbacks.filter((e=>t.hasImage(e,r))),t.dispatchRenderCallbacks(this.haveRenderCallbacks,r);for(const n in t.getUpdatedImages(r))this.patchUpdatedImage(this.iconPositions[n],t.getImage(n,r),e),this.patchUpdatedImage(this.patternPositions[n],t.getImage(n,r),e);}patchUpdatedImage(t,e,r){if(!t||!e)return;if(t.version===e.version)return;t.version=e.version;const[n,i]=t.tl,a=!!Object.keys(this.patternPositions).length;r.update(e.data,{useMipmap:a},{x:n,y:i});}}ra(dy,"ImagePosition"),ra(my,"ImageAtlas");const yy=1e20;function gy(t,e,r,n,i,a,s,o,l){for(let u=e;u<e+n;u++)xy(t,r*a+u,a,i,s,o,l);for(let u=r;u<r+i;u++)xy(t,u*a+e,1,n,s,o,l);}function xy(t,e,r,n,i,a,s){a[0]=0,s[0]=-yy,s[1]=yy,i[0]=t[e];for(let o=1,l=0,u=0;o<n;o++){i[o]=t[e+o*r];const n=o*o;do{const t=a[l];u=(i[o]-i[t]+n-t*t)/(o-t)/2;}while(u<=s[l]&&--l>-1);l++,a[l]=o,s[l]=u,s[l+1]=yy;}for(let o=0,l=0;o<n;o++){for(;s[l+1]<o;)l++;const n=a[l],u=o-n;t[e+o*r]=i[n]+u*u;}}const vy=2,by={none:0,ideographs:1,all:2};class _y{constructor(t,e,r){this.requestManager=t,this.localGlyphMode=e,this.localFontFamily=r,this.urls={},this.entries={},this.localGlyphs={200:{},400:{},500:{},900:{}};}setURL(t,e){this.urls[e]=t;}getGlyphs(t,e,r){const i=[],a=this.urls[e]||n.GLYPHS_URL;for(const e in t)for(const r of t[e])i.push({stack:e,id:r});E(i,(({stack:t,id:e},r)=>{let n=this.entries[t];n||(n=this.entries[t]={glyphs:{},requests:{},ranges:{},ascender:void 0,descender:void 0});let i=n.glyphs[e];if(void 0!==i)return void r(null,{stack:t,id:e,glyph:i});if(i=this._tinySDF(n,t,e),i)return n.glyphs[e]=i,void r(null,{stack:t,id:e,glyph:i});const s=Math.floor(e/256);if(256*s>65535)return void r(new Error("glyphs > 65535 not supported"));if(n.ranges[s])return void r(null,{stack:t,id:e,glyph:i});let o=n.requests[s];o||(o=n.requests[s]=[],_y.loadGlyphRange(t,s,a,this.requestManager,((t,e)=>{if(e){n.ascender=e.ascender,n.descender=e.descender;for(const t in e.glyphs)this._doesCharSupportLocalGlyph(+t)||(n.glyphs[+t]=e.glyphs[+t]);n.ranges[s]=!0;}for(const r of o)r(t,e);delete n.requests[s];}))),o.push(((n,i)=>{n?r(n):i&&r(null,{stack:t,id:e,glyph:i.glyphs[e]||null});}));}),((t,e)=>{if(t)r(t);else if(e){const t={};for(const{stack:r,id:n,glyph:i}of e)void 0===t[r]&&(t[r]={}),void 0===t[r].glyphs&&(t[r].glyphs={}),t[r].glyphs[n]=i&&{id:i.id,bitmap:i.bitmap.clone(),metrics:i.metrics},t[r].ascender=this.entries[r].ascender,t[r].descender=this.entries[r].descender;r(null,t);}}));}_doesCharSupportLocalGlyph(t){return this.localGlyphMode!==by.none&&(this.localGlyphMode===by.all?!!this.localFontFamily:!!this.localFontFamily&&(oa["CJK Unified Ideographs"](t)||oa["Hangul Syllables"](t)||oa.Hiragana(t)||oa.Katakana(t)||oa["CJK Symbols and Punctuation"](t)||oa["CJK Unified Ideographs Extension A"](t)||oa["CJK Unified Ideographs Extension B"](t)))}_tinySDF(t,e,r){const n=this.localFontFamily;if(!n||!this._doesCharSupportLocalGlyph(r))return;let i=t.tinySDF;if(!i){let r="400";/bold/i.test(e)?r="900":/medium/i.test(e)?r="500":/light/i.test(e)&&(r="200"),i=t.tinySDF=new _y.TinySDF({fontFamily:n,fontWeight:r,fontSize:24*vy,buffer:3*vy,radius:8*vy}),i.fontWeight=r;}if(this.localGlyphs[i.fontWeight][r])return this.localGlyphs[i.fontWeight][r];const a=String.fromCodePoint(r),{data:s,width:o,height:l,glyphWidth:u,glyphHeight:c,glyphLeft:h,glyphTop:p,glyphAdvance:f}=i.draw(a);return this.localGlyphs[i.fontWeight][r]={id:r,bitmap:new vp({width:o,height:l},s),metrics:{width:u/vy,height:c/vy,left:h/vy,top:p/vy-27,advance:f/vy,localGlyph:!0}}}}_y.loadGlyphRange=function(t,e,r,n,i){const a=256*e,s=a+255,o=n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}",t).replace("{range}",`${a}-${s}`),At.Glyphs);Pt(o,((t,e)=>{if(t)i(t);else if(e){const t={},r=function(t){return new Vm(t).readFields(Fm,{})}(e);for(const e of r.glyphs)t[e.id]=e;i(null,{glyphs:t,ascender:r.ascender,descender:r.descender});}}));},_y.TinySDF=class{constructor({fontSize:t=24,buffer:e=3,radius:r=8,cutoff:n=.25,fontFamily:i="sans-serif",fontWeight:a="normal",fontStyle:s="normal"}={}){this.buffer=e,this.cutoff=n,this.radius=r;const o=this.size=t+4*e,l=this._createCanvas(o),u=this.ctx=l.getContext("2d",{willReadFrequently:!0});u.font=`${s} ${a} ${t}px ${i}`,u.textBaseline="alphabetic",u.textAlign="left",u.fillStyle="black",this.gridOuter=new Float64Array(o*o),this.gridInner=new Float64Array(o*o),this.f=new Float64Array(o),this.z=new Float64Array(o+1),this.v=new Uint16Array(o);}_createCanvas(t){const e=document.createElement("canvas");return e.width=e.height=t,e}draw(t){const{width:e,actualBoundingBoxAscent:r,actualBoundingBoxDescent:n,actualBoundingBoxLeft:i,actualBoundingBoxRight:a}=this.ctx.measureText(t),s=Math.ceil(r),o=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(a-i))),l=Math.min(this.size-this.buffer,s+Math.ceil(n)),u=o+2*this.buffer,c=l+2*this.buffer,h=Math.max(u*c,0),p=new Uint8ClampedArray(h),f={data:p,width:u,height:c,glyphWidth:o,glyphHeight:l,glyphTop:s,glyphLeft:0,glyphAdvance:e};if(0===o||0===l)return f;const{ctx:d,buffer:m,gridInner:y,gridOuter:g}=this;d.clearRect(m,m,o,l),d.fillText(t,m,m+s);const x=d.getImageData(m,m,o,l);g.fill(yy,0,h),y.fill(0,0,h);for(let t=0;t<l;t++)for(let e=0;e<o;e++){const r=x.data[4*(t*o+e)+3]/255;if(0===r)continue;const n=(t+m)*u+e+m;if(1===r)g[n]=0,y[n]=yy;else {const t=.5-r;g[n]=t>0?t*t:0,y[n]=t<0?t*t:0;}}gy(g,0,0,u,c,u,this.f,this.v,this.z),gy(y,m,m,o,l,u,this.f,this.v,this.z);for(let t=0;t<h;t++){const e=Math.sqrt(g[t])-Math.sqrt(y[t]);p[t]=Math.round(255-255*(e/this.radius+this.cutoff));}return f}};const wy=fy;function My(t,e,r,n){const i=[],a=t.imagePrimary,s=a.pixelRatio,o=a.paddedRect.w-2*wy,l=a.paddedRect.h-2*wy,u=t.right-t.left,c=t.bottom-t.top,h=a.stretchX||[[0,o]],p=a.stretchY||[[0,l]],f=(t,e)=>t+e[1]-e[0],d=h.reduce(f,0),m=p.reduce(f,0),y=o-d,x=l-m;let v=0,b=d,_=0,w=m,M=0,A=y,S=0,I=x;if(a.content&&n){const t=a.content;v=Ay(h,0,t[0]),_=Ay(p,0,t[1]),b=Ay(h,t[0],t[2]),w=Ay(p,t[1],t[3]),M=t[0]-v,S=t[1]-_,A=t[2]-t[0]-b,I=t[3]-t[1]-w;}const k=(n,i,o,l)=>{const h=Iy(n.stretch-v,b,u,t.left),p=ky(n.fixed-M,A,n.stretch,d),f=Iy(i.stretch-_,w,c,t.top),y=ky(i.fixed-S,I,i.stretch,m),x=Iy(o.stretch-v,b,u,t.left),k=ky(o.fixed-M,A,o.stretch,d),P=Iy(l.stretch-_,w,c,t.top),E=ky(l.fixed-S,I,l.stretch,m),z=new g(h,f),T=new g(x,f),B=new g(x,P),C=new g(h,P),R=new g(p/s,y/s),D=new g(k/s,E/s),V=e*Math.PI/180;if(V){const t=Math.sin(V),e=Math.cos(V),r=[e,-t,t,e];z._matMult(r),T._matMult(r),C._matMult(r),B._matMult(r);}const L=n.stretch+n.fixed,F=o.stretch+o.fixed,N=i.stretch+i.fixed,O=l.stretch+l.fixed,U=t.imageSecondary;return {tl:z,tr:T,bl:C,br:B,texPrimary:{x:a.paddedRect.x+wy+L,y:a.paddedRect.y+wy+N,w:F-L,h:O-N},texSecondary:U?{x:U.paddedRect.x+wy+L,y:U.paddedRect.y+wy+N,w:F-L,h:O-N}:void 0,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:R,pixelOffsetBR:D,minFontScaleX:A/s/u,minFontScaleY:I/s/c,isSDF:r}};if(n&&(a.stretchX||a.stretchY)){const t=Sy(h,y,d),e=Sy(p,x,m);for(let r=0;r<t.length-1;r++){const n=t[r],a=t[r+1];for(let t=0;t<e.length-1;t++)i.push(k(n,e[t],a,e[t+1]));}}else i.push(k({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:o+1},{fixed:0,stretch:l+1}));return i}function Ay(t,e,r){let n=0;for(const i of t)n+=Math.max(e,Math.min(r,i[1]))-Math.max(e,Math.min(r,i[0]));return n}function Sy(t,e,r){const n=[{fixed:-wy,stretch:0}];for(const[e,r]of t){const t=n[n.length-1];n.push({fixed:e-t.stretch,stretch:t.stretch}),n.push({fixed:e-t.stretch,stretch:t.stretch+(r-e)});}return n.push({fixed:e+wy,stretch:r}),n}function Iy(t,e,r,n){return t/e*r+n}function ky(t,e,r,n){return t-e*r/n}function Py(t,e,r,n){const i=e+t.positionedLines[n].lineOffset;return 0===n?r+i/2:r+(i+(e+t.positionedLines[n-1].lineOffset))/2}function Ey(t,e=1,r=!1){let n=1/0,i=1/0,a=-1/0,s=-1/0;const o=t[0];for(let t=0;t<o.length;t++){const e=o[t];(!t||e.x<n)&&(n=e.x),(!t||e.y<i)&&(i=e.y),(!t||e.x>a)&&(a=e.x),(!t||e.y>s)&&(s=e.y);}const l=Math.min(a-n,s-i);let u=l/2;const c=new zr([],zy);if(0===l)return new g(n,i);for(let e=n;e<a;e+=l)for(let r=i;r<s;r+=l)c.push(new Ty(e+u,r+u,u,t));let h=function(t){let e=0,r=0,n=0;const i=t[0];for(let t=0,a=i.length,s=a-1;t<a;s=t++){const a=i[t],o=i[s],l=a.x*o.y-o.x*a.y;r+=(a.x+o.x)*l,n+=(a.y+o.y)*l,e+=3*l;}return new Ty(r/e,n/e,0,t)}(t),p=c.length;for(;c.length;){const n=c.pop();(n.d>h.d||!h.d)&&(h=n,r&&console.log("found best %d after %d probes",Math.round(1e4*n.d)/1e4,p)),n.max-h.d<=e||(u=n.h/2,c.push(new Ty(n.p.x-u,n.p.y-u,u,t)),c.push(new Ty(n.p.x+u,n.p.y-u,u,t)),c.push(new Ty(n.p.x-u,n.p.y+u,u,t)),c.push(new Ty(n.p.x+u,n.p.y+u,u,t)),p+=4);}return r&&(console.log(`num probes: ${p}`),console.log(`best distance: ${h.d}`)),h.p}function zy(t,e){return e.max-t.max}class Ty{constructor(t,e,r,n){this.p=new g(t,e),this.h=r,this.d=function(t,e){let r=!1,n=1/0;for(let i=0;i<e.length;i++){const a=e[i];for(let e=0,i=a.length,s=i-1;e<i;s=e++){const i=a[e],o=a[s];i.y>t.y!=o.y>t.y&&t.x<(o.x-i.x)*(t.y-i.y)/(o.y-i.y)+i.x&&(r=!r),n=Math.min(n,ql(t,i,o));}}return (r?1:-1)*Math.sqrt(n)}(this.p,n),this.max=this.d+this.h*Math.SQRT2;}}const By=Number.POSITIVE_INFINITY,Cy=Math.sqrt(2);function Ry(t,[e,r]){let n=0,i=0;if(r===By){e<0&&(e=0);const r=e/Cy;switch(t){case"top-right":case"top-left":i=r-7;break;case"bottom-right":case"bottom-left":i=7-r;break;case"bottom":i=7-e;break;case"top":i=e-7;}switch(t){case"top-right":case"bottom-right":n=-r;break;case"top-left":case"bottom-left":n=r;break;case"left":n=e;break;case"right":n=-e;}}else {switch(e=Math.abs(e),r=Math.abs(r),t){case"top-right":case"top-left":case"top":i=r-7;break;case"bottom-right":case"bottom-left":case"bottom":i=7-r;}switch(t){case"top-right":case"bottom-right":case"right":n=-e;break;case"top-left":case"bottom-left":case"left":n=e;}}return [n,i]}function Dy(t){switch(t){case"right":case"top-right":case"bottom-right":return "right";case"left":case"top-left":case"bottom-left":return "left"}return "center"}function Vy(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d){let m=a.textMaxSize.evaluate(e,{},h);void 0===m&&(m=s);const y=t.layers[0].layout,g=y.get("icon-offset").evaluate(e,{},h),x=Oy(r.horizontal)||r.vertical,v="globe"===p.name,_=im,w=s/_,M=t.tilePixelRatio*m/_,A=(B=t.overscaling,t.zoom>18&&B>2&&(B>>=1),Math.max(Tr/(512*B),1)*y.get("symbol-spacing")),S=y.get("text-padding")*t.tilePixelRatio,I=y.get("icon-padding")*t.tilePixelRatio,k=b(y.get("text-max-angle")),P="map"===y.get("text-rotation-alignment")&&"point"!==y.get("symbol-placement"),E="map"===y.get("icon-rotation-alignment")&&"point"!==y.get("symbol-placement"),z=y.get("symbol-placement"),T=A/2;var B;const C=y.get("icon-text-fit").evaluate(e,{},h),R=y.get("icon-text-fit-padding").evaluate(e,{},h),D="none"!==C;let V;!1===t.hasAnyIconTextFit&&D&&(t.hasAnyIconTextFit=!0),n&&D&&(t.allowVerticalPlacement&&r.vertical&&(V=ry(n,r.vertical,C,R,g,w)),x&&(n=ry(n,x,C,R,g,w)));const L=(s,o,m)=>{if(o.x<0||o.x>=Tr||o.y<0||o.y>=Tr)return;let y=null;if(v){const{x:t,y:e,z:r}=p.projectTilePoint(o.x,o.y,m);y={anchor:new ny(t,e,r,0,void 0),up:p.upVector(m,o.x,o.y)};}!function(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,g,x,v,b,_,w,M,A,S,I){const k=t.addToLineVertexArray(e,n);let P,E,z,T,B,C,R,D=0,V=0,L=0,F=0,N=-1,O=-1;const U={};let q=ho("");const $=r?r.anchor:e,G="none"!==l.layout.get("icon-text-fit").evaluate(b,{},A);let Y=0,X=0;if(void 0===l._unevaluatedLayout.getValue("text-radial-offset")?[Y,X]=l.layout.get("text-offset").evaluate(b,{},A).map((t=>t*im)):(Y=l.layout.get("text-radial-offset").evaluate(b,{},A)*im,X=By),t.allowVerticalPlacement&&i.vertical){const t=i.vertical;if(d)C=jy(t),o&&(R=jy(o));else {const r=l.layout.get("text-rotate").evaluate(b,{},A)+90;z=Uy(u,$,e,c,h,p,t,f,r,m),o&&(T=Uy(u,$,e,c,h,p,o,g,r));}}if(a){const n=l.layout.get("icon-rotate").evaluate(b,{},A),i=My(a,n,w,G),s=o?My(o,n,w,G):void 0;E=Uy(u,$,e,c,h,p,a,g,n),D=4*i.length;const f=t.iconSizeData;let d=null;"source"===f.kind?(d=[am*l.layout.get("icon-size").evaluate(b,{},A)],d[0]>Fy&&j(`${t.layerIds[0]}: Value for "icon-size" is >= ${Ly}. Reduce your "icon-size".`)):"composite"===f.kind&&(d=[am*_.compositeIconSizes[0].evaluate(b,{},A),am*_.compositeIconSizes[1].evaluate(b,{},A)],(d[0]>Fy||d[1]>Fy)&&j(`${t.layerIds[0]}: Value for "icon-size" is >= ${Ly}. Reduce your "icon-size".`)),t.addSymbols(t.icon,i,d,v,x,b,!1,r,e,k.lineStartIndex,k.lineLength,-1,M,A,S,I),N=t.icon.placedSymbolArray.length-1,s&&(V=4*s.length,t.addSymbols(t.icon,s,d,v,x,b,jm.vertical,r,e,k.lineStartIndex,k.lineLength,-1,M,A,S,I),O=t.icon.placedSymbolArray.length-1);}for(const n in i.horizontal){const a=i.horizontal[n];P||(q=ho(a.text),d?B=jy(a):P=Uy(u,$,e,c,h,p,a,f,l.layout.get("text-rotate").evaluate(b,{},A),m));const o=1===a.positionedLines.length;if(L+=Ny(t,r,e,a,s,l,d,b,m,k,i.vertical?jm.horizontal:jm.horizontalOnly,o?Object.keys(i.horizontal):[n],U,N,_,M,A,S),o)break}i.vertical&&(F+=Ny(t,r,e,i.vertical,s,l,d,b,m,k,jm.vertical,["vertical"],U,O,_,M,A,S));let Z=-1;const K=(t,e)=>t?Math.max(t,e):e;Z=K(B,Z),Z=K(C,Z),Z=K(R,Z);const H=Z>-1?1:0;t.glyphOffsetArray.length>=65535&&j("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),void 0!==b.sortKey&&t.addToSortKeyRanges(t.symbolInstances.length,b.sortKey),t.symbolInstances.emplaceBack(e.x,e.y,$.x,$.y,$.z,U.right>=0?U.right:-1,U.center>=0?U.center:-1,U.left>=0?U.left:-1,U.vertical>=0?U.vertical:-1,N,O,q,void 0!==P?P:t.collisionBoxArray.length,void 0!==P?P+1:t.collisionBoxArray.length,void 0!==z?z:t.collisionBoxArray.length,void 0!==z?z+1:t.collisionBoxArray.length,void 0!==E?E:t.collisionBoxArray.length,void 0!==E?E+1:t.collisionBoxArray.length,T||t.collisionBoxArray.length,T?T+1:t.collisionBoxArray.length,c,L,F,D,V,H,0,Y,X,Z,0,G?1:0);}(t,o,y,s,r,n,i,V,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,S,P,l,0,I,E,g,e,a,u,c,h,f,d);};if("line"===z)for(const i of hy(e.geometry,0,0,Tr,Tr)){const e=uy(i,A,k,r.vertical||x,n,_,M,t.overscaling,Tr);for(const r of e)x&&qy(t,x.text,T,r)||L(i,r,h);}else if("line-center"===z){for(const t of e.geometry)if(t.length>1){const e=ly(t,k,r.vertical||x,n,_,M);e&&L(t,e,h);}}else if("Polygon"===e.type)for(const t of nf(e.geometry,0)){const e=Ey(t,16);L(t[0],new ny(e.x,e.y,0,0,void 0),h);}else if("LineString"===e.type)for(const t of e.geometry)L(t,new ny(t[0].x,t[0].y,0,0,void 0),h);else if("Point"===e.type)for(const t of e.geometry)for(const e of t)L([e],new ny(e.x,e.y,0,0,void 0),h);}const Ly=255,Fy=Ly*am;function Ny(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m,y,x){const v=function(t,e,r,n,i,a,s,o){const l=[];if(0===e.positionedLines.length)return l;const u=n.layout.get("text-rotate").evaluate(a,{})*Math.PI/180,c=function(t){const e=t[0],r=t[1],n=e*r;return n>0?[e,-r]:n<0?[-e,r]:0===e?[r,e]:[r,-e]}(r);let h=Math.abs(e.top-e.bottom);for(const t of e.positionedLines)h-=t.lineOffset;const p=e.positionedLines.length,f=h/p;let d=e.top-r[1];for(let t=0;t<p;++t){const n=e.positionedLines[t];d=Py(e,f,d,t);for(const t of n.positionedGlyphs){if(!t.rect)continue;const n=t.rect||{};let a=Um+1,h=!0,p=1,f=0;if(t.imageName){const e=s[t.imageName];if(!e)continue;if(e.sdf){j("SDF images are not supported in formatted text and will be ignored.");continue}h=!1,p=e.pixelRatio,a=fy/p;}const m=(i||o)&&t.vertical,y=t.metrics.advance*t.scale/2,x=t.metrics,v=t.rect;if(null===v)continue;o&&e.verticalizable&&(f=t.imageName?y-t.metrics.width*t.scale/2:0);const b=i?[t.x+y,t.y]:[0,0];let _=[0,0],w=[0,0],M=!1;i||(m?(w=[t.x+y+c[0],t.y+c[1]-f],M=!0):_=[t.x+y+r[0],t.y+r[1]-f]);const A=v.w*t.scale/(p*(t.localGlyph?vy:1)),S=v.h*t.scale/(p*(t.localGlyph?vy:1));let I,k,P,E;if(m){const e=t.y-d,r=new g(-y,y-e),n=-Math.PI/2,i=new g(...w);I=new g(-y+_[0],_[1]),I._rotateAround(n,r)._add(i),I.x+=-e+y,I.y-=(x.left-a)*t.scale;const s=t.imageName?x.advance*t.scale:im*t.scale,o=String.fromCodePoint(t.glyph);pm(o)?I.x+=(1-a)*t.scale:fm(o)?I.x+=s-x.height*t.scale+(-a-1)*t.scale:I.x+=t.imageName||x.width+2*a===v.w&&x.height+2*a===v.h?(s-S)/2:(s-(x.height+2*a)*t.scale)/2,k=new g(I.x,I.y-A),P=new g(I.x+S,I.y),E=new g(I.x+S,I.y-A);}else {const e=(x.left-a)*t.scale-y+_[0],r=(-x.top-a)*t.scale+_[1],n=e+A,i=r+S;I=new g(e,r),k=new g(n,r),P=new g(e,i),E=new g(n,i);}if(u){let t;t=i?new g(0,0):M?new g(c[0],c[1]):new g(r[0],r[1]),I._rotateAround(u,t),k._rotateAround(u,t),P._rotateAround(u,t),E._rotateAround(u,t);}const z=new g(0,0),T=new g(0,0);l.push({tl:I,tr:k,bl:P,br:E,texPrimary:n,texSecondary:void 0,writingMode:e.writingMode,glyphOffset:b,sectionIndex:t.sectionIndex,isSDF:h,pixelOffsetTL:z,pixelOffsetBR:T,minFontScaleX:0,minFontScaleY:0});}}return l}(0,n,l,a,s,o,i,t.allowVerticalPlacement),b=t.textSizeData;let _=null;"source"===b.kind?(_=[am*a.layout.get("text-size").evaluate(o,{},y)],_[0]>Fy&&j(`${t.layerIds[0]}: Value for "text-size" is >= ${Ly}. Reduce your "text-size".`)):"composite"===b.kind&&(_=[am*d.compositeTextSizes[0].evaluate(o,{},y),am*d.compositeTextSizes[1].evaluate(o,{},y)],(_[0]>Fy||_[1]>Fy)&&j(`${t.layerIds[0]}: Value for "text-size" is >= ${Ly}. Reduce your "text-size".`)),t.addSymbols(t.text,v,_,l,s,o,c,e,r,u.lineStartIndex,u.lineLength,f,m,y,x,!1);for(const e of h)p[e]=t.text.placedSymbolArray.length-1;return 4*v.length}function Oy(t){for(const e in t)return t[e];return null}function Uy(t,e,r,n,i,a,s,o,l,u){let c=s.top,h=s.bottom,p=s.left,f=s.right;const d=s.collisionPadding;if(d&&(p-=d[0],c-=d[1],f+=d[2],h+=d[3]),l){const t=new g(p,c),e=new g(f,c),r=new g(p,h),n=new g(f,h),i=b(l);let a=new g(0,0);u&&(a=new g(u[0],u[1])),t._rotateAround(i,a),e._rotateAround(i,a),r._rotateAround(i,a),n._rotateAround(i,a),p=Math.min(t.x,e.x,r.x,n.x),f=Math.max(t.x,e.x,r.x,n.x),c=Math.min(t.y,e.y,r.y,n.y),h=Math.max(t.y,e.y,r.y,n.y);}return t.emplaceBack(e.x,e.y,e.z,r.x,r.y,p,c,f,h,o,n,i,a),t.length-1}function jy(t){t.collisionPadding&&(t.top-=t.collisionPadding[1],t.bottom+=t.collisionPadding[3]);const e=t.bottom-t.top;return e>0?Math.max(10,e):null}function qy(t,e,r,n){const i=t.compareText;if(e in i){const t=i[e];for(let e=t.length-1;e>=0;e--)if(n.dist(t[e])<r)return !0}else i[e]=[];return i[e].push(n),!1}function $y(t,e){const r=t.fovAboveCenter,n=t.elevation?t.elevation.getMinElevationBelowMSL()*e:0,i=(t._camera.position[2]*t.worldSize-n)/Math.cos(t._pitch),a=Math.sin(r)*i/Math.sin(Math.max(Math.PI/2-t._pitch-r,.01)),s=Math.sin(t._pitch)*a+i;return Math.min(1.01*s,i*(1/t._horizonShift))}function Gy(t,e){if(!e.isReprojectedInTileSpace)return {scale:1<<t.z,x:t.x,y:t.y,x2:t.x+1,y2:t.y+1,projection:e};const r=Math.pow(2,-t.z),n=t.x*r,i=(t.x+1)*r,a=t.y*r,s=(t.y+1)*r,o=ml(n),l=ml(i),u=yl(a),c=yl(s),h=e.project(o,u),p=e.project(l,u),f=e.project(l,c),d=e.project(o,c);let m=Math.min(h.x,p.x,f.x,d.x),y=Math.min(h.y,p.y,f.y,d.y),g=Math.max(h.x,p.x,f.x,d.x),x=Math.max(h.y,p.y,f.y,d.y);const v=r/16;function b(t,r,n,i,a,s){const o=(n+a)/2,l=(i+s)/2,u=e.project(ml(o),yl(l)),c=Math.max(0,m-u.x,y-u.y,u.x-g,u.y-x);m=Math.min(m,u.x),g=Math.max(g,u.x),y=Math.min(y,u.y),x=Math.max(x,u.y),c>v&&(b(t,u,n,i,o,l),b(u,r,o,l,a,s));}b(h,p,n,a,i,a),b(p,f,i,a,i,s),b(f,d,i,s,n,s),b(d,h,n,s,n,a),m-=v,y-=v,g+=v,x+=v;const _=1/Math.max(g-m,x-y);return {scale:_,x:m*_,y:y*_,x2:g*_,y2:x*_,projection:e}}function Yy(t,{x:e,y:r},n=0){return new g(((e-n)*t.scale-t.x)*Tr,(r*t.scale-t.y)*Tr)}const Xy=t.a6.identity(new Float32Array(16));class Zy{constructor(t){this.spec=t,this.name=t.name,this.wrap=!1,this.requiresDraping=!1,this.supportsWorldCopies=!1,this.supportsTerrain=!1,this.supportsFog=!1,this.supportsFreeCamera=!1,this.zAxisUnit="meters",this.isReprojectedInTileSpace=!0,this.unsupportedLayers=["custom"],this.center=[0,0],this.range=[3.5,7];}project(t,e){return {x:0,y:0,z:0}}unproject(t,e){return new tl(0,0)}projectTilePoint(t,e,r){return {x:t,y:e,z:0}}locationPoint(t,e,r=!0){return t._coordinatePoint(t.locationCoordinate(e),r)}pixelsPerMeter(t,e){return dl(1,t)*e}pixelSpaceConversion(t,e,r){return 1}farthestPixelDistance(t){return $y(t,t.pixelsPerMeter)}pointCoordinate(t,e,r,n){const i=t.horizonLineFromTop(!1),a=new g(e,Math.max(i,r));return t.rayIntersectionCoordinate(t.pointRayIntersection(a,n))}pointCoordinate3D(t,e,r){const n=new g(e,r);if(t.elevation)return t.elevation.pointCoordinate(n);{const e=this.pointCoordinate(t,n.x,n.y,0);return [e.x,e.y,e.z]}}isPointAboveHorizon(t,e){if(t.elevation)return !this.pointCoordinate3D(t,e.x,e.y);const r=t.horizonLineFromTop();return e.y<r}createInversionMatrix(t,e){return Xy}createTileMatrix(e,r,n){let i,a,s;const o=n.canonical,l=t.a6.identity(new Float64Array(16));if(this.isReprojectedInTileSpace){const u=Gy(o,this);i=1,a=u.x+n.wrap*u.scale,s=u.y,t.a6.scale(l,l,[i/u.scale,i/u.scale,e.pixelsPerMeter/r]);}else i=r/e.zoomScale(o.z),a=(o.x+Math.pow(2,o.z)*n.wrap)*i,s=o.y*i;return t.a6.translate(l,l,[a,s,0]),t.a6.scale(l,l,[i/Tr,i/Tr,1]),l}upVector(t,e,r){return [0,0,1]}upVectorScale(t,e,r){return {metersToTile:1}}}class Ky extends Zy{constructor(t){super(t),this.range=[4,7],this.center=t.center||[-96,37.5];const[e,r]=this.parallels=t.parallels||[29.5,45.5],n=Math.sin(b(e));this.n=(n+Math.sin(b(r)))/2,this.c=1+n*(2*this.n-n),this.r0=Math.sqrt(this.c)/this.n;}project(t,e){const{n:r,c:n,r0:i}=this,a=b(t-this.center[0]),s=b(e),o=Math.sqrt(n-2*r*Math.sin(s))/r;return {x:o*Math.sin(a*r),y:o*Math.cos(a*r)-i,z:0}}unproject(t,e){const{n:r,c:n,r0:i}=this,a=i+e;let s=Math.atan2(t,Math.abs(a))*Math.sign(a);a*r<0&&(s-=Math.PI*Math.sign(t)*Math.sign(a));const o=b(this.center[0])*r;s=P(s,-Math.PI-o,Math.PI-o);const l=I(_(s/r)+this.center[0],-180,180),u=Math.asin(I((n-(t*t+a*a)*r*r)/(2*r),-1,1)),c=I(_(u),-xl,xl);return new tl(l,c)}}const Hy=1.340264,Wy=-.081106,Jy=893e-6,Qy=.003796,tg=Math.sqrt(3)/2;class eg extends Zy{project(t,e){e=e/180*Math.PI,t=t/180*Math.PI;const r=Math.asin(tg*Math.sin(e)),n=r*r,i=n*n*n;return {x:.5*(t*Math.cos(r)/(tg*(Hy+3*Wy*n+i*(7*Jy+9*Qy*n)))/Math.PI+.5),y:1-.5*(r*(Hy+Wy*n+i*(Jy+Qy*n))/Math.PI+1),z:0}}unproject(t,e){t=(2*t-.5)*Math.PI;let r=e=(2*(1-e)-1)*Math.PI,n=r*r,i=n*n*n;for(let t,a,s,o=0;o<12&&(a=r*(Hy+Wy*n+i*(Jy+Qy*n))-e,s=Hy+3*Wy*n+i*(7*Jy+9*Qy*n),t=a/s,r=I(r-t,-Math.PI/3,Math.PI/3),n=r*r,i=n*n*n,!(Math.abs(t)<1e-12));++o);const a=tg*t*(Hy+3*Wy*n+i*(7*Jy+9*Qy*n))/Math.cos(r),s=Math.asin(Math.sin(r)/tg),o=I(180*a/Math.PI,-180,180),l=I(180*s/Math.PI,-xl,xl);return new tl(o,l)}}class rg extends Zy{constructor(t){super(t),this.wrap=!0,this.supportsWorldCopies=!0;}project(t,e){return {x:.5+t/360,y:.5-e/360,z:0}}unproject(t,e){const r=360*(t-.5),n=I(360*(.5-e),-xl,xl);return new tl(r,n)}}const ng=Math.PI/2;function ig(t){return Math.tan((ng+t)/2)}class ag extends Zy{constructor(t){super(t),this.center=t.center||[0,30];const[e,r]=this.parallels=t.parallels||[30,30];let n=b(e),i=b(r);this.southernCenter=n+i<0,this.southernCenter&&(n=-n,i=-i);const a=Math.cos(n),s=ig(n);this.n=n===i?Math.sin(n):Math.log(a/Math.cos(i))/Math.log(ig(i)/s),this.f=a*Math.pow(ig(n),this.n)/this.n;}project(t,e){e=b(e),this.southernCenter&&(e=-e),t=b(t-this.center[0]);const r=1e-6,{n:n,f:i}=this;i>0?e<-ng+r&&(e=-ng+r):e>ng-r&&(e=ng-r);const a=i/Math.pow(ig(e),n);let s=a*Math.sin(n*t),o=i-a*Math.cos(n*t);return s=.5*(s/Math.PI+.5),o=.5*(o/Math.PI+.5),{x:s,y:this.southernCenter?o:1-o,z:0}}unproject(t,e){t=(2*t-.5)*Math.PI,this.southernCenter&&(e=1-e),e=(2*(1-e)-.5)*Math.PI;const{n:r,f:n}=this,i=n-e,a=Math.sign(i),s=Math.sign(r)*Math.sqrt(t*t+i*i);let o=Math.atan2(t,Math.abs(i))*a;i*r<0&&(o-=Math.PI*Math.sign(t)*a);const l=I(_(o/r)+this.center[0],-180,180),u=I(_(2*Math.atan(Math.pow(n/s,1/r))-ng),-xl,xl);return new tl(l,this.southernCenter?-u:u)}}class sg extends Zy{constructor(t){super(t),this.wrap=!0,this.supportsWorldCopies=!0,this.supportsTerrain=!0,this.supportsFog=!0,this.supportsFreeCamera=!0,this.isReprojectedInTileSpace=!1,this.unsupportedLayers=[],this.range=null;}project(t,e){return {x:pl(t),y:fl(e),z:0}}unproject(t,e){const r=ml(t),n=yl(e);return new tl(r,n)}}const og=b(xl);class lg extends Zy{project(t,e){const r=(e=b(e))*e,n=r*r;return {x:.5*((t=b(t))*(.8707-.131979*r+n*(n*(.003971*r-.001529*n)-.013791))/Math.PI+.5),y:1-.5*(e*(1.007226+r*(.015085+n*(.028874*r-.044475-.005916*n)))/Math.PI+1),z:0}}unproject(t,e){t=(2*t-.5)*Math.PI;let r=e=(2*(1-e)-1)*Math.PI,n=25,i=0,a=r*r;do{a=r*r;const t=a*a;i=(r*(1.007226+a*(.015085+t*(.028874*a-.044475-.005916*t)))-e)/(1.007226+a*(.045255+t*(.259866*a-.311325-.005916*11*t))),r=I(r-i,-og,og);}while(Math.abs(i)>1e-6&&--n>0);a=r*r;const s=I(_(t/(.8707+a*(a*(a*a*a*(.003971-.001529*a)-.013791)-.131979))),-180,180),o=_(r);return new tl(s,o)}}const ug=b(xl);class cg extends Zy{project(t,e){e=b(e),t=b(t);const r=Math.cos(e),n=2/Math.PI,i=Math.acos(r*Math.cos(t/2)),a=Math.sin(i)/i,s=.5*(t*n+2*r*Math.sin(t/2)/a)||0,o=.5*(e+Math.sin(e)/a)||0;return {x:.5*(s/Math.PI+.5),y:1-.5*(o/Math.PI+1),z:0}}unproject(t,e){let r=t=(2*t-.5)*Math.PI,n=e=(2*(1-e)-1)*Math.PI,i=25;const a=1e-6;let s=0,o=0;do{const i=Math.cos(n),a=Math.sin(n),l=2*a*i,u=a*a,c=i*i,h=Math.cos(r/2),p=Math.sin(r/2),f=2*h*p,d=p*p,m=1-c*h*h,y=m?1/m:0,g=m?Math.acos(i*h)*Math.sqrt(1/m):0,x=.5*(2*g*i*p+2*r/Math.PI)-t,v=.5*(g*a+n)-e,b=.5*y*(c*d+g*i*h*u)+1/Math.PI,_=y*(f*l/4-g*a*p),w=.125*y*(l*p-g*a*c*f),M=.5*y*(u*h+g*d*i)+.5,A=_*w-M*b;s=(v*_-x*M)/A,o=(x*w-v*b)/A,r=I(r-s,-Math.PI,Math.PI),n=I(n-o,-ug,ug);}while((Math.abs(s)>a||Math.abs(o)>a)&&--i>0);return new tl(_(r),_(n))}}class hg extends Zy{constructor(t){super(t),this.center=t.center||[0,0],this.parallels=t.parallels||[0,0],this.cosPhi=Math.max(.01,Math.cos(b(this.parallels[0]))),this.scale=1/(2*Math.max(Math.PI*this.cosPhi,1/this.cosPhi)),this.wrap=!0,this.supportsWorldCopies=!0;}project(t,e){const{scale:r,cosPhi:n}=this;return {x:b(t)*n*r+.5,y:-Math.sin(b(e))/n*r+.5,z:0}}unproject(t,e){const{scale:r,cosPhi:n}=this,i=-(e-.5)/r,a=I(_((t-.5)/r)/n,-180,180),s=Math.asin(I(i*n,-1,1)),o=I(_(s),-xl,xl);return new tl(a,o)}}class pg extends sg{constructor(t){super(t),this.requiresDraping=!0,this.supportsWorldCopies=!1,this.supportsFog=!0,this.zAxisUnit="pixels",this.unsupportedLayers=["debug"],this.range=[3,5];}projectTilePoint(e,r,n){const i=Zh(e,r,n),a=Wh(jh(n));return t.N.transformMat4(i,i,a),{x:i[0],y:i[1],z:i[2]}}locationPoint(e,r){const n=Wo(r.lat,r.lng),i=t.N.normalize([],n),a=e.elevation?e.elevation.getAtPointOrZero(e.locationCoordinate(r),e._centerAltitude):e._centerAltitude,s=dl(1,0)*Tr*a;t.N.scaleAndAdd(n,n,i,s);const o=t.a6.identity(new Float64Array(16));return t.a6.multiply(o,e.pixelMatrix,e.globeMatrix),t.N.transformMat4(n,n,o),new g(n[0],n[1])}pixelsPerMeter(t,e){return dl(1,0)*e}pixelSpaceConversion(t,e,r){const n=dl(1,t)*e,i=ue(dl(1,45)*e,n,r);return this.pixelsPerMeter(t,e)/i}createTileMatrix(e,r,n){const i=Jh(jh(n.canonical));return t.a6.multiply(new Float64Array(16),e.globeMatrix,i)}createInversionMatrix(e,r){const{center:n}=e,i=Wh(jh(r));return t.a6.rotateY(i,i,b(n.lng)),t.a6.rotateX(i,i,b(n.lat)),t.a6.scale(i,i,[e._pixelsPerMercatorPixel,e._pixelsPerMercatorPixel,1]),Float32Array.from(i)}pointCoordinate(t,e,r,n){return Nh(t,e,r,!0)||new Ml(0,0)}pointCoordinate3D(t,e,r){const n=this.pointCoordinate(t,e,r,0);return [n.x,n.y,n.z]}isPointAboveHorizon(t,e){return !Nh(t,e.x,e.y,!1)}farthestPixelDistance(e){const r=function(e,r){const n=e.cameraToCenterDistance,i=e._centerAltitude*r,a=e._camera,s=e._camera.forward(),o=t.N.add([],t.N.scale([],s,-n),[0,0,i]),l=e.worldSize/(2*Math.PI),u=[0,0,-l],c=e.width/e.height,h=Math.tan(e.fovAboveCenter),p=t.N.scale([],a.up(),h),f=t.N.scale([],a.right(),h*c),d=t.N.normalize([],t.N.add([],t.N.add([],s,p),f)),m=[];let y;if(new Sh(o,d).closestPointOnSphere(u,l,m)){const r=t.N.add([],m,u),n=t.N.sub([],r,o);y=Math.cos(e.fovAboveCenter)*t.N.length(n);}else {const e=t.N.sub([],o,u),r=t.N.sub([],u,o);t.N.normalize(r,r);const n=t.N.length(e)-l;y=Math.sqrt(n*(n+2*l));const i=Math.acos(y/(l+n))-Math.acos(t.N.dot(s,r));y*=Math.cos(i);}return 1.01*y}(e,this.pixelsPerMeter(e.center.lat,e.worldSize)),n=rp(e.zoom);if(n>0){const t=$y(e,dl(1,e.center.lat)*e.worldSize),i=e.worldSize/(2*Math.PI),a=Math.max(e.width,e.height)/e.worldSize*Math.PI;return ue(r,t+i*(1-Math.cos(a)),Math.pow(n,10))}return r}upVector(t,e,r){return Zh(e,r,t,1)}upVectorScale(t){return {metersToTile:Lh(Kh(jh(t)))}}}function fg(t){const e=t.parallels,r=!!e&&Math.abs(e[0]+e[1])<.01;switch(t.name){case"mercator":return new sg(t);case"equirectangular":return new rg(t);case"naturalEarth":return new lg(t);case"equalEarth":return new eg(t);case"winkelTripel":return new cg(t);case"albers":return r?new hg(t):new Ky(t);case"lambertConformalConic":return r?new hg(t):new ag(t);case"globe":return new pg(t)}throw new Error(`Invalid projection name: ${t.name}`)}const dg=zf.types,mg=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function yg(t,e,r,n,i,a,s,o,l,u,c,h,p){const f=o?Math.min(Fy,Math.round(o[0])):0,d=o?Math.min(Fy,Math.round(o[1])):0;t.emplaceBack(e,r,Math.round(32*n),Math.round(32*i),a,s,(f<<1)+(l?1:0),d,16*u,16*c,256*h,256*p);}function gg(t,e,r){t.emplaceBack(e,r);}function xg(t,e,r,n,i,a,s){t.emplaceBack(e,r,n,i,a,s);}function vg(t,e,r,n,i){t.emplaceBack(e,r,n,i),t.emplaceBack(e,r,n,i),t.emplaceBack(e,r,n,i),t.emplaceBack(e,r,n,i);}function bg(t){for(const e of t.sections)if(ma(e.text))return !0;return !1}class _g{constructor(t){this.layoutVertexArray=new _s,this.indexArray=new Es,this.programConfigurations=t,this.segments=new eo,this.dynamicLayoutVertexArray=new gs,this.opacityVertexArray=new Ms,this.placedSymbolArray=new Gs,this.iconTransitioningVertexArray=new As,this.globeExtVertexArray=new ws,this.zOffsetVertexArray=new Bs;}isEmpty(){return 0===this.layoutVertexArray.length&&0===this.indexArray.length&&0===this.dynamicLayoutVertexArray.length&&0===this.opacityVertexArray.length&&0===this.iconTransitioningVertexArray.length}upload(t,e,r,n,i){this.isEmpty()||(r&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Kd.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,e),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,Wd.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,mg,!0),this.iconTransitioningVertexArray.length>0&&(this.iconTransitioningVertexBuffer=t.createVertexBuffer(this.iconTransitioningVertexArray,Qd.members,!0)),this.globeExtVertexArray.length>0&&(this.globeExtVertexBuffer=t.createVertexBuffer(this.globeExtVertexArray,Hd.members,!0)),!this.zOffsetVertexBuffer&&(this.zOffsetVertexArray.length>0||i)&&(this.zOffsetVertexBuffer=t.createVertexBuffer(this.zOffsetVertexArray,Jd.members,!0)),this.opacityVertexBuffer.itemSize=1),(r||n)&&this.programConfigurations.upload(t));}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy(),this.iconTransitioningVertexBuffer&&this.iconTransitioningVertexBuffer.destroy(),this.globeExtVertexBuffer&&this.globeExtVertexBuffer.destroy(),this.zOffsetVertexBuffer&&this.zOffsetVertexBuffer.destroy());}}ra(_g,"SymbolBuffers");class wg{constructor(t,e,r){this.layoutVertexArray=new t,this.layoutAttributes=e,this.indexArray=new r,this.segments=new eo,this.collisionVertexArray=new Ps,this.collisionVertexArrayExt=new gs;}upload(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,tm.members,!0),this.collisionVertexBufferExt=t.createVertexBuffer(this.collisionVertexArrayExt,em.members,!0);}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy(),this.collisionVertexBufferExt.destroy());}}ra(wg,"CollisionBuffers");class Mg{constructor(e){this.collisionBoxArray=e.collisionBoxArray,this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map((t=>t.fqid)),this.index=e.index,this.pixelRatio=e.pixelRatio,this.sourceLayerIndex=e.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.fullyClipped=!1,this.hasAnyIconTextFit=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=t.a6.identity([]),this.placementViewportMatrix=t.a6.identity([]);const r=this.layers[0]._unevaluatedLayout._values;this.textSizeData=sm(this.zoom,r["text-size"]),this.iconSizeData=sm(this.zoom,r["icon-size"]);const n=this.layers[0].layout,i=n.get("symbol-sort-key"),a=n.get("symbol-z-order");this.canOverlap=n.get("text-allow-overlap")||n.get("icon-allow-overlap")||n.get("text-ignore-placement")||n.get("icon-ignore-placement"),this.sortFeaturesByKey="viewport-y"!==a&&void 0!==i.constantOr(1),this.sortFeaturesByY=("viewport-y"===a||"auto"===a&&!this.sortFeaturesByKey)&&this.canOverlap,this.writingModes=n.get("text-writing-mode").map((t=>jm[t])),this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.sourceID=e.sourceID,this.projection=e.projection,this.hasAnyZOffset=!1,this.zOffsetSortDirty=!1,this.zOffsetBuffersNeedUpload=n.get("symbol-z-elevate");}createArrays(){this.text=new _g(new Vo(this.layers,this.zoom,(t=>/^text/.test(t)))),this.icon=new _g(new Vo(this.layers,this.zoom,(t=>/^icon/.test(t)))),this.glyphOffsetArray=new Zs,this.lineVertexArray=new Ks,this.symbolInstances=new Xs;}calculateGlyphDependencies(t,e,r,n,i){for(let r=0;r<t.length;r++){const a=t.codePointAt(r);if(void 0===a)break;if(e[a]=!0,n&&i&&a<=65535){const n=hm[t.charAt(r)];n&&(e[n.charCodeAt(0)]=!0);}}}populate(e,r,n,i){const a=this.layers[0],s=a.layout,o="globe"===this.projection.name,l=s.get("text-font"),u=s.get("text-field"),c=s.get("icon-image"),h=("constant"!==u.value.kind||u.value.value instanceof De&&!u.value.value.isEmpty()||u.value.value.toString().length>0)&&("constant"!==l.value.kind||l.value.value.length>0),p="constant"!==c.value.kind||!!c.value.value||Object.keys(c.parameters).length>0,f=s.get("symbol-sort-key");if(this.features=[],!h&&!p)return;const d=r.iconDependencies,m=r.glyphDependencies,y=r.availableImages,g=new Pa(this.zoom);for(const{feature:r,id:u,index:c,sourceLayerIndex:x}of e){const e=a._featureFilter.needGeometry,v=Bl(r,e);if(!a._featureFilter.filter(g,v,n))continue;if(e||(v.geometry=Tl(r,n,i)),o&&1!==r.type&&n.z<=5){const e=v.geometry,r=.98078528056,i=(e,i)=>{const a=Zh(e.x,e.y,n,1),s=Zh(i.x,i.y,n,1);return t.N.dot(a,s)<r};for(let t=0;t<e.length;t++)e[t]=kl(e[t],i);}let b,_;if(h){const t=a.getValueAndResolveTokens("text-field",v,n,y),e=De.factory(t);bg(e)&&(this.hasRTLText=!0),(!this.hasRTLText||"unavailable"===Sa()||this.hasRTLText&&ka.isParsed())&&(b=cm(e,a,v));}if(p){const t=a.getValueAndResolveTokens("icon-image",v,n,y);_=t instanceof Ve?t:Ve.fromString(t);}if(!b&&!_)continue;const w=this.sortFeaturesByKey?f.evaluate(v,{},n):void 0;if(this.features.push({id:u,text:b,icon:_,index:c,sourceLayerIndex:x,geometry:v.geometry,properties:r.properties,type:dg[r.type],sortKey:w}),_&&(d[_.namePrimary]=!0,_.nameSecondary&&(d[_.nameSecondary]=!0)),b){const t=l.evaluate(v,{},n).join(","),e="map"===s.get("text-rotation-alignment")&&"point"!==s.get("symbol-placement");this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(jm.vertical)>=0;for(const r of b.sections)if(r.image)d[r.image.namePrimary]=!0;else {const n=la(b.toString()),i=r.fontStack||t,a=m[i]=m[i]||{};this.calculateGlyphDependencies(r.text,a,e,this.allowVerticalPlacement,n);}}}"line"===s.get("symbol-placement")&&(this.features=function(t){const e={},r={},n=[];let i=0;function a(e){n.push(t[e]),i++;}function s(t,e,i){const a=r[t];return delete r[t],r[e]=a,n[a].geometry[0].pop(),n[a].geometry[0]=n[a].geometry[0].concat(i[0]),a}function o(t,r,i){const a=e[r];return delete e[r],e[t]=a,n[a].geometry[0].shift(),n[a].geometry[0]=i[0].concat(n[a].geometry[0]),a}function l(t,e,r){const n=r?e[0][e[0].length-1]:e[0][0];return `${t}:${n.x}:${n.y}`}for(let u=0;u<t.length;u++){const c=t[u],h=c.geometry,p=c.text?c.text.toString():null;if(!p){a(u);continue}const f=l(p,h),d=l(p,h,!0);if(f in r&&d in e&&r[f]!==e[d]){const t=o(f,d,h),i=s(f,d,n[t].geometry);delete e[f],delete r[d],r[l(p,n[i].geometry,!0)]=i,n[t].geometry=null;}else f in r?s(f,d,h):d in e?o(f,d,h):(a(u),e[f]=i-1,r[d]=i-1);}return n.filter((t=>t.geometry))}(this.features)),this.sortFeaturesByKey&&this.features.sort(((t,e)=>t.sortKey-e.sortKey));}update(t,e,r,n,i){const a=0!==Object.keys(t).length;if(a&&!this.stateDependentLayers.length)return;const s=a?this.stateDependentLayers:this.layers;this.text.programConfigurations.updatePaintArrays(t,e,s,r,n,i),this.icon.programConfigurations.updatePaintArrays(t,e,s,r,n,i);}updateZOffset(){const t=(t,e,n)=>{r+=e,r>t.length&&t.resize(r);for(let i=-e;i<0;i++)t.emplace(i+r,n);},e=(t,e,r)=>{n+=e,n>t.length&&t.resize(n);for(let i=-e;i<0;i++)t.emplace(i+n,r);};if(!this.zOffsetBuffersNeedUpload)return;this.zOffsetBuffersNeedUpload=!1;let r=0,n=0;for(let r=0;r<this.symbolInstances.length;r++){const n=this.symbolInstances.get(r),{numHorizontalGlyphVertices:i,numVerticalGlyphVertices:a,numIconVertices:s}=n,o=n.zOffset,l=s>0;if((i>0||a>0)&&(t(this.text.zOffsetVertexArray,i,o),t(this.text.zOffsetVertexArray,a,o)),l){const{placedIconSymbolIndex:t,verticalPlacedIconSymbolIndex:r}=n;t>=0&&e(this.icon.zOffsetVertexArray,s,o),r>=0&&e(this.icon.zOffsetVertexArray,n.numVerticalIconVertices,o);}}this.text.zOffsetVertexBuffer&&this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray),this.icon.zOffsetVertexBuffer&&this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);}isEmpty(){return 0===this.symbolInstances.length&&!this.hasRTLText}uploadPending(){return !this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload,this.zOffsetBuffersNeedUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload,this.zOffsetBuffersNeedUpload),this.uploaded=!0;}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy();}getProjection(){return this.projectionInstance||(this.projectionInstance=fg(this.projection)),this.projectionInstance}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData();}addToLineVertexArray(t,e){const r=this.lineVertexArray.length;if(void 0!==t.segment)for(const{x:t,y:r}of e)this.lineVertexArray.emplaceBack(t,r);return {lineStartIndex:r,lineLength:this.lineVertexArray.length-r}}addSymbols(t,e,r,n,i,a,s,o,l,u,c,h,p,f,d,m){const y=t.indexArray,g=t.layoutVertexArray,x=t.globeExtVertexArray,v=t.segments.prepareSegment(4*e.length,g,y,this.canOverlap?a.sortKey:void 0),b=this.glyphOffsetArray.length,_=v.vertexLength,w=this.allowVerticalPlacement&&s===jm.vertical?Math.PI/2:0,M=a.text&&a.text.sections;for(let n=0;n<e.length;n++){const{tl:i,tr:s,bl:u,br:c,texPrimary:h,texSecondary:b,pixelOffsetTL:_,pixelOffsetBR:A,minFontScaleX:S,minFontScaleY:I,glyphOffset:k,isSDF:P,sectionIndex:E}=e[n],z=v.vertexLength,T=k[1];if(yg(g,l.x,l.y,i.x,T+i.y,h.x,h.y,r,P,_.x,_.y,S,I),yg(g,l.x,l.y,s.x,T+s.y,h.x+h.w,h.y,r,P,A.x,_.y,S,I),yg(g,l.x,l.y,u.x,T+u.y,h.x,h.y+h.h,r,P,_.x,A.y,S,I),yg(g,l.x,l.y,c.x,T+c.y,h.x+h.w,h.y+h.h,r,P,A.x,A.y,S,I),o){const{x:e,y:r,z:n}=o.anchor,[i,a,s]=o.up;xg(x,e,r,n,i,a,s),xg(x,e,r,n,i,a,s),xg(x,e,r,n,i,a,s),xg(x,e,r,n,i,a,s),vg(t.dynamicLayoutVertexArray,e,r,n,w);}else vg(t.dynamicLayoutVertexArray,l.x,l.y,l.z,w);if(m){const e=b||h;gg(t.iconTransitioningVertexArray,e.x,e.y),gg(t.iconTransitioningVertexArray,e.x+e.w,e.y),gg(t.iconTransitioningVertexArray,e.x,e.y+e.h),gg(t.iconTransitioningVertexArray,e.x+e.w,e.y+e.h);}y.emplaceBack(z,z+1,z+2),y.emplaceBack(z+1,z+2,z+3),v.vertexLength+=4,v.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(k[0]),n!==e.length-1&&E===e[n+1].sectionIndex||t.programConfigurations.populatePaintArrays(g.length,a,a.index,{},p,f,d,M&&M[E]);}const A=o?o.anchor:l;t.placedSymbolArray.emplaceBack(A.x,A.y,A.z,l.x,l.y,b,this.glyphOffsetArray.length-b,_,u,c,l.segment,r?r[0]:0,r?r[1]:0,n[0],n[1],s,0,!1,0,h,0);}_commitLayoutVertex(t,e,r,n,i,a,s){t.emplaceBack(e,r,n,i,a,Math.round(s.x),Math.round(s.y));}_addCollisionDebugVertices(t,e,r,n,i,a,s){const o=r.segments.prepareSegment(4,r.layoutVertexArray,r.indexArray),l=o.vertexLength,u=s.tileAnchorX,c=s.tileAnchorY;for(let t=0;t<4;t++)r.collisionVertexArray.emplaceBack(0,0,0,0);this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt,e,t.padding,s.zOffset),this._commitLayoutVertex(r.layoutVertexArray,n,i,a,u,c,new g(t.x1,t.y1)),this._commitLayoutVertex(r.layoutVertexArray,n,i,a,u,c,new g(t.x2,t.y1)),this._commitLayoutVertex(r.layoutVertexArray,n,i,a,u,c,new g(t.x2,t.y2)),this._commitLayoutVertex(r.layoutVertexArray,n,i,a,u,c,new g(t.x1,t.y2)),o.vertexLength+=4;const h=r.indexArray;h.emplaceBack(l,l+1),h.emplaceBack(l+1,l+2),h.emplaceBack(l+2,l+3),h.emplaceBack(l+3,l),o.primitiveLength+=4;}_addTextDebugCollisionBoxes(t,e,r,n,i,a){for(let s=n;s<i;s++){const n=r.get(s),i=this.getSymbolInstanceTextSize(t,a,e,s);this._addCollisionDebugVertices(n,i,this.textCollisionBox,n.projectedAnchorX,n.projectedAnchorY,n.projectedAnchorZ,a);}}_addIconDebugCollisionBoxes(t,e,r,n,i,a){for(let s=n;s<i;s++){const n=r.get(s),i=this.getSymbolInstanceIconSize(t,e,a.placedIconSymbolIndex);this._addCollisionDebugVertices(n,i,this.iconCollisionBox,n.projectedAnchorX,n.projectedAnchorY,n.projectedAnchorZ,a);}}generateCollisionDebugBuffers(t,e){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new wg(Is,rm.members,As),this.iconCollisionBox=new wg(Is,rm.members,As);const r=lm(this.iconSizeData,t),n=lm(this.textSizeData,t);for(let i=0;i<this.symbolInstances.length;i++){const a=this.symbolInstances.get(i);this._addTextDebugCollisionBoxes(n,t,e,a.textBoxStartIndex,a.textBoxEndIndex,a),this._addTextDebugCollisionBoxes(n,t,e,a.verticalTextBoxStartIndex,a.verticalTextBoxEndIndex,a),this._addIconDebugCollisionBoxes(r,t,e,a.iconBoxStartIndex,a.iconBoxEndIndex,a),this._addIconDebugCollisionBoxes(r,t,e,a.verticalIconBoxStartIndex,a.verticalIconBoxEndIndex,a);}}getSymbolInstanceTextSize(t,e,r,n){const i=this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex>=0?e.rightJustifiedTextSymbolIndex:e.centerJustifiedTextSymbolIndex>=0?e.centerJustifiedTextSymbolIndex:e.leftJustifiedTextSymbolIndex>=0?e.leftJustifiedTextSymbolIndex:e.verticalPlacedTextSymbolIndex>=0?e.verticalPlacedTextSymbolIndex:n),a=om(this.textSizeData,t,i)/im;return this.tilePixelRatio*a}getSymbolInstanceIconSize(t,e,r){const n=this.icon.placedSymbolArray.get(r),i=om(this.iconSizeData,t,n);return this.tilePixelRatio*i}_commitDebugCollisionVertexUpdate(t,e,r,n){t.emplaceBack(e,-r,-r,n),t.emplaceBack(e,r,-r,n),t.emplaceBack(e,r,r,n),t.emplaceBack(e,-r,r,n);}_updateTextDebugCollisionBoxes(t,e,r,n,i,a){for(let s=n;s<i;s++){const n=r.get(s),i=this.getSymbolInstanceTextSize(t,a,e,s);this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt,i,n.padding,a.zOffset);}}_updateIconDebugCollisionBoxes(t,e,r,n,i,a){for(let s=n;s<i;s++){const n=r.get(s),i=this.getSymbolInstanceIconSize(t,e,a.placedIconSymbolIndex);this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt,i,n.padding,a.zOffset);}}updateCollisionDebugBuffers(t,e){if(!this.hasDebugData())return;this.hasTextCollisionBoxData()&&this.textCollisionBox.collisionVertexArrayExt.clear(),this.hasIconCollisionBoxData()&&this.iconCollisionBox.collisionVertexArrayExt.clear();const r=lm(this.iconSizeData,t),n=lm(this.textSizeData,t);for(let i=0;i<this.symbolInstances.length;i++){const a=this.symbolInstances.get(i);this._updateTextDebugCollisionBoxes(n,t,e,a.textBoxStartIndex,a.textBoxEndIndex,a),this._updateTextDebugCollisionBoxes(n,t,e,a.verticalTextBoxStartIndex,a.verticalTextBoxEndIndex,a),this._updateIconDebugCollisionBoxes(r,t,e,a.iconBoxStartIndex,a.iconBoxEndIndex,a),this._updateIconDebugCollisionBoxes(r,t,e,a.verticalIconBoxStartIndex,a.verticalIconBoxEndIndex,a);}this.hasTextCollisionBoxData()&&this.textCollisionBox.collisionVertexBufferExt&&this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),this.hasIconCollisionBoxData()&&this.iconCollisionBox.collisionVertexBufferExt&&this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);}_deserializeCollisionBoxesForSymbol(t,e,r,n,i,a,s,o,l){const u={};if(e<r){const{x1:r,y1:n,x2:i,y2:a,padding:s,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:f}=t.get(e);u.textBox={x1:r,y1:n,x2:i,y2:a,padding:s,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.textFeatureIndex=f;}if(n<i){const{x1:e,y1:r,x2:i,y2:a,padding:s,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:f}=t.get(n);u.verticalTextBox={x1:e,y1:r,x2:i,y2:a,padding:s,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.verticalTextFeatureIndex=f;}if(a<s){const{x1:e,y1:r,x2:n,y2:i,padding:s,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:f}=t.get(a);u.iconBox={x1:e,y1:r,x2:n,y2:i,padding:s,projectedAnchorX:o,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.iconFeatureIndex=f;}if(o<l){const{x1:e,y1:r,x2:n,y2:i,padding:a,projectedAnchorX:s,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p,featureIndex:f}=t.get(o);u.verticalIconBox={x1:e,y1:r,x2:n,y2:i,padding:a,projectedAnchorX:s,projectedAnchorY:l,projectedAnchorZ:c,tileAnchorX:h,tileAnchorY:p},u.verticalIconFeatureIndex=f;}return u}deserializeCollisionBoxes(t){this.collisionArrays=[];for(let e=0;e<this.symbolInstances.length;e++){const r=this.symbolInstances.get(e);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,r.textBoxStartIndex,r.textBoxEndIndex,r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r.iconBoxStartIndex,r.iconBoxEndIndex,r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex));}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}hasIconTextFit(){return this.hasAnyIconTextFit}addIndicesForPlacedSymbol(t,e){const r=t.placedSymbolArray.get(e),n=r.vertexStartIndex+4*r.numGlyphs;for(let e=r.vertexStartIndex;e<n;e+=4)t.indexArray.emplaceBack(e,e+1,e+2),t.indexArray.emplaceBack(e+1,e+2,e+3);}getSortedSymbolIndexes(t){if(this.sortedAngle===t&&void 0!==this.symbolInstanceIndexes)return this.symbolInstanceIndexes;const e=Math.sin(t),r=Math.cos(t),n=[],i=[],a=[];for(let t=0;t<this.symbolInstances.length;++t){a.push(t);const s=this.symbolInstances.get(t);n.push(0|Math.round(e*s.tileAnchorX+r*s.tileAnchorY)),i.push(s.featureIndex);}return a.sort(((t,e)=>n[t]-n[e]||i[e]-i[t])),a}getSortedIndexesByZOffset(){if(!this.zOffsetSortDirty)return this.symbolInstanceIndexesSortedZOffset;if(!this.symbolInstanceIndexesSortedZOffset){this.symbolInstanceIndexesSortedZOffset=[];for(let t=0;t<this.symbolInstances.length;++t)this.symbolInstanceIndexesSortedZOffset.push(t);}return this.zOffsetSortDirty=!1,this.symbolInstanceIndexesSortedZOffset.sort(((t,e)=>this.symbolInstances.get(e).zOffset-this.symbolInstances.get(t).zOffset))}addToSortKeyRanges(t,e){const r=this.sortKeyRanges[this.sortKeyRanges.length-1];r&&r.sortKey===e?r.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:e,symbolInstanceStart:t,symbolInstanceEnd:t+1});}sortFeatures(t){if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(const t of this.symbolInstanceIndexes){const e=this.symbolInstances.get(t);this.featureSortOrder.push(e.featureIndex);const{rightJustifiedTextSymbolIndex:r,centerJustifiedTextSymbolIndex:n,leftJustifiedTextSymbolIndex:i,verticalPlacedTextSymbolIndex:a,placedIconSymbolIndex:s,verticalPlacedIconSymbolIndex:o}=e;r>=0&&this.addIndicesForPlacedSymbol(this.text,r),n>=0&&n!==r&&this.addIndicesForPlacedSymbol(this.text,n),i>=0&&i!==n&&i!==r&&this.addIndicesForPlacedSymbol(this.text,i),a>=0&&this.addIndicesForPlacedSymbol(this.text,a),s>=0&&this.addIndicesForPlacedSymbol(this.icon,s),o>=0&&this.addIndicesForPlacedSymbol(this.icon,o);}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray);}}}ra(Mg,"SymbolBucket",{omit:["layers","collisionBoxArray","features","compareText"]}),Mg.addDynamicAttributes=vg;const Ag=new Oa({"symbol-placement":new La(qa.layout_symbol["symbol-placement"]),"symbol-spacing":new La(qa.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new La(qa.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new Fa(qa.layout_symbol["symbol-sort-key"]),"symbol-z-order":new La(qa.layout_symbol["symbol-z-order"]),"symbol-z-elevate":new La(qa.layout_symbol["symbol-z-elevate"]),"icon-allow-overlap":new La(qa.layout_symbol["icon-allow-overlap"]),"icon-ignore-placement":new La(qa.layout_symbol["icon-ignore-placement"]),"icon-optional":new La(qa.layout_symbol["icon-optional"]),"icon-rotation-alignment":new La(qa.layout_symbol["icon-rotation-alignment"]),"icon-size":new Fa(qa.layout_symbol["icon-size"]),"icon-text-fit":new Fa(qa.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new Fa(qa.layout_symbol["icon-text-fit-padding"]),"icon-image":new Fa(qa.layout_symbol["icon-image"]),"icon-rotate":new Fa(qa.layout_symbol["icon-rotate"]),"icon-padding":new La(qa.layout_symbol["icon-padding"]),"icon-keep-upright":new La(qa.layout_symbol["icon-keep-upright"]),"icon-offset":new Fa(qa.layout_symbol["icon-offset"]),"icon-anchor":new Fa(qa.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new La(qa.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new La(qa.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new La(qa.layout_symbol["text-rotation-alignment"]),"text-field":new Fa(qa.layout_symbol["text-field"]),"text-font":new Fa(qa.layout_symbol["text-font"]),"text-size":new Fa(qa.layout_symbol["text-size"]),"text-max-width":new Fa(qa.layout_symbol["text-max-width"]),"text-line-height":new Fa(qa.layout_symbol["text-line-height"]),"text-letter-spacing":new Fa(qa.layout_symbol["text-letter-spacing"]),"text-justify":new Fa(qa.layout_symbol["text-justify"]),"text-radial-offset":new Fa(qa.layout_symbol["text-radial-offset"]),"text-variable-anchor":new La(qa.layout_symbol["text-variable-anchor"]),"text-anchor":new Fa(qa.layout_symbol["text-anchor"]),"text-max-angle":new La(qa.layout_symbol["text-max-angle"]),"text-writing-mode":new La(qa.layout_symbol["text-writing-mode"]),"text-rotate":new Fa(qa.layout_symbol["text-rotate"]),"text-padding":new La(qa.layout_symbol["text-padding"]),"text-keep-upright":new La(qa.layout_symbol["text-keep-upright"]),"text-transform":new Fa(qa.layout_symbol["text-transform"]),"text-offset":new Fa(qa.layout_symbol["text-offset"]),"text-allow-overlap":new La(qa.layout_symbol["text-allow-overlap"]),"text-ignore-placement":new La(qa.layout_symbol["text-ignore-placement"]),"text-optional":new La(qa.layout_symbol["text-optional"]),visibility:new La(qa.layout_symbol.visibility)});var Sg={paint:new Oa({"icon-opacity":new Fa(qa.paint_symbol["icon-opacity"]),"icon-emissive-strength":new Fa(qa.paint_symbol["icon-emissive-strength"]),"text-emissive-strength":new Fa(qa.paint_symbol["text-emissive-strength"]),"icon-color":new Fa(qa.paint_symbol["icon-color"]),"icon-halo-color":new Fa(qa.paint_symbol["icon-halo-color"]),"icon-halo-width":new Fa(qa.paint_symbol["icon-halo-width"]),"icon-halo-blur":new Fa(qa.paint_symbol["icon-halo-blur"]),"icon-translate":new La(qa.paint_symbol["icon-translate"]),"icon-translate-anchor":new La(qa.paint_symbol["icon-translate-anchor"]),"icon-image-cross-fade":new Fa(qa.paint_symbol["icon-image-cross-fade"]),"text-opacity":new Fa(qa.paint_symbol["text-opacity"]),"text-color":new Fa(qa.paint_symbol["text-color"],{runtimeType:_e,getOverride:t=>t.textColor,hasOverride:t=>!!t.textColor}),"text-halo-color":new Fa(qa.paint_symbol["text-halo-color"]),"text-halo-width":new Fa(qa.paint_symbol["text-halo-width"]),"text-halo-blur":new Fa(qa.paint_symbol["text-halo-blur"]),"text-translate":new La(qa.paint_symbol["text-translate"]),"text-translate-anchor":new La(qa.paint_symbol["text-translate-anchor"]),"icon-color-saturation":new La(qa.paint_symbol["icon-color-saturation"])}),layout:Ag};class Ig{constructor(t){this.type=t.property.overrides?t.property.overrides.runtimeType:ge,this.defaultValue=t;}evaluate(t){if(t.formattedSection){const e=this.defaultValue.property.overrides;if(e&&e.hasOverride(t.formattedSection))return e.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default}eachChild(t){this.defaultValue.isConstant()||t(this.defaultValue.value._styleExpression.expression);}outputDefined(){return !1}serialize(){return null}}ra(Ig,"FormatSectionOverride",{omit:["defaultValue"]});class kg extends ss{constructor(t,e,r){super(t,Sg,e,r);}recalculate(t,e){super.recalculate(t,e),"auto"===this.layout.get("icon-rotation-alignment")&&(this.layout._values["icon-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-rotation-alignment")&&(this.layout._values["text-rotation-alignment"]="point"!==this.layout.get("symbol-placement")?"map":"viewport"),"auto"===this.layout.get("text-pitch-alignment")&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")),"auto"===this.layout.get("icon-pitch-alignment")&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment"));const r=this.layout.get("text-writing-mode");if(r){const t=[];for(const e of r)t.indexOf(e)<0&&t.push(e);this.layout._values["text-writing-mode"]=t;}else this.layout._values["text-writing-mode"]="point"===this.layout.get("symbol-placement")?["horizontal"]:["horizontal","vertical"];this._setPaintOverrides();}getValueAndResolveTokens(t,e,r,n){const i=this.layout.get(t).evaluate(e,{},r,n),a=this._unevaluatedLayout._values[t];return a.isDataDriven()||$i(a.value)||!i?i:function(t,e){return e.replace(/{([^{}]+)}/g,((e,r)=>r in t?String(t[r]):""))}(e.properties,i)}createBucket(t){return new Mg(t)}queryRadius(){return 0}queryIntersectsFeature(){return !1}_setPaintOverrides(){for(const t of Sg.paint.overridableProperties){if(!kg.hasPaintOverride(this.layout,t))continue;const e=this.paint.get(t),r=new Ig(e),n=new qi(r,e.property.specification,this.scope,this.options);let i=null;i="constant"===e.value.kind||"source"===e.value.kind?new Yi("source",n):new Xi("composite",n,e.value.zoomStops,e.value._interpolationType),this.paint._values[t]=new Da(e.property,i,e.parameters);}}_handleOverridablePaintPropertyUpdate(t,e,r){return !(!this.layout||e.isDataDriven()||r.isDataDriven())&&kg.hasPaintOverride(this.layout,t)}static hasPaintOverride(t,e){const r=t.get("text-field"),n=Sg.paint.properties[e];let i=!1;const a=t=>{for(const e of t)if(n.overrides&&n.overrides.hasOverride(e))return void(i=!0)};if("constant"===r.value.kind&&r.value.value instanceof De)a(r.value.value.sections);else if("source"===r.value.kind){const t=e=>{i||(e instanceof je&&Ne(e.value)===Se?a(e.value.sections):e instanceof Xe?a(e.sections):e.eachChild(t));},e=r.value;e._styleExpression&&t(e._styleExpression.expression);}return i}getProgramIds(){const t=0!==this.paint.get("icon-opacity").constantOr(1),e=0!==this.paint.get("text-opacity").constantOr(1),r=[];return t&&r.push("symbolIcon"),e&&r.push("symbolSDF"),r}getDefaultProgramParams(t,e){return {config:new Do(this,e),overrideFog:!1}}}const Pg=new Oa({visibility:new La(qa.layout_background.visibility)});var Eg={paint:new Oa({"background-color":new La(qa.paint_background["background-color"]),"background-pattern":new La(qa.paint_background["background-pattern"]),"background-opacity":new La(qa.paint_background["background-opacity"]),"background-emissive-strength":new La(qa.paint_background["background-emissive-strength"])}),layout:Pg};const zg=new Oa({visibility:new La(qa.layout_raster.visibility)});var Tg={paint:new Oa({"raster-opacity":new La(qa.paint_raster["raster-opacity"]),"raster-color":new Na(qa.paint_raster["raster-color"]),"raster-color-mix":new La(qa.paint_raster["raster-color-mix"]),"raster-color-range":new La(qa.paint_raster["raster-color-range"]),"raster-hue-rotate":new La(qa.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new La(qa.paint_raster["raster-brightness-min"]),"raster-brightness-max":new La(qa.paint_raster["raster-brightness-max"]),"raster-saturation":new La(qa.paint_raster["raster-saturation"]),"raster-contrast":new La(qa.paint_raster["raster-contrast"]),"raster-resampling":new La(qa.paint_raster["raster-resampling"]),"raster-fade-duration":new La(qa.paint_raster["raster-fade-duration"]),"raster-emissive-strength":new La(qa.paint_raster["raster-emissive-strength"]),"raster-array-band":new La(qa.paint_raster["raster-array-band"]),"raster-elevation":new La(qa.paint_raster["raster-elevation"])}),layout:zg},Bg=cs([{name:"a_pos",type:"Int16",components:2},{name:"a_texture_pos",type:"Int16",components:2}]);class Cg{constructor(t,e,r,n){this.context=t,this.format=r,this.texture=t.gl.createTexture(),this.update(e,n);}update(t,e,r){const{width:n,height:i}=t,{context:a}=this,{gl:s}=a;if(s.bindTexture(s.TEXTURE_2D,this.texture),a.pixelStoreUnpackFlipY.set(!1),a.pixelStoreUnpack.set(1),a.pixelStoreUnpackPremultiplyAlpha.set(this.format===s.RGBA&&(!e||!1!==e.premultiply)),r||this.size&&this.size[0]===n&&this.size[1]===i){const{x:e,y:a}=r||{x:0,y:0};if(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement||t instanceof ImageData||ImageBitmap&&t instanceof ImageBitmap)s.texSubImage2D(s.TEXTURE_2D,0,e,a,s.RGBA,s.UNSIGNED_BYTE,t);else {let r=this.format,o=s.UNSIGNED_BYTE;this.format===s.R32F&&(r=s.RED,o=s.FLOAT),s.texSubImage2D(s.TEXTURE_2D,0,e,a,n,i,r,o,t.data);}}else if(this.size=[n,i],t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement||t instanceof ImageData||ImageBitmap&&t instanceof ImageBitmap){let e=this.format;this.format===s.R8&&(e=s.RED),s.texImage2D(s.TEXTURE_2D,0,this.format,e,s.UNSIGNED_BYTE,t);}else {let e=this.format,r=this.format,a=s.UNSIGNED_BYTE;this.format===s.DEPTH_COMPONENT&&(e=s.DEPTH_COMPONENT16,a=s.UNSIGNED_SHORT),this.format===s.R8&&(r=s.RED),this.format===s.R32F&&(a=s.FLOAT,r=s.RED),s.texImage2D(s.TEXTURE_2D,0,e,n,i,0,r,a,t.data);}this.useMipmap=Boolean(e&&e.useMipmap),this.useMipmap&&s.generateMipmap(s.TEXTURE_2D);}bind(t,e,r=!1){const{context:n}=this,{gl:i}=n;i.bindTexture(i.TEXTURE_2D,this.texture),t!==this.minFilter&&(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,t),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,this.useMipmap&&!r?t===i.NEAREST?i.NEAREST_MIPMAP_NEAREST:i.LINEAR_MIPMAP_LINEAR:t),this.minFilter=t),e!==this.wrapS&&(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,e),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,e),this.wrapS=e);}bindExtraParam(t,e,r,n){const{context:i}=this,{gl:a}=i;a.bindTexture(a.TEXTURE_2D,this.texture),e!==this.magFilter&&(a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,e),this.magFilter=e),t!==this.minFilter&&(a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,this.useMipmap?t===a.NEAREST?a.NEAREST_MIPMAP_NEAREST:a.LINEAR_MIPMAP_LINEAR:t),this.minFilter=t),r!==this.wrapS&&(a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,r),this.wrapS=r),n!==this.wrapT&&(a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,n),this.wrapT=n);}destroy(){const{gl:t}=this.context;t.deleteTexture(this.texture),this.texture=null;}}class Rg{constructor(t,e){this.context=t,this.texture=e;}bind(t,e){const{context:r}=this,{gl:n}=r;n.bindTexture(n.TEXTURE_2D,this.texture),t!==this.minFilter&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,t),this.minFilter=t),e!==this.wrapS&&(n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,e),this.wrapS=e);}}function Dg(e,r,n,i,a,s,o,l){const u=[e,r,1,n,i,1,a,s,1],c=[o,l,1],h=t.co.adjoint([],u),[p,f,d]=t.N.transformMat3(c,c,h);return t.co.multiply(u,u,[p,0,0,0,f,0,0,0,d])}function Vg(e,r,n,i,a,s,o,l){const u=function(e,r,n,i,a,s,o,l){const u=Dg(0,0,1,0,1,1,0,1),c=Dg(e,r,n,i,a,s,o,l),h=t.co.adjoint([],u);return t.co.multiply(c,c,h)}(e,r,n,i,a,s,o,l);return [u[2]/u[8]/Tr,u[5]/u[8]/Tr]}function Lg(t){return [t[0],Math.min(Math.max(t[1],-xl),xl)]}class Fg extends ee{constructor(t,e,r,n){super(),this.id=t,this.dispatcher=r,this.coordinates=e.coordinates,this.type="image",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this.tiles={},this._loaded=!1,this.onNorthPole=!1,this.onSouthPole=!1,this.setEventedParent(n),this.options=e,this._dirty=!1;}load(t,e){if(this._loaded=e||!1,this.fire(new Qt("dataloading",{dataType:"source"})),this.url=this.options.url,!this.url)return t&&(this.coordinates=t),this._loaded=!0,void this._finishLoading();this._imageRequest=Ct(this.map._requestManager.transformRequest(this.url,At.Image),((e,r)=>{this._imageRequest=null,this._loaded=!0,e?this.fire(new te(e)):r&&(this.image=r instanceof HTMLImageElement?st.getImageData(r):r,this._dirty=!0,this.width=this.image.width,this.height=this.image.height,t&&(this.coordinates=t),this._finishLoading());}));}loaded(){return this._loaded}updateImage(t){return t.url?(this._imageRequest&&t.url!==this.options.url&&(this._imageRequest.cancel(),this._imageRequest=null),this.options.url=t.url,this.load(t.coordinates,this._loaded),this):this}setTexture(t){if(!(t.handle instanceof WebGLTexture))throw new Error("The provided handle is not a WebGLTexture instance");return this.texture=new Rg(this.map.painter.context,t.handle),this.width=t.dimensions[0],this.height=t.dimensions[1],this._dirty=!1,this._loaded=!0,this._finishLoading(),this}_finishLoading(){this.map&&(this.setCoordinates(this.coordinates),this.fire(new Qt("data",{dataType:"source",sourceDataType:"metadata"})));}onAdd(t){this.map=t,this.load();}onRemove(){this._imageRequest&&(this._imageRequest.cancel(),this._imageRequest=null),!this.texture||this.texture instanceof Rg||this.texture.destroy(),this.boundsBuffer&&(this.boundsBuffer.destroy(),this.elevatedGlobeVertexBuffer&&this.elevatedGlobeVertexBuffer.destroy(),this.elevatedGlobeIndexBuffer&&this.elevatedGlobeIndexBuffer.destroy());}setCoordinates(t){if(this.coordinates=t,this._boundsArray=void 0,this._unsupportedCoords=!1,!t.length)return this;this.onNorthPole=!1,this.onSouthPole=!1;let e=t[0][1],r=t[0][1];for(const n of t)n[1]>r&&(r=n[1]),n[1]<e&&(e=n[1]);const n=(r+e)/2;if(n>xl?this.onNorthPole=!0:n<-xl&&(this.onSouthPole=!0),!this.onNorthPole&&!this.onSouthPole){const e=t.map(Ml.fromLngLat);this.tileID=function(t){let e=1/0,r=1/0,n=-1/0,i=-1/0;for(const a of t)e=Math.min(e,a.x),r=Math.min(r,a.y),n=Math.max(n,a.x),i=Math.max(i,a.y);const a=Math.max(n-e,i-r),s=Math.max(0,Math.floor(-Math.log(a)/Math.LN2)),o=Math.pow(2,s);let l=Math.floor((e+n)/2*o);return l>1&&(l-=1),new il(s,l,Math.floor((r+i)/2*o))}(e),this.minzoom=this.maxzoom=this.tileID.z;}return this.fire(new Qt("data",{dataType:"source",sourceDataType:"content"})),this}_clear(){this._boundsArray=void 0,this._unsupportedCoords=!1;}_prepareData(e){for(const t in this.tiles){const e=this.tiles[t];"loaded"!==e.state&&(e.state="loaded",e.texture=this.texture);}if(this._boundsArray||this.onNorthPole||this.onSouthPole||this._unsupportedCoords)return;const r=Gy(new il(0,0,0),this.map.transform.projection),n=[r.projection.project(this.coordinates[0][0],this.coordinates[0][1]),r.projection.project(this.coordinates[1][0],this.coordinates[1][1]),r.projection.project(this.coordinates[2][0],this.coordinates[2][1]),r.projection.project(this.coordinates[3][0],this.coordinates[3][1])];if(!function(t){const e=t[1].x-t[0].x,r=t[1].y-t[0].y,n=t[2].x-t[1].x,i=t[2].y-t[1].y,a=t[3].x-t[2].x,s=t[3].y-t[2].y,o=t[0].x-t[3].x,l=t[0].y-t[3].y,u=e*i-n*r,c=n*s-a*i,h=a*l-o*s,p=o*r-e*l;return u>0&&c>0&&h>0&&p>0||u<0&&c<0&&h<0&&p<0}(n))return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"),void(this._unsupportedCoords=!0);const i=Gy(this.tileID,this.map.transform.projection),[a,s,o,l]=this.coordinates.map((t=>{const e=i.projection.project(t[0],t[1]);return Yy(i,e)._round()}));this.perspectiveTransform=Vg(a.x,a.y,s.x,s.y,o.x,o.y,l.x,l.y);const u=this._boundsArray=new ds;u.emplaceBack(a.x,a.y,0,0),u.emplaceBack(s.x,s.y,Tr,0),u.emplaceBack(l.x,l.y,0,Tr),u.emplaceBack(o.x,o.y,Tr,Tr),this.boundsBuffer&&(this.boundsBuffer.destroy(),this.elevatedGlobeVertexBuffer&&this.elevatedGlobeVertexBuffer.destroy(),this.elevatedGlobeIndexBuffer&&this.elevatedGlobeIndexBuffer.destroy()),this.boundsBuffer=e.createVertexBuffer(u,Bg.members),this.boundsSegments=eo.simpleSegment(0,0,4,2);const c=[],h=[Lg((p=this.coordinates)[0]),Lg(p[1]),Lg(p[2]),Lg(p[3])];var p;const[f,d,m,y]=function(t){let e=t[0][0],r=e,n=t[0][1],i=n;for(let a=1;a<t.length;a++)t[a][0]<e?e=t[a][0]:t[a][0]>r&&(r=t[a][0]),t[a][1]<n?n=t[a][1]:t[a][1]>i&&(i=t[a][1]);return [e,n,r-e,i-n]}(h);{const i=new ds,[a,s,o,l]=function(t){let e=t[0].x,r=e,n=t[0].y,i=n;for(let a=1;a<t.length;a++)t[a].x<e?e=t[a].x:t[a].x>r&&(r=t[a].x),t[a].y<n?n=t[a].y:t[a].y>i&&(i=t[a].y);return [e,n,r-e,i-n]}(n),u=t=>[(t.x-a)/o,(t.y-s)/l],[h,p,g,x]=n.map(u),v=function(e,r,n,i,a,s,o,l){const u=Dg(0,0,1,0,1,1,0,1),c=Dg(e,r,n,i,a,s,o,l),h=t.co.adjoint([],c);return t.co.multiply(u,u,h)}(h[0],h[1],p[0],p[1],g[0],g[1],x[0],x[1]);this.elevatedGlobePerspectiveTransform=Vg(h[0],h[1],p[0],p[1],g[0],g[1],x[0],x[1]);const b=(e,r)=>{c.push(e.lng);const n=Math.round((e.lng-f)/m*Tr),a=Math.round((e.lat-d)/y*Tr),s=u(r),o=t.N.transformMat3([],[s[0],s[1],1],v),l=Math.round(o[0]/o[2]*Tr),h=Math.round(o[1]/o[2]*Tr);i.emplaceBack(n,a,l,h);},_=n[3].x-n[0].x,w=n[3].y-n[0].y,M=n[2].x-n[1].x,A=n[2].y-n[1].y;for(let t=0;t<65;t++){const e=t/64,i=[n[0].x+e*_,n[0].y+e*w],a=[n[1].x+e*M,n[1].y+e*A],s=a[0]-i[0],o=a[1]-i[1];for(let t=0;t<65;t++){const e=t/64,n={x:i[0]+s*e,y:i[1]+o*e,z:0};b(r.projection.unproject(n.x,n.y),n);}}this.elevatedGlobeVertexBuffer=e.createVertexBuffer(i,Bg.members);}{this.maxLongitudeTriangleSize=0;let t=[],r=new Es;const n=(e,n,i)=>{r.emplaceBack(e,n,i);const a=c[e],s=c[n],o=c[i],l=Math.min(Math.min(a,s),o),u=Math.max(Math.max(a,s),o)-l;u>this.maxLongitudeTriangleSize&&(this.maxLongitudeTriangleSize=u),t.push(l+u/2);};for(let t=0;t<64;t++)for(let e=0;e<64;e++){const r=65*t+e,i=r+1,a=r+65,s=a+1;n(r,a,i),n(i,a,s);}[t,r]=function(t,e){const r=Array.from({length:t.length},((t,e)=>e));r.sort(((e,r)=>t[e]-t[r]));const n=[],i=new Es;for(let a=0;a<r.length;a++){const s=r[a];n.push(t[s]);const o=3*s,l=o+1;i.emplaceBack(e.uint16[o],e.uint16[l],e.uint16[l+1]);}return [n,i]}(t,r),this.elevatedGlobeTrianglesCenterLongitudes=t,this.elevatedGlobeIndexBuffer=e.createIndexBuffer(r);}this.elevatedGlobeSegments=eo.simpleSegment(0,0,4225,8192),this.elevatedGlobeGridMatrix=new Float32Array([0,m/Tr,0,y/Tr,0,0,d,f,0]);}prepare(){const t=0!==Object.keys(this.tiles).length;if(this.tileID&&!t)return;const e=this.map.painter.context,r=e.gl;!this._dirty||this.texture instanceof Rg||(this.texture?this.texture.update(this.image):(this.texture=new Cg(e,this.image,r.RGBA),this.texture.bind(r.LINEAR,r.CLAMP_TO_EDGE)),this._dirty=!1),t&&this._prepareData(e);}loadTile(t,e){this.tileID&&this.tileID.equals(t.tileID.canonical)?(this.tiles[String(t.tileID.wrap)]=t,t.buckets={},e(null)):(t.state="errored",e(null));}serialize(){return {type:"image",url:this.options.url,coordinates:this.coordinates}}hasTransition(){return !1}getSegmentsForLongitude(t){const e=this.elevatedGlobeSegments;if(!this.elevatedGlobeTrianglesCenterLongitudes||!e)return null;const r=this.elevatedGlobeTrianglesCenterLongitudes;let n=((t,e)=>t+360*Math.round((e-t)/360))(t+180,r[0]);const i=new eo,a=(t,r)=>{i.segments.push({vertexOffset:0,primitiveOffset:t,vertexLength:e.segments[0].vertexLength,primitiveLength:r,sortKey:void 0,vaos:{}});},s=.51*this.maxLongitudeTriangleSize;if(Math.abs(r[0]-n)<=s){const t=it(r,0,r.length,n+s);return t===r.length||a(t,nt(r,t+1,r.length,n+360-s)-t),i}n<r[0]&&(n+=360);const o=nt(r,0,r.length,n-s);if(o===r.length)return a(0,r.length),i;a(0,o-0);const l=it(r,o+1,r.length,n+s);return l!==r.length&&a(l,r.length-l),i}}const Ng=(Math.pow(256,2)-1)/16907520;class Og extends ss{constructor(t,e,r){super(t,Tg,e,r),this.updateColorRamp(),this._curRampRange=[NaN,NaN];}getProgramIds(){return ["raster"]}hasColorMap(){return !!this._transitionablePaint._values["raster-color"].value.value}tileCoverLift(){return this.paint.get("raster-elevation")}isLayerDraped(t){return !(t&&t._source instanceof Fg&&(t._source.onNorthPole||t._source.onSouthPole))&&0===this.paint.get("raster-elevation")}_handleSpecialPaintPropertyUpdate(t){"raster-color"!==t&&"raster-color-range"!==t||(this._curRampRange=[NaN,NaN],this.updateColorRamp());}updateColorRamp(t){if(!this.hasColorMap())return;if(!this._curRampRange)return;const e=this._transitionablePaint._values["raster-color"].value.expression,[r,n]=t||this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({zoom:0})||[NaN,NaN];isNaN(r)&&isNaN(n)||r===this._curRampRange[0]&&n===this._curRampRange[1]||(this.colorRamp=Ap({expression:e,evaluationKey:"rasterValue",image:this.colorRamp,clips:[{start:r,end:n}],resolution:256}),this.colorRampTexture=null,this._curRampRange=[r,n]);}}const Ug=new Oa({visibility:new La(qa["layout_raster-particle"].visibility)});var jg={paint:new Oa({"raster-particle-array-band":new La(qa["paint_raster-particle"]["raster-particle-array-band"]),"raster-particle-count":new La(qa["paint_raster-particle"]["raster-particle-count"]),"raster-particle-color":new Na(qa["paint_raster-particle"]["raster-particle-color"]),"raster-particle-max-speed":new La(qa["paint_raster-particle"]["raster-particle-max-speed"]),"raster-particle-speed-factor":new La(qa["paint_raster-particle"]["raster-particle-speed-factor"]),"raster-particle-fade-opacity-factor":new La(qa["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),"raster-particle-reset-rate-factor":new La(qa["paint_raster-particle"]["raster-particle-reset-rate-factor"])}),layout:Ug};class qg extends ss{constructor(t,e,r){super(t,jg,e,r),this._updateColorRamp(),this.onRemove=t=>{this.colorRampTexture&&this.colorRampTexture.destroy(),this.transformFeedbackObject&&t.painter.context.gl.deleteTransformFeedback(this.transformFeedbackObject),this.tileFramebuffer&&this.tileFramebuffer.destroy();},this.lastInvalidatedAt=st.now();}hasColorMap(){return !!this._transitionablePaint._values["raster-particle-color"].value.value}getProgramIds(){return ["rasterParticle"]}hasOffscreenPass(){return "none"!==this.visibility}isLayerDraped(t){return !1}_handleSpecialPaintPropertyUpdate(t){"raster-particle-color"!==t&&"raster-particle-max-speed"!==t||(this._updateColorRamp(),this._invalidateAnimationState()),"raster-particle-count"===t&&this._invalidateAnimationState();}_updateColorRamp(){if(!this.hasColorMap())return;const t=this._transitionablePaint._values["raster-particle-color"].value.expression,e=this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({zoom:0});this.colorRamp=Ap({expression:t,evaluationKey:"rasterParticleSpeed",image:this.colorRamp,clips:[{start:0,end:e}],resolution:256}),this.colorRampTexture=null;}_invalidateAnimationState(){this.lastInvalidatedAt=st.now();}}class $g extends ss{constructor(t,e){super(t,{},e),this.implementation=t,t.slot&&(this.slot=t.slot);}is3D(){return "3d"===this.implementation.renderingMode}hasOffscreenPass(){return void 0!==this.implementation.prerender}isLayerDraped(t){return void 0!==this.implementation.renderToTile}shouldRedrape(){return !!this.implementation.shouldRerenderTiles&&this.implementation.shouldRerenderTiles()}recalculate(){}updateTransitions(){}hasTransition(){return !1}serialize(){}onAdd(t){this.implementation.onAdd&&this.implementation.onAdd(t,t.painter.context.gl);}onRemove(t){this.implementation.onRemove&&this.implementation.onRemove(t,t.painter.context.gl);}}const Gg=new Oa({visibility:new La(qa.layout_sky.visibility)});var Yg={paint:new Oa({"sky-type":new La(qa.paint_sky["sky-type"]),"sky-atmosphere-sun":new La(qa.paint_sky["sky-atmosphere-sun"]),"sky-atmosphere-sun-intensity":new La(qa.paint_sky["sky-atmosphere-sun-intensity"]),"sky-gradient-center":new La(qa.paint_sky["sky-gradient-center"]),"sky-gradient-radius":new La(qa.paint_sky["sky-gradient-radius"]),"sky-gradient":new Na(qa.paint_sky["sky-gradient"]),"sky-atmosphere-halo-color":new La(qa.paint_sky["sky-atmosphere-halo-color"]),"sky-atmosphere-color":new La(qa.paint_sky["sky-atmosphere-color"]),"sky-opacity":new La(qa.paint_sky["sky-opacity"])}),layout:Gg};function Xg(e,r,n){const i=[0,0,1],a=t.bi.identity([]);return t.bi.rotateY(a,a,n?-b(e)+Math.PI:b(e)),t.bi.rotateX(a,a,-b(r)),t.N.transformQuat(i,i,a),t.N.normalize(i,i)}var Zg={paint:new Oa({})};function Kg(e,r){const n=Wg(e.projection,e.zoom,e.width,e.height),i=function(e,r,n,i,a){const s=new tl(n.lng-180*Jg,n.lat),o=new tl(n.lng+180*Jg,n.lat),l=e.project(s.lng,s.lat),u=e.project(o.lng,o.lat),c=-Math.atan2(u.y-l.y,u.x-l.x),h=Ml.fromLngLat(n);h.y=I(h.y,-1+Jg,1-Jg);const p=h.toLngLat(),f=e.project(p.lng,p.lat),d=Ml.fromLngLat(p);d.x+=Jg;const m=d.toLngLat(),y=e.project(m.lng,m.lat),g=tx(y.x-f.x,y.y-f.y,c),x=Ml.fromLngLat(p);x.y+=Jg;const v=x.toLngLat(),b=e.project(v.lng,v.lat),_=tx(b.x-f.x,b.y-f.y,c),w=Math.abs(g.x)/Math.abs(_.y),M=t.a6.identity([]);t.a6.rotateZ(M,M,-c*(1-(a?0:i)));const A=t.a6.identity([]);return t.a6.scale(A,A,[1,1-(1-w)*i,1]),A[4]=-_.x/_.y*i,t.a6.rotateZ(A,A,c),t.a6.multiply(A,M,A),A}(e.projection,0,e.center,n,r),a=Hg(e);return t.a6.scale(i,i,[a,a,1]),i}function Hg(t){const e=t.projection,r=Wg(t.projection,t.zoom,t.width,t.height),n=Qg(e,t.center),i=Qg(e,tl.convert(e.center));return Math.pow(2,n*r+(1-r)*i)}function Wg(t,e,r,n,i=1/0){const a=t.range;if(!a)return 0;const s=Math.min(i,Math.max(r,n)),o=Math.log(s/1024)/Math.LN2;return k(a[0]+o,a[1]+o,e)}const Jg=1/4e4;function Qg(t,e){const r=I(e.lat,-xl,xl),n=new tl(e.lng-180*Jg,r),i=new tl(e.lng+180*Jg,r),a=t.project(n.lng,r),s=t.project(i.lng,r),o=Ml.fromLngLat(n),l=Ml.fromLngLat(i),u=s.x-a.x,c=s.y-a.y,h=l.x-o.x,p=l.y-o.y,f=Math.sqrt((h*h+p*p)/(u*u+c*c));return Math.log(f)/Math.LN2}function tx(t,e,r){const n=Math.cos(r),i=Math.sin(r);return {x:t*n-e*i,y:t*i+e*n}}function ex(e,r,n){t.a6.identity(e),t.a6.rotateZ(e,e,b(r[2])),t.a6.rotateX(e,e,b(r[0])),t.a6.rotateY(e,e,b(r[1])),t.a6.scale(e,e,n),t.a6.multiply(e,e,[1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1]);}function rx(e,r,n,i,a,s,o,l){const u=[n[0]-r[0],n[1]-r[1],0],c=[i[0]-r[0],i[1]-r[1],0];if(t.N.length(u)<1e-12||t.N.length(c)<1e-12)return t.bi.identity(e);const h=t.N.cross([],u,c);t.N.normalize(h,h),t.N.subtract(c,i,r),u[2]=(s-a)*l,c[2]=(o-a)*l;const p=u;return t.N.cross(p,u,c),t.N.normalize(p,p),t.bi.rotationTo(e,h,p)}function nx(e,r,n=!1){const i=rp(r.zoom),a=function(e,r,n){const i=r.worldSize,a=[e[12],e[13],e[14]],s=yl(a[1]/i),o=ml(a[0]/i),l=t.a6.identity([]),u=dl(1,s)*i,c=dl(1,0)*i*bl(s,r.zoom),h=1/Qh(i);let p=c*h;if(n){const t=Wg(r.projection,r.zoom,r.width,r.height,1024);p=h*r.projection.pixelSpaceConversion(r.center.lat,i,t);}const f=Wo(s,o);t.N.add(f,f,t.N.scale([],t.N.normalize([],f),u*p*a[2]));const d=function(e){const r=[e[0],e[1],e[2]];let n=[0,1,0];const i=t.N.cross([],n,r);return t.N.cross(n,r,i),0===t.N.squaredLength(n)&&(n=[0,1,0],t.N.cross(i,r,n)),t.N.normalize(i,i),t.N.normalize(n,n),t.N.normalize(r,r),[i[0],i[1],i[2],0,n[0],n[1],n[2],0,r[0],r[1],r[2],0,e[0],e[1],e[2],1]}(f);t.a6.scale(l,l,[p,p,p*u]),t.a6.translate(l,l,[-a[0],-a[1],-a[2]]);const m=t.a6.multiply([],r.globeMatrix,d);return t.a6.multiply(m,m,l),t.a6.multiply(m,m,e),m}(e,r,n);if(i>0){const n=function(e,r){const n=r.worldSize,i=dl(1,0)*n*bl(r.center.lat,r.zoom)/Qh(n),a=dl(1,r.center.lat)*n,s=t.a6.identity([]);return t.a6.rotateY(s,s,b(r.center.lng)),t.a6.rotateX(s,s,b(r.center.lat)),t.a6.translate(s,s,[0,0,jo]),t.a6.scale(s,s,[i,i,i*a]),t.a6.translate(s,s,[r.point.x-.5*n,r.point.y-.5*n,0]),t.a6.multiply(s,s,e),t.a6.multiply(s,r.globeMatrix,s)}(e,r);return function(e,r,n){const i=(e,r,n)=>{const i=t.N.length(e),a=t.N.length(r),s=qh(e,r,n);return t.N.scale(s,s,1/t.N.length(s)*ue(i,a,n))},a=i([e[0],e[1],e[2]],[r[0],r[1],r[2]],n),s=i([e[4],e[5],e[6]],[r[4],r[5],r[6]],n),o=i([e[8],e[9],e[10]],[r[8],r[9],r[10]],n),l=qh([e[12],e[13],e[14]],[r[12],r[13],r[14]],n);return [a[0],a[1],a[2],0,s[0],s[1],s[2],0,o[0],o[1],o[2],0,l[0],l[1],l[2],1]}(a,n,i)}return a}function ix(t,e,r,n){const i=Bh.projectAabbCorners(n,r);let a=Number.MAX_VALUE,s=-1;for(let t=0;t<i.length;++t){const r=i[t];r[0]=(.5*r[0]+.5)*e.width,r[1]=(.5-.5*r[1])*e.height,r[2]<a&&(s=t,a=r[2]);}const o=t=>new g(i[t][0],i[t][1]);let l;switch(s){case 0:case 6:l=[o(1),o(5),o(4),o(7),o(3),o(2),o(1)];break;case 1:case 7:l=[o(0),o(4),o(5),o(6),o(2),o(3),o(0)];break;case 3:case 5:l=[o(1),o(0),o(4),o(7),o(6),o(2),o(1)];break;default:l=[o(1),o(5),o(6),o(7),o(3),o(0),o(1)];}if(Vl(t,l))return a}const ax=cs([{name:"a_pos_3f",components:3,type:"Float32"}]),sx=cs([{name:"a_color_3f",components:3,type:"Float32"}]),ox=cs([{name:"a_color_4f",components:4,type:"Float32"}]),lx=cs([{name:"a_uv_2f",components:2,type:"Float32"}]),ux=cs([{name:"a_normal_3f",components:3,type:"Float32"}]),cx=cs([{name:"a_normal_matrix0",components:4,type:"Float32"},{name:"a_normal_matrix1",components:4,type:"Float32"},{name:"a_normal_matrix2",components:4,type:"Float32"},{name:"a_normal_matrix3",components:4,type:"Float32"}]),hx=cs([{name:"a_pbr",components:4,type:"Uint16"},{name:"a_heightBasedEmissiveStrength",components:3,type:"Float32"}]);class px{constructor(t,e){this.feature=t,this.instancedDataOffset=e,this.instancedDataCount=0,this.rotation=[0,0,0],this.scale=[1,1,1],this.translation=[0,0,0];}}class fx{constructor(){this.instancedDataArray=new Ns,this.instancesEvaluatedElevation=[],this.features=[],this.idToFeaturesIndex={};}}class dx{constructor(t){this.zoom=t.zoom,this.canonical=t.canonical,this.layers=t.layers,this.layerIds=this.layers.map((t=>t.fqid)),this.projection=t.projection,this.index=t.index,this.hasZoomDependentProperties=this.layers[0].isZoomDependent(),this.stateDependentLayerIds=this.layers.filter((t=>t.isStateDependent())).map((t=>t.id)),this.hasPattern=!1,this.instancesPerModel={},this.validForExaggeration=0,this.maxVerticalOffset=0,this.maxScale=0,this.maxHeight=0,this.lookupDim=this.zoom>this.canonical.z?256:this.zoom>15?75:100,this.instanceCount=0,this.terrainElevationMin=0,this.terrainElevationMax=0,this.validForDEMTile={id:null,timestamp:0};}populate(t,e,r,n){this.tileToMeter=wl(r);const i=this.layers[0]._featureFilter.needGeometry;this.lookup=new Uint8Array(this.lookupDim*this.lookupDim);for(const{feature:a,id:s,index:o,sourceLayerIndex:l}of t){const t=Bl(a,i);if(!this.layers[0]._featureFilter.filter(new Pa(this.zoom),t,r))continue;const u={id:s,sourceLayerIndex:l,index:o,geometry:i?t.geometry:Tl(a,r,n),properties:a.properties,type:a.type,patterns:{}},c=this.addFeature(u,u.geometry,t);c&&e.featureIndex.insert(a,u.geometry,o,l,this.index,this.instancesPerModel[c].instancedDataArray.length,Tr/32);}this.lookup=null;}update(t,e,r,n){for(const e in this.instancesPerModel){const r=this.instancesPerModel[e];for(const e in t)r.idToFeaturesIndex.hasOwnProperty(e)&&this.evaluate(r.features[r.idToFeaturesIndex[e]],t[e],r,!0);}this.maxHeight=0;}updateZoomBasedPaintProperties(){if(!this.hasZoomDependentProperties)return !1;let e=!1;for(const r in this.instancesPerModel){const n=this.instancesPerModel[r];for(const r of n.features){const i=this.layers[0],a=r.feature,s=this.canonical,o=i.paint.get("model-rotation").evaluate(a,{},s),l=i.paint.get("model-scale").evaluate(a,{},s),u=i.paint.get("model-translation").evaluate(a,{},s);t.N.exactEquals(r.rotation,o)&&t.N.exactEquals(r.scale,l)&&t.N.exactEquals(r.translation,u)||(this.evaluate(r,r.featureStates,n,!0),e=!0);}}return e}isEmpty(){for(const t in this.instancesPerModel)if(0!==this.instancesPerModel[t].instancedDataArray.length)return !1;return !0}uploadPending(){return !this.uploaded}upload(t){if(!this.uploaded)for(const e in this.instancesPerModel){const r=this.instancesPerModel[e];r.instancedDataArray.length<0||0===r.instancedDataArray.length||(r.instancedDataBuffer?r.instancedDataBuffer.updateData(r.instancedDataArray):r.instancedDataBuffer=t.createVertexBuffer(r.instancedDataArray,cx.members,!0,void 0,this.instanceCount));}this.uploaded=!0;}destroy(){for(const t in this.instancesPerModel){const e=this.instancesPerModel[t];0!==e.instancedDataArray.length&&e.instancedDataBuffer&&e.instancedDataBuffer.destroy();}}addFeature(t,e,r){const n=this.layers[0],i=n.layout.get("model-id").evaluate(r,{},this.canonical);if(!i)return j(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`),i;this.instancesPerModel[i]||(this.instancesPerModel[i]=new fx);const a=this.instancesPerModel[i],s=a.instancedDataArray,o=new px(r,s.length);for(const t of e)for(const e of t){if(e.x<0||e.x>=Tr||e.y<0||e.y>=Tr)continue;const t=(this.lookupDim-1)/Tr,r=this.lookupDim*(e.y*t|0)+e.x*t|0;if(this.lookup){if(0!==this.lookup[r])continue;this.lookup[r]=1;}this.instanceCount++;const n=s.length;s.resize(n+1),a.instancesEvaluatedElevation.push(0),s.float32[16*n]=e.x,s.float32[16*n+1]=e.y;}return o.instancedDataCount=a.instancedDataArray.length-o.instancedDataOffset,o.instancedDataCount>0&&(t.id&&(a.idToFeaturesIndex[t.id]=a.features.length),a.features.push(o),this.evaluate(o,{},a,!1)),i}evaluate(t,e,r,n){const i=this.layers[0],a=t.feature,s=this.canonical,o=t.rotation=i.paint.get("model-rotation").evaluate(a,e,s),l=t.scale=i.paint.get("model-scale").evaluate(a,e,s),u=t.translation=i.paint.get("model-translation").evaluate(a,e,s),c=i.paint.get("model-color").evaluate(a,e,s);c.a=i.paint.get("model-color-mix-intensity").evaluate(a,e,s);const h=[];this.maxVerticalOffset<u[2]&&(this.maxVerticalOffset=u[2]),this.maxScale=Math.max(Math.max(this.maxScale,l[0]),Math.max(l[1],l[2])),ex(h,o,l);const p=Math.round(100*c.a)+c.b/1.05;for(let e=0;e<t.instancedDataCount;++e){const i=t.instancedDataOffset+e,a=16*i,o=r.instancedDataArray.float32;let l=0;n&&(l=o[a+6]-r.instancesEvaluatedElevation[i]);const f=0|o[a+1];o[a]=(0|o[a])+c.r/1.05,o[a+1]=f+c.g/1.05,o[a+2]=p,o[a+3]=1/(s.z>10?this.tileToMeter:wl(s,f)),o[a+4]=u[0],o[a+5]=u[1],o[a+6]=u[2]+l,o[a+7]=h[0],o[a+8]=h[1],o[a+9]=h[2],o[a+10]=h[4],o[a+11]=h[5],o[a+12]=h[6],o[a+13]=h[8],o[a+14]=h[9],o[a+15]=h[10],r.instancesEvaluatedElevation[i]=u[2];}}}ra(dx,"ModelBucket",{omit:["layers"]}),ra(fx,"PerModelAttributes"),ra(px,"ModelFeature");const mx=new Oa({visibility:new La(qa.layout_model.visibility),"model-id":new Fa(qa.layout_model["model-id"])});var yx={paint:new Oa({"model-opacity":new La(qa.paint_model["model-opacity"]),"model-rotation":new Fa(qa.paint_model["model-rotation"]),"model-scale":new Fa(qa.paint_model["model-scale"]),"model-translation":new Fa(qa.paint_model["model-translation"]),"model-color":new Fa(qa.paint_model["model-color"]),"model-color-mix-intensity":new Fa(qa.paint_model["model-color-mix-intensity"]),"model-type":new La(qa.paint_model["model-type"]),"model-cast-shadows":new La(qa.paint_model["model-cast-shadows"]),"model-receive-shadows":new La(qa.paint_model["model-receive-shadows"]),"model-ambient-occlusion-intensity":new La(qa.paint_model["model-ambient-occlusion-intensity"]),"model-emissive-strength":new Fa(qa.paint_model["model-emissive-strength"]),"model-roughness":new Fa(qa.paint_model["model-roughness"]),"model-height-based-emissive-strength-multiplier":new Fa(qa.paint_model["model-height-based-emissive-strength-multiplier"]),"model-cutoff-fade-range":new La(qa.paint_model["model-cutoff-fade-range"])}),layout:mx};const gx=64,xx={CoordinateSpaceTile:1,CoordinateSpaceYUp:2,HasMapboxMeshFeatures:4,HasMeshoptCompression:8};function vx(e,r,n,i,a,s,o,l,u,c=!1){const h=n.zoom,p=n.project(i),f=bl(i.lat,h),d=1/f;t.a6.identity(e),t.a6.translate(e,e,[p.x+o[0]*d,p.y+o[1]*d,o[2]]);let m=1,y=1;const g=n.worldSize;if(c){if("mercator"===n.projection.name){let e=0;n.elevation&&(e=n.elevation.getAtPointOrZero(new Ml(p.x/g,p.y/g),0));const r=t.a7.transformMat4([],[p.x,p.y,e,1],n.projMatrix)[3]/n.cameraToCenterDistance;m=r,y=r*bl(n.center.lat,h);}else if("globe"===n.projection.name){const r=nx(e,n),a=t.a6.multiply([],n.projMatrix,r),s=[0,0,0,1];t.a7.transformMat4(s,s,a);const o=s[3]/n.cameraToCenterDistance,l=rp(h),u=n.projection.pixelsPerMeter(i.lat,g)*bl(i.lat,h),c=n.projection.pixelsPerMeter(n.center.lat,g)*bl(n.center.lat,h);m=o/ue(u,vl(n.center.lat),l),y=o*f/u,m*=c,y*=c;}}else m=d;t.a6.scale(e,e,[m,m,y]);const x=[...e],v=r.orientation,b=[];if(ex(b,[v[0]+a[0],v[1]+a[1],v[2]+a[2]],s),t.a6.multiply(e,x,b),l&&n.elevation){let a=0;const s=[];if(u&&n.elevation){a=function(e,r,n,i,a){const s=r.elevation;if(!s)return 0;const o=Bh.projectAabbCorners(n,i),l=dl(1,a.lat)*r.worldSize,u=function(e,r){const n=[0,0,1],i=[{corners:[0,1,3,2],dotProductWithUp:0},{corners:[1,5,2,6],dotProductWithUp:0},{corners:[0,4,1,5],dotProductWithUp:0},{corners:[2,6,3,7],dotProductWithUp:0},{corners:[4,7,5,6],dotProductWithUp:0},{corners:[0,3,4,7],dotProductWithUp:0}];for(const a of i){const i=e[a.corners[0]],s=e[a.corners[1]],o=e[a.corners[2]],l=[s[0]-i[0],s[1]-i[1],r*(s[2]-i[2])],u=t.N.cross(l,l,[o[0]-i[0],o[1]-i[1],r*(o[2]-i[2])]);t.N.normalize(u,u),a.dotProductWithUp=t.N.dot(u,n);}return i.sort(((t,e)=>t.dotProductWithUp-e.dotProductWithUp)),i[0].corners}(o,l),c=o[u[0]],h=o[u[1]],p=o[u[2]],f=o[u[3]],d=s.getAtPointOrZero(new Ml(c[0]/r.worldSize,c[1]/r.worldSize),0),m=s.getAtPointOrZero(new Ml(h[0]/r.worldSize,h[1]/r.worldSize),0),y=s.getAtPointOrZero(new Ml(p[0]/r.worldSize,p[1]/r.worldSize),0),g=s.getAtPointOrZero(new Ml(f[0]/r.worldSize,f[1]/r.worldSize),0),x=(d+g)/2,v=(m+y)/2;return x>v?m<y?rx(e,h,f,c,m,g,d,l):rx(e,p,c,f,y,d,g,l):d<g?rx(e,c,h,p,d,m,y,l):rx(e,f,p,h,g,y,m,l),Math.max(x,v)}(s,n,r.aabb,e,i);const o=t.a6.fromQuat([],s),l=t.a6.multiply([],o,b);t.a6.multiply(e,x,l);}else a=n.elevation.getAtPointOrZero(new Ml(p.x/g,p.y/g),0);0!==a&&(e[14]+=a);}}function bx(t,e,r=!1){t.uploaded||(t.gfxTexture=new Cg(e,t.image,r?e.gl.R8:e.gl.RGBA,{useMipmap:t.sampler.minFilter>=e.gl.NEAREST_MIPMAP_NEAREST}),t.uploaded=!0,t.image=null);}function _x(t,e,r){t.indexBuffer=e.createIndexBuffer(t.indexArray,!1,!0),t.vertexBuffer=e.createVertexBuffer(t.vertexArray,ax.members,!1,!0),t.normalArray&&(t.normalBuffer=e.createVertexBuffer(t.normalArray,ux.members,!1,!0)),t.texcoordArray&&(t.texcoordBuffer=e.createVertexBuffer(t.texcoordArray,lx.members,!1,!0)),t.colorArray&&(t.colorBuffer=e.createVertexBuffer(t.colorArray,(12===t.colorArray.bytesPerElement?sx:ox).members,!1,!0)),t.featureArray&&(t.pbrBuffer=e.createVertexBuffer(t.featureArray,hx.members,!0)),t.segments=eo.simpleSegment(0,0,t.vertexArray.length,t.indexArray.length);const n=t.material;n.pbrMetallicRoughness.baseColorTexture&&bx(n.pbrMetallicRoughness.baseColorTexture,e),n.pbrMetallicRoughness.metallicRoughnessTexture&&bx(n.pbrMetallicRoughness.metallicRoughnessTexture,e),n.normalTexture&&bx(n.normalTexture,e),n.occlusionTexture&&bx(n.occlusionTexture,e,r),n.emissionTexture&&bx(n.emissionTexture,e);}function wx(t,e,r){if(t.meshes)for(const n of t.meshes)_x(n,e,r);if(t.children)for(const n of t.children)wx(n,e,r);}function Mx(t){if(t.meshes)for(const e of t.meshes)e.indexArray.destroy(),e.vertexArray.destroy(),e.colorArray&&e.colorArray.destroy(),e.normalArray&&e.normalArray.destroy(),e.texcoordArray&&e.texcoordArray.destroy(),e.featureArray&&e.featureArray.destroy();if(t.children)for(const e of t.children)Mx(e);}function Ax(t){if(t.meshes)for(const r of t.meshes)r.vertexBuffer&&(r.vertexBuffer.destroy(),r.indexBuffer.destroy(),r.normalBuffer&&r.normalBuffer.destroy(),r.texcoordBuffer&&r.texcoordBuffer.destroy(),r.colorBuffer&&r.colorBuffer.destroy(),r.pbrBuffer&&r.pbrBuffer.destroy(),r.segments.destroy(),r.material&&((e=r.material).pbrMetallicRoughness.baseColorTexture&&e.pbrMetallicRoughness.baseColorTexture.gfxTexture&&e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(),e.pbrMetallicRoughness.metallicRoughnessTexture&&e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture&&e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(),e.normalTexture&&e.normalTexture.gfxTexture&&e.normalTexture.gfxTexture.destroy(),e.emissionTexture&&e.emissionTexture.gfxTexture&&e.emissionTexture.gfxTexture.destroy(),e.occlusionTexture&&e.occlusionTexture.gfxTexture&&e.occlusionTexture.gfxTexture.destroy()));var e;if(t.children)for(const e of t.children)Ax(e);}class Sx{constructor(t){this._callback=t,this._triggered=!1,"undefined"!=typeof MessageChannel&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._callback();});}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout((()=>{this._triggered=!1,this._callback();}),0));}remove(){this._channel=void 0,this._callback=()=>{};}}class Ix{constructor(){this.tasks={},this.taskQueue=[],V(["process"],this),this.invoker=new Sx(this.process),this.nextId=0;}add(t,e){const r=this.nextId++,n=function({type:t,isSymbolTile:e,zoom:r}){return r=r||0,"message"===t?0:"maybePrepare"!==t||e?"parseTile"!==t||e?"parseTile"===t&&e?300-r:"maybePrepare"===t&&e?400-r:500:200-r:100-r}(e);if(0===n){Y();try{t();}finally{}return null}return this.tasks[r]={fn:t,metadata:e,priority:n,id:r},this.taskQueue.push(r),this.invoker.trigger(),{cancel:()=>{delete this.tasks[r];}}}process(){Y();try{if(this.taskQueue=this.taskQueue.filter((t=>!!this.tasks[t])),!this.taskQueue.length)return;const t=this.pick();if(null===t)return;const e=this.tasks[t];if(delete this.tasks[t],this.taskQueue.length&&this.invoker.trigger(),!e)return;e.fn();}finally{}}pick(){let t=null,e=1/0;for(let r=0;r<this.taskQueue.length;r++){const n=this.tasks[this.taskQueue[r]];n.priority<e&&(e=n.priority,t=r);}if(null===t)return null;const r=this.taskQueue[t];return this.taskQueue.splice(t,1),r}remove(){this.invoker.remove();}}class kx{constructor(t,e,r){this.target=t,this.parent=e,this.mapId=r,this.callbacks={},this.cancelCallbacks={},V(["receive"],this),this.target.addEventListener("message",this.receive,!1),this.scheduler=new Ix;}send(t,e,r,n,i=!1,a){const s=Math.round(1e18*Math.random()).toString(36).substring(0,10);r&&(r.metadata=a,this.callbacks[s]=r);const o=new Set;return this.target.postMessage({id:s,type:t,hasCallback:!!r,targetMapId:n,mustQueue:i,sourceMapId:this.mapId,data:aa(e,o)},o),{cancel:()=>{r&&delete this.callbacks[s],this.target.postMessage({id:s,type:"<cancel>",targetMapId:n,sourceMapId:this.mapId});}}}receive(t){const e=t.data,r=e.id;if(r&&(!e.targetMapId||this.mapId===e.targetMapId))if("<cancel>"===e.type){const t=this.cancelCallbacks[r];delete this.cancelCallbacks[r],t&&t.cancel();}else if(e.mustQueue||Y()){const t=this.callbacks[r],n=this.scheduler.add((()=>this.processTask(r,e)),t&&t.metadata||{type:"message"});n&&(this.cancelCallbacks[r]=n);}else this.processTask(r,e);}processTask(t,e){if(delete this.cancelCallbacks[t],"<response>"===e.type){const r=this.callbacks[t];delete this.callbacks[t],r&&(e.error?r(sa(e.error)):r(null,sa(e.data)));}else {const r=new Set,n=e.hasCallback?(e,n)=>{this.target.postMessage({id:t,type:"<response>",sourceMapId:this.mapId,error:e?aa(e):null,data:aa(n,r)},r);}:t=>{},i=sa(e.data);if(this.parent[e.type])this.parent[e.type](e.sourceMapId,i,n);else if(this.parent.getWorkerSource){const t=e.type.split(".");this.parent.getWorkerSource(e.sourceMapId,t[0],i.source,i.scope)[t[1]](i,n);}else n(new Error(`Could not find function ${e.type}`));}}remove(){this.scheduler.remove(),this.target.removeEventListener("message",this.receive,!1);}}class Px{constructor(t,e){this.workerPool=t,this.actors=[],this.currentActor=0,this.id=B();const r=this.workerPool.acquire(this.id);for(let t=0;t<r.length;t++){const n=new Px.Actor(r[t],e,this.id);n.name=`Worker ${t}`,this.actors.push(n);}this.ready=!1,this.broadcast("checkIfReady",null,(()=>{this.ready=!0;}));}broadcast(t,e,r){E(this.actors,((r,n)=>{r.send(t,e,n);}),r=r||function(){});}getActor(){return this.currentActor=(this.currentActor+1)%this.actors.length,this.actors[this.currentActor]}remove(){this.actors.forEach((t=>{t.remove();})),this.actors=[],this.workerPool.release(this.id);}}Px.Actor=kx;var Ex={workerUrl:"",workerClass:null,workerParams:void 0};function zx(){return null!=Ex.workerClass?new Ex.workerClass:new self.Worker(Ex.workerUrl,Ex.workerParams)}const Tx="mapboxgl_preloaded_worker_pool";class Bx{constructor(){this.active={};}acquire(t){if(!this.workers)for(this.workers=[];this.workers.length<Bx.workerCount;)this.workers.push(new zx);return this.active[t]=!0,this.workers.slice()}release(t){delete this.active[t],this.workers&&0===this.numActive()&&(this.workers.forEach((t=>{t.terminate();})),this.workers=null);}isPreloaded(){return !!this.active[Tx]}numActive(){return Object.keys(this.active).length}}let Cx;function Rx(){return Cx||(Cx=new Bx),Cx}Bx.workerCount=2;let Dx,Vx,Lx,Fx,Nx,Ox=null;function Ux(){return Y()&&self.worker&&self.worker.dracoUrl?self.worker.dracoUrl:Vx||n.DRACO_URL}function jx(){if(Y()&&self.worker&&self.worker.meshoptUrl)return self.worker.meshoptUrl;if(Fx)return Fx;const t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]);if("object"!=typeof WebAssembly)throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");return Fx=WebAssembly.validate(t)?n.MESHOPT_SIMD_URL:n.MESHOPT_URL,Fx}const qx={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},$x={5120:"DT_INT8",5121:"DT_UINT8",5122:"DT_INT16",5123:"DT_UINT16",5125:"DT_UINT32",5126:"DT_FLOAT32"},Gx={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16};function Yx(t,e,r){const n=r.json.bufferViews.length,i=r.buffers.length;e.bufferView=n,r.json.bufferViews[n]={buffer:i,byteLength:t.byteLength},r.buffers[i]=t;}const Xx="KHR_draco_mesh_compression";function Zx(t,e){const r=t.extensions&&t.extensions[Xx];if(!r)return;const n=new Lx.Decoder,i=ev(e,r.bufferView),a=new Lx.Mesh;if(!n.DecodeArrayToMesh(i,i.byteLength,a))throw new Error("Failed to decode Draco mesh");const s=e.json.accessors[t.indices],o=qx[s.componentType],l=s.count*o.BYTES_PER_ELEMENT,u=Lx._malloc(l);o===Uint16Array?n.GetTrianglesUInt16Array(a,l,u):n.GetTrianglesUInt32Array(a,l,u),Yx(Lx.memory.buffer.slice(u,u+l),s,e),Lx._free(u);for(const i of Object.keys(r.attributes)){const s=n.GetAttributeByUniqueId(a,r.attributes[i]),o=e.json.accessors[t.attributes[i]],l=$x[o.componentType],u=o.count*Gx[o.type]*qx[o.componentType].BYTES_PER_ELEMENT,c=Lx._malloc(u);n.GetAttributeDataArrayForAllPoints(a,s,Lx[l],u,c),Yx(Lx.memory.buffer.slice(c,c+u),o,e),Lx._free(c);}n.destroy(),a.destroy(),delete t.extensions[Xx];}const Kx="EXT_meshopt_compression";function Hx(t,e){if(!t.extensions||!t.extensions[Kx])return;const r=t.extensions[Kx],n=new Uint8Array(e.buffers[r.buffer],r.byteOffset||0,r.byteLength||0),i=new Uint8Array(r.count*r.byteStride);Nx.decodeGltfBuffer(i,r.count,r.byteStride,n,r.mode,r.filter),t.buffer=e.buffers.length,t.byteOffset=0,e.buffers[t.buffer]=i.buffer,delete t.extensions[Kx];}const Wx=1179937895,Jx=new TextDecoder("utf8");function Qx(t,e){return new URL(t,e).href}function tv(t,e,r,n){return fetch(Qx(t.uri,n)).then((t=>t.arrayBuffer())).then((t=>{e.buffers[r]=t;}))}function ev(t,e){const r=t.json.bufferViews[e];return new Uint8Array(t.buffers[r.buffer],r.byteOffset||0,r.byteLength)}function rv(t,e,r,n){if(t.uri){const i=Qx(t.uri,n);return fetch(i).then((t=>t.blob())).then((t=>createImageBitmap(t))).then((t=>{e.images[r]=t;}))}if(void 0!==t.bufferView){const n=ev(e,t.bufferView),i=new Blob([n],{type:t.mimeType});return createImageBitmap(i).then((t=>{e.images[r]=t;}))}}function nv(t,e=0,r){const n={json:null,images:[],buffers:[]};if(new Uint32Array(t,e,1)[0]===Wx){const r=new Uint32Array(t,e);let i=2;const a=(r[i++]>>2)-3,s=r[i++]>>2;if(i++,n.json=JSON.parse(Jx.decode(r.subarray(i,i+s))),i+=s,i<a){const a=r[i++];i++;const s=e+(i<<2);n.buffers[0]=t.slice(s,s+a);}}else n.json=JSON.parse(Jx.decode(new Uint8Array(t,e)));const{buffers:i,images:a,meshes:s,extensionsUsed:o,bufferViews:l}=n.json;let u=Promise.resolve();if(i){const t=[];for(let e=0;e<i.length;e++){const a=i[e];a.uri?t.push(tv(a,n,e,r)):n.buffers[e]||(n.buffers[e]=null);}u=Promise.all(t);}return u.then((()=>{const t=[],e=o&&o.includes(Xx),i=o&&o.includes(Kx);if(e&&t.push(function(){if(!Lx)return Dx||(Dx=function(t){let e,r=null;function n(){e=new Uint8Array(r.buffer);}function i(){throw new Error("Unexpected Draco error.")}const a={a:{a:i,d:function(t,r,n){return e.copyWithin(t,r,r+n)},c:function(t){const i=e.length,a=Math.max(t>>>0,Math.ceil(1.2*i)),s=Math.ceil((a-i)/65536);try{return r.grow(s),n(),!0}catch(t){return !1}},b:i}};return (WebAssembly.instantiateStreaming?WebAssembly.instantiateStreaming(t,a):t.then((t=>t.arrayBuffer())).then((t=>WebAssembly.instantiate(t,a)))).then((t=>{const{Rb:i,Qb:a,P:s,T:o,X:l,Ja:u,La:c,Qa:h,Va:p,Wa:f,eb:d,jb:m,f:y,e:g,yb:x,zb:v,Ab:b,Bb:_,Db:w,Gb:M}=t.instance.exports;r=g;const A=(()=>{let t=0,r=0,n=0,s=0;return o=>{n&&(i(s),i(t),r+=n,n=t=0),t||(r+=128,t=a(r));const l=o.length+7&-8;let u=t;l>=r&&(n=l,u=s=a(l));for(let t=0;t<o.length;t++)e[u+t]=o[t];return u}})();return n(),y(),{memory:g,_free:i,_malloc:a,Mesh:class{constructor(){this.ptr=s();}destroy(){o(this.ptr);}},Decoder:class{constructor(){this.ptr=u();}destroy(){m(this.ptr);}DecodeArrayToMesh(t,e,r){const n=A(t),i=c(this.ptr,n,e,r.ptr);return !!l(i)}GetAttributeByUniqueId(t,e){return {ptr:h(this.ptr,t.ptr,e)}}GetTrianglesUInt16Array(t,e,r){p(this.ptr,t.ptr,e,r);}GetTrianglesUInt32Array(t,e,r){f(this.ptr,t.ptr,e,r);}GetAttributeDataArrayForAllPoints(t,e,r,n,i){d(this.ptr,t.ptr,e.ptr,r,n,i);}},DT_INT8:x(),DT_UINT8:v(),DT_INT16:b(),DT_UINT16:_(),DT_UINT32:w(),DT_FLOAT32:M()}}))}(fetch(Ux())),Dx.then((t=>{Lx=t,Dx=void 0;})))}()),i&&t.push(function(){if(Nx)return;const t=function(t){let e;const r=WebAssembly.instantiateStreaming(t,{}).then((t=>{e=t.instance,e.exports.__wasm_call_ctors();})),n={NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},i={ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return {ready:r,supported:!0,decodeGltfBuffer(t,r,a,s,o,l){!function(t,e,r,n,i,a,s){const o=t.exports.sbrk,l=n+3&-4,u=o(l*i),c=o(a.length),h=new Uint8Array(t.exports.memory.buffer);h.set(a,c);const p=e(u,n,i,c,a.length);if(0===p&&s&&s(u,l,i),r.set(h.subarray(u,u+n*i)),o(u-o(0)),0!==p)throw new Error(`Malformed buffer data: ${p}`)}(e,e.exports[i[o]],t,r,a,s,e.exports[n[l]]);}}}(fetch(jx()));return t.ready.then((()=>{Nx=t;}))}()),a)for(let e=0;e<a.length;e++)t.push(rv(a[e],n,e,r));return (t.length?Promise.all(t):Promise.resolve()).then((()=>{if(e&&s)for(const{primitives:t}of s)for(const e of t)Zx(e,n);if(i&&s&&l)for(const t of l)Hx(t,n);return n}))}))}class iv{constructor(t,e,r){if(this.triangleCount=e.length/3,this.min=new g(0,0),this.max=new g(0,0),this.xScale=0,this.yScale=0,this.cellsX=0,this.cellsY=0,this.cells=[],this.payload=[],0===this.triangleCount||0===t.length||0===r)return;const n=t.map((t=>t.x)),i=t.map((t=>t.y));this.min=new g(Math.min(...n),Math.min(...i)),this.max=new g(Math.max(...n),Math.max(...i));const a=this.max.sub(this.min);a.x=Math.max(a.x,1),a.y=Math.max(a.y,1);const s=Math.max(a.x,a.y)/r;this.cellsX=Math.max(1,Math.ceil(a.x/s)),this.cellsY=Math.max(1,Math.ceil(a.y/s)),this.xScale=1/s,this.yScale=1/s;const o=[];for(let r=0;r<this.triangleCount;r++){const n=t[e[3*r+0]].sub(this.min),i=t[e[3*r+1]].sub(this.min),a=t[e[3*r+2]].sub(this.min),l=av(Math.floor(Math.min(n.x,i.x,a.x)),this.xScale,this.cellsX),u=av(Math.floor(Math.max(n.x,i.x,a.x)),this.xScale,this.cellsX),c=av(Math.floor(Math.min(n.y,i.y,a.y)),this.yScale,this.cellsY),h=av(Math.floor(Math.max(n.y,i.y,a.y)),this.yScale,this.cellsY),p=new g(0,0),f=new g(0,0),d=new g(0,0),m=new g(0,0);for(let t=c;t<=h;++t){p.y=f.y=t*s,d.y=m.y=(t+1)*s;for(let e=l;e<=u;++e)p.x=d.x=e*s,f.x=m.x=(e+1)*s,(Kl(n,i,a,p,f,m)||Kl(n,i,a,p,m,d))&&o.push({cellIdx:t*this.cellsX+e,triIdx:r});}}if(0===o.length)return;o.sort(((t,e)=>t.cellIdx-e.cellIdx||t.triIdx-e.triIdx));let l=0;for(;l<o.length;){const t=o[l].cellIdx,e={start:this.payload.length,len:0};for(;l<o.length&&o[l].cellIdx===t;)++e.len,this.payload.push(o[l++].triIdx);this.cells[t]=e;}}query(t,e,r){if(0===this.triangleCount||0===this.cells.length)return;if(t.x>this.max.x||this.min.x>e.x)return;if(t.y>this.max.y||this.min.y>e.y)return;this.lookup||(this.lookup=new Uint8Array(Math.ceil(this.triangleCount/8)));for(let t=0;t<this.lookup.length;t++)this.lookup[t]=0;const n=av(t.x-this.min.x,this.xScale,this.cellsX),i=av(e.x-this.min.x,this.xScale,this.cellsX),a=av(t.y-this.min.y,this.yScale,this.cellsY),s=av(e.y-this.min.y,this.yScale,this.cellsY);for(let t=a;t<=s;t++)for(let e=n;e<=i;e++){const n=this.cells[t*this.cellsX+e];if(n)for(let t=0;t<n.len;t++){const e=this.payload[n.start+t],i=Math.floor(e/8),a=1<<e%8;if(!(this.lookup[i]&a)&&(this.lookup[i]|=a,r.push(e),r.length===this.triangleCount))return}}}}function av(t,e,r){return Math.max(0,Math.min(r-1,Math.floor(t*e)))}function sv(t,e){const r=t.json.bufferViews[e.bufferView],n=qx[e.componentType];return new n(t.buffers[r.buffer],(e.byteOffset||0)+(r.byteOffset||0),e.count*(r.byteStride&&r.byteStride!==Gx[e.type]*n.BYTES_PER_ELEMENT?r.byteStride/n.BYTES_PER_ELEMENT:Gx[e.type]))}function ov(t,e,r,n){const i=qx[e.componentType],a=function(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:return 1}}(i),s=t.json.bufferViews[e.bufferView],o=s.byteStride?s.byteStride/i.BYTES_PER_ELEMENT:Gx[e.type],l=r.float32,u=l.length/r.capacity;for(let t=0,r=0;t<e.count*o;t+=o,r+=u)for(let e=0;e<u;e++)l[r+e]=n[t+e]*a;r._trim();}function lv(t,e,r){const n=t.indices,i=t.attributes,a={};a.indexArray=new Es;const s=e.json.accessors[n],o=s.count/3;a.indexArray.reserve(o);const l=sv(e,s);for(let t=0;t<o;t++)a.indexArray.emplaceBack(l[3*t],l[3*t+1],l[3*t+2]);a.indexArray._trim(),a.vertexArray=new Ls;const u=e.json.accessors[i.POSITION];a.vertexArray.reserve(u.count);const c=sv(e,u);for(let t=0;t<u.count;t++)a.vertexArray.emplaceBack(c[3*t],c[3*t+1],c[3*t+2]);if(a.vertexArray._trim(),a.aabb=new Bh(u.min,u.max),a.centroid=function(t,e){const r=[0,0,0],n=t.length;if(n>0){for(let i=0;i<n;i++){const n=3*t[i];r[0]+=e[n],r[1]+=e[n+1],r[2]+=e[n+2];}r[0]/=n,r[1]/=n,r[2]/=n;}return r}(l,c),void 0!==i.COLOR_0){const t=e.json.accessors[i.COLOR_0],r=Gx[t.type],n=sv(e,t);a.colorArray=3===r?new Ls:new gs,a.colorArray.resize(t.count),ov(e,t,a.colorArray,n);}if(void 0!==i.NORMAL){a.normalArray=new Ls;const t=e.json.accessors[i.NORMAL];a.normalArray.resize(t.count);const r=sv(e,t);ov(e,t,a.normalArray,r);}if(void 0!==i.TEXCOORD_0&&r.length>0){a.texcoordArray=new Fs;const t=e.json.accessors[i.TEXCOORD_0];a.texcoordArray.resize(t.count);const r=sv(e,t);ov(e,t,a.texcoordArray,r);}if(void 0!==i._FEATURE_ID_RGBA4444){const t=e.json.accessors[i._FEATURE_ID_RGBA4444];e.json.extensionsUsed&&e.json.extensionsUsed.includes("EXT_meshopt_compression")&&(a.featureData=sv(e,t));}void 0!==i._FEATURE_RGBA4444&&(a.featureData=new Uint32Array(sv(e,e.json.accessors[i._FEATURE_RGBA4444]).buffer));const h=t.material;return a.material=function(t,e){const{emissiveFactor:r=[0,0,0],alphaMode:n="OPAQUE",alphaCutoff:i=.5,normalTexture:a,occlusionTexture:s,emissiveTexture:o,doubleSided:l}=t,{baseColorFactor:u=[1,1,1,1],metallicFactor:c=1,roughnessFactor:h=1,baseColorTexture:p,metallicRoughnessTexture:f}=t.pbrMetallicRoughness||{},d=s?e[s.index]:void 0;if(s&&s.extensions&&s.extensions.KHR_texture_transform&&d){const t=s.extensions.KHR_texture_transform;d.offsetScale=[t.offset[0],t.offset[1],t.scale[0],t.scale[1]];}return {pbrMetallicRoughness:{baseColorFactor:new le(...u),metallicFactor:c,roughnessFactor:h,baseColorTexture:p?e[p.index]:void 0,metallicRoughnessTexture:f?e[f.index]:void 0},doubleSided:l,emissiveFactor:r,alphaMode:n,alphaCutoff:i,normalTexture:a?e[a.index]:void 0,occlusionTexture:d,emissionTexture:o?e[o.index]:void 0,defined:void 0===t.defined}}(void 0!==h?e.json.materials[h]:{defined:!1},r),a}function uv(e,r,n){const{matrix:i,rotation:a,translation:s,scale:o,mesh:l,extras:u,children:c}=e,h={};if(h.matrix=i||t.a6.fromRotationTranslationScale([],a||[0,0,0,1],s||[0,0,0],o||[1,1,1]),void 0!==l){h.meshes=n[l];const t=h.anchor=[0,0];for(const e of h.meshes){const{min:r,max:n}=e.aabb;t[0]+=r[0]+n[0],t[1]+=r[1]+n[1];}t[0]=Math.floor(t[0]/h.meshes.length/2),t[1]=Math.floor(t[1]/h.meshes.length/2);}if(u&&(u.id&&(h.id=u.id),u.lights&&(h.lights=function(t){if(!t.length)return [];const e=function(t){const e=atob(t),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.codePointAt(t);return r}(t),r=[],n=e.length/24,i=new Uint16Array(e.buffer),a=new Float32Array(e.buffer);for(let t=0;t<n;t++){const e=i[2*t*6]/30,n=i[2*t*6+1]/30,s=i[2*t*6+10]/100,o=a[6*t+1],l=a[6*t+2],u=a[6*t+3],c=a[6*t+4],h=u-o,p=c-l,f=Math.hypot(h,p);r.push({pos:[o+.5*h,l+.5*p,n],normal:[p/f,-h/f,0],width:f,height:e,depth:s,points:[o,l,u,c]});}return r}(u.lights))),c){const t=[];for(const e of c)t.push(uv(r.json.nodes[e],r,n));h.children=t;}return h}function cv(t){if(0===t.vertices.length||0===t.indices.length)return null;const[e,r]=[t.vertices[0].clone(),t.vertices[0].clone()];for(let n=1;n<t.vertices.length;++n){const i=t.vertices[n];e.x=Math.min(e.x,i.x),e.y=Math.min(e.y,i.y),r.x=Math.max(r.x,i.x),r.y=Math.max(r.y,i.y);}const n=Math.ceil(Math.max(r.x-e.x,r.y-e.y)/256),i=Math.max(8,n),a=new iv(t.vertices,t.indices,i);return {vertices:t.vertices,indices:t.indices,grid:a,min:e,max:r}}function hv(t){if(!t.extras||!t.extras.ground)return null;const e=t.extras.ground;if(!e||!Array.isArray(e)||0===e.length)return null;const r=e[0];if(!r||!Array.isArray(r)||0===r.length)return null;const n=[];for(const t of r){if(!Array.isArray(t)||2!==t.length)continue;const e=t[0],r=t[1];"number"==typeof e&&"number"==typeof r&&n.push(new g(e,r));}if(n.length<3)return null;n.length>1&&n[n.length-1].equals(n[0])&&n.pop();let i=0;for(let t=0;t<n.length;t++){const e=n[t],r=n[(t+1)%n.length],a=n[(t+2)%n.length];i+=(e.x-r.x)*(a.y-r.y)-(a.x-r.x)*(e.y-r.y);}i>0&&n.reverse();const a=rf(n.flatMap((t=>[t.x,t.y])),[]);return 0===a.length?null:{vertices:n,indices:a}}function pv(t){const e=[],r=[];let n=0;for(const i of t){n=e.length;const t=i.vertexArray.float32,a=i.indexArray.uint16;for(let r=0;r<i.vertexArray.length;r++)e.push(new g(t[3*r+0],t[3*r+1]));for(let t=0;t<3*i.indexArray.length;t++)r.push(a[t]+n);}if(r.length%3!=0)return null;for(let t=0;t<r.length;t+=3){const n=e[r[t+0]],i=e[r[t+1]],a=e[r[t+2]];(n.x-i.x)*(a.y-i.y)-(a.x-i.x)*(n.y-i.y)>0&&([r[t+1],r[t+2]]=[r[t+2],r[t+1]]);}return {vertices:e,indices:r}}function fv(t){const e=function(t,e){const r=[],n=WebGL2RenderingContext;if(t.json.textures)for(const i of t.json.textures){const a={magFilter:n.LINEAR,minFilter:n.NEAREST,wrapS:n.REPEAT,wrapT:n.REPEAT};void 0!==i.sampler&&Object.assign(a,t.json.samplers[i.sampler]),r.push({image:e[i.source],sampler:a,uploaded:!1});}return r}(t,t.images),r=function(t,e){const r=[];for(const n of t.json.meshes){const i=[];for(const r of n.primitives)i.push(lv(r,t,e));r.push(i);}return r}(t,e),{scenes:n,scene:i,nodes:a}=t.json,s=n?n[i||0].nodes:a,o=[];for(const e of s)o.push(uv(a[e],t,r));return function(t,e,r){const n={},i=new Set;for(let a=0;a<t.length;a++){const t=r[e[a]];if(!t.extras)continue;const s=t.extras["mapbox:footprint:version"],o=t.extras["mapbox:footprint:id"];(s||o)&&i.add(a),"1.0.0"===s&&o&&(n[o]=a);}for(let a=0;a<t.length;a++){if(i.has(a))continue;const s=t[a],o=r[e[a]];if(!o.extras)continue;let l=null;s.id in n&&(l=pv(t[n[s.id]].meshes)),l||(l=hv(o)),l&&(s.footprint=cv(l));}if(i.size>0){const e=Array.from(i.values()).sort(((t,e)=>t-e));for(let r=e.length-1;r>=0;r--)t.splice(e[r],1);}}(o,s,t.json.nodes),o}function dv(t){t.heightmap=new Float32Array(4096),t.heightmap.fill(-1);const e=t.vertexArray.float32,r=t.aabb.min[0]-1,n=t.aabb.min[1]-1,i=gx/(t.aabb.max[0]-r+2),a=gx/(t.aabb.max[1]-n+2);for(let s=0;s<e.length;s+=3){const o=e[s+2],l=(e[s+0]-r)*i|0,u=(e[s+1]-n)*a|0;o>t.heightmap[u*gx+l]&&(t.heightmap[u*gx+l]=o);}}function mv(e,r){const n={};n.indexArray=new Es,n.indexArray.reserve(4*e.length),n.vertexArray=new Ls,n.vertexArray.reserve(10*e.length),n.colorArray=new gs,n.vertexArray.reserve(10*e.length);let i=0;for(const a of e){const e=Math.min(10,Math.max(4,1.3*a.height))*r,s=[-a.normal[1],a.normal[0],0],o=Math.min(.29,.1*a.width/a.depth),l=a.width-2*a.depth*r*(o+.01),u=t.N.scaleAndAdd([],a.pos,s,l/2),c=t.N.scaleAndAdd([],a.pos,s,-l/2),h=[u[0],u[1],u[2]+a.height],p=[c[0],c[1],c[2]+a.height],f=t.N.scaleAndAdd([],a.normal,s,o);t.N.scale(f,f,e);const d=t.N.scaleAndAdd([],a.normal,s,-o);t.N.scale(d,d,e),t.N.add(f,u,f),t.N.add(d,c,d),u[2]+=.1,c[2]+=.1,n.vertexArray.emplaceBack(f[0],f[1],f[2]),n.vertexArray.emplaceBack(d[0],d[1],d[2]),n.vertexArray.emplaceBack(u[0],u[1],u[2]),n.vertexArray.emplaceBack(c[0],c[1],c[2]),n.vertexArray.emplaceBack(h[0],h[1],h[2]),n.vertexArray.emplaceBack(p[0],p[1],p[2]),n.vertexArray.emplaceBack(u[0],u[1],u[2]),n.vertexArray.emplaceBack(c[0],c[1],c[2]),n.vertexArray.emplaceBack(f[0],f[1],f[2]),n.vertexArray.emplaceBack(d[0],d[1],d[2]);const m=l/e/2;n.colorArray.emplaceBack(-m-o,-1,m,.8),n.colorArray.emplaceBack(m+o,-1,m,.8),n.colorArray.emplaceBack(-m,0,m,1.3),n.colorArray.emplaceBack(m,0,m,1.3),n.colorArray.emplaceBack(m+o,-.8,m,.7),n.colorArray.emplaceBack(m+o,-.8,m,.7),n.colorArray.emplaceBack(0,0,m,1.3),n.colorArray.emplaceBack(0,0,m,1.3),n.colorArray.emplaceBack(m+o,-1.2,m,.8),n.colorArray.emplaceBack(m+o,-1.2,m,.8),n.indexArray.emplaceBack(6+i,4+i,8+i),n.indexArray.emplaceBack(7+i,9+i,5+i),n.indexArray.emplaceBack(0+i,1+i,2+i),n.indexArray.emplaceBack(1+i,3+i,2+i),i+=10;}const a={defined:!0,emissiveFactor:[0,0,0]},s={};return s.baseColorFactor=le.white,a.pbrMetallicRoughness=s,n.material=a,n.aabb=new Bh([1/0,1/0,1/0],[-1/0,-1/0,-1/0]),n}ra(iv,"TriangleGridIndex");class yv{constructor(t){this._stringToNumber={},this._numberToString=[];for(let e=0;e<t.length;e++){const r=t[e];this._stringToNumber[r]=e,this._numberToString[e]=r;}}encode(t){return this._stringToNumber[t]}decode(t){return this._numberToString[t]}}const gv=["tile","layer","source","sourceLayer","state"];class xv{constructor(t,e,r,n,i){this.type="Feature",this._vectorTileFeature=t,this._z=e,this._x=r,this._y=n,this.properties=t.properties,this.id=i;}get geometry(){return void 0===this._geometry&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._x,this._y,this._z).geometry),this._geometry}set geometry(t){this._geometry=t;}toJSON(){const t={type:"Feature",state:void 0,geometry:this.geometry,properties:this.properties};void 0!==this.id&&(t.id=this.id);for(const e of gv)void 0!==this[e]&&(t[e]=this[e]);return t}}class vv{constructor(t,e){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new ta(Tr,16,0),this.featureIndexArray=new Ws,this.promoteId=e,this.is3DTile=!1;}insert(t,e,r,n,i,a=0,s=0){const o=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(r,n,i,a);const l=this.grid;for(let t=0;t<e.length;t++){const r=e[t],n=[1/0,1/0,-1/0,-1/0];for(let t=0;t<r.length;t++){const e=r[t];n[0]=Math.min(n[0],e.x),n[1]=Math.min(n[1],e.y),n[2]=Math.max(n[2],e.x),n[3]=Math.max(n[3],e.y);}0!==s&&(n[0]-=s,n[1]-=s,n[2]+=s,n[3]+=s),n[0]<Tr&&n[1]<Tr&&n[2]>=0&&n[3]>=0&&l.insert(o,n[0],n[1],n[2],n[3]);}}loadVTLayers(){if(!this.vtLayers){this.vtLayers=new Ef(new Vm(this.rawTileData)).layers,this.sourceLayerCoder=new yv(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"]),this.vtFeatures={};for(const t in this.vtLayers)this.vtFeatures[t]=[];}return this.vtLayers}query(t,e,r,n){this.loadVTLayers();const i=t.params||{},a=Ga(i.filter),s=t.tileResult,o=t.transform,l=s.bufferedTilespaceBounds,u=this.grid.query(l.min.x,l.min.y,l.max.x,l.max.y,((t,e,r,n)=>Yl(s.bufferedTilespaceGeometry,t,e,r,n)));u.sort(_v);let c=null;o.elevation&&u.length>0&&(c=Wf.create(o.elevation,this.tileID));const h={};let p;for(let l=0;l<u.length;l++){const f=u[l];if(f===p)continue;p=f;const d=this.featureIndexArray.get(f);let m=null;if(this.is3DTile){const t=this.bucketLayerIDs[0][0],r=e[t];if("model"!==r.type)continue;const{queryFeature:n,intersectionZ:i}=r.queryIntersectsMatchingFeature(s,d.featureIndex,a,o);n&&this.appendToResult(h,t,d.featureIndex,n,i);}else this.loadMatchingFeature(h,d,a,i.layers,i.availableImages,e,r,n,((e,r,n,i=0)=>(m||(m=Tl(e,this.tileID.canonical,t.tileTransform)),r.queryIntersectsFeature(s,e,n,m,this.z,t.transform,t.pixelPosMatrix,c,i))));}return h}loadMatchingFeature(t,e,r,n,i,a,s,o,l){const{featureIndex:u,bucketIndex:c,sourceLayerIndex:h,layoutVertexArrayOffset:p}=e,f=this.bucketLayerIDs[c];if(n&&!function(t,e){for(let r=0;r<t.length;r++)if(e.indexOf(t[r])>=0)return !0;return !1}(n,f))return;const d=this.sourceLayerCoder.decode(h),m=this.vtLayers[d].feature(u);if(r.needGeometry){const t=Bl(m,!0);if(!r.filter(new Pa(this.tileID.overscaledZ),t,this.tileID.canonical))return}else if(!r.filter(new Pa(this.tileID.overscaledZ),m))return;const y=this.getId(m,d);for(let e=0;e<f.length;e++){const r=f[e];if(n&&n.indexOf(r)<0)continue;const c=a[r];if(!c)continue;let h={};void 0!==y&&o&&(h=o.getState(c.sourceLayer||"_geojsonTileLayer",y));const d=!l||l(m,c,h,p);if(!d)continue;const g=new xv(m,this.z,this.x,this.y,y),x=z({},s[r]);x.paint=bv(x.paint,c.paint,m,h,i),x.layout=bv(x.layout,c.layout,m,h,i),g.layer=x,this.appendToResult(t,r,u,g,d);}}appendToResult(t,e,r,n,i){let a=t[e];void 0===a&&(a=t[e]=[]),a.push({featureIndex:r,feature:n,intersectionZ:i});}lookupSymbolFeatures(t,e,r,n,i,a,s,o){const l={};this.loadVTLayers();const u=Ga(i);for(const i of t)this.loadMatchingFeature(l,{bucketIndex:r,sourceLayerIndex:n,featureIndex:i,layoutVertexArrayOffset:0},u,a,s,o,e);return l}loadFeature(t){const{featureIndex:e,sourceLayerIndex:r}=t;this.loadVTLayers();const n=this.sourceLayerCoder.decode(r),i=this.vtFeatures[n];if(i[e])return i[e];const a=this.vtLayers[n].feature(e);return i[e]=a,a}hasLayer(t){for(const e of this.bucketLayerIDs)for(const r of e)if(t===r)return !0;return !1}getId(t,e){let r=t.id;if(this.promoteId){const n="string"==typeof this.promoteId?this.promoteId:this.promoteId[e];null!=n&&(r=t.properties[n]),"boolean"==typeof r&&(r=Number(r));}return r}}function bv(t,e,r,n,i){return F(t,((t,a)=>{const s=e instanceof Va?e.get(a):null;return s&&s.evaluate?s.evaluate(r,n,i):s}))}function _v(t,e){return e-t}ra(vv,"FeatureIndex",{omit:["rawTileData","sourceLayerCoder"]});const wv=new Float32Array(262144),Mv=new Uint8Array(262144);function Av(t){let e=0;if(t.meshes)for(const r of t.meshes)e=Math.max(e,r.aabb.max[2]);if(t.children)for(const r of t.children)e=Math.max(e,Av(r));return e}function Sv(t,e,r){if(t.meshes)for(const n of t.meshes)n.aabb.min[0]!==1/0&&r.insert(e,n.aabb.min[0],n.aabb.min[1],n.aabb.max[0],n.aabb.max[1]);if(t.children)for(const n of t.children)Sv(n,e,r);}const Iv=["","wall","door","roof","window","lamp","logo"];class kv{constructor(t){this.node=t,this.evaluatedRMEA=[[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[.4,1,0,1],[1,0,0,1],[1,0,0,1]],this.hiddenByReplacement=!1,this.evaluatedScale=[1,1,1],this.evaluatedColor=[],this.emissionHeightBasedParams=[],this.feature={type:"Point",id:t.id,geometry:[],properties:{height:Av(t)}};}getLocalBounds(){if(!this.node.meshes)return new Bh([1/0,1/0,1/0],[-1/0,-1/0,-1/0]);if(!this.aabb){let t=0;const e=new Bh([1/0,1/0,1/0],[-1/0,-1/0,-1/0]);for(const r of this.node.meshes)this.node.lightMeshIndex!==t&&e.encapsulate(r.aabb),t++;this.aabb=e;}return this.aabb}}class Pv{constructor(t,e,r,n,i,a){this.id=e,this.modelTraits|=xx.CoordinateSpaceTile,this.uploaded=!1,this.hasPattern=!1,r&&(this.modelTraits|=xx.HasMapboxMeshFeatures),n&&(this.modelTraits|=xx.HasMeshoptCompression),this.zoom=-1,this.terrainExaggeration=1,this.projection={name:"mercator"},this.replacementUpdateTime=0,this.elevationReadFromZ=255,this.brightness=i,this.dirty=!0,this.needsUpload=!1,this.nodesInfo=[];for(const e of t)this.nodesInfo.push(new kv(e)),Sv(e,a.featureIndexArray.length,a.grid),a.featureIndexArray.emplaceBack(this.nodesInfo.length-1,0,a.bucketLayerIDs.length-1,0);}update(){console.log("Update 3D model bucket");}populate(){console.log("populate 3D model bucket");}uploadPending(){return !this.uploaded||this.needsUpload}upload(t){if(!this.needsUpload)return;const e=this.getNodesInfo();for(const r of e){const e=r.node;this.uploaded?this.updatePbrBuffer(e):wx(e,t,!0);}for(const t of e)Mx(t.node);this.uploaded=!0,this.needsUpload=!1;}updatePbrBuffer(t){let e=!1;if(!t.meshes)return e;for(const r of t.meshes)r.pbrBuffer&&(r.pbrBuffer.updateData(r.featureArray),e=!0);return e}needsReEvaluation(t,e,r){const n=t.transform.projectionOptions,i=t.style.getBrightness(),a=this.brightness!==i;return !!(!this.uploaded||this.dirty||n.name!==this.projection.name||Ev(r.paint.get("model-color").value,a)||Ev(r.paint.get("model-color-mix-intensity").value,a)||Ev(r.paint.get("model-roughness").value,a)||Ev(r.paint.get("model-emissive-strength").value,a)||Ev(r.paint.get("model-height-based-emissive-strength-multiplier").value,a))&&(this.projection=n,this.brightness=i,!0)}evaluateScale(t,e){if(t.transform.zoom===this.zoom)return;this.zoom=t.transform.zoom;const r=this.getNodesInfo(),n=this.id.canonical;for(const t of r){const r=t.feature;t.evaluatedScale=e.paint.get("model-scale").evaluate(r,{},n);}}evaluate(t){const e=this.getNodesInfo();for(const r of e){if(!r.node.meshes)continue;const e=r.feature,n=r.node.meshes&&r.node.meshes[0].featureData,i=r.evaluatedColor[2],a=r.evaluatedRMEA[2],s=this.id.canonical;if(r.hasTranslucentParts=!1,n){for(let n=0;n<Iv.length;n++){const i=Iv[n];i.length&&(e.properties.part=i);const a=t.paint.get("model-color").evaluate(e,{},s),o=t.paint.get("model-color-mix-intensity").evaluate(e,{},s);r.evaluatedColor[n]=[a.r,a.g,a.b,o],r.evaluatedRMEA[n][0]=t.paint.get("model-roughness").evaluate(e,{},s),r.evaluatedRMEA[n][2]=t.paint.get("model-emissive-strength").evaluate(e,{},s),r.evaluatedRMEA[n][3]=a.a,r.emissionHeightBasedParams[n]=t.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e,{},s),!r.hasTranslucentParts&&a.a<1&&(r.hasTranslucentParts=!0);}delete e.properties.part,Tv(r,i!==r.evaluatedColor[2]||a!==r.evaluatedRMEA[2],this.modelTraits);}else r.evaluatedRMEA[0][2]=t.paint.get("model-emissive-strength").evaluate(e,{},s);r.evaluatedScale=t.paint.get("model-scale").evaluate(e,{},s),this.updatePbrBuffer(r.node)||(this.needsUpload=!0);}this.dirty=!1;}elevationUpdate(t,e,r,n){const i=t.findDEMTileFor(r);if(i&&(i.tileID.canonical!==this.terrainTile||e!==this.terrainExaggeration)){if(i.dem&&i.tileID.overscaledZ!==this.elevationReadFromZ){this.elevationReadFromZ=i.tileID.overscaledZ;const e=Wf.create(t,r,i);if(!e)return;this.modelTraits&xx.HasMapboxMeshFeatures&&this.updateDEM(t,e,r,n);for(const t of this.getNodesInfo()){const r=t.node;if(!r.footprint||!r.footprint.vertices||!r.footprint.vertices.length)continue;const n=r.footprint.vertices;let i=e.getElevationAt(n[0].x,n[0].y,!0,!0);for(let t=1;t<n.length;t++)i=Math.min(i,e.getElevationAt(n[t].x,n[t].y,!0,!0));r.elevation=i;}}this.terrainTile=i.tileID.canonical,this.terrainExaggeration=e;}}updateDEM(t,e,r,n){let i=e._dem._modifiedForSources[n];if(void 0===i&&(e._dem._modifiedForSources[n]=[],i=e._dem._modifiedForSources[n]),i.includes(r.canonical))return;const a=e._dem.dim;i.push(r.canonical);let s=!1;for(const t of this.getNodesInfo()){const r=t.node;if(!r.footprint||!r.footprint.grid)continue;const n=r.footprint.grid,i=e.tileCoordToPixel(n.min.x,n.min.y),o=e.tileCoordToPixel(n.max.x,n.max.y),l=Math.min(Math.min(a-o.y,i.x),Math.min(i.y,a-o.x));if(l<0)continue;const u=I(l,2,5);let c=Math.max(0,i.x-u),h=Math.max(0,i.y-u),p=Math.min(o.x+u,a-1),f=Math.min(o.y+u,a-1);for(let t=h;t<=f;++t)for(let e=c;e<=p;++e)Mv[t*a+e]=255;let d=0,m=0;for(let t=0;t<n.cellsY;++t)for(let r=0;r<n.cellsX;++r){if(!n.cells[t*n.cellsX+r])continue;const i=e.tileCoordToPixel(n.min.x+r/n.xScale,n.min.y+t/n.yScale),s=e.tileCoordToPixel(n.min.x+(r+1)/n.xScale,n.min.y+(t+1)/n.yScale);for(let t=i.y;t<=Math.min(s.y+1,a-1);++t)for(let r=i.x;r<=Math.min(s.x+1,a-1);++r)255===Mv[t*a+r]&&(Mv[t*a+r]=0,d+=e.getElevationAtPixel(r,t),m++);}const y=d/m;c=Math.max(1,i.x-u),h=Math.max(1,i.y-u),p=Math.min(o.x+u,a-2),f=Math.min(o.y+u,a-2),s=!0;for(let t=h;t<=f;++t)for(let r=c;r<=p;++r)0===Mv[t*a+r]&&(wv[t*a+r]=e._dem.set(r,t,y));for(let t=1;t<u;++t){c=Math.max(1,i.x-t),h=Math.max(1,i.y-t),p=Math.min(o.x+t,a-2),f=Math.min(o.y+t,a-2);for(let r=h;r<=f;++r)for(let n=c;n<=p;++n){const i=r*a+n;if(255===Mv[i]){let s=0,o=0,l=-1,c=-1;for(let e=-1;e<=1;++e)for(let i=-1;i<=1;++i){const u=(r+e)*a+n+i;if(Mv[u]>=t)continue;const h=wv[u],p=Math.abs(h);p>o&&(s=h,o=p,l=i,c=e);}if(o>.1){const a=1-(t+.5*Math.abs(l*c))/u;let o=e._dem.get(n,r)+s*a;const h=e._dem.get(n+l,r+c),p=e._dem.get(n-l,r-c,!0);(o-h)*(o-p)>0&&(o=(h+p)/2),wv[i]=e._dem.set(n,r,o),Mv[i]=t;}}}}}s&&(e._demTile.needsDEMTextureUpload=!0,e._dem._timestamp=st.now());}getNodesInfo(){return this.nodesInfo}destroy(){const t=this.getNodesInfo();for(const e of t)Mx(e.node),Ax(e.node);}isEmpty(){return !this.nodesInfo.length}updateReplacement(t,e){if(e.updateTime===this.replacementUpdateTime)return;this.replacementUpdateTime=e.updateTime;const r=e.getReplacementRegionsForTile(t.toUnwrapped()),n=this.getNodesInfo();for(let t=0;t<this.nodesInfo.length;t++){const e=n[t].node;n[t].hiddenByReplacement=!!e.footprint&&!r.find((t=>t.footprint===e.footprint));}}getHeightAtTileCoord(t,e){const r=this.getNodesInfo(),n=[];for(let i=0;i<this.nodesInfo.length;i++){const a=r[i],s=a.node.meshes[0];if(t<s.aabb.min[0]||e<s.aabb.min[1]||t>s.aabb.max[0]||e>s.aabb.max[1])continue;const o=(t-s.aabb.min[0])/(s.aabb.max[0]-s.aabb.min[0])*gx|0,l=Math.min(63,(e-s.aabb.min[1])/(s.aabb.max[1]-s.aabb.min[1])*gx|0)*gx+Math.min(63,o);if(!(s.heightmap[l]<0&&a.node.footprint)){if(a.hiddenByReplacement)return;return {height:s.heightmap[l],maxHeight:a.feature.properties.height,hidden:!1,verticalScale:a.evaluatedScale[2]}}if(a.node.footprint.grid.query(new g(t,e),new g(t,e),n),n.length>0)return {height:void 0,maxHeight:a.feature.properties.height,hidden:a.hiddenByReplacement,verticalScale:a.evaluatedScale[2]}}}}function Ev(t,e){return !t.isLightConstant&&e}function zv(t,e,r,n,i,a,s,o){let l=(61440&e|(61440&e)>>4)>>8,u=(3840&e|(3840&e)>>4)>>4,c=240&e|(240&e)>>4;r[3]>0&&(l=ue(l,255*r[0],r[3]),u=ue(u,255*r[1],r[3]),c=ue(c,255*r[2],r[3]));const h=l<<8|u,p=c<<8|Math.floor(255*n[3]),f=function(t){const e=I(t,0,2);return Math.min(Math.round(.5*e*255),255)}(n[2])<<8|15*n[0]<<4|15*n[1],d=I(i[0],0,1),m=I(i[1],0,1),y=I(i[2],0,1),g=I(i[3],0,1);let x,v,b,_;if(d!==m&&s!==a&&m!==d){const t=s-a;v=1/(t*(m-d)),b=-(a+t*d)/(t*(m-d));const e=I(i[4],-1,1);_=Math.pow(10,e),x=255*y<<8|255*g;}else x=65535,v=0,b=1,_=1;if(t.emplaceBack(h,p,f,x,v,b,_),o){const t=o.length;o.clear();for(let e=0;e<t;e++)o.emplaceBack(h,p,f,x,v,b,_);}}function Tv(t,e,r){const n=t.node;let i=0;const a=r&xx.HasMeshoptCompression;for(const r of n.meshes){if(n.lights&&n.lightMeshIndex===i)continue;if(!r.featureData)continue;r.featureArray=new Os,r.featureArray.reserve(r.featureData.length);let s=e;for(const e of r.featureData){const i=a?65535&e:e>>16&65535,o=a?e>>16&65535:65535&e,l=(15&o)<8?15&o:0,u=t.evaluatedRMEA[l],c=t.evaluatedColor[l],h=t.emissionHeightBasedParams[l];let p;if(s&&2===l&&n.lights&&(p=new Os,p.resize(10*n.lights.length)),zv(r.featureArray,i,c,u,h,r.aabb.min[2],r.aabb.max[2],p),p&&s){s=!1;const t=n.meshes[n.lightMeshIndex];t.featureArray=p,t.featureArray._trim();}}r.featureArray._trim(),i++;}}function Bv(t,e,r,n){const i=1<<t.z;e.lat=yl((n/Tr+t.y)/i),e.lng=ml((r/Tr+t.x)/i);}ra(Pv,"Tiled3dModelBucket",{omit:["layers"]}),ra(kv,"Tiled3dModelFeature");const Cv={circle:class extends ss{constructor(t,e,r){super(t,eu,e,r);}createBucket(t){return new Dl(t)}queryRadius(t){const e=t;return Hl("circle-radius",this,e)+Hl("circle-stroke-width",this,e)+Wl(this.paint.get("circle-translate"))}queryIntersectsFeature(t,e,r,n,i,a,s,o){const l=Ql(this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,t.pixelToTileUnitsFactor),u=this.paint.get("circle-radius").evaluate(e,r)+this.paint.get("circle-stroke-width").evaluate(e,r);return cp(t,n,a,s,o,"map"===this.paint.get("circle-pitch-alignment"),"map"===this.paint.get("circle-pitch-scale"),l,u)}getProgramIds(){return ["circle"]}getDefaultProgramParams(t,e){const r=up(this);return {config:new Do(this,e),defines:r,overrideFog:!1}}},heatmap:class extends ss{createBucket(t){return new mp(t)}constructor(t,e,r){super(t,Mp,e,r),this._updateColorRamp();}_handleSpecialPaintPropertyUpdate(t){"heatmap-color"===t&&this._updateColorRamp();}_updateColorRamp(){this.colorRamp=Ap({expression:this._transitionablePaint._values["heatmap-color"].value.expression,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null;}resize(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null);}queryRadius(t){return Hl("heatmap-radius",this,t)}queryIntersectsFeature(t,e,r,n,i,a,s,o){const l=this.paint.get("heatmap-radius").evaluate(e,r);return cp(t,n,a,s,o,!0,!0,new g(0,0),l)}hasOffscreenPass(){return 0!==this.paint.get("heatmap-opacity")&&"none"!==this.visibility}getProgramIds(){return ["heatmap","heatmapTexture"]}getDefaultProgramParams(t,e){return "heatmap"===t?{config:new Do(this,e),overrideFog:!1}:{}}},hillshade:class extends ss{constructor(t,e,r){super(t,Ip,e,r);}hasOffscreenPass(){return 0!==this.paint.get("hillshade-exaggeration")&&"none"!==this.visibility}getProgramIds(){return ["hillshade","hillshadePrepare"]}getDefaultProgramParams(t,e){return {overrideFog:!1}}},fill:class extends ss{constructor(t,e,r){super(t,cf,e,r);}getProgramIds(){const t=this.paint.get("fill-pattern"),e=t&&t.constantOr(1),r=[e?"fillPattern":"fill"];return this.paint.get("fill-antialias")&&r.push(e&&!this.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline"),r}getDefaultProgramParams(t,e){return {config:new Do(this,e),overrideFog:!1}}recalculate(t,e){super.recalculate(t,e);const r=this.paint._values["fill-outline-color"];"constant"===r.value.kind&&void 0===r.value.value&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"]);}createBucket(t){return new lf(t)}queryRadius(){return Wl(this.paint.get("fill-translate"))}queryIntersectsFeature(t,e,r,n,i,a){return !t.queryGeometry.isAboveHorizon&&Fl(Jl(t.tilespaceGeometry,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,t.pixelToTileUnitsFactor),n)}isTileClipped(){return !0}},"fill-extrusion":class extends ss{constructor(t,e,r){super(t,kd,e,r),this._stats={numRenderedVerticesInShadowPass:0,numRenderedVerticesInTransparentPass:0};}createBucket(t){return new md(t)}queryRadius(){return Wl(this.paint.get("fill-extrusion-translate"))}is3D(){return !0}hasShadowPass(){return !0}cutoffRange(){return this.paint.get("fill-extrusion-cutoff-fade-range")}canCastShadows(){return !0}getProgramIds(){return [this.paint.get("fill-extrusion-pattern").constantOr(1)?"fillExtrusionPattern":"fillExtrusion"]}queryIntersectsFeature(e,r,n,i,a,s,o,l,u){const c=Ql(this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),s.angle,e.pixelToTileUnitsFactor),h=this.paint.get("fill-extrusion-height").evaluate(r,n),p=this.paint.get("fill-extrusion-base").evaluate(r,n),f=[0,0],d=l&&s.elevation,m=s.elevation?s.elevation.exaggeration():1,y=e.tile.getBucket(this);if(d&&y instanceof md){const t=y.centroidVertexArray,e=u+1;e<t.length&&(f[0]=t.geta_centroid_pos0(e),f[1]=t.geta_centroid_pos1(e));}if(0===f[0]&&1===f[1])return !1;"globe"===s.projection.name&&(i=Ad([i],[new g(0,0),new g(Tr,Tr)],e.tileID.canonical).map((t=>t.polygon)).flat());const x=d?l:null,[v,b]=function(e,r,n,i,a,s,o,l,u,c,h){return "globe"===e.projection.name?function(e,r,n,i,a,s,o,l,u,c,h){const p=[],f=[],d=e.projection.upVectorScale(h,e.center.lat,e.worldSize).metersToTile,m=[0,0,0,1],y=[0,0,0,1],g=(t,e,r,n)=>{t[0]=e,t[1]=r,t[2]=n,t[3]=1;},x=Md();n>0&&(n+=x),i+=x;for(const x of r){const r=[],v=[];for(const p of x){const f=p.x+a.x,x=p.y+a.y,b=e.projection.projectTilePoint(f,x,h),_=e.projection.upVector(h,p.x,p.y);let w=n,M=i;if(o){const t=Td(f,x,n,i,o,l,u,c);w+=t.base,M+=t.top;}0!==n?g(m,b.x+_[0]*d*w,b.y+_[1]*d*w,b.z+_[2]*d*w):g(m,b.x,b.y,b.z),g(y,b.x+_[0]*d*M,b.y+_[1]*d*M,b.z+_[2]*d*M),t.N.transformMat4(m,m,s),t.N.transformMat4(y,y,s),r.push(new Pd(m[0],m[1],m[2])),v.push(new Pd(y[0],y[1],y[2]));}p.push(r),f.push(v);}return [p,f]}(e,r,n,i,a,s,o,l,u,c,h):o?function(e,r,n,i,a,s,o,l,u){const c=[],h=[],p=[0,0,0,1];for(const f of e){const e=[],d=[];for(const c of f){const h=c.x+i.x,f=c.y+i.y,m=Td(h,f,r,n,s,o,l,u);p[0]=h,p[1]=f,p[2]=m.base,p[3]=1,t.a7.transformMat4(p,p,a),p[3]=Math.max(p[3],1e-5);const y=new Pd(p[0]/p[3],p[1]/p[3],p[2]/p[3]);p[0]=h,p[1]=f,p[2]=m.top,p[3]=1,t.a7.transformMat4(p,p,a),p[3]=Math.max(p[3],1e-5);const g=new Pd(p[0]/p[3],p[1]/p[3],p[2]/p[3]);e.push(y),d.push(g);}c.push(e),h.push(d);}return [c,h]}(r,n,i,a,s,o,l,u,c):function(t,e,r,n,i){const a=[],s=[],o=i[8]*e,l=i[9]*e,u=i[10]*e,c=i[11]*e,h=i[8]*r,p=i[9]*r,f=i[10]*r,d=i[11]*r;for(const e of t){const t=[],r=[];for(const a of e){const e=a.x+n.x,s=a.y+n.y,m=i[0]*e+i[4]*s+i[12],y=i[1]*e+i[5]*s+i[13],g=i[2]*e+i[6]*s+i[14],x=i[3]*e+i[7]*s+i[15],v=m+o,b=y+l,_=g+u,w=Math.max(x+c,1e-5),M=m+h,A=y+p,S=g+f,I=Math.max(x+d,1e-5);t.push(new Pd(v/w,b/w,_/w)),r.push(new Pd(M/I,A/I,S/I));}a.push(t),s.push(r);}return [a,s]}(r,n,i,a,s)}(s,i,p,h,c,o,x,f,m,s.center.lat,e.tileID.canonical),_=e.queryGeometry;return function(t,e,r){let n=1/0;Fl(r,e)&&(n=zd(r,e[0]));for(let i=0;i<e.length;i++){const a=e[i],s=t[i];for(let t=0;t<a.length-1;t++){const e=a[t],i=[e,a[t+1],s[t+1],s[t],e];Vl(r,i)&&(n=Math.min(n,zd(r,i)));}}return n!==1/0&&n}(v,b,_.isPointQuery()?_.screenBounds:_.screenGeometry)}},line:class extends ss{constructor(t,e,r){super(t,Ud,e,r),this.gradientVersion=0;}_handleSpecialPaintPropertyUpdate(t){if("line-gradient"===t){const t=this._transitionablePaint._values["line-gradient"].value.expression;this.stepInterpolant=t._styleExpression&&t._styleExpression.expression instanceof Sn,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER;}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}widthExpression(){return this._transitionablePaint._values["line-width"].value.expression}recalculate(t,e){super.recalculate(t,e),this.paint._values["line-floorwidth"]=Xd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,t);}createBucket(t){return new Nd(t)}getProgramIds(){return [this.paint.get("line-pattern").constantOr(1)?"linePattern":"line"]}getDefaultProgramParams(t,e){const r=Gd(this);return {config:new Do(this,e),defines:r,overrideFog:!1}}queryRadius(t){const e=t,r=Zd(Hl("line-width",this,e),Hl("line-gap-width",this,e)),n=Hl("line-offset",this,e);return r/2+Math.abs(n)+Wl(this.paint.get("line-translate"))}queryIntersectsFeature(t,e,r,n,i,a){if(t.queryGeometry.isAboveHorizon)return !1;const s=Jl(t.tilespaceGeometry,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),a.angle,t.pixelToTileUnitsFactor),o=t.pixelToTileUnitsFactor/2*Zd(this.paint.get("line-width").evaluate(e,r),this.paint.get("line-gap-width").evaluate(e,r)),l=this.paint.get("line-offset").evaluate(e,r);return l&&(n=function(t,e){const r=[],n=new g(0,0);for(let i=0;i<t.length;i++){const a=t[i],s=[];for(let t=0;t<a.length;t++){const r=a[t],i=a[t+1],o=0===t?n:r.sub(a[t-1])._unit()._perp(),l=t===a.length-1?n:i.sub(r)._unit()._perp(),u=o._add(l)._unit();u._mult(1/(u.x*l.x+u.y*l.y)),s.push(u._mult(e)._add(r));}r.push(s);}return r}(n,l*t.pixelToTileUnitsFactor)),function(t,e,r){for(let n=0;n<e.length;n++){const i=e[n];if(t.length>=3)for(let e=0;e<i.length;e++)if(Gl(t,i[e]))return !0;if(Nl(t,i,r))return !0}return !1}(s,n,o)}isTileClipped(){return !0}},symbol:kg,background:class extends ss{constructor(t,e,r){super(t,Eg,e,r);}getProgramIds(){return [this.paint.get("background-pattern")?"backgroundPattern":"background"]}getDefaultProgramParams(t,e){return {overrideFog:!1}}},raster:Og,"raster-particle":qg,sky:class extends ss{constructor(t,e,r){super(t,Yg,e,r),this._updateColorRamp();}_handleSpecialPaintPropertyUpdate(t){"sky-gradient"===t?this._updateColorRamp():"sky-atmosphere-sun"!==t&&"sky-atmosphere-halo-color"!==t&&"sky-atmosphere-color"!==t&&"sky-atmosphere-sun-intensity"!==t||(this._skyboxInvalidated=!0);}_updateColorRamp(){this.colorRamp=Ap({expression:this._transitionablePaint._values["sky-gradient"].value.expression,evaluationKey:"skyRadialProgress"}),this.colorRampTexture&&(this.colorRampTexture.destroy(),this.colorRampTexture=null);}needsSkyboxCapture(t){if(this._skyboxInvalidated||!this.skyboxTexture||!this.skyboxGeometry)return !0;if(!this.paint.get("sky-atmosphere-sun")){const e=t.style.light.properties.get("position");return this._lightPosition.azimuthal!==e.azimuthal||this._lightPosition.polar!==e.polar}return !1}getCenter(t,e){if("atmosphere"===this.paint.get("sky-type")){const r=this.paint.get("sky-atmosphere-sun"),n=!r,i=t.style.light,a=i.properties.get("position");return n&&"viewport"===i.properties.get("anchor")&&j("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),n?Xg(a.azimuthal,90-a.polar,e):Xg(r[0],90-r[1],e)}const r=this.paint.get("sky-gradient-center");return Xg(r[0],90-r[1],e)}isSky(){return !0}markSkyboxValid(t){this._skyboxInvalidated=!1,this._lightPosition=t.style.light.properties.get("position");}hasOffscreenPass(){return !0}getProgramIds(){const t=this.paint.get("sky-type");return "atmosphere"===t?["skyboxCapture","skybox"]:"gradient"===t?["skyboxGradient"]:null}},slot:class extends ss{constructor(t,e,r){super(t,Zg,e);}},model:class extends ss{constructor(t,e,r){super(t,yx,e,r),this._stats={numRenderedVerticesInShadowPass:0,numRenderedVerticesInTransparentPass:0};}createBucket(t){return new dx(t)}getProgramIds(){return ["model"]}is3D(){return !0}hasShadowPass(){return !0}canCastShadows(){return !0}hasLightBeamPass(){return !0}cutoffRange(){return this.paint.get("model-cutoff-fade-range")}queryRadius(t){return t instanceof Pv?Tr-1:0}queryIntersectsFeature(e,r,n,i,a,s){if(!this.modelManager)return !1;const o=this.modelManager,l=e.tile.getBucket(this);if(!(l&&l instanceof dx))return !1;const u=l;for(const n in u.instancesPerModel){const i=u.instancesPerModel[n];if(i.idToFeaturesIndex.hasOwnProperty(r.id)){const a=i.features[i.idToFeaturesIndex[r.id]],l=o.getModel(n,this.scope);if(!l)return !1;let c=t.a6.create();const h=new tl(0,0),p=u.canonical;let f=Number.MAX_VALUE;for(let r=0;r<a.instancedDataCount;++r){const n=16*(a.instancedDataOffset+r),o=i.instancedDataArray.float32,u=[o[n+4],o[n+5],o[n+6]];Bv(p,h,o[n],0|o[n+1]),vx(c,l,s,h,a.rotation,a.scale,u,!1,!1,!1),"globe"===s.projection.name&&(c=nx(c,s));const d=t.a6.multiply([],s.projMatrix,c),m=e.queryGeometry,y=ix(m.isPointQuery()?m.screenBounds:m.screenGeometry,s,d,l.aabb);null!=y&&(f=Math.min(y,f));}return f!==Number.MAX_VALUE&&f}}return !1}_handleOverridablePaintPropertyUpdate(t,e,r){return !(!this.layout||e.isDataDriven()||r.isDataDriven()||"model-color"!==t&&"model-color-mix-intensity"!==t&&"model-rotation"!==t&&"model-scale"!==t&&"model-translation"!==t&&"model-emissive-strength"!==t)}_isPropertyZoomDependent(t){const e=this._transitionablePaint._values[t];return null!=e&&null!=e.value&&null!=e.value.expression&&e.value.expression instanceof Xi}isZoomDependent(){return this._isPropertyZoomDependent("model-scale")||this._isPropertyZoomDependent("model-rotation")||this._isPropertyZoomDependent("model-translation")}queryIntersectsMatchingFeature(e,r,n,i){const a=e.tile,s=a.getBucket(this);let o=null,l=Number.MAX_VALUE;if(!(s&&s instanceof Pv))return {queryFeature:o,intersectionZ:l};const u=s.getNodesInfo()[r];if(u.hiddenByReplacement||!u.node.meshes||!n.filter(new Pa(a.tileID.overscaledZ),u.feature,a.tileID.canonical))return {queryFeature:o,intersectionZ:l};const c=u.node,h=i.calculatePosMatrix(a.tileID.toUnwrapped(),i.worldSize),p=u.evaluatedScale;let f=0;i.elevation&&c.elevation&&(f=c.elevation*i.elevation.exaggeration()),t.a6.translate(h,h,[(c.anchor?c.anchor[0]:0)*(p[0]-1),(c.anchor?c.anchor[1]:0)*(p[1]-1),f]),t.a6.scale(h,h,p),t.a6.multiply(h,h,c.matrix);const d=e.queryGeometry,m=d.isPointQuery()?d.screenBounds:d.screenGeometry,y=function(e){const r=t.a6.multiply([],h,e.matrix),n=t.a6.multiply(r,i.expandedFarZProjMatrix,r);for(let t=0;t<e.meshes.length;++t){const r=e.meshes[t];if(t===e.lightMeshIndex)continue;const a=ix(m,i,n,r.aabb);null!=a&&(l=Math.min(a,l));}if(e.children)for(const t of e.children)y(t);};if(y(c),l===Number.MAX_VALUE)return {queryFeature:o,intersectionZ:l};const g=new tl(0,0);return Bv(a.tileID.canonical,g,u.node.anchor[0],u.node.anchor[1]),o={type:"Feature",geometry:{type:"Point",coordinates:[g.lng,g.lat]},properties:u.feature.properties,id:u.feature.id,state:{},layer:this.serialize()},{queryFeature:o,intersectionZ:l}}}},Rv={read:function(t,e){return t.readFields(Rv._readField,{header_length:0,x:0,y:0,z:0,layers:[]},e)},_readField:function(t,e,r){1===t?e.header_length=r.readFixed32():2===t?e.x=r.readVarint():3===t?e.y=r.readVarint():4===t?e.z=r.readVarint():5===t&&e.layers.push(Rv.Layer.read(r,r.readVarint()+r.pos));},PixelFormat:{PIXEL_FORMAT_UNKNOWN:{value:0,options:{}},PIXEL_FORMAT_UINT32:{value:1,options:{}},PIXEL_FORMAT_UINT16:{value:2,options:{}},PIXEL_FORMAT_UINT8:{value:3,options:{}}},Filter:{}};Rv.Filter.read=function(t,e){return t.readFields(Rv.Filter._readField,{delta_filter:null,filter:null,zigzag_filter:null,bitshuffle_filter:null,byteshuffle_filter:null},e)},Rv.Filter._readField=function(t,e,r){1===t?(e.delta_filter=Rv.Filter.Delta.read(r,r.readVarint()+r.pos),e.filter="delta_filter"):2===t?(e.zigzag_filter=Rv.Filter.Zigzag.read(r,r.readVarint()+r.pos),e.filter="zigzag_filter"):3===t?(e.bitshuffle_filter=Rv.Filter.BitShuffle.read(r,r.readVarint()+r.pos),e.filter="bitshuffle_filter"):4===t&&(e.byteshuffle_filter=Rv.Filter.ByteShuffle.read(r,r.readVarint()+r.pos),e.filter="byteshuffle_filter");},Rv.Filter.Delta={},Rv.Filter.Delta.read=function(t,e){return t.readFields(Rv.Filter.Delta._readField,{block_size:0},e)},Rv.Filter.Delta._readField=function(t,e,r){1===t&&(e.block_size=r.readVarint());},Rv.Filter.Zigzag={},Rv.Filter.Zigzag.read=function(t,e){return t.readFields(Rv.Filter.Zigzag._readField,{},e)},Rv.Filter.Zigzag._readField=function(t,e,r){},Rv.Filter.BitShuffle={},Rv.Filter.BitShuffle.read=function(t,e){return t.readFields(Rv.Filter.BitShuffle._readField,{},e)},Rv.Filter.BitShuffle._readField=function(t,e,r){},Rv.Filter.ByteShuffle={},Rv.Filter.ByteShuffle.read=function(t,e){return t.readFields(Rv.Filter.ByteShuffle._readField,{},e)},Rv.Filter.ByteShuffle._readField=function(t,e,r){},Rv.Codec={},Rv.Codec.read=function(t,e){return t.readFields(Rv.Codec._readField,{gzip_data:null,codec:null,jpeg_image:null,webp_image:null,png_image:null},e)},Rv.Codec._readField=function(t,e,r){1===t?(e.gzip_data=Rv.Codec.GzipData.read(r,r.readVarint()+r.pos),e.codec="gzip_data"):2===t?(e.jpeg_image=Rv.Codec.JpegImage.read(r,r.readVarint()+r.pos),e.codec="jpeg_image"):3===t?(e.webp_image=Rv.Codec.WebpImage.read(r,r.readVarint()+r.pos),e.codec="webp_image"):4===t&&(e.png_image=Rv.Codec.PngImage.read(r,r.readVarint()+r.pos),e.codec="png_image");},Rv.Codec.GzipData={},Rv.Codec.GzipData.read=function(t,e){return t.readFields(Rv.Codec.GzipData._readField,{},e)},Rv.Codec.GzipData._readField=function(t,e,r){},Rv.Codec.JpegImage={},Rv.Codec.JpegImage.read=function(t,e){return t.readFields(Rv.Codec.JpegImage._readField,{},e)},Rv.Codec.JpegImage._readField=function(t,e,r){},Rv.Codec.WebpImage={},Rv.Codec.WebpImage.read=function(t,e){return t.readFields(Rv.Codec.WebpImage._readField,{},e)},Rv.Codec.WebpImage._readField=function(t,e,r){},Rv.Codec.PngImage={},Rv.Codec.PngImage.read=function(t,e){return t.readFields(Rv.Codec.PngImage._readField,{},e)},Rv.Codec.PngImage._readField=function(t,e,r){},Rv.DataIndexEntry={},Rv.DataIndexEntry.read=function(t,e){return t.readFields(Rv.DataIndexEntry._readField,{first_byte:0,last_byte:0,filters:[],codec:null,offset:0,scale:0,bands:[]},e)},Rv.DataIndexEntry._readField=function(t,e,r){1===t?e.first_byte=r.readFixed64():2===t?e.last_byte=r.readFixed64():3===t?e.filters.push(Rv.Filter.read(r,r.readVarint()+r.pos)):4===t?e.codec=Rv.Codec.read(r,r.readVarint()+r.pos):5===t?e.offset=r.readFloat():6===t?e.scale=r.readFloat():7===t&&e.bands.push(r.readString());},Rv.Layer={},Rv.Layer.read=function(t,e){return t.readFields(Rv.Layer._readField,{version:0,name:"",units:"",tilesize:0,buffer:0,pixel_format:0,data_index:[]},e)},Rv.Layer._readField=function(t,e,r){1===t?e.version=r.readVarint():2===t?e.name=r.readString():3===t?e.units=r.readString():4===t?e.tilesize=r.readVarint():5===t?e.buffer=r.readVarint():6===t?e.pixel_format=r.readVarint():7===t&&e.data_index.push(Rv.DataIndexEntry.read(r,r.readVarint()+r.pos));};const Dv={read:function(t,e){return t.readFields(Dv._readField,{uint32_values:null,values:null,fixed32_values:null},e)},_readField:function(t,e,r){2===t?(e.uint32_values=Dv.Uint32Values.read(r,r.readVarint()+r.pos),e.values="uint32_values"):3===t&&(e.fixed32_values=Dv.Fixed32Values.read(r,r.readVarint()+r.pos),e.values="fixed32_values");},Uint32Values:{}};Dv.Uint32Values.read=function(t,e){return t.readFields(Dv.Uint32Values._readField,{values:[]},e)},Dv.Uint32Values._readField=function(t,e,r){1===t&&(e.readValuesInto=function(t){if(2!==t.type)throw new Error(`Unsupported pbf type "${t.type}"`);const e=function(t){return 2===t.type?t.readVarint()+t.pos:t.pos+1}(t),r=t.pos;return t.pos=e,function(n){t.pos=r;let i=0;for(;t.pos<e;){const e=t.readVarint();n[i++]=e;}return n}}(r));},Dv.Fixed32Values={},Dv.Fixed32Values.read=function(t,e){return t.readFields(Dv.Fixed32Values._readField,{values:[]},e)},Dv.Fixed32Values._readField=function(t,e,r){throw new Error("Not implemented")};
    /**
     * tiny-lru
     *
     * @copyright 2023 Jason Mulligan <jason.mulligan@avoidwork.com>
     * @license BSD-3-Clause
     * @version 11.2.5
     */
    class Vv{constructor(t=0,e=0,r=!1){this.first=null,this.items=Object.create(null),this.last=null,this.max=t,this.resetTtl=r,this.size=0,this.ttl=e;}clear(){return this.first=null,this.items=Object.create(null),this.last=null,this.size=0,this}delete(t){if(this.has(t)){const e=this.items[t];delete this.items[t],this.size--,null!==e.prev&&(e.prev.next=e.next),null!==e.next&&(e.next.prev=e.prev),this.first===e&&(this.first=e.next),this.last===e&&(this.last=e.prev);}return this}entries(t=this.keys()){return t.map((t=>[t,this.get(t)]))}evict(t=!1){if(t||this.size>0){const t=this.first;delete this.items[t.key],0==--this.size?(this.first=null,this.last=null):(this.first=t.next,this.first.prev=null);}return this}expiresAt(t){let e;return this.has(t)&&(e=this.items[t].expiry),e}get(t){let e;if(this.has(t)){const r=this.items[t];this.ttl>0&&r.expiry<=Date.now()?this.delete(t):(e=r.value,this.set(t,e,!0));}return e}has(t){return t in this.items}keys(){const t=[];let e=this.first;for(;null!==e;)t.push(e.key),e=e.next;return t}set(t,e,r=!1,n=this.resetTtl){let i;if(r||this.has(t)){if(i=this.items[t],i.value=e,!1===r&&n&&(i.expiry=this.ttl>0?Date.now()+this.ttl:this.ttl),this.last!==i){const t=this.last,e=i.next,r=i.prev;this.first===i&&(this.first=i.next),i.next=null,i.prev=this.last,t.next=i,null!==r&&(r.next=e),null!==e&&(e.prev=r);}}else this.max>0&&this.size===this.max&&this.evict(!0),i=this.items[t]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key:t,prev:this.last,next:null,value:e},1==++this.size?this.first=i:this.last.next=i;return this.last=i,this}values(t=this.keys()){return t.map((t=>this.get(t)))}}function Lv(t,e){if(4!==e.length)throw new Error(`Expected data of dimension 4 but got ${e.length}.`);let r=e[3];for(let n=2;n>=1;n--){const i=1===n?1:0,a=2===n?1:0;for(let n=0;n<e[0];n++){const s=e[1]*n;for(let n=i;n<e[1];n++){const i=e[2]*(n+s);for(let n=a;n<e[2];n++){const a=e[3]*(n+i);for(let n=0;n<e[3];n++){const e=a+n;t[e]+=t[e-r];}}}}r*=e[n];}return t}function Fv(t){for(let e=0,r=t.length;e<r;e++)t[e]=t[e]>>>1^-(1&t[e]);return t}function Nv(t,e){switch(e){case"uint32":return t;case"uint16":for(let e=0;e<t.length;e+=2){const r=t[e],n=t[e+1];t[e]=(240&r)>>4|(61440&r)>>8|(240&n)<<4|61440&n,t[e+1]=15&r|(3840&r)>>4|(15&n)<<8|(3840&n)<<4;}return t;case"uint8":for(let e=0;e<t.length;e+=4){const r=t[e],n=t[e+1],i=t[e+2],a=t[e+3];t[e+0]=(192&r)>>6|(192&n)>>4|(192&i)>>2|192&a,t[e+1]=(48&r)>>4|(48&n)>>2|48&i|(48&a)<<2,t[e+2]=(12&r)>>2|12&n|(12&i)<<2|(12&a)<<4,t[e+3]=3&r|(3&n)<<2|(3&i)<<4|(3&a)<<6;}return t;default:throw new Error(`Invalid pixel format, "${e}"`)}}class Ov extends Error{constructor(t){super(t),this.name="MRTError";}}var Uv=Uint8Array,jv=Uint16Array,qv=Int32Array,$v=new Uv([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Gv=new Uv([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Yv=new Uv([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Xv=function(t,e){for(var r=new jv(31),n=0;n<31;++n)r[n]=e+=1<<t[n-1];var i=new qv(r[30]);for(n=1;n<30;++n)for(var a=r[n];a<r[n+1];++a)i[a]=a-r[n]<<5|n;return {b:r,r:i}},Zv=Xv($v,2),Kv=Zv.b,Hv=Zv.r;Kv[28]=258,Hv[258]=28;for(var Wv=Xv(Gv,0).b,Jv=new jv(32768),Qv=0;Qv<32768;++Qv){var tb=(43690&Qv)>>1|(21845&Qv)<<1;Jv[Qv]=((65280&(tb=(61680&(tb=(52428&tb)>>2|(13107&tb)<<2))>>4|(3855&tb)<<4))>>8|(255&tb)<<8)>>1;}var eb=function(t,e,r){for(var n=t.length,i=0,a=new jv(e);i<n;++i)t[i]&&++a[t[i]-1];var s,o=new jv(e);for(i=1;i<e;++i)o[i]=o[i-1]+a[i-1]<<1;if(r){s=new jv(1<<e);var l=15-e;for(i=0;i<n;++i)if(t[i])for(var u=i<<4|t[i],c=e-t[i],h=o[t[i]-1]++<<c,p=h|(1<<c)-1;h<=p;++h)s[Jv[h]>>l]=u;}else for(s=new jv(n),i=0;i<n;++i)t[i]&&(s[i]=Jv[o[t[i]-1]++]>>15-t[i]);return s},rb=new Uv(288);for(Qv=0;Qv<144;++Qv)rb[Qv]=8;for(Qv=144;Qv<256;++Qv)rb[Qv]=9;for(Qv=256;Qv<280;++Qv)rb[Qv]=7;for(Qv=280;Qv<288;++Qv)rb[Qv]=8;var nb=new Uv(32);for(Qv=0;Qv<32;++Qv)nb[Qv]=5;var ib=eb(rb,9,1),ab=eb(nb,5,1),sb=function(t){for(var e=t[0],r=1;r<t.length;++r)t[r]>e&&(e=t[r]);return e},ob=function(t,e,r){var n=e/8|0;return (t[n]|t[n+1]<<8)>>(7&e)&r},lb=function(t,e){var r=e/8|0;return (t[r]|t[r+1]<<8|t[r+2]<<16)>>(7&e)},ub=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],cb=function(t,e,r){var n=new Error(e||ub[t]);if(n.code=t,Error.captureStackTrace&&Error.captureStackTrace(n,cb),!r)throw n;return n},hb=new Uv(0),pb="undefined"!=typeof TextDecoder&&new TextDecoder;try{pb.decode(hb,{stream:!0});}catch(t){}const fb={gzip_data:"gzip"};const db={0:"uint32",1:"uint32",2:"uint16",3:"uint8"},mb={uint32:1,uint16:2,uint8:4},yb={uint32:Uint32Array,uint16:Uint16Array,uint8:Uint8Array};class gb{constructor(t=1){this.x=NaN,this.y=NaN,this.z=NaN,this.layers={},this._cacheSize=t;}getLayer(t){return this.layers[t]}getHeaderLength(t){const e=new Uint8Array(t),r=new DataView(t);if(13!==e[0])throw new Ov("File is not a valid MRT.");return r.getUint32(1,!0)}parseHeader(t){const e=new Uint8Array(t),r=this.getHeaderLength(t);if(e.length<r)throw new Ov(`Expected header with length >= ${r} but got buffer of length ${e.length}`);const n=new Vm(e.subarray(0,r)),i=Rv.read(n);if(!isNaN(this.x)&&(this.x!==i.x||this.y!==i.y||this.z!==i.z))throw new Ov(`Invalid attempt to parse header ${i.z}/${i.x}/${i.y} for tile ${this.z}/${this.x}/${this.y}`);this.x=i.x,this.y=i.y,this.z=i.z;for(const t of i.layers)this.layers[t.name]=new xb(t,{cacheSize:this._cacheSize});return this}createDecodingTask(t){const e=[],r=this.getLayer(t.layerName);for(let n=0;n<r.dataIndex.length;n++){const i=r.dataIndex[n],a=i.first_byte-t.firstByte,s=i.last_byte+1-t.firstByte;if(n<t.firstBlock||n>t.lastBlock)continue;if(r._blocksInProgress.has(n))continue;const o={layerName:r.name,firstByte:a,lastByte:s,pixelFormat:r.pixelFormat,blockIndex:n,blockShape:[i.bands.length].concat(r.bandShape),buffer:r.buffer,codec:i.codec.codec,filters:i.filters.map((t=>t.filter))};r._blocksInProgress.add(n),e.push(o);}return new vb(e,(()=>{e.forEach((t=>r._blocksInProgress.delete(t.blockIndex)));}),((t,n)=>{if(e.forEach((t=>r._blocksInProgress.delete(t.blockIndex))),t)throw t;n.forEach((t=>{this.getLayer(t.layerName).processDecodedData(t);}));}))}}class xb{constructor({version:t,name:e,units:r,tilesize:n,pixel_format:i,buffer:a,data_index:s},o){if(this.version=t,1!==this.version)throw new Ov(`Cannot parse raster layer encoded with MRT version ${t}`);this.name=e,this.units=r,this.tileSize=n,this.buffer=a,this.pixelFormat=db[i],this.dataIndex=s,this.bandShape=[n+2*a,n+2*a,mb[this.pixelFormat]],this._decodedBlocks=function(t=1e3,e=0,r=!1){if(isNaN(t)||t<0)throw new TypeError("Invalid max value");if(isNaN(e)||e<0)throw new TypeError("Invalid ttl value");if("boolean"!=typeof r)throw new TypeError("Invalid resetTtl value");return new Vv(t,e,r)}(o?o.cacheSize:5),this._blocksInProgress=new Set;}processDecodedData(t){const e=t.blockIndex.toString();this._decodedBlocks.get(e)||this._decodedBlocks.set(e,t.data);}getBlockForBand(t){let e=0;switch(typeof t){case"string":for(const[r,n]of this.dataIndex.entries()){for(const[i,a]of n.bands.entries())if(a===t)return {bandIndex:e+i,blockIndex:r,blockBandIndex:i};e+=n.bands.length;}break;case"number":for(const[r,n]of this.dataIndex.entries()){if(t>=e&&t<e+n.bands.length)return {bandIndex:t,blockIndex:r,blockBandIndex:t-e};e+=n.bands.length;}break;default:throw new Ov(`Invalid band \`${JSON.stringify(t)}\`. Expected string or integer.`)}throw new Ov(`Band not found: ${JSON.stringify(t)}`)}getDataRange(t){let e=1/0,r=-1/0,n=1/0,i=-1/0;for(const a of t){const{blockIndex:t}=this.getBlockForBand(a);if(t<0)throw new Ov(`Invalid band: ${JSON.stringify(a)}`);const s=this.dataIndex[t];n=Math.min(n,t),i=Math.max(i,t),e=Math.min(e,s.first_byte),r=Math.max(r,s.last_byte);}return {layerName:this.name,firstByte:e,lastByte:r,firstBlock:n,lastBlock:i}}hasBand(t){const{blockIndex:e}=this.getBlockForBand(t);return e>=0}hasDataForBand(t){const{blockIndex:e}=this.getBlockForBand(t);return e>=0&&!!this._decodedBlocks.get(e.toString())}getBandView(t){const{blockIndex:e,blockBandIndex:r}=this.getBlockForBand(t),n=this._decodedBlocks.get(e.toString());if(!n)throw new Ov(`Data for band ${JSON.stringify(t)} of layer "${this.name}" not decoded.`);const i=this.dataIndex[e],a=this.bandShape.reduce(((t,e)=>t*e),1),s=r*a,o=n.subarray(s,s+a);return {data:o,bytes:new Uint8Array(o.buffer).subarray(o.byteOffset,o.byteOffset+o.byteLength),tileSize:this.tileSize,buffer:this.buffer,offset:i.offset,scale:i.scale}}}class vb{constructor(t,e,r){this.tasks=t,this._onCancel=e,this._onComplete=r,this._finalized=!1;}cancel(){this._finalized||(this._onCancel(),this._finalized=!0);}complete(t,e){this._finalized||(this._onComplete(t,e),this._finalized=!0);}}gb.performDecoding=function(t,e){return Promise.all(e.tasks.map((e=>{const{layerName:r,firstByte:n,lastByte:i,pixelFormat:a,blockShape:s,blockIndex:o,filters:l,codec:u}=e,c=new Uint8Array(t).subarray(n,i+1),h=new Uint32Array(s[0]*s[1]*s[2]);let p;if("gzip_data"!==u)throw new Error(`Unhandled codec: ${u}`);return p=function(t,e){if(!globalThis.DecompressionStream&&"gzip_data"===e)return Promise.resolve(((a=function(t){31==t[0]&&139==t[1]&&8==t[2]||cb(6,"invalid gzip data");var e=t[3],r=10;4&e&&(r+=2+(t[10]|t[11]<<8));for(var n=(e>>3&1)+(e>>4&1);n>0;n-=!t[r++]);return r+(2&e)}(i=t))+8>i.length&&cb(6,"invalid gzip data"),function(t,e,r,n){var i=t.length;if(!i||e.f&&!e.l)return r||new Uv(0);var a=!r,s=a||2!=e.i,o=e.i;a&&(r=new Uv(3*i));var l=function(t){var e=r.length;if(t>e){var n=new Uv(Math.max(2*e,t));n.set(r),r=n;}},u=e.f||0,c=e.p||0,h=e.b||0,p=e.l,f=e.d,d=e.m,m=e.n,y=8*i;do{if(!p){u=ob(t,c,1);var g=ob(t,c+1,3);if(c+=3,!g){var x=t[(E=4+((c+7)/8|0))-4]|t[E-3]<<8,v=E+x;if(v>i){o&&cb(0);break}s&&l(h+x),r.set(t.subarray(E,v),h),e.b=h+=x,e.p=c=8*v,e.f=u;continue}if(1==g)p=ib,f=ab,d=9,m=5;else if(2==g){var b=ob(t,c,31)+257,_=ob(t,c+10,15)+4,w=b+ob(t,c+5,31)+1;c+=14;for(var M=new Uv(w),A=new Uv(19),S=0;S<_;++S)A[Yv[S]]=ob(t,c+3*S,7);c+=3*_;var I=sb(A),k=(1<<I)-1,P=eb(A,I,1);for(S=0;S<w;){var E,z=P[ob(t,c,k)];if(c+=15&z,(E=z>>4)<16)M[S++]=E;else {var T=0,B=0;for(16==E?(B=3+ob(t,c,3),c+=2,T=M[S-1]):17==E?(B=3+ob(t,c,7),c+=3):18==E&&(B=11+ob(t,c,127),c+=7);B--;)M[S++]=T;}}var C=M.subarray(0,b),R=M.subarray(b);d=sb(C),m=sb(R),p=eb(C,d,1),f=eb(R,m,1);}else cb(1);if(c>y){o&&cb(0);break}}s&&l(h+131072);for(var D=(1<<d)-1,V=(1<<m)-1,L=c;;L=c){var F=(T=p[lb(t,c)&D])>>4;if((c+=15&T)>y){o&&cb(0);break}if(T||cb(2),F<256)r[h++]=F;else {if(256==F){L=c,p=null;break}var N=F-254;F>264&&(N=ob(t,c,(1<<(j=$v[S=F-257]))-1)+Kv[S],c+=j);var O=f[lb(t,c)&V],U=O>>4;if(O||cb(3),c+=15&O,R=Wv[U],U>3){var j=Gv[U];R+=lb(t,c)&(1<<j)-1,c+=j;}if(c>y){o&&cb(0);break}s&&l(h+131072);var q=h+N;if(h<R){var $=0-R,G=Math.min(R,q);for($+h<0&&cb(3);h<G;++h)r[h]=n[$+h];}for(;h<q;++h)r[h]=r[h-R];}}e.l=p,e.p=L,e.b=h,e.f=u,p&&(u=1,e.m=d,e.d=f,e.n=m);}while(!u);return h!=r.length&&a?function(t,e,r){return (null==e||e<0)&&(e=0),(null==r||r>t.length)&&(r=t.length),new Uv(t.subarray(e,r))}(r,0,h):r.subarray(0,h)}(i.subarray(a,-8),{i:2},new Uv(((r=i)[(n=r.length)-4]|r[n-3]<<8|r[n-2]<<16|r[n-1]<<24)>>>0),void 0)));var r,n,i,a;const s=fb[e];if(!s)throw new Error(`Unhandled codec: ${e}`);const o=new globalThis.DecompressionStream(s);return new Response(new Blob([t]).stream().pipeThrough(o)).arrayBuffer().then((t=>new Uint8Array(t)))}(c,u).then((t=>{const e=Dv.read(new Vm(t));if("uint32_values"===e.values)return e.uint32_values.readValuesInto(h),new(yb[a])(h.buffer);throw new Error(`Unhandled numeric data "${e.values}"`)})),p.then((t=>{for(let e=l.length-1;e>=0;e--)switch(l[e]){case"delta_filter":Lv(t,s);break;case"zigzag_filter":Fv(t);break;case"bitshuffle_filter":Nv(t,a);break;default:throw new Error(`Unhandled filter "${l[e]}"`)}return {layerName:r,blockIndex:o,data:t}})).catch((t=>{throw t}))})))},ra(vb,"MRTDecodingBatch",{omit:["_onCancel","_onComplete"]});const bb=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class _b{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,r]=new Uint8Array(t,0,2);if(219!==e)throw new Error("Data does not appear to be in a KDBush format.");const n=r>>4;if(1!==n)throw new Error(`Got v${n} data when expected v1.`);const i=bb[15&r];if(!i)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(t,2,1),[s]=new Uint32Array(t,4,1);return new _b(s,a,i,t)}constructor(t,e=64,r=Float64Array,n){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=r,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const i=bb.indexOf(this.ArrayType),a=2*t*this.ArrayType.BYTES_PER_ELEMENT,s=t*this.IndexArrayType.BYTES_PER_ELEMENT,o=(8-s%8)%8;if(i<0)throw new Error(`Unexpected typed array class: ${r}.`);n&&n instanceof ArrayBuffer?(this.data=n,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+s+o,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+a+s+o),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+s+o,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+i]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t);}add(t,e){const r=this._pos>>1;return this.ids[r]=r,this.coords[this._pos++]=t,this.coords[this._pos++]=e,r}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return wb(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:a,nodeSize:s}=this,o=[0,i.length-1,0],l=[];for(;o.length;){const u=o.pop()||0,c=o.pop()||0,h=o.pop()||0;if(c-h<=s){for(let s=h;s<=c;s++){const o=a[2*s],u=a[2*s+1];o>=t&&o<=r&&u>=e&&u<=n&&l.push(i[s]);}continue}const p=h+c>>1,f=a[2*p],d=a[2*p+1];f>=t&&f<=r&&d>=e&&d<=n&&l.push(i[p]),(0===u?t<=f:e<=d)&&(o.push(h),o.push(p-1),o.push(1-u)),(0===u?r>=f:n>=d)&&(o.push(p+1),o.push(c),o.push(1-u));}return l}within(t,e,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:n,coords:i,nodeSize:a}=this,s=[0,n.length-1,0],o=[],l=r*r;for(;s.length;){const u=s.pop()||0,c=s.pop()||0,h=s.pop()||0;if(c-h<=a){for(let r=h;r<=c;r++)Ib(i[2*r],i[2*r+1],t,e)<=l&&o.push(n[r]);continue}const p=h+c>>1,f=i[2*p],d=i[2*p+1];Ib(f,d,t,e)<=l&&o.push(n[p]),(0===u?t-r<=f:e-r<=d)&&(s.push(h),s.push(p-1),s.push(1-u)),(0===u?t+r>=f:e+r>=d)&&(s.push(p+1),s.push(c),s.push(1-u));}return o}}function wb(t,e,r,n,i,a){if(i-n<=r)return;const s=n+i>>1;Mb(t,e,s,n,i,a),wb(t,e,r,n,s-1,1-a),wb(t,e,r,s+1,i,1-a);}function Mb(t,e,r,n,i,a){for(;i>n;){if(i-n>600){const s=i-n+1,o=r-n+1,l=Math.log(s),u=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*u*(s-u)/s)*(o-s/2<0?-1:1);Mb(t,e,r,Math.max(n,Math.floor(r-o*u/s+c)),Math.min(i,Math.floor(r+(s-o)*u/s+c)),a);}const s=e[2*r+a];let o=n,l=i;for(Ab(t,e,n,r),e[2*i+a]>s&&Ab(t,e,n,i);o<l;){for(Ab(t,e,o,l),o++,l--;e[2*o+a]<s;)o++;for(;e[2*l+a]>s;)l--;}e[2*n+a]===s?Ab(t,e,n,l):(l++,Ab(t,e,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1);}}function Ab(t,e,r,n){Sb(t,r,n),Sb(e,2*r,2*n),Sb(e,2*r+1,2*n+1);}function Sb(t,e,r){const n=t[e];t[e]=t[r],t[r]=n;}function Ib(t,e,r,n){const i=t-r,a=e-n;return i*i+a*a}t.$=Yy,t.A=Di,t.B=Bi,t.C=nr,t.D=qa,t.E=ee,t.F=Oa,t.G=La,t.H=class{constructor(t){this.specification=t;}possiblyEvaluate(t,e){return G(t.expression.evaluate(e))}interpolate(t,e,r){return {x:ue(t.x,e.x,r),y:ue(t.y,e.y,r),z:ue(t.z,e.z,r),azimuthal:ue(t.azimuthal,e.azimuthal,r),polar:ue(t.polar,e.polar,r)}}},t.I=dy,t.J=Ta,t.K=Pa,t.L=Ml,t.M=class{constructor(t,e,r,n){this.id=t,this.position=null!=e?new tl(e[0],e[1]):new tl(0,0),this.orientation=null!=r?r:[0,0,0],this.nodes=n,this.uploaded=!1,this.aabb=new Bh([1/0,1/0,1/0],[-1/0,-1/0,-1/0]),this.matrix=[];}_applyTransformations(e,r){if(t.a6.multiply(e.matrix,r,e.matrix),e.meshes)for(const t of e.meshes){const r=Bh.applyTransform(t.aabb,e.matrix);this.aabb.encapsulate(r);}if(e.children)for(const t of e.children)this._applyTransformations(t,e.matrix);}computeBoundsAndApplyParent(){const e=t.a6.identity([]);for(const t of this.nodes)this._applyTransformations(t,e);}computeModelMatrix(t,e,r,n,i,a,s=!1){vx(this.matrix,this,t.transform,this.position,e,r,n,i,a,s);}upload(t){if(!this.uploaded){for(const e of this.nodes)wx(e,t);for(const t of this.nodes)Mx(t);this.uploaded=!0;}}destroy(){for(const t of this.nodes)Ax(t);}},t.O=k,t.P=g,t.Q=Va,t.R=At,t.S=rp,t.T=Cg,t.U=ue,t.V=Tr,t.W=ce,t.X=class{constructor(t){this.specification=t;}possiblyEvaluate(t,e){return function([t,e]){const r=G([1,t,e]);return {x:r.x,y:r.y,z:r.z}}(t.expression.evaluate(e))}interpolate(t,e,r){return {x:ue(t.x,e.x,r),y:ue(t.y,e.y,r),z:ue(t.z,e.z,r)}}},t.Y=function(t,e,r=0,n=!0){const i=new g(r,r),a=t.sub(i),s=e.add(i),o=[a,new g(s.x,a.y),s,new g(a.x,s.y)];return n&&o.push(a.clone()),o},t.Z=Xi,t._=function(t,e){const r=[];for(let n=0;n<t.length;n++){const i=P(n-1,-1,t.length-1),a=P(n+1,-1,t.length-1),s=t[n],o=t[a],l=t[i].sub(s).unit(),u=o.sub(s).unit(),c=u.angleWithSep(l.x,l.y),h=l.add(u).unit().mult(-1*e/Math.sin(c/2));r.push(s.add(h));}return r},t.a=te,t.a$=function(t){const e=[];for(const r in t)e.push(t[r]);return e},t.a0=Yl,t.a1=function(e,r,n=0){return t.N.fromValues(((r.x-n)*e.scale-e.x)*Tr,(r.y*e.scale-e.y)*Tr,gl(r.z,r.y))},t.a2=Sh,t.a3=jd,t.a4=function(t){let e=1/0,r=1/0,n=-1/0,i=-1/0;for(const a of t)e=Math.min(e,a.x),r=Math.min(r,a.y),n=Math.max(n,a.x),i=Math.max(i,a.y);return {min:new g(e,r),max:new g(n,i)}},t.a5=pl,t.a8=Gl,t.a9=Sl,t.aA=bi,t.aB=eo,t.aC=B,t.aD=qs,t.aE=Mg,t.aF=function(){ka.isLoading()||ka.isLoaded()||"deferred"!==Sa()||Ia();},t.aG=Ga,t.aH=Bl,t.aI=xv,t.aJ=X,t.aK=Nd,t.aL=lf,t.aM=Tl,t.aN=ps,t.aO=Vs,t.aP=Vh,t.aQ=rf,t.aR=Bg,t.aS=function(e,r){const n=rp(r.zoom);if(0===n)return jh(e);const i=Yh(e),a=Xh(i),s=pl(i.getWest())*r.worldSize,o=pl(i.getEast())*r.worldSize,l=fl(i.getNorth())*r.worldSize,u=fl(i.getSouth())*r.worldSize,c=[s,l,0],h=[o,l,0],p=[s,u,0],f=[o,u,0],d=t.a6.invert([],r.globeMatrix);return t.N.transformMat4(c,c,d),t.N.transformMat4(h,h,d),t.N.transformMat4(p,p,d),t.N.transformMat4(f,f,d),a[0]=qh(a[0],p,n),a[1]=qh(a[1],f,n),a[2]=qh(a[2],h,n),a[3]=qh(a[3],c,n),Bh.fromPoints(a)},t.aT=Wh,t.aU=Zh,t.aV=qh,t.aW=fs,t.aX=Dh,t.aY=V,t.aZ=gb,t.a_=Pt,t.aa=I,t.ab=jo,t.ac=function(t,e){const r={};for(let n=0;n<e.length;n++){const i=e[n];i in t&&(r[i]=t[i]);}return r},t.ad=el,t.ae=fl,t.af=class{constructor(t){this.entries={},this.scheduler=t;}request(t,e,r,n){const i=this.entries[t]=this.entries[t]||{callbacks:[]};if(i.result){const[t,r]=i.result;return this.scheduler?this.scheduler.add((()=>{n(t,r);}),e):n(t,r),()=>{}}return i.callbacks.push(n),i.cancel||(i.cancel=r(((r,n)=>{i.result=[r,n];for(const t of i.callbacks)this.scheduler?this.scheduler.add((()=>{t(r,n);}),e):t(r,n);setTimeout((()=>delete this.entries[t]),3e3);}))),()=>{i.result||(i.callbacks=i.callbacks.filter((t=>t!==n)),i.callbacks.length||(i.cancel(),delete this.entries[t]));}}},t.ag=is,t.ah=function(t,e,r){const n=JSON.stringify(t.request);return t.data&&(this.deduped.entries[n]={result:[null,t.data]}),this.deduped.request(n,{type:"parseTile",isSymbolTile:t.isSymbolTile,zoom:t.tileZoom},(e=>{const n=Pt(t.request,((t,n,i,a)=>{t?e(t):n&&e(null,{vectorTile:r?void 0:new Ef(new Vm(n)),rawData:n,cacheControl:i,expires:a});}));return ()=>{n.cancel(),e();}}),e)},t.ai=function(t){yt++,yt>ut&&(t.getActor().send("enforceCacheSizeLimit",lt),yt=0);},t.aj=qt,t.ak=at,t.al=function(t){return t<=1?1:Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},t.am=sl,t.an=Og,t.ao=qg,t.ap=Fg,t.aq=function(t,e){const r=document.createElement("video");r.muted=!0,r.onloadstart=function(){e(null,r);};for(let e=0;e<t.length;e++){const n=document.createElement("source");Et(t[e])||(r.crossOrigin="Anonymous"),n.src=t[e],r.appendChild(n);}return {cancel:()=>{}}},t.ar=Rg,t.as=Gy,t.at=ml,t.au=yl,t.av=ds,t.aw=Es,t.ax=le,t.ay=cs,t.az=Ls,t.b=Qt,t.b$=wa,t.b0=function(t,e){const r=[];for(const n in t)n in e||r.push(n);return r},t.b1=E,t.b2=["type","source","source-layer","minzoom","maxzoom","filter","layout"],t.b3=function(e,r){const{x:n,y:i}=e.point,a=ep(n,i,e.worldSize/e._pixelsPerMercatorPixel,0,0);return t.a6.multiply(a,a,Jh(jh(r)))},t.b5=lm,t.b6=jm,t.b7=om,t.b8=function(t,e,r,n,i){const a=5*e+2;t.float32[a+0]=r,t.float32[a+1]=n,t.float32[a+2]=i;},t.b9=vg,t.bA=Wg,t.bB=Kg,t.bC=function(e){const r=Kg(e,!0);return t.b4.invert([],[r[0],r[1],r[4],r[5]])},t.bD=Ih,t.bE=function(t){const{x:e,y:r}=t.point,{lng:n,lat:i}=t._center;return ep(e,r,t.worldSize,n,i)},t.bF=_,t.bG=qo,t.bH=function(t){const e=Math.round((t+45+360)%360/90)%4;return w[e]},t.bI=45,t.bJ=hl,t.bK=So,t.bL=bo,t.bM=_o,t.bN=vo,t.bO=xo,t.bP=wo,t.bQ=function(t,e,r){const n=Math.sqrt(t*t+e*e+r*r),i=n>0?Math.acos(r/n)*v:0;let a=0!==t||0!==e?Math.atan2(-e,-t)*v+90:0;return a<0&&(a+=360),[n,a,i]},t.bR=wl,t.bS=Bh,t.bT=G,t.bU=function(t){return [Math.pow(t[0],1/2.2),Math.pow(t[1],1/2.2),Math.pow(t[2],1/2.2)]},t.bV=function(t){return t({pluginStatus:ba,pluginURL:_a}),Aa.on("pluginStateChange",t),t},t.bW=Px,t.bX=Rx,t.bY=_y,t.bZ=by,t.b_=It,t.ba=hy,t.bb=Vl,t.bc=im,t.bd=Ry,t.be=Dy,t.bf=Qm,t.bg=_b,t.bh=P,t.bj=b,t.bk=rt,t.bl=dl,t.bm=function(t,e,r){t[4*e+0]=r[0],t[4*e+1]=r[1],t[4*e+2]=r[2],t[4*e+3]=r[3];},t.bn=tl,t.bo=fg,t.bp=al,t.bq=Th,t.br=Hg,t.bs=il,t.bt=Gh,t.bu=function(t,e,r,n,i,a,s,o,l){if("globe"===l.name)return Gh(t,e,new il(r,n,i),!1);const u=Gy({z:r,x:n,y:i},l);return new Bh([(a+u.x/u.scale)*e,e*(u.y/u.scale),s],[(a+u.x2/u.scale)*e,e*(u.y2/u.scale),o])},t.bv=function(t,e,r){let n=0;for(let i=0;i<2;++i){const a=r?r[i]:0;t[i]>a&&(n+=(t[i]-a)*(t[i]-a)),e[i]<a&&(n+=(a-e[i])*(a-e[i]));}return n},t.bw=xl,t.bx=$o,t.by=function(e){const r=t.a6.identity(new Float64Array(16));t.a6.multiply(r,e.pixelMatrix,e.globeMatrix);const n=[0,Zo,0],i=[0,Ko,0];return t.N.transformMat4(n,n,r),t.N.transformMat4(i,i,r),[n[0]>0&&n[0]<=e.width&&n[1]>0&&n[1]<=e.height&&!ip(e,new tl(e.center.lat,90)),i[0]>0&&i[0]<=e.width&&i[1]>0&&i[1]<=e.height&&!ip(e,new tl(e.center.lat,-90))]},t.bz=function(e,r){const{scale:n}=e.tileTransform,i=n*Tr/(e.tileSize*Math.pow(2,r.zoom-e.tileID.overscaledZ+e.tileID.canonical.z));return t.b4.scale(new Float32Array(4),r.inverseAdjustmentMatrix,[i,i])},t.c=fv,t.c$=function(){return !!document.fullscreenElement||!!document.webkitFullscreenElement},t.c0=a,t.c1=O,t.c2=function(t,e,r){return "custom"===t.type?new $g(t,e):new Cv[t.type](t,e,r)},t.c3=function(t){const e=t.indexOf(ns);return e>=0?t.slice(0,e):t},t.c4=function(t){return t.indexOf(ns)>=0},t.c5=function(t){const e=t.indexOf(ns);return e>=0?t.slice(e+1):""},t.c6=function(t){const e=[],r=t.id;return void 0===r&&e.push({message:`layers.${r}: missing required property "id"`}),void 0===t.render&&e.push({message:`layers.${r}: missing required method "render"`}),t.renderingMode&&"2d"!==t.renderingMode&&"3d"!==t.renderingMode&&e.push({message:`layers.${r}: property "renderingMode" must be either "2d" or "3d"`}),e},t.c7=N,t.c8=Aa,t.c9=kt,t.cA=Gd,t.cB=(t,e,r,n,i,a)=>{const s=t.transform;return {u_matrix:$d(t,e,r,n),u_texsize:e.imageAtlasTexture?e.imageAtlasTexture.size:[0,0],u_pixels_to_tile_units:s.calculatePixelsToTileUnitsMatrix(e),u_device_pixel_ratio:i,u_image:0,u_tile_units_to_pixels:qd(e,s),u_units_to_pixels:[1/s.pixelsToGLUnits[0],1/s.pixelsToGLUnits[1]],u_alpha_discard_threshold:0,u_trim_offset:a}},t.cC=(t,e,r,n,i,a,s)=>{const o=t.transform,l=o.calculatePixelsToTileUnitsMatrix(e);return {u_matrix:$d(t,e,r,n),u_pixels_to_tile_units:l,u_device_pixel_ratio:a,u_units_to_pixels:[1/o.pixelsToGLUnits[0],1/o.pixelsToGLUnits[1]],u_dash_image:0,u_gradient_image:1,u_image_height:i,u_texsize:Yd(r)&&e.lineAtlasTexture?e.lineAtlasTexture.size:[0,0],u_tile_units_to_pixels:qd(e,t.transform),u_alpha_discard_threshold:0,u_trim_offset:s,u_emissive_strength:r.paint.get("line-emissive-strength")}},t.cD=R,t.cE=Ap,t.cF=Md,t.cG=ll,t.cH=md,t.cI=id,t.cJ=450,t.cK=7,t.cL=Ng,t.cM=256,t.cN=Jh,t.cO=Cs,t.cP=Rs,t.cQ=function(t,e,r,n,i){return I((t-e)/(r-e)*(i-n)+n,n,i)},t.cR=bl,t.cS=nx,t.cT=[1,1,1],t.cU=Wf,t.cV=xx,t.cW=As,t.cX=class{constructor(){this._updateTime=0,this._sourceIds=[],this._activeRegions=[],this._prevRegions=[];}clear(){this._activeRegions.length>0&&++this._updateTime,this._activeRegions=[],this._prevRegions=[];}get updateTime(){return this._updateTime}getReplacementRegionsForTile(t){const e=Df(new g(0,0),new g(Tr,Tr),t),r=[];for(const n of this._activeRegions){if(n.hiddenByOverlap)continue;if(!Rf(e,n))continue;const i=Vf(n.min,n.max,t);r.push({min:i.min,max:i.max,sourceId:this._sourceIds[n.priority],footprint:n.footprint,footprintTileId:n.tileId});}return r}setSources(t){this._setSources(t.map((t=>({getSourceId:()=>t.cache.id,getFootprints:()=>{const e=[];for(const r of t.cache.getVisibleCoordinates()){const n=t.cache.getTile(r).buckets[t.layer];if(n)for(const t of n.getNodesInfo()){const n=t.node;n.footprint&&e.push({footprint:n.footprint,id:r.toUnwrapped()});}}return e}}))));}_addSource(t){const e=t.getFootprints();if(0!==e.length){for(const t of e){if(!t.footprint)continue;const e=Df(t.footprint.min,t.footprint.max,t.id);this._activeRegions.push({min:e.min,max:e.max,hiddenByOverlap:!1,priority:this._sourceIds.length,tileId:t.id,footprint:t.footprint});}this._sourceIds.push(t.getSourceId());}}_computeReplacement(){this._activeRegions.sort(((t,e)=>t.priority-e.priority||Bf(t.min,e.min)||Bf(t.max,e.max)));let t=this._activeRegions.length!==this._prevRegions.length;if(!t){let e=0,r=0;for(;!t&&e!==this._activeRegions.length;){const n=this._activeRegions[e],i=this._prevRegions[r];t=n.priority!==i.priority||!Cf(n,i),++e,++r;}}if(t){++this._updateTime;const t=t=>{const e=this._activeRegions;if(t>=e.length)return t;const r=e[t].priority;for(;t<e.length&&e[t].priority===r;)++t;return t};if(this._sourceIds.length>1){let e=0,r=t(e);for(;e!==r;){let n=e;const i=e;for(;n!==r;){const t=this._activeRegions[n];t.hiddenByOverlap=!1;for(let e=0;e<i;e++){const r=this._activeRegions[e];if(!r.hiddenByOverlap&&Rf(t,r)&&(t.hiddenByOverlap=Ff(t.footprint,t.tileId,r.footprint,r.tileId),t.hiddenByOverlap))break}++n;}e=r,r=t(e);}}}}_setSources(t){[this._prevRegions,this._activeRegions]=[this._activeRegions,[]],this._sourceIds=[];for(let e=t.length-1;e>=0;e--)this._addSource(t[e]);this._computeReplacement();}},t.cY=class{constructor(t){this._createGrid(t),this._createPoles(t);}destroy(){this._poleIndexBuffer.destroy(),this._gridBuffer.destroy(),this._gridIndexBuffer.destroy(),this._poleNorthVertexBuffer.destroy(),this._poleSouthVertexBuffer.destroy();for(const t of this._poleSegments)t.destroy();for(const t of this._gridSegments)t.withSkirts.destroy(),t.withoutSkirts.destroy();}_fillGridMeshWithLods(t,e){const r=new ps,n=new Es,i=[],a=t+1+2,s=e[0]+1,o=e[0]+1+(1+e.length),l=(t,e,r)=>{let n=t===a-1?t-2:0===t?t:t-1;return n+=r?24575:0,[n,e]};for(let t=0;t<a;++t)r.emplaceBack(...l(t,0,!0));for(let t=0;t<s;++t)for(let e=0;e<a;++e)r.emplaceBack(...l(e,t,(0===e||e===a-1)&&!0));for(let t=0;t<e.length;++t){const n=e[t];for(let t=0;t<a;++t)r.emplaceBack(...l(t,n,!0));}for(let t=0;t<e.length;++t){const s=n.length,l=e[t]+1+2,u=new Es;for(let r=0;r<l-1;r++){const i=r===l-2,s=i?a*(o-e.length+t-r):a;for(let t=0;t<a-1;t++){const e=r*a+t;0===r||i||0===t||t===a-2?(u.emplaceBack(e+1,e,e+s),u.emplaceBack(e+s,e+s+1,e+1)):(n.emplaceBack(e+1,e,e+s),n.emplaceBack(e+s,e+s+1,e+1));}}const c=eo.simpleSegment(0,s,r.length,n.length-s);for(let t=0;t<u.uint16.length;t+=3)n.emplaceBack(u.uint16[t],u.uint16[t+1],u.uint16[t+2]);const h=eo.simpleSegment(0,s,r.length,n.length-s);i.push({withoutSkirts:c,withSkirts:h});}return {vertices:r,indices:n,segments:i}}_createGrid(t){const e=this._fillGridMeshWithLods(Yo,Xo);this._gridSegments=e.segments,this._gridBuffer=t.createVertexBuffer(e.vertices,Vh.members),this._gridIndexBuffer=t.createIndexBuffer(e.indices,!0);}_createPoles(t){const e=new Es;for(let t=0;t<=Yo;t++)e.emplaceBack(0,t+1,t+2);this._poleIndexBuffer=t.createIndexBuffer(e,!0);const r=new Cs,n=new Cs,i=new Cs,a=new Cs;this._poleSegments=[];for(let t=0,e=0;t<qo;t++){const s=360/(1<<t);r.emplaceBack(0,-jo,0,.5,0),n.emplaceBack(0,-jo,0,.5,1),i.emplaceBack(0,-jo,0,.5,.5),a.emplaceBack(0,-jo,0,.5,.5);for(let t=0;t<=Yo;t++){let e=t/Yo,o=0;const l=ue(0,s,e),[u,c,h]=Ho(sp,op,l,jo);r.emplaceBack(u,c,h,e,o),n.emplaceBack(u,c,h,e,1-o);const p=b(l);e=.5+.5*Math.sin(p),o=.5+.5*Math.cos(p),i.emplaceBack(u,c,h,e,o),a.emplaceBack(u,c,h,e,1-o);}this._poleSegments.push(eo.simpleSegment(e,0,66,64)),e+=66;}this._poleNorthVertexBuffer=t.createVertexBuffer(r,Rh,!1),this._poleSouthVertexBuffer=t.createVertexBuffer(n,Rh,!1),this._texturedPoleNorthVertexBuffer=t.createVertexBuffer(i,Rh,!1),this._texturedPoleSouthVertexBuffer=t.createVertexBuffer(a,Rh,!1);}getGridBuffers(t,e){return [this._gridBuffer,this._gridIndexBuffer,e?this._gridSegments[t].withSkirts:this._gridSegments[t].withoutSkirts]}getPoleBuffers(t,e){return [e?this._texturedPoleNorthVertexBuffer:this._poleNorthVertexBuffer,e?this._texturedPoleSouthVertexBuffer:this._poleSouthVertexBuffer,this._poleIndexBuffer,this._poleSegments[t]]}},t.cZ=function(t){return Ht.has(t)},t.c_=A,t.ca=Mo,t.cb=class extends go{constructor(t){super(t),this.current=Io;}set(t,e,r){if(this.fetchUniformLocation(t,e))for(let t=0;t<9;t++)if(r[t]!==this.current[t]){this.current=r,this.gl.uniformMatrix3fv(this.location,!1,r);break}}},t.cc=M,t.cd=function(t,e,r){const n=rp(r.zoom),i=t.style.map._antialias,a=e.options.extStandardDerivativesForceOff||t.terrain&&t.terrain.exaggeration()>0;return 0===n&&!i&&!a},t.ce=function(e){const r=e.pixelsPerMeter,n=r/dl(1,e.center.lat),i=t.a6.identity(new Float64Array(16));return t.a6.translate(i,i,[e.point.x,e.point.y,0]),t.a6.scale(i,i,[n,n,r]),Float32Array.from(i)},t.cf=Yh,t.cg=function(t){const e=xl-5;t=I(t,-e,e)/e*90;const r=Math.pow(Math.abs(Math.sin(b(t))),3);return Math.round(r*(Xo.length-1))},t.ch=function(e,r,n,i){const a=r.getNorth(),s=r.getSouth(),o=r.getWest(),l=r.getEast(),u=1<<e.z,c=l-o,h=a-s,p=c/Yo,f=-h/Xo[n],d=[0,p,0,f,0,0,a,o,0];if(e.z>0){const e=180/i;t.co.multiply(d,d,[e/c+1,0,0,0,e/h+1,0,-.5*e/p,.5*e/f,1]);}return d[2]=u,d[5]=e.x,d[8]=e.y,d},t.ci=jh,t.cj=function(e,r,n){const i=t.a6.identity(new Float64Array(16)),a=(r/(1<<e)-.5)*Math.PI*2;return t.a6.rotateY(i,n.globeMatrix,a),Float32Array.from(i)},t.ck=class{isDataAvailableAtPoint(t){const e=this._source();if(this.isUsingMockSource()||!e||t.y<0||t.y>1)return !1;const r=e.getSource().maxzoom,n=1<<r,i=Math.floor(t.x),a=Math.floor((t.x-i)*n),s=Math.floor(t.y*n),o=this.findDEMTileFor(new sl(r,i,r,a,s));return !(!o||!o.dem)}getAtPointOrZero(t,e=0){return this.getAtPoint(t,e)||0}getAtPoint(t,e,r=!0){if(this.isUsingMockSource())return null;null==e&&(e=null);const n=this._source();if(!n)return e;if(t.y<0||t.y>1)return e;const i=n.getSource().maxzoom,a=1<<i,s=Math.floor(t.x),o=t.x-s,l=new sl(i,s,i,Math.floor(o*a),Math.floor(t.y*a)),u=this.findDEMTileFor(l);if(!u||!u.dem)return e;const c=u.dem,h=1<<u.tileID.canonical.z,p=(o*h-u.tileID.canonical.x)*c.dim,f=(t.y*h-u.tileID.canonical.y)*c.dim,d=Math.floor(p),m=Math.floor(f);return (r?this.exaggeration():1)*ue(ue(c.get(d,m),c.get(d,m+1),f-m),ue(c.get(d+1,m),c.get(d+1,m+1),f-m),p-d)}getAtTileOffset(t,e,r){const n=1<<t.canonical.z;return this.getAtPointOrZero(new Ml(t.wrap+(t.canonical.x+e/Tr)/n,(t.canonical.y+r/Tr)/n))}getAtTileOffsetFunc(e,r,n,i){return a=>{const s=this.getAtTileOffset(e,a.x,a.y),o=i.upVector(e.canonical,a.x,a.y),l=i.upVectorScale(e.canonical,r,n).metersToTile;return t.N.scale(o,o,s*l),o}}getForTilePoints(t,e,r,n){if(this.isUsingMockSource())return !1;const i=Wf.create(this,t,n);return !!i&&(e.forEach((t=>{t[2]=this.exaggeration()*i.getElevationAt(t[0],t[1],r);})),!0)}getMinMaxForTile(t){if(this.isUsingMockSource())return null;const e=this.findDEMTileFor(t);if(!e||!e.dem)return null;const r=e.dem.tree,n=e.tileID,i=1<<t.canonical.z-n.canonical.z;let a=t.canonical.x/i-n.canonical.x,s=t.canonical.y/i-n.canonical.y,o=0;for(let e=0;e<t.canonical.z-n.canonical.z&&!r.leaves[o];e++){a*=2,s*=2;const t=2*Math.floor(s)+Math.floor(a);o=r.childOffsets[o]+t,a%=1,s%=1;}return {min:this.exaggeration()*r.minimums[o],max:this.exaggeration()*r.maximums[o]}}getMinElevationBelowMSL(){throw new Error("Pure virtual method called.")}raycast(t,e,r){throw new Error("Pure virtual method called.")}pointCoordinate(t){throw new Error("Pure virtual method called.")}_source(){throw new Error("Pure virtual method called.")}isUsingMockSource(){throw new Error("Pure virtual method called.")}exaggeration(){throw new Error("Pure virtual method called.")}findDEMTileFor(t){throw new Error("Pure virtual method called.")}get visibleDemTiles(){throw new Error("Getter must be implemented in subclass.")}getMinMaxForVisibleTiles(){const t=this.visibleDemTiles;if(0===t.length)return null;let e=!1,r=Number.MAX_VALUE,n=Number.MIN_VALUE;for(const i of t){const t=this.getMinMaxForTile(i.tileID);t&&(r=Math.min(r,t.min),n=Math.max(n,t.max),e=!0);}return e?{min:r,max:n}:null}},t.cl=Lh,t.cm=_p,t.cn=function(t,e){return [Math.pow(t[0],2.2)*e,Math.pow(t[1],2.2)*e,Math.pow(t[2],2.2)*e]},t.cp=tp,t.cq=256,t.cr=function(e,r){const n=[0,0,0],i=Wh(jh(r.canonical));return t.N.transformMat4(n,n,i),t.N.transformMat4(n,n,e),n},t.cs=t=>({u_camera_to_center_distance:new vo(t),u_extrude_scale:new Po(t),u_device_pixel_ratio:new vo(t),u_matrix:new So(t),u_inv_rot_matrix:new So(t),u_merc_center:new bo(t),u_tile_id:new _o(t),u_zoom_transition:new vo(t),u_up_dir:new _o(t),u_emissive_strength:new vo(t)}),t.ct=t=>({u_matrix:new So(t),u_pixels_to_tile_units:new Po(t),u_device_pixel_ratio:new vo(t),u_units_to_pixels:new bo(t),u_dash_image:new xo(t),u_gradient_image:new xo(t),u_image_height:new vo(t),u_texsize:new bo(t),u_tile_units_to_pixels:new vo(t),u_alpha_discard_threshold:new vo(t),u_trim_offset:new bo(t),u_emissive_strength:new vo(t)}),t.cu=t=>({u_matrix:new So(t),u_texsize:new bo(t),u_pixels_to_tile_units:new Po(t),u_device_pixel_ratio:new vo(t),u_image:new xo(t),u_units_to_pixels:new bo(t),u_tile_units_to_pixels:new vo(t),u_alpha_discard_threshold:new vo(t),u_trim_offset:new bo(t)}),t.cv=ks,t.cw=nm,t.cx=um,t.cy=up,t.cz=(t,e,r,n,i,a)=>{const s=t.transform,o="globe"===s.projection.name;let l;if("map"===a.paint.get("circle-pitch-alignment"))if(o){const t=tp(s.zoom,e.canonical)*s._pixelsPerMercatorPixel;l=Float32Array.from([t,0,0,t]);}else l=s.calculatePixelsToTileUnitsMatrix(r);else l=new Float32Array([s.pixelsToGLUnits[0],0,0,s.pixelsToGLUnits[1]]);const u={u_camera_to_center_distance:t.transform.getCameraToCenterDistance(s.projection),u_matrix:t.translatePosMatrix(e.projMatrix,r,a.paint.get("circle-translate"),a.paint.get("circle-translate-anchor")),u_device_pixel_ratio:st.devicePixelRatio,u_extrude_scale:l,u_inv_rot_matrix:lp,u_merc_center:[0,0],u_tile_id:[0,0,0],u_zoom_transition:0,u_up_dir:[0,0,0],u_emissive_strength:a.paint.get("circle-emissive-strength")};if(o){u.u_inv_rot_matrix=n,u.u_merc_center=i,u.u_tile_id=[e.canonical.x,e.canonical.y,1<<e.canonical.z],u.u_zoom_transition=rp(s.zoom);const t=i[0]*Tr,r=i[1]*Tr;u.u_up_dir=s.projection.upVector(new il(0,0,0),t,r);}return u},t.d=Ct,t.d0=S,t.d1=_l,t.d2=Wo,t.d3=function([t,e,r]){const n=Math.hypot(t,e,r),i=Math.atan2(t,r),a=.5*Math.PI-Math.acos(-e/n);return new tl(_(i),_(a))},t.d4=Jo,t.d5=n,t.d6=ip,t.d7=np,t.d8=function(e){const r=[0,0,0],n=t.a6.identity(new Float64Array(16));return t.a6.multiply(n,e.pixelMatrix,e.globeMatrix),t.N.transformMat4(r,r,n),new g(r[0],r[1])},t.d9=function(t){const e=t.navigator?t.navigator.userAgent:null;return !!function(t){if(null==tt){const e=t.navigator?t.navigator.userAgent:null;tt=!!t.safari||!(!e||!(/\b(iPad|iPhone|iPod)\b/.test(e)||e.match("Safari")&&!e.match("Chrome")));}return tt}(t)&&e&&(e.match("Version/15.4")||e.match("Version/15.5")||e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))},t.dA=vy,t.dB=yv,t.dC=vv,t.dD=Vd,t.dE=F,t.dF=my,t.dG=function(t,e,r,n,i,a,s,o,l,u,c){t.createArrays(),t.tilePixelRatio=Tr/(512*t.overscaling),t.compareText={},t.iconsNeedLinear=!1;const h=t.layers[0].layout,p=t.layers[0]._unevaluatedLayout._values,f={};if("composite"===t.textSizeData.kind){const{minZoom:e,maxZoom:r}=t.textSizeData;f.compositeTextSizes=[p["text-size"].possiblyEvaluate(new Pa(e),o),p["text-size"].possiblyEvaluate(new Pa(r),o)];}if("composite"===t.iconSizeData.kind){const{minZoom:e,maxZoom:r}=t.iconSizeData;f.compositeIconSizes=[p["icon-size"].possiblyEvaluate(new Pa(e),o),p["icon-size"].possiblyEvaluate(new Pa(r),o)];}f.layoutTextSize=p["text-size"].possiblyEvaluate(new Pa(l+1),o),f.layoutIconSize=p["icon-size"].possiblyEvaluate(new Pa(l+1),o),f.textMaxSize=p["text-size"].possiblyEvaluate(new Pa(18),o);const d="map"===h.get("text-rotation-alignment")&&"point"!==h.get("symbol-placement"),m=h.get("text-size");let y=!1;for(const e of t.features)if(e.icon&&e.icon.nameSecondary){y=!0;break}for(const a of t.features){const l=h.get("text-font").evaluate(a,{},o).join(","),p=m.evaluate(a,{},o),g=f.layoutTextSize.evaluate(a,{},o),x=(f.layoutIconSize.evaluate(a,{},o),{horizontal:{},vertical:void 0}),v=a.text;let b,_=[0,0];if(v){const n=v.toString(),s=h.get("text-letter-spacing").evaluate(a,{},o)*im,u=h.get("text-line-height").evaluate(a,{},o)*im,c=ua(n)?s:0,f=h.get("text-anchor").evaluate(a,{},o),m=h.get("text-variable-anchor");if(!m){const t=h.get("text-radial-offset").evaluate(a,{},o);_=t?Ry(f,[t*im,By]):h.get("text-offset").evaluate(a,{},o).map((t=>t*im));}let y=d?"center":h.get("text-justify").evaluate(a,{},o);const b="point"===h.get("symbol-placement"),w=b?h.get("text-max-width").evaluate(a,{},o)*im:1/0,M=a=>{t.allowVerticalPlacement&&la(n)&&(x.vertical=Gm(v,e,r,i,l,w,u,f,a,c,_,jm.vertical,!0,g,p));};if(!d&&m){const t="auto"===y?m.map((t=>Dy(t))):[y];let n=!1;for(let a=0;a<t.length;a++){const s=t[a];if(!x.horizontal[s])if(n)x.horizontal[s]=x.horizontal[0];else {const t=Gm(v,e,r,i,l,w,u,"center",s,c,_,jm.horizontal,!1,g,p);t&&(x.horizontal[s]=t,n=1===t.positionedLines.length);}}M("left");}else {if("auto"===y&&(y=Dy(f)),b||h.get("text-writing-mode").indexOf("horizontal")>=0||!la(n)){const t=Gm(v,e,r,i,l,w,u,f,y,c,_,jm.horizontal,!1,g,p);t&&(x.horizontal[y]=t);}M(b?"left":y);}}let w=!1;if(a.icon&&a.icon.namePrimary){const e=n[a.icon.namePrimary];e&&(b=ey(i[a.icon.namePrimary],a.icon.nameSecondary?i[a.icon.nameSecondary]:void 0,h.get("icon-offset").evaluate(a,{},o),h.get("icon-anchor").evaluate(a,{},o)),w=e.sdf,void 0===t.sdfIcons?t.sdfIcons=e.sdf:t.sdfIcons!==e.sdf&&j("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(e.pixelRatio!==t.pixelRatio||0!==h.get("icon-rotate").constantOr(1))&&(t.iconsNeedLinear=!0));}const M=Oy(x.horizontal)||x.vertical;t.iconsInText||(t.iconsInText=!!M&&M.iconsInText),(M||b)&&Vy(t,a,x,b,n,f,g,0,_,w,s,o,u,c,y);}a&&t.generateCollisionDebugBuffers(l,t.collisionBoxArray);},t.dH=Ef,t.dI=Vm,t.dJ=Hf,t.dK=h,t.dL=zf,t.dM=gf,t.dN=m,t.dO=mm,t.dP=function(t){let e=0;if(new Uint32Array(t,0,1)[0]!==Wx){const r=new Uint32Array(t,0,7),[,,n,i,a,s]=r;e=r.byteLength+i+a+s+a,(n!==t.byteLength||e>=t.byteLength)&&j("Invalid b3dm header information.");}return nv(t,e)},t.dQ=function(t,e){const r=fv(t);for(const t of r){for(const e of t.meshes)dv(e);t.lights&&(t.lightMeshIndex=t.meshes.length,t.meshes.push(mv(t.lights,e)));}return r},t.dR=Pv,t.dS=kx,t.dT=ka,t.dU=function(t){ft(),ct&&ct.then((e=>{e.keys().then((r=>{for(let n=0;n<r.length-t;n++)e.delete(r[n]);}));}));},t.da=class{constructor(t,e,r){this._transformRequestFn=t,this._customAccessToken=e,this._silenceAuthErrors=!!r,this._createSkuToken();}_createSkuToken(){const t=function(){let t="";for(let e=0;e<10;e++)t+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62*Math.random())];return {token:["1",Rt,t].join(""),tokenExpiresAt:Date.now()+432e5}}();this._skuToken=t.token,this._skuTokenExpiresAt=t.tokenExpiresAt;}_isSkuTokenExpired(){return Date.now()>this._skuTokenExpiresAt}transformRequest(t,e){return this._transformRequestFn&&this._transformRequestFn(t,e)||{url:t}}normalizeStyleURL(t,r){if(!a(t))return t;const n=Lt(t);return n.params.push(`sdk=js-${e}`),n.path=`/styles/v1${n.path}`,this._makeAPIURL(n,this._customAccessToken||r)}normalizeGlyphsURL(t,e){if(!a(t))return t;const r=Lt(t);return r.path=`/fonts/v1${r.path}`,this._makeAPIURL(r,this._customAccessToken||e)}normalizeModelURL(t,e){if(!a(t))return t;const r=Lt(t);return r.path=`/models/v1${r.path}`,this._makeAPIURL(r,this._customAccessToken||e)}normalizeSourceURL(t,e,r,n){if(!a(t))return t;const i=Lt(t);return i.path=`/v4/${i.authority}.json`,i.params.push("secure"),r&&i.params.push(`language=${r}`),n&&i.params.push(`worldview=${n}`),this._makeAPIURL(i,this._customAccessToken||e)}normalizeSpriteURL(t,e,r,n){const i=Lt(t);return a(t)?(i.path=`/styles/v1${i.path}/sprite${e}${r}`,this._makeAPIURL(i,this._customAccessToken||n)):(i.path+=`${e}${r}`,Ft(i))}normalizeTileURL(t,e,r){if(this._isSkuTokenExpired()&&this._createSkuToken(),t&&!a(t))return t;const i=Lt(t);i.path=i.path.replace(/(\.(png|jpg)\d*)(?=$)/,`${e||r&&"raster"!==i.authority&&512===r?"@2x":""}${gt.supported?".webp":"$1"}`),"raster"===i.authority?i.path=`/${n.RASTER_URL_PREFIX}${i.path}`:"rasterarrays"===i.authority?i.path=`/${n.RASTERARRAYS_URL_PREFIX}${i.path}`:(i.path=i.path.replace(/^.+\/v4\//,"/"),i.path=`/${n.TILE_URL_VERSION}${i.path}`);const s=this._customAccessToken||function(t){for(const e of t){const t=e.match(/^access_token=(.*)$/);if(t)return t[1]}return null}(i.params)||n.ACCESS_TOKEN;return n.REQUIRE_ACCESS_TOKEN&&s&&this._skuToken&&i.params.push(`sku=${this._skuToken}`),this._makeAPIURL(i,s)}canonicalizeTileURL(t,e){const r=Lt(t);if(!r.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/)||!r.path.match(/\.[\w]+$/))return t;let i="mapbox://";r.path.match(/^\/raster\/v1\//)?i+=`raster/${r.path.replace(`/${n.RASTER_URL_PREFIX}/`,"")}`:r.path.match(/^\/rasterarrays\/v1\//)?i+=`rasterarrays/${r.path.replace(`/${n.RASTERARRAYS_URL_PREFIX}/`,"")}`:i+=`tiles/${r.path.replace(`/${n.TILE_URL_VERSION}/`,"")}`;let a=r.params;return e&&(a=a.filter((t=>!t.match(/^access_token=/)))),a.length&&(i+=`?${a.join("&")}`),i}canonicalizeTileset(t,e){const r=!!e&&a(e),n=[];for(const e of t.tiles||[])i(e)?n.push(this.canonicalizeTileURL(e,r)):n.push(e);return n}_makeAPIURL(t,e){const r="See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",i=Lt(n.API_URL);if(t.protocol=i.protocol,t.authority=i.authority,"http"===t.protocol){const e=t.params.indexOf("secure");e>=0&&t.params.splice(e,1);}if("/"!==i.path&&(t.path=`${i.path}${t.path}`),!n.REQUIRE_ACCESS_TOKEN)return Ft(t);if(e=e||n.ACCESS_TOKEN,!this._silenceAuthErrors){if(!e)throw new Error(`An API access token is required to use Mapbox GL. ${r}`);if("s"===e[0])throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`)}return t.params=t.params.filter((t=>-1===t.indexOf("access_token"))),t.params.push(`access_token=${e||""}`),Ft(t)}},t.db=function(t,e){e?Ht.add(t):Ht.delete(t);},t.dc=gt,t.dd=Xt,t.de=Kt,t.df=Dt,t.dg=Gt,t.dh=function(t){Ht.delete(t);},t.di=Zt,t.dj=$t,t.dk=e,t.dl=function(t,e){lt=t,ut=e;},t.dm=function(t,e,r=!1){if(ba===ya||ba===ga||ba===xa)throw new Error("setRTLTextPlugin cannot be called multiple times.");_a=st.resolveURL(t),ba=ya,va=e,Ma(),r||Ia();},t.dn=Sa,t.dp=function(){Rx().acquire(Tx);},t.dq=function(){const t=Cx;t&&(t.isPreloaded()&&1===t.numActive()?(t.release(Tx),Cx=null):console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));},t.dr=Bx,t.ds=function(t){const e=pt();if(!e)return;const r=e.delete(ot);t&&r.catch(t).then((()=>t()));},t.dt=Ex,t.du=Ux,t.dv=function(t){Vx=st.resolveURL(t),Ox||(Ox=new Px(Rx(),new ee)),Ox.broadcast("setDracoUrl",Vx);},t.dw=jx,t.dx=function(t){Fx=st.resolveURL(t),Ox||(Ox=new Px(Rx(),new ee)),Ox.broadcast("setMeshoptUrl",Fx);},t.dy=ra,t.dz=vp,t.e=z,t.f=st,t.g=function(t,e){return kt(z(t,{type:"json"}),e)},t.h=bp,t.i=Ke,t.j=pe,t.k=Ti,t.l=function(t){return fetch(t).then((t=>t.arrayBuffer())).then((e=>nv(e,0,t)))},t.m=Ci,t.n=$i,t.o=ja,t.p=py,t.q=Zi,t.r=Gi,t.s=Ri,t.t=mn,t.u=Ua,t.v=gn,t.w=j,t.x=dn,t.z=$a;}));

    define(["./shared"],(function(e){function t(e){const t=e?e.url.toString():void 0;return t?performance.getEntriesByName(t):[]}function s(e){if("number"==typeof e||"boolean"==typeof e||"string"==typeof e||null==e)return JSON.stringify(e);if(Array.isArray(e)){let t="[";for(const i of e)t+=`${s(i)},`;return `${t}]`}let t="{";for(const i of Object.keys(e).sort())t+=`${i}:${s(e[i])},`;return `${t}}`}function i(t){let i="";for(const o of e.b2)i+=`/${s(t[o])}`;return i}class o{constructor(e){this.keyCache={},this._layers={},this._layerConfigs={},e&&this.replace(e);}replace(e,t){this._layerConfigs={},this._layers={},this.update(e,[],t);}update(t,s,o){this._options=o;for(const s of t)this._layerConfigs[s.id]=s,(this._layers[s.id]=e.c2(s,this.scope,this._options)).compileFilter(),this.keyCache[s.id]&&delete this.keyCache[s.id];for(const e of s)delete this.keyCache[e],delete this._layerConfigs[e],delete this._layers[e];this.familiesBySource={};const r=function(e,t){const s={};for(let o=0;o<e.length;o++){const r=t&&t[e[o].id]||i(e[o]);t&&(t[e[o].id]=r);let n=s[r];n||(n=s[r]=[]),n.push(e[o]);}const o=[];for(const e in s)o.push(s[e]);return o}(e.a$(this._layerConfigs),this.keyCache);for(const e of r){const t=e.map((e=>this._layers[e.id])),s=t[0];if("none"===s.visibility)continue;const i=s.source||"";let o=this.familiesBySource[i];o||(o=this.familiesBySource[i]={});const r=s.sourceLayer||"_geojsonTileLayer";let n=o[r];n||(n=o[r]=[]),n.push(t);}}}const r=1*e.dA;class n{constructor(t){const s={},i=[];for(const e in t){const o=t[e],n=s[e]={};for(const e in o.glyphs){const t=o.glyphs[+e];if(!t||0===t.bitmap.width||0===t.bitmap.height)continue;const s=t.metrics.localGlyph?r:1,a={x:0,y:0,w:t.bitmap.width+2*s,h:t.bitmap.height+2*s};i.push(a),n[e]=a;}}const{w:o,h:n}=e.p(i),a=new e.dz({width:o||1,height:n||1});for(const i in t){const o=t[i];for(const t in o.glyphs){const n=o.glyphs[+t];if(!n||0===n.bitmap.width||0===n.bitmap.height)continue;const l=s[i][t],h=n.metrics.localGlyph?r:1;e.dz.copy(n.bitmap,a,{x:0,y:0},{x:l.x+h,y:l.y+h},n.bitmap);}}this.image=a,this.positions=s;}}e.dy(n,"GlyphAtlas");class a{constructor(t){this.tileID=new e.am(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.tileZoom=t.tileZoom,this.uid=t.uid,this.zoom=t.zoom,this.canonical=t.tileID.canonical,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.scope=t.scope,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.promoteId=t.promoteId,this.isSymbolTile=t.isSymbolTile,this.tileTransform=e.as(t.tileID.canonical,t.projection),this.projection=t.projection,this.brightness=t.brightness,this.extraShadowCaster=!!t.extraShadowCaster;}parse(t,s,i,o,r){this.status="parsing",this.data=t,this.collisionBoxArray=new e.aD;const a=new e.dB(Object.keys(t.layers).sort()),h=new e.dC(this.tileID,this.promoteId);h.bucketLayerIDs=[];const c={},u=new e.dD(256,256),d={featureIndex:h,iconDependencies:{},patternDependencies:{},glyphDependencies:{},lineAtlas:u,availableImages:i,brightness:this.brightness},p=s.familiesBySource[this.source];for(const s in p){const o=t.layers[s];if(!o)continue;let r=!1,n=!1,u=!1;for(const e of p[s])"symbol"===e[0].type?r=!0:n=!0,e[0].is3D()&&"model"!==e[0].type&&(u=!0);if(this.extraShadowCaster&&!u)continue;if(!0===this.isSymbolTile&&!r)continue;if(!1===this.isSymbolTile&&!n)continue;1===o.version&&e.w(`Vector tile source "${this.source}" layer "${s}" does not use vector tile spec v2 and therefore may have some rendering errors.`);const f=a.encode(s),g=[];for(let e=0;e<o.length;e++){const t=o.feature(e),i=h.getId(t,s);g.push({feature:t,id:i,index:e,sourceLayerIndex:f});}for(const e of p[s]){const t=e[0];(!this.extraShadowCaster||t.is3D()&&"model"!==t.type)&&(void 0!==this.isSymbolTile&&"symbol"===t.type!==this.isSymbolTile||t.minzoom&&this.zoom<Math.floor(t.minzoom)||t.maxzoom&&this.zoom>=t.maxzoom||"none"!==t.visibility&&(l(e,this.zoom,d.brightness,i),(c[t.id]=t.createBucket({index:h.bucketLayerIDs.length,layers:e,zoom:this.zoom,canonical:this.canonical,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:f,sourceID:this.source,projection:this.projection.spec})).populate(g,d,this.tileID.canonical,this.tileTransform),h.bucketLayerIDs.push(e.map((e=>e.id)))));}}let f,g,m,y;u.trim();const v={type:"maybePrepare",isSymbolTile:this.isSymbolTile,zoom:this.zoom},x=()=>{if(f)return this.status="done",r(f);if(this.extraShadowCaster)this.status="done",r(null,{buckets:e.a$(c).filter((e=>!e.isEmpty())),featureIndex:h,collisionBoxArray:null,glyphAtlasImage:null,lineAtlas:null,imageAtlas:null,brightness:d.brightness,glyphMap:null,iconMap:null,glyphPositions:null});else if(g&&m&&y){const t=new n(g),s=new e.dF(m,y);for(const o in c){const r=c[o];r instanceof e.aE?(l(r.layers,this.zoom,d.brightness,i),e.dG(r,g,t.positions,m,s.iconPositions,this.showCollisionBoxes,i,this.tileID.canonical,this.tileZoom,this.projection,this.brightness)):r.hasPattern&&(r instanceof e.aK||r instanceof e.aL||r instanceof e.cH)&&(l(r.layers,this.zoom,d.brightness,i),r.addFeatures(d,this.tileID.canonical,s.patternPositions,i,this.tileTransform,this.brightness));}this.status="done",r(null,{buckets:e.a$(c).filter((e=>!e.isEmpty())),featureIndex:h,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:t.image,lineAtlas:u,imageAtlas:s,brightness:d.brightness});}};if(!this.extraShadowCaster){const t=e.dE(d.glyphDependencies,(e=>Object.keys(e).map(Number)));Object.keys(t).length?o.send("getGlyphs",{uid:this.uid,stacks:t,scope:this.scope},((e,t)=>{f||(f=e,g=t,x());}),void 0,!1,v):g={};const s=Object.keys(d.iconDependencies);s.length?o.send("getImages",{icons:s,source:this.source,scope:this.scope,tileID:this.tileID,type:"icons"},((e,t)=>{f||(f=e,m=t,x());}),void 0,!1,v):m={};const i=Object.keys(d.patternDependencies);i.length?o.send("getImages",{icons:i,source:this.source,scope:this.scope,tileID:this.tileID,type:"patterns"},((e,t)=>{f||(f=e,y=t,x());}),void 0,!1,v):y={};}x();}}function l(t,s,i,o){const r=new e.K(s,{brightness:i});for(const e of t)e.recalculate(r,o);}class h extends e.E{constructor(t,s,i,o,r,n){super(),this.actor=t,this.layerIndex=s,this.availableImages=i,this.loadVectorData=r||e.ah,this.loading={},this.loaded={},this.deduped=new e.af(t.scheduler),this.isSpriteLoaded=o,this.scheduler=t.scheduler,this.brightness=n;}loadTile(s,i){const o=s.uid,r=s&&s.request,n=r&&r.collectResourceTiming,l=this.loading[o]=new a(s);l.abort=this.loadVectorData(s,((a,h)=>{const c=!this.loading[o];if(delete this.loading[o],c||a||!h)return l.status="done",c||(this.loaded[o]=l),i(a);const u=h.rawData,d={};h.expires&&(d.expires=h.expires),h.cacheControl&&(d.cacheControl=h.cacheControl),l.vectorTile=h.vectorTile||new e.dH(new e.dI(u));const p=()=>{l.parse(l.vectorTile,this.layerIndex,this.availableImages,this.actor,((s,o)=>{if(s||!o)return i(s);const a={};if(n){const e=t(r);e.length>0&&(a.resourceTiming=JSON.parse(JSON.stringify(e)));}i(null,e.e({rawTileData:u.slice(0)},o,d,a));}));};this.isSpriteLoaded?p():this.once("isSpriteLoaded",(()=>{this.scheduler?this.scheduler.add(p,{type:"parseTile",isSymbolTile:s.isSymbolTile,zoom:s.tileZoom}):p();})),this.loaded=this.loaded||{},this.loaded[o]=l;}));}reloadTile(t,s){const i=this.loaded,o=t.uid,r=this;if(i&&i[o]){const n=i[o];n.showCollisionBoxes=t.showCollisionBoxes,n.projection=t.projection,n.brightness=t.brightness,n.tileTransform=e.as(t.tileID.canonical,t.projection),n.extraShadowCaster=t.extraShadowCaster;const a=(e,t)=>{const i=n.reloadCallback;i&&(delete n.reloadCallback,n.parse(n.vectorTile,r.layerIndex,this.availableImages,r.actor,i)),s(e,t);};"parsing"===n.status?n.reloadCallback=a:"done"===n.status&&(n.vectorTile?n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor,a):a());}else s(null,void 0);}abortTile(e,t){const s=e.uid,i=this.loading[s];i&&(i.abort&&i.abort(),delete this.loading[s]),t();}removeTile(e,t){const s=this.loaded,i=e.uid;s&&s[i]&&delete s[i],t();}}class c{loadTile(t,s){const{uid:i,encoding:o,rawImageData:r,padding:n}=t,a=ImageBitmap&&r instanceof ImageBitmap?this.getImageData(r,n):r;s(null,new e.dJ(i,a,o,n<1));}getImageData(e,t){this.offscreenCanvas&&this.offscreenCanvasContext||(this.offscreenCanvas=new OffscreenCanvas(e.width,e.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d",{willReadFrequently:!0})),this.offscreenCanvas.width=e.width,this.offscreenCanvas.height=e.height,this.offscreenCanvasContext.drawImage(e,0,0,e.width,e.height);const s=this.offscreenCanvasContext.getImageData(-t,-t,e.width+2*t,e.height+2*t);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),s}}class u{decodeRasterArray({task:t,buffer:s},i){e.aZ.performDecoding(s,t).then((e=>{i(null,e);}),(e=>{i(e);}));}}function d(e,t){if(0!==e.length){p(e[0],t);for(var s=1;s<e.length;s++)p(e[s],!t);}}function p(e,t){for(var s=0,i=0,o=0,r=e.length,n=r-1;o<r;n=o++){var a=(e[o][0]-e[n][0])*(e[n][1]+e[o][1]),l=s+a;i+=Math.abs(s)>=Math.abs(a)?s-l+a:a-l+s,s=l;}s+i>=0!=!!t&&e.reverse();}var f=e.dK((function e(t,s){var i,o=t&&t.type;if("FeatureCollection"===o)for(i=0;i<t.features.length;i++)e(t.features[i],s);else if("GeometryCollection"===o)for(i=0;i<t.geometries.length;i++)e(t.geometries[i],s);else if("Feature"===o)e(t.geometry,s);else if("Polygon"===o)d(t.coordinates,s);else if("MultiPolygon"===o)for(i=0;i<t.coordinates.length;i++)d(t.coordinates[i],s);return t}));const g=e.dL.prototype.toGeoJSON;let m=class{constructor(t){this._feature=t,this.extent=e.V,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10));}loadGeometry(){if(1===this._feature.type){const t=[];for(const s of this._feature.geometry)t.push([new e.P(s[0],s[1])]);return t}{const t=[];for(const s of this._feature.geometry){const i=[];for(const t of s)i.push(new e.P(t[0],t[1]));t.push(i);}return t}}toGeoJSON(e,t,s){return g.call(this,e,t,s)}},y=class{constructor(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=e.V,this.length=t.length,this._features=t;}feature(e){return new m(this._features[e])}};var v={exports:{}},x=e.dN,w=e.dM.VectorTileFeature,S=b;function b(e,t){this.options=t||{},this.features=e,this.length=e.length;}function I(e,t){this.id="number"==typeof e.id?e.id:void 0,this.type=e.type,this.rawGeometry=1===e.type?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096;}b.prototype.feature=function(e){return new I(this.features[e],this.options.extent)},I.prototype.loadGeometry=function(){var e=this.rawGeometry;this.geometry=[];for(var t=0;t<e.length;t++){for(var s=e[t],i=[],o=0;o<s.length;o++)i.push(new x(s[o][0],s[o][1]));this.geometry.push(i);}return this.geometry},I.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,s=-1/0,i=1/0,o=-1/0,r=0;r<e.length;r++)for(var n=e[r],a=0;a<n.length;a++){var l=n[a];t=Math.min(t,l.x),s=Math.max(s,l.x),i=Math.min(i,l.y),o=Math.max(o,l.y);}return [t,i,s,o]},I.prototype.toGeoJSON=w.prototype.toGeoJSON;var M=e.dO,k=S;function T(e){var t=new M;return function(e,t){for(var s in e.layers)t.writeMessage(3,P,e.layers[s]);}(e,t),t.finish()}function P(e,t){var s;t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var i={keys:[],values:[],keycache:{},valuecache:{}};for(s=0;s<e.length;s++)i.feature=e.feature(s),t.writeMessage(2,C,i);var o=i.keys;for(s=0;s<o.length;s++)t.writeStringField(3,o[s]);var r=i.values;for(s=0;s<r.length;s++)t.writeMessage(4,O,r[s]);}function C(e,t){var s=e.feature;void 0!==s.id&&t.writeVarintField(1,s.id),t.writeMessage(2,_,e),t.writeVarintField(3,s.type),t.writeMessage(4,j,s);}function _(e,t){var s=e.feature,i=e.keys,o=e.values,r=e.keycache,n=e.valuecache;for(var a in s.properties){var l=s.properties[a],h=r[a];if(null!==l){void 0===h&&(i.push(a),r[a]=h=i.length-1),t.writeVarint(h);var c=typeof l;"string"!==c&&"boolean"!==c&&"number"!==c&&(l=JSON.stringify(l));var u=c+":"+l,d=n[u];void 0===d&&(o.push(l),n[u]=d=o.length-1),t.writeVarint(d);}}}function D(e,t){return (t<<3)+(7&e)}function L(e){return e<<1^e>>31}function j(e,t){for(var s=e.loadGeometry(),i=e.type,o=0,r=0,n=s.length,a=0;a<n;a++){var l=s[a],h=1;1===i&&(h=l.length),t.writeVarint(D(1,h));for(var c=3===i?l.length-1:l.length,u=0;u<c;u++){1===u&&1!==i&&t.writeVarint(D(2,c-1));var d=l[u].x-o,p=l[u].y-r;t.writeVarint(L(d)),t.writeVarint(L(p)),o+=d,r+=p;}3===i&&t.writeVarint(D(7,1));}}function O(e,t){var s=typeof e;"string"===s?t.writeStringField(1,e):"boolean"===s?t.writeBooleanField(7,e):"number"===s&&(e%1!=0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e));}v.exports=T,v.exports.fromVectorTileJs=T,v.exports.fromGeojsonVt=function(e,t){t=t||{};var s={};for(var i in e)s[i]=new k(e[i].features,t),s[i].name=i,s[i].version=t.version,s[i].extent=t.extent;return T({layers:s})},v.exports.GeoJSONWrapper=k;var z=e.dK(v.exports);const Z={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},A=Math.fround||(E=new Float32Array(1),e=>(E[0]=+e,E[0]));var E;const F=3,N=5,B=6;class W{constructor(e){this.options=Object.assign(Object.create(Z),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[];}load(e){const{log:t,minZoom:s,maxZoom:i}=this.options;t&&console.time("total time");const o=`prepare ${e.length} points`;t&&console.time(o),this.points=e;const r=[];for(let t=0;t<e.length;t++){const s=e[t];if(!s.geometry)continue;const[i,o]=s.geometry.coordinates,n=A(R(i)),a=A(Y(o));r.push(n,a,1/0,t,-1,1),this.options.reduce&&r.push(0);}let n=this.trees[i+1]=this._createTree(r);t&&console.timeEnd(o);for(let e=i;e>=s;e--){const s=+Date.now();n=this.trees[e]=this._createTree(this._cluster(n,e)),t&&console.log("z%d: %d clusters in %dms",e,n.numItems,+Date.now()-s);}return t&&console.timeEnd("total time"),this}getClusters(e,t){let s=((e[0]+180)%360+360)%360-180;const i=Math.max(-90,Math.min(90,e[1]));let o=180===e[2]?180:((e[2]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)s=-180,o=180;else if(s>o){const e=this.getClusters([s,i,180,r],t),n=this.getClusters([-180,i,o,r],t);return e.concat(n)}const n=this.trees[this._limitZoom(t)],a=n.range(R(s),Y(r),R(o),Y(i)),l=n.data,h=[];for(const e of a){const t=this.stride*e;h.push(l[t+N]>1?G(l,t,this.clusterProps):this.points[l[t+F]]);}return h}getChildren(e){const t=this._getOriginId(e),s=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[s];if(!o)throw new Error(i);const r=o.data;if(t*this.stride>=r.length)throw new Error(i);const n=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=o.within(r[t*this.stride],r[t*this.stride+1],n),l=[];for(const t of a){const s=t*this.stride;r[s+4]===e&&l.push(r[s+N]>1?G(r,s,this.clusterProps):this.points[r[s+F]]);}if(0===l.length)throw new Error(i);return l}getLeaves(e,t,s){const i=[];return this._appendLeaves(i,e,t=t||10,s=s||0,0),i}getTile(e,t,s){const i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),{extent:r,radius:n}=this.options,a=n/r,l=(s-a)/o,h=(s+1+a)/o,c={features:[]};return this._addTileFeatures(i.range((t-a)/o,l,(t+1+a)/o,h),i.data,t,s,o,c),0===t&&this._addTileFeatures(i.range(1-a/o,l,1,h),i.data,o,s,o,c),t===o-1&&this._addTileFeatures(i.range(0,l,a/o,h),i.data,-1,s,o,c),c.features.length?c:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const s=this.getChildren(e);if(t++,1!==s.length)break;e=s[0].properties.cluster_id;}return t}_appendLeaves(e,t,s,i,o){const r=this.getChildren(t);for(const t of r){const r=t.properties;if(r&&r.cluster?o+r.point_count<=i?o+=r.point_count:o=this._appendLeaves(e,r.cluster_id,s,i,o):o<i?o++:e.push(t),e.length===s)break}return o}_createTree(t){const s=new e.bg(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let e=0;e<t.length;e+=this.stride)s.add(t[e],t[e+1]);return s.finish(),s.data=t,s}_addTileFeatures(e,t,s,i,o,r){for(const n of e){const e=n*this.stride,a=t[e+N]>1;let l,h,c;if(a)l=J(t,e,this.clusterProps),h=t[e],c=t[e+1];else {const s=this.points[t[e+F]];l=s.properties;const[i,o]=s.geometry.coordinates;h=R(i),c=Y(o);}const u={type:1,geometry:[[Math.round(this.options.extent*(h*o-s)),Math.round(this.options.extent*(c*o-i))]],tags:l};let d;d=a||this.options.generateId?t[e+F]:this.points[t[e+F]].id,void 0!==d&&(u.id=d),r.features.push(u);}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,t){const{radius:s,extent:i,reduce:o,minPoints:r}=this.options,n=s/(i*Math.pow(2,t)),a=e.data,l=[],h=this.stride;for(let s=0;s<a.length;s+=h){if(a[s+2]<=t)continue;a[s+2]=t;const i=a[s],c=a[s+1],u=e.within(a[s],a[s+1],n),d=a[s+N];let p=d;for(const e of u){const s=e*h;a[s+2]>t&&(p+=a[s+N]);}if(p>d&&p>=r){let e,r=i*d,n=c*d,f=-1;const g=(s/h<<5)+(t+1)+this.points.length;for(const i of u){const l=i*h;if(a[l+2]<=t)continue;a[l+2]=t;const c=a[l+N];r+=a[l]*c,n+=a[l+1]*c,a[l+4]=g,o&&(e||(e=this._map(a,s,!0),f=this.clusterProps.length,this.clusterProps.push(e)),o(e,this._map(a,l)));}a[s+4]=g,l.push(r/p,n/p,1/0,g,-1,p),o&&l.push(f);}else {for(let e=0;e<h;e++)l.push(a[s+e]);if(p>1)for(const e of u){const s=e*h;if(!(a[s+2]<=t)){a[s+2]=t;for(let e=0;e<h;e++)l.push(a[s+e]);}}}}return l}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return (e-this.points.length)%32}_map(e,t,s){if(e[t+N]>1){const i=this.clusterProps[e[t+B]];return s?Object.assign({},i):i}const i=this.points[e[t+F]].properties,o=this.options.map(i);return s&&o===i?Object.assign({},o):o}}function G(e,t,s){return {type:"Feature",id:e[t+F],properties:J(e,t,s),geometry:{type:"Point",coordinates:[(i=e[t],360*(i-.5)),X(e[t+1])]}};var i;}function J(e,t,s){const i=e[t+N],o=i>=1e4?`${Math.round(i/1e3)}k`:i>=1e3?Math.round(i/100)/10+"k":i,r=e[t+B],n=-1===r?{}:Object.assign({},s[r]);return Object.assign(n,{cluster:!0,cluster_id:e[t+F],point_count:i,point_count_abbreviated:o})}function R(e){return e/360+.5}function Y(e){const t=Math.sin(e*Math.PI/180),s=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return s<0?0:s>1?1:s}function X(e){const t=(180-360*e)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}var V={exports:{}};V.exports=function(){function e(s,i,o,r){for(var n,a=r,l=o-i>>1,h=o-i,c=s[i],u=s[i+1],d=s[o],p=s[o+1],f=i+3;f<o;f+=3){var g=t(s[f],s[f+1],c,u,d,p);if(g>a)n=f,a=g;else if(g===a){var m=Math.abs(f-l);m<h&&(n=f,h=m);}}a>r&&(n-i>3&&e(s,i,n,r),s[n+2]=a,o-n>3&&e(s,n,o,r));}function t(e,t,s,i,o,r){var n=o-s,a=r-i;if(0!==n||0!==a){var l=((e-s)*n+(t-i)*a)/(n*n+a*a);l>1?(s=o,i=r):l>0&&(s+=n*l,i+=a*l);}return (n=e-s)*n+(a=t-i)*a}function s(e,t,s,o){var r={id:void 0===e?null:e,type:t,geometry:s,tags:o,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return function(e){var t=e.geometry,s=e.type;if("Point"===s||"MultiPoint"===s||"LineString"===s)i(e,t);else if("Polygon"===s||"MultiLineString"===s)for(var o=0;o<t.length;o++)i(e,t[o]);else if("MultiPolygon"===s)for(o=0;o<t.length;o++)for(var r=0;r<t[o].length;r++)i(e,t[o][r]);}(r),r}function i(e,t){for(var s=0;s<t.length;s+=3)e.minX=Math.min(e.minX,t[s]),e.minY=Math.min(e.minY,t[s+1]),e.maxX=Math.max(e.maxX,t[s]),e.maxY=Math.max(e.maxY,t[s+1]);}function o(e,t,i,l){if(t.geometry){var h=t.geometry.coordinates,c=t.geometry.type,u=Math.pow(i.tolerance/((1<<i.maxZoom)*i.extent),2),d=[],p=t.id;if(i.promoteId?p=t.properties[i.promoteId]:i.generateId&&(p=l||0),"Point"===c)r(h,d);else if("MultiPoint"===c)for(var f=0;f<h.length;f++)r(h[f],d);else if("LineString"===c)n(h,d,u,!1);else if("MultiLineString"===c){if(i.lineMetrics){for(f=0;f<h.length;f++)n(h[f],d=[],u,!1),e.push(s(p,"LineString",d,t.properties));return}a(h,d,u,!1);}else if("Polygon"===c)a(h,d,u,!0);else {if("MultiPolygon"!==c){if("GeometryCollection"===c){for(f=0;f<t.geometry.geometries.length;f++)o(e,{id:p,geometry:t.geometry.geometries[f],properties:t.properties},i,l);return}throw new Error("Input data is not a valid GeoJSON object.")}for(f=0;f<h.length;f++){var g=[];a(h[f],g,u,!0),d.push(g);}}e.push(s(p,c,d,t.properties));}}function r(e,t){t.push(l(e[0])),t.push(h(e[1])),t.push(0);}function n(t,s,i,o){for(var r,n,a=0,c=0;c<t.length;c++){var u=l(t[c][0]),d=h(t[c][1]);s.push(u),s.push(d),s.push(0),c>0&&(a+=o?(r*d-u*n)/2:Math.sqrt(Math.pow(u-r,2)+Math.pow(d-n,2))),r=u,n=d;}var p=s.length-3;s[2]=1,e(s,0,p,i),s[p+2]=1,s.size=Math.abs(a),s.start=0,s.end=s.size;}function a(e,t,s,i){for(var o=0;o<e.length;o++){var r=[];n(e[o],r,s,i),t.push(r);}}function l(e){return e/360+.5}function h(e){var t=Math.sin(e*Math.PI/180),s=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return s<0?0:s>1?1:s}function c(e,t,i,o,r,n,a,l){if(o/=t,n>=(i/=t)&&a<o)return e;if(a<i||n>=o)return null;for(var h=[],c=0;c<e.length;c++){var p=e[c],g=p.geometry,m=p.type,y=0===r?p.minX:p.minY,v=0===r?p.maxX:p.maxY;if(y>=i&&v<o)h.push(p);else if(!(v<i||y>=o)){var x=[];if("Point"===m||"MultiPoint"===m)u(g,x,i,o,r);else if("LineString"===m)d(g,x,i,o,r,!1,l.lineMetrics);else if("MultiLineString"===m)f(g,x,i,o,r,!1);else if("Polygon"===m)f(g,x,i,o,r,!0);else if("MultiPolygon"===m)for(var w=0;w<g.length;w++){var S=[];f(g[w],S,i,o,r,!0),S.length&&x.push(S);}if(x.length){if(l.lineMetrics&&"LineString"===m){for(w=0;w<x.length;w++)h.push(s(p.id,m,x[w],p.tags));continue}"LineString"!==m&&"MultiLineString"!==m||(1===x.length?(m="LineString",x=x[0]):m="MultiLineString"),"Point"!==m&&"MultiPoint"!==m||(m=3===x.length?"Point":"MultiPoint"),h.push(s(p.id,m,x,p.tags));}}}return h.length?h:null}function u(e,t,s,i,o){for(var r=0;r<e.length;r+=3){var n=e[r+o];n>=s&&n<=i&&(t.push(e[r]),t.push(e[r+1]),t.push(e[r+2]));}}function d(e,t,s,i,o,r,n){for(var a,l,h=p(e),c=0===o?m:y,u=e.start,d=0;d<e.length-3;d+=3){var f=e[d],v=e[d+1],x=e[d+2],w=e[d+3],S=e[d+4],b=0===o?f:v,I=0===o?w:S,M=!1;n&&(a=Math.sqrt(Math.pow(f-w,2)+Math.pow(v-S,2))),b<s?I>s&&(l=c(h,f,v,w,S,s),n&&(h.start=u+a*l)):b>i?I<i&&(l=c(h,f,v,w,S,i),n&&(h.start=u+a*l)):g(h,f,v,x),I<s&&b>=s&&(l=c(h,f,v,w,S,s),M=!0),I>i&&b<=i&&(l=c(h,f,v,w,S,i),M=!0),!r&&M&&(n&&(h.end=u+a*l),t.push(h),h=p(e)),n&&(u+=a);}var k=e.length-3;f=e[k],v=e[k+1],x=e[k+2],(b=0===o?f:v)>=s&&b<=i&&g(h,f,v,x),k=h.length-3,r&&k>=3&&(h[k]!==h[0]||h[k+1]!==h[1])&&g(h,h[0],h[1],h[2]),h.length&&t.push(h);}function p(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function f(e,t,s,i,o,r){for(var n=0;n<e.length;n++)d(e[n],t,s,i,o,r,!1);}function g(e,t,s,i){e.push(t),e.push(s),e.push(i);}function m(e,t,s,i,o,r){var n=(r-t)/(i-t);return e.push(r),e.push(s+(o-s)*n),e.push(1),n}function y(e,t,s,i,o,r){var n=(r-s)/(o-s);return e.push(t+(i-t)*n),e.push(r),e.push(1),n}function v(e,t){for(var i=[],o=0;o<e.length;o++){var r,n=e[o],a=n.type;if("Point"===a||"MultiPoint"===a||"LineString"===a)r=x(n.geometry,t);else if("MultiLineString"===a||"Polygon"===a){r=[];for(var l=0;l<n.geometry.length;l++)r.push(x(n.geometry[l],t));}else if("MultiPolygon"===a)for(r=[],l=0;l<n.geometry.length;l++){for(var h=[],c=0;c<n.geometry[l].length;c++)h.push(x(n.geometry[l][c],t));r.push(h);}i.push(s(n.id,a,r,n.tags));}return i}function x(e,t){var s=[];s.size=e.size,void 0!==e.start&&(s.start=e.start,s.end=e.end);for(var i=0;i<e.length;i+=3)s.push(e[i]+t,e[i+1],e[i+2]);return s}function w(e,t){if(e.transformed)return e;var s,i,o,r=1<<e.z,n=e.x,a=e.y;for(s=0;s<e.features.length;s++){var l=e.features[s],h=l.geometry,c=l.type;if(l.geometry=[],1===c)for(i=0;i<h.length;i+=2)l.geometry.push(S(h[i],h[i+1],t,r,n,a));else for(i=0;i<h.length;i++){var u=[];for(o=0;o<h[i].length;o+=2)u.push(S(h[i][o],h[i][o+1],t,r,n,a));l.geometry.push(u);}}return e.transformed=!0,e}function S(e,t,s,i,o,r){return [Math.round(s*(e*i-o)),Math.round(s*(t*i-r))]}function b(e,t,s,i,o){for(var r=t===o.maxZoom?0:o.tolerance/((1<<t)*o.extent),n={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:s,y:i,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},a=0;a<e.length;a++){n.numFeatures++,I(n,e[a],r,o);var l=e[a].minX,h=e[a].minY,c=e[a].maxX,u=e[a].maxY;l<n.minX&&(n.minX=l),h<n.minY&&(n.minY=h),c>n.maxX&&(n.maxX=c),u>n.maxY&&(n.maxY=u);}return n}function I(e,t,s,i){var o=t.geometry,r=t.type,n=[];if("Point"===r||"MultiPoint"===r)for(var a=0;a<o.length;a+=3)n.push(o[a]),n.push(o[a+1]),e.numPoints++,e.numSimplified++;else if("LineString"===r)M(n,o,e,s,!1,!1);else if("MultiLineString"===r||"Polygon"===r)for(a=0;a<o.length;a++)M(n,o[a],e,s,"Polygon"===r,0===a);else if("MultiPolygon"===r)for(var l=0;l<o.length;l++){var h=o[l];for(a=0;a<h.length;a++)M(n,h[a],e,s,!0,0===a);}if(n.length){var c=t.tags||null;if("LineString"===r&&i.lineMetrics){for(var u in c={},t.tags)c[u]=t.tags[u];c.mapbox_clip_start=o.start/o.size,c.mapbox_clip_end=o.end/o.size;}var d={geometry:n,type:"Polygon"===r||"MultiPolygon"===r?3:"LineString"===r||"MultiLineString"===r?2:1,tags:c};null!==t.id&&(d.id=t.id),e.features.push(d);}}function M(e,t,s,i,o,r){var n=i*i;if(i>0&&t.size<(o?n:i))s.numPoints+=t.length/3;else {for(var a=[],l=0;l<t.length;l+=3)(0===i||t[l+2]>n)&&(s.numSimplified++,a.push(t[l]),a.push(t[l+1])),s.numPoints++;o&&function(e,t){for(var s=0,i=0,o=e.length,r=o-2;i<o;r=i,i+=2)s+=(e[i]-e[r])*(e[i+1]+e[r+1]);if(s>0===t)for(i=0,o=e.length;i<o/2;i+=2){var n=e[i],a=e[i+1];e[i]=e[o-2-i],e[i+1]=e[o-1-i],e[o-2-i]=n,e[o-1-i]=a;}}(a,r),e.push(a);}}function k(e,t){var s=(t=this.options=function(e,t){for(var s in t)e[s]=t[s];return e}(Object.create(this.options),t)).debug;if(s&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var i=function(e,t){var s=[];if("FeatureCollection"===e.type)for(var i=0;i<e.features.length;i++)o(s,e.features[i],t,i);else o(s,"Feature"===e.type?e:{geometry:e},t);return s}(e,t);this.tiles={},this.tileCoords=[],s&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),(i=function(e,t){var s=t.buffer/t.extent,i=e,o=c(e,1,-1-s,s,0,-1,2,t),r=c(e,1,1-s,2+s,0,-1,2,t);return (o||r)&&(i=c(e,1,-s,1+s,0,-1,2,t)||[],o&&(i=v(o,1).concat(i)),r&&(i=i.concat(v(r,-1)))),i}(i,t)).length&&this.splitTile(i,0,0,0),s&&(i.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)));}function T(e,t,s){return 32*((1<<e)*s+t)+e}return k.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0},k.prototype.splitTile=function(e,t,s,i,o,r,n){for(var a=[e,t,s,i],l=this.options,h=l.debug;a.length;){i=a.pop(),s=a.pop(),t=a.pop(),e=a.pop();var u=1<<t,d=T(t,s,i),p=this.tiles[d];if(!p&&(h>1&&console.time("creation"),p=this.tiles[d]=b(e,t,s,i,l),this.tileCoords.push({z:t,x:s,y:i}),h)){h>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,s,i,p.numFeatures,p.numPoints,p.numSimplified),console.timeEnd("creation"));var f="z"+t;this.stats[f]=(this.stats[f]||0)+1,this.total++;}if(p.source=e,o){if(t===l.maxZoom||t===o)continue;var g=1<<o-t;if(s!==Math.floor(r/g)||i!==Math.floor(n/g))continue}else if(t===l.indexMaxZoom||p.numPoints<=l.indexMaxPoints)continue;if(p.source=null,0!==e.length){h>1&&console.time("clipping");var m,y,v,x,w,S,I=.5*l.buffer/l.extent,M=.5-I,k=.5+I,P=1+I;m=y=v=x=null,w=c(e,u,s-I,s+k,0,p.minX,p.maxX,l),S=c(e,u,s+M,s+P,0,p.minX,p.maxX,l),e=null,w&&(m=c(w,u,i-I,i+k,1,p.minY,p.maxY,l),y=c(w,u,i+M,i+P,1,p.minY,p.maxY,l),w=null),S&&(v=c(S,u,i-I,i+k,1,p.minY,p.maxY,l),x=c(S,u,i+M,i+P,1,p.minY,p.maxY,l),S=null),h>1&&console.timeEnd("clipping"),a.push(m||[],t+1,2*s,2*i),a.push(y||[],t+1,2*s,2*i+1),a.push(v||[],t+1,2*s+1,2*i),a.push(x||[],t+1,2*s+1,2*i+1);}}},k.prototype.getTile=function(e,t,s){var i=this.options,o=i.extent,r=i.debug;if(e<0||e>24)return null;var n=1<<e,a=T(e,t=(t%n+n)%n,s);if(this.tiles[a])return w(this.tiles[a],o);r>1&&console.log("drilling down to z%d-%d-%d",e,t,s);for(var l,h=e,c=t,u=s;!l&&h>0;)h--,c=Math.floor(c/2),u=Math.floor(u/2),l=this.tiles[T(h,c,u)];return l&&l.source?(r>1&&console.log("found parent tile z%d-%d-%d",h,c,u),r>1&&console.time("drilling down"),this.splitTile(l.source,h,c,u,e,t,s),r>1&&console.timeEnd("drilling down"),this.tiles[a]?w(this.tiles[a],o):null):null},function(e,t){return new k(e,t)}}();var $=e.dK(V.exports);function U(e,t){const s=e.tileID.canonical;if(!this._geoJSONIndex)return t(null,null);const i=this._geoJSONIndex.getTile(s.z,s.x,s.y);if(!i)return t(null,null);const o=new y(i.features);let r=z(o);0===r.byteOffset&&r.byteLength===r.buffer.byteLength||(r=new Uint8Array(r)),t(null,{vectorTile:o,rawData:r.buffer});}class q extends h{constructor(e,t,s,i,o,r){super(e,t,s,i,U,r),o&&(this.loadGeoJSON=o);}loadData(s,i){const o=s&&s.request,r=o&&o.collectResourceTiming;this.loadGeoJSON(s,((n,a)=>{if(n||!a)return i(n);if("object"!=typeof a)return i(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));{f(a,!0);try{if(s.filter){const t=e.r(s.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if("error"===t.result)throw new Error(t.value.map((e=>`${e.key}: ${e.message}`)).join(", "));const i=a.features.filter((e=>t.value.evaluate({zoom:0},e)));a={type:"FeatureCollection",features:i};}this._geoJSONIndex=s.cluster?new W(function({superclusterOptions:t,clusterProperties:s}){if(!s||!t)return t;const i={},o={},r={accumulated:null,zoom:0},n={properties:null},a=Object.keys(s);for(const t of a){const[r,n]=s[t],a=e.r(n),l=e.r("string"==typeof r?[r,["accumulated"],["get",t]]:r);i[t]=a.value,o[t]=l.value;}return t.map=e=>{n.properties=e;const t={};for(const e of a)t[e]=i[e].evaluate(r,n);return t},t.reduce=(e,t)=>{n.properties=t;for(const t of a)r.accumulated=e[t],e[t]=o[t].evaluate(r,n);},t}(s)).load(a.features):$(a,s.geojsonVtOptions);}catch(n){return i(n)}this.loaded={};const l={};if(r){const e=t(o);e&&(l.resourceTiming={},l.resourceTiming[s.source]=JSON.parse(JSON.stringify(e)));}i(null,l);}}));}reloadTile(e,t){const s=this.loaded;return s&&s[e.uid]?super.reloadTile(e,t):this.loadTile(e,t)}loadGeoJSON(t,s){if(t.request)e.g(t.request,s);else {if("string"!=typeof t.data)return s(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));try{return s(null,JSON.parse(t.data))}catch(e){return s(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`))}}}getClusterExpansionZoom(e,t){try{t(null,this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));}catch(e){t(e);}}getClusterChildren(e,t){try{t(null,this._geoJSONIndex.getChildren(e.clusterId));}catch(e){t(e);}}getClusterLeaves(e,t){try{t(null,this._geoJSONIndex.getLeaves(e.clusterId,e.limit,e.offset));}catch(e){t(e);}}}class K{constructor(t,s){this.tileID=new e.am(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.tileZoom=t.tileZoom,this.uid=t.uid,this.zoom=t.zoom,this.canonical=t.tileID.canonical,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.projection=t.projection,this.brightness=s;}parse(t,s,i,o){this.status="parsing";const r=new e.am(i.tileID.overscaledZ,i.tileID.wrap,i.tileID.canonical.z,i.tileID.canonical.x,i.tileID.canonical.y),n={},a=s.familiesBySource[i.source],l=new e.dC(r,i.promoteId);return l.bucketLayerIDs=[],l.is3DTile=!0,e.dP(t).then((t=>{if(!t)return o(new Error("Could not parse tile"));const s=e.dQ(t,1/e.bR(i.tileID.canonical)),h=t.json.extensionsUsed&&t.json.extensionsUsed.includes("MAPBOX_mesh_features")||t.json.asset.extras&&t.json.asset.extras.MAPBOX_mesh_features,c=t.json.extensionsUsed&&t.json.extensionsUsed.includes("EXT_meshopt_compression"),u=new e.K(this.zoom,{brightness:this.brightness});for(const t in a)for(const i of a[t]){const t=i[0];l.bucketLayerIDs.push(i.map((e=>e.id))),t.recalculate(u,[]);const o=new e.dR(s,r,h,c,this.brightness,l);h||(o.needsUpload=!0),n[t.fqid]=o,o.evaluate(t);}this.status="done",o(null,{buckets:n,featureIndex:l});})).catch((e=>o(new Error(e.message))))}}class H{constructor(e,t,s,i,o,r){this.actor=e,this.layerIndex=t,this.brightness=r,this.loading={},this.loaded={};}loadTile(t,s){const i=t.uid,o=this.loading[i]=new K(t,this.brightness);e.a_(t.request,((e,r)=>{const n=!this.loading[i];return delete this.loading[i],n||e?(o.status="done",n||(this.loaded[i]=o),s(e)):r&&0!==r.byteLength?void o.parse(r,this.layerIndex,t,((e,t)=>{o.status="done",this.loaded=this.loaded||{},this.loaded[i]=o,e||!t?s(e):s(null,t);})):(o.status="done",this.loaded[i]=o,s())}));}reloadTile(e,t){const s=this.loaded,i=e.uid;if(s&&s[i]){const o=s[i];o.projection=e.projection,o.brightness=e.brightness;const r=(s,i)=>{o.reloadCallback&&(delete o.reloadCallback,this.loadTile(e,t)),t(s,i);};"parsing"===o.status?o.reloadCallback=r:"done"===o.status&&this.loadTile(e,t);}}abortTile(e,t){const s=e.uid;this.loading[s]&&delete this.loading[s],t();}removeTile(e,t){const s=this.loaded,i=e.uid;s&&s[i]&&delete s[i],t();}}class Q{constructor(t){this.self=t,this.actor=new e.dS(t,this),this.layerIndexes={},this.availableImages={},this.isSpriteLoaded={},this.projections={},this.defaultProjection=e.bo({name:"mercator"}),this.workerSourceTypes={vector:h,geojson:q,"batched-model":H},this.workerSources={},this.demWorkerSources={},this.self.registerWorkerSource=(e,t)=>{if(this.workerSourceTypes[e])throw new Error(`Worker source with name "${e}" already registered.`);this.workerSourceTypes[e]=t;},this.self.registerRTLTextPlugin=t=>{if(e.dT.isParsed())throw new Error("RTL text plugin already registered.");e.dT.applyArabicShaping=t.applyArabicShaping,e.dT.processBidirectionalText=t.processBidirectionalText,e.dT.processStyledBidirectionalText=t.processStyledBidirectionalText;};}clearCaches(e,t,s){delete this.layerIndexes[e],delete this.availableImages[e],delete this.workerSources[e],delete this.demWorkerSources[e],delete this.rasterArrayWorkerSource,s();}checkIfReady(e,t,s){s();}setReferrer(e,t){this.referrer=t;}spriteLoaded(t,{scope:s,isLoaded:i}){if(this.isSpriteLoaded[t]||(this.isSpriteLoaded[t]={}),this.isSpriteLoaded[t][s]=i,this.workerSources[t]&&this.workerSources[t][s])for(const o in this.workerSources[t][s]){const r=this.workerSources[t][s][o];for(const t in r)r[t]instanceof h&&(r[t].isSpriteLoaded=i,r[t].fire(new e.b("isSpriteLoaded")));}}setImages(e,{scope:t,images:s},i){if(this.availableImages[e]||(this.availableImages[e]={}),this.availableImages[e][t]=s,this.workerSources[e]&&this.workerSources[e][t]){for(const i in this.workerSources[e][t]){const o=this.workerSources[e][t][i];for(const e in o)o[e].availableImages=s;}i();}else i();}setProjection(t,s){this.projections[t]=e.bo(s);}setBrightness(e,t,s){this.brightness=t,s();}setLayers(e,t,s){this.getLayerIndex(e,t.scope).replace(t.layers,t.options),s();}updateLayers(e,t,s){this.getLayerIndex(e,t.scope).update(t.layers,t.removedIds,t.options),s();}loadTile(e,t,s){t.projection=this.projections[e]||this.defaultProjection,this.getWorkerSource(e,t.type,t.source,t.scope).loadTile(t,s);}loadDEMTile(e,t,s){this.getDEMWorkerSource(e,t.source,t.scope).loadTile(t,s);}decodeRasterArray(e,t,s){this.getRasterArrayWorkerSource().decodeRasterArray(t,s);}reloadTile(e,t,s){t.projection=this.projections[e]||this.defaultProjection,this.getWorkerSource(e,t.type,t.source,t.scope).reloadTile(t,s);}abortTile(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).abortTile(t,s);}removeTile(e,t,s){this.getWorkerSource(e,t.type,t.source,t.scope).removeTile(t,s);}removeSource(e,t,s){if(!(this.workerSources[e]&&this.workerSources[e][t.scope]&&this.workerSources[e][t.scope][t.type]&&this.workerSources[e][t.scope][t.type][t.source]))return;const i=this.workerSources[e][t.scope][t.type][t.source];delete this.workerSources[e][t.scope][t.type][t.source],void 0!==i.removeSource?i.removeSource(t,s):s();}loadWorkerSource(e,t,s){try{this.self.importScripts(t.url),s();}catch(e){s(e.toString());}}syncRTLPluginState(t,s,i){try{e.dT.setState(s);const t=e.dT.getPluginURL();if(e.dT.isLoaded()&&!e.dT.isParsed()&&null!=t){this.self.importScripts(t);const s=e.dT.isParsed();i(s?void 0:new Error(`RTL Text Plugin failed to import scripts from ${t}`),s);}}catch(e){i(e.toString());}}setDracoUrl(e,t){this.dracoUrl=t;}getAvailableImages(e,t){this.availableImages[e]||(this.availableImages[e]={});let s=this.availableImages[e][t];return s||(s=[]),s}getLayerIndex(e,t){this.layerIndexes[e]||(this.layerIndexes[e]={});let s=this.layerIndexes[e][t];return s||(s=this.layerIndexes[e][t]=new o,s.scope=t),s}getWorkerSource(e,t,s,i){if(this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][i]||(this.workerSources[e][i]={}),this.workerSources[e][i][t]||(this.workerSources[e][i][t]={}),this.isSpriteLoaded[e]||(this.isSpriteLoaded[e]={}),!this.workerSources[e][i][t][s]){const o={send:(t,s,i,o,r,n)=>{this.actor.send(t,s,i,e,r,n);},scheduler:this.actor.scheduler};this.workerSources[e][i][t][s]=new this.workerSourceTypes[t](o,this.getLayerIndex(e,i),this.getAvailableImages(e,i),this.isSpriteLoaded[e][i],void 0,this.brightness);}return this.workerSources[e][i][t][s]}getDEMWorkerSource(e,t,s){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][s]||(this.demWorkerSources[e][s]={}),this.demWorkerSources[e][s][t]||(this.demWorkerSources[e][s][t]=new c),this.demWorkerSources[e][s][t]}getRasterArrayWorkerSource(){return this.rasterArrayWorkerSource||(this.rasterArrayWorkerSource=new u),this.rasterArrayWorkerSource}enforceCacheSizeLimit(t,s){e.dU(s);}getWorkerPerformanceMetrics(e,t,s){s(void 0,void 0);}}return "undefined"!=typeof WorkerGlobalScope&&"undefined"!=typeof self&&self instanceof WorkerGlobalScope&&(self.worker=new Q(self)),Q}));

    define(["./shared"],(function(e){function t(e,i){if(Array.isArray(e)){if(!Array.isArray(i)||e.length!==i.length)return !1;for(let o=0;o<e.length;o++)if(!t(e[o],i[o]))return !1;return !0}if("object"==typeof e&&null!==e&&null!==i){if("object"!=typeof i)return !1;if(Object.keys(e).length!==Object.keys(i).length)return !1;for(const o in e)if(!t(e[o],i[o]))return !1;return !0}return e===i}var i=o;function o(e){return !function(e){return "undefined"==typeof window||"undefined"==typeof document?"not a browser":function(){if(!("Worker"in window&&"Blob"in window&&"URL"in window))return !1;var e,t,i=new Blob([""],{type:"text/javascript"}),o=URL.createObjectURL(i);try{t=new Worker(o),e=!0;}catch(t){e=!1;}return t&&t.terminate(),URL.revokeObjectURL(o),e}()?function(){var e=document.createElement("canvas");e.width=e.height=1;var t=e.getContext("2d");if(!t)return !1;var i=t.getImageData(0,0,1,1);return i&&i.width===e.width}()?(void 0===r[t=e&&e.failIfMajorPerformanceCaveat]&&(r[t]=function(e){var t,i=function(e){var t=document.createElement("canvas"),i=Object.create(o.webGLContextAttributes);return i.failIfMajorPerformanceCaveat=e,t.getContext("webgl2",i)}(e);if(!i)return !1;try{t=i.createShader(i.VERTEX_SHADER);}catch(e){return !1}return !(!t||i.isContextLost())&&(i.shaderSource(t,"void main() {}"),i.compileShader(t),!0===i.getShaderParameter(t,i.COMPILE_STATUS))}(t)),r[t]?document.documentMode?"insufficient ECMAScript 6 support":void 0:"insufficient WebGL2 support"):"insufficient Canvas/getImageData support":"insufficient worker support";var t;}(e)}var r={};function s(e,t,i){const o=document.createElement(e);return null!=t&&(o.className=t),i&&i.appendChild(o),o}function n(e,t,i){const o=document.createElementNS("http://www.w3.org/2000/svg",e);for(const e of Object.keys(t))o.setAttributeNS(null,e,String(t[e]));return i&&i.appendChild(o),o}o.webGLContextAttributes={antialias:!1,alpha:!0,stencil:!0,depth:!0};const a="undefined"!=typeof document?document.documentElement&&document.documentElement.style:null,l=a&&void 0!==a.userSelect?"userSelect":"WebkitUserSelect";let c;function h(){a&&l&&(c=a[l],a[l]="none");}function u(){a&&l&&(a[l]=c);}function d(e){e.preventDefault(),e.stopPropagation(),window.removeEventListener("click",d,!0);}function _(){window.addEventListener("click",d,!0),window.setTimeout((()=>{window.removeEventListener("click",d,!0);}),0);}function p(e,t){const i=e.getBoundingClientRect();return g(e,i,t)}function f(e,t){const i=e.getBoundingClientRect(),o=[];for(let r=0;r<t.length;r++)o.push(g(e,i,t[r]));return o}function m(e){return void 0!==window.InstallTrigger&&2===e.button&&e.ctrlKey&&window.navigator.platform.toUpperCase().indexOf("MAC")>=0?0:e.button}function g(t,i,o){const r=t.offsetWidth===i.width?1:t.offsetWidth/i.width;return new e.P((o.clientX-i.left)*r,(o.clientY-i.top)*r)}class v{constructor(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSourceCaches={},this._updatedPaintProps=new Set,this._updatedImages=new Set;}isDirty(){return this._changed}setDirty(){this._changed=!0;}getUpdatedSourceCaches(){return this._updatedSourceCaches}updateSourceCache(e,t){this._updatedSourceCaches[e]=t,this.setDirty();}discardSourceCacheUpdate(e){delete this._updatedSourceCaches[e];}updateLayer(e){const t=e.scope;this._updatedLayers[t]=this._updatedLayers[t]||new Set,this._updatedLayers[t].add(e.id),this.setDirty();}removeLayer(e){const t=e.scope;this._removedLayers[t]=this._removedLayers[t]||{},this._updatedLayers[t]=this._updatedLayers[t]||new Set,this._removedLayers[t][e.id]=e,this._updatedLayers[t].delete(e.id),this._updatedPaintProps.delete(e.fqid),this.setDirty();}getRemovedLayer(e){return this._removedLayers[e.scope]?this._removedLayers[e.scope][e.id]:null}discardLayerRemoval(e){this._removedLayers[e.scope]&&delete this._removedLayers[e.scope][e.id];}getLayerUpdatesByScope(){const e={};for(const t in this._updatedLayers)e[t]=e[t]||{},e[t].updatedIds=Array.from(this._updatedLayers[t].values());for(const t in this._removedLayers)e[t]=e[t]||{},e[t].removedIds=Object.keys(this._removedLayers[t]);return e}getUpdatedPaintProperties(){return this._updatedPaintProps}updatePaintProperties(e){this._updatedPaintProps.add(e.fqid),this.setDirty();}getUpdatedImages(){return Array.from(this._updatedImages.values())}updateImage(e){this._updatedImages.add(e),this.setDirty();}resetUpdatedImages(){this._updatedImages.clear();}reset(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSourceCaches={},this._updatedPaintProps.clear(),this._updatedImages.clear();}}class x extends e.E{constructor(e){super(),this.requestManager=e,this.models={"":{}},this.numModelsLoading={};}loadModel(t,i){return e.l(this.requestManager.transformRequest(i,e.R.Model).url).then((i=>{if(!i)return;const o=e.c(i),r=new e.M(t,void 0,void 0,o);return r.computeBoundsAndApplyParent(),r})).catch((o=>{this.fire(new e.a(new Error(`Could not load model ${t} from ${i}: ${o.message}`)));}))}load(t,i){this.models[i]||(this.models[i]={});const o=Object.keys(t);this.numModelsLoading[i]=(this.numModelsLoading[i]||0)+o.length;const r=[];for(const e of o)r.push(this.loadModel(e,t[e]));Promise.allSettled(r).then((t=>{for(let e=0;e<t.length;e++){const{status:r,value:s}=t[e];"fulfilled"===r&&s&&(this.models[i][o[e]]=s);}this.numModelsLoading[i]-=o.length,this.fire(new e.b("data",{dataType:"style"}));})).catch((t=>{this.fire(new e.a(new Error(`Could not load models: ${t.message}`)));}));}isLoaded(){for(const e in this.numModelsLoading)if(this.numModelsLoading[e]>0)return !1;return !0}hasModel(e,t){return !!this.getModel(e,t)}getModel(e,t){return this.models[t]||(this.models[t]={}),this.models[t][e]}addModel(e,t,i){this.models[i]||(this.models[i]={}),this.hasModel(e,i)&&this.removeModel(e,i),this.load({[e]:this.requestManager.normalizeModelURL(t)},i);}addModels(e,t){const i={};for(const t in e)i[t]=this.requestManager.normalizeModelURL(e[t]);this.load(i,t);}removeModel(e,t){this.models[t]||(this.models[t]={});const i=this.models[t][e];delete this.models[t][e],i.destroy();}listModels(e){return this.models[e]||(this.models[e]={}),Object.keys(this.models[e])}upload(e,t){this.models[t]||(this.models[t]={});for(const i in this.models[t])this.models[t][i].upload(e.context);}}class y{constructor(){this.state={},this.stateChanges={},this.deletedStates={};}updateState(t,i,o){const r=String(i);if(this.stateChanges[t]=this.stateChanges[t]||{},this.stateChanges[t][r]=this.stateChanges[t][r]||{},e.e(this.stateChanges[t][r],o),null===this.deletedStates[t]){this.deletedStates[t]={};for(const e in this.state[t])e!==r&&(this.deletedStates[t][e]=null);}else if(this.deletedStates[t]&&null===this.deletedStates[t][r]){this.deletedStates[t][r]={};for(const e in this.state[t][r])o[e]||(this.deletedStates[t][r][e]=null);}else for(const e in o)this.deletedStates[t]&&this.deletedStates[t][r]&&null===this.deletedStates[t][r][e]&&delete this.deletedStates[t][r][e];}removeFeatureState(e,t,i){if(null===this.deletedStates[e])return;const o=String(t);if(this.deletedStates[e]=this.deletedStates[e]||{},i&&void 0!==t)null!==this.deletedStates[e][o]&&(this.deletedStates[e][o]=this.deletedStates[e][o]||{},this.deletedStates[e][o][i]=null);else if(void 0!==t)if(this.stateChanges[e]&&this.stateChanges[e][o])for(i in this.deletedStates[e][o]={},this.stateChanges[e][o])this.deletedStates[e][o][i]=null;else this.deletedStates[e][o]=null;else this.deletedStates[e]=null;}getState(t,i){const o=String(i),r=e.e({},(this.state[t]||{})[o],(this.stateChanges[t]||{})[o]);if(null===this.deletedStates[t])return {};if(this.deletedStates[t]){const e=this.deletedStates[t][i];if(null===e)return {};for(const t in e)delete r[t];}return r}initializeTileState(e,t){e.setFeatureState(this.state,t);}coalesceChanges(t,i){const o={};for(const t in this.stateChanges){this.state[t]=this.state[t]||{};const i={};for(const o in this.stateChanges[t])this.state[t][o]||(this.state[t][o]={}),e.e(this.state[t][o],this.stateChanges[t][o]),i[o]=this.state[t][o];o[t]=i;}for(const t in this.deletedStates){this.state[t]=this.state[t]||{};const i={};if(null===this.deletedStates[t])for(const e in this.state[t])i[e]={},this.state[t][e]={};else for(const e in this.deletedStates[t]){if(null===this.deletedStates[t][e])this.state[t][e]={};else if(this.state[t][e])for(const i of Object.keys(this.deletedStates[t][e]))delete this.state[t][e][i];i[e]=this.state[t][e];}o[t]=o[t]||{},e.e(o[t],i);}if(this.stateChanges={},this.deletedStates={},0!==Object.keys(o).length)for(const e in t)t[e].setFeatureState(o,i);}}function b(e){const{userImage:t}=e;return !!(t&&t.render&&t.render())&&(e.data.replace(new Uint8Array(t.data.buffer)),!0)}class w extends e.E{constructor(){super(),this.images={},this.updatedImages={},this.callbackDispatchedThisFrame={},this.loaded={},this.requestors=[],this.patterns={},this.atlasImage={},this.atlasTexture={},this.dirty=!0;}createScope(t){this.images[t]={},this.loaded[t]=!1,this.updatedImages[t]={},this.patterns[t]={},this.callbackDispatchedThisFrame[t]={},this.atlasImage[t]=new e.h({width:1,height:1});}isLoaded(){for(const e in this.loaded)if(!this.loaded[e])return !1;return !0}setLoaded(e,t){if(this.loaded[t]!==e&&(this.loaded[t]=e,e)){for(const{ids:e,callback:i}of this.requestors)this._notify(e,t,i);this.requestors=[];}}hasImage(e,t){return !!this.getImage(e,t)}getImage(e,t){return this.images[t][e]}addImage(e,t,i){this._validate(e,i)&&(this.images[t][e]=i);}_validate(t,i){let o=!0;return this._validateStretch(i.stretchX,i.data&&i.data.width)||(this.fire(new e.a(new Error(`Image "${t}" has invalid "stretchX" value`))),o=!1),this._validateStretch(i.stretchY,i.data&&i.data.height)||(this.fire(new e.a(new Error(`Image "${t}" has invalid "stretchY" value`))),o=!1),this._validateContent(i.content,i)||(this.fire(new e.a(new Error(`Image "${t}" has invalid "content" value`))),o=!1),o}_validateStretch(e,t){if(!e)return !0;let i=0;for(const o of e){if(o[0]<i||o[1]<o[0]||t<o[1])return !1;i=o[1];}return !0}_validateContent(e,t){return !(e&&(4!==e.length||e[0]<0||t.data.width<e[0]||e[1]<0||t.data.height<e[1]||e[2]<0||t.data.width<e[2]||e[3]<0||t.data.height<e[3]||e[2]<e[0]||e[3]<e[1]))}updateImage(e,t,i){i.version=this.images[t][e].version+1,this.images[t][e]=i,this.updatedImages[t][e]=!0;}removeImage(e,t){const i=this.images[t][e];delete this.images[t][e],delete this.patterns[t][e],i.userImage&&i.userImage.onRemove&&i.userImage.onRemove();}listImages(e){return Object.keys(this.images[e])}getImages(e,t,i){let o=!0;const r=!!this.loaded[t];if(!r)for(const i of e)this.images[t][i]||(o=!1);r||o?this._notify(e,t,i):this.requestors.push({ids:e,scope:t,callback:i});}getUpdatedImages(e){return this.updatedImages[e]}_notify(t,i,o){const r={};for(const o of t){this.images[i][o]||this.fire(new e.b("styleimagemissing",{id:o}));const t=this.images[i][o];t?r[o]={data:t.data.clone(),pixelRatio:t.pixelRatio,sdf:t.sdf,version:t.version,stretchX:t.stretchX,stretchY:t.stretchY,content:t.content,hasRenderCallback:Boolean(t.userImage&&t.userImage.render)}:e.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);}o(null,r);}getPixelSize(e){const{width:t,height:i}=this.atlasImage[e];return {width:t,height:i}}getPattern(t,i){const o=this.patterns[i][t],r=this.getImage(t,i);if(!r)return null;if(o&&o.position.version===r.version)return o.position;if(o)o.position.version=r.version;else {const o={w:r.data.width+2,h:r.data.height+2,x:0,y:0},s=new e.I(o,r);this.patterns[i][t]={bin:o,position:s};}return this._updatePatternAtlas(i),this.patterns[i][t].position}bind(t,i){const o=t.gl;let r=this.atlasTexture[i];r?this.dirty&&(r.update(this.atlasImage[i]),this.dirty=!1):(r=new e.T(t,this.atlasImage[i],o.RGBA),this.atlasTexture[i]=r),r.bind(o.LINEAR,o.CLAMP_TO_EDGE);}_updatePatternAtlas(t){const i=[];for(const e in this.patterns[t])i.push(this.patterns[t][e].bin);const{w:o,h:r}=e.p(i),s=this.atlasImage[t];s.resize({width:o||1,height:r||1});for(const i in this.patterns[t]){const{bin:o}=this.patterns[t][i],r=o.x+1,n=o.y+1,a=this.images[t][i].data,l=a.width,c=a.height;e.h.copy(a,s,{x:0,y:0},{x:r,y:n},{width:l,height:c}),e.h.copy(a,s,{x:0,y:c-1},{x:r,y:n-1},{width:l,height:1}),e.h.copy(a,s,{x:0,y:0},{x:r,y:n+c},{width:l,height:1}),e.h.copy(a,s,{x:l-1,y:0},{x:r-1,y:n},{width:1,height:c}),e.h.copy(a,s,{x:0,y:0},{x:r+l,y:n},{width:1,height:c});}this.dirty=!0;}beginFrame(){for(const e in this.images)this.callbackDispatchedThisFrame[e]={};}dispatchRenderCallbacks(e,t){for(const i of e){if(this.callbackDispatchedThisFrame[t][i])continue;this.callbackDispatchedThisFrame[t][i]=!0;const e=this.images[t][i];b(e)&&this.updateImage(i,t,e);}}}class T{constructor(e,t,i,o){this.message=(e?`${e}: `:"")+i,o&&(this.identifier=o),null!=t&&t.__line__&&(this.line=t.__line__);}}class E extends T{}function S(t){const i=t.key,o=t.value,r=t.valueSpec||{},s=t.objectElementValidators||{},n=t.style,a=t.styleSpec;let l=[];const c=e.i(o);if("object"!==c)return [new T(i,o,`object expected, ${c} found`)];for(const e in o){const t=e.split(".")[0];let c;s[t]?c=s[t]:r[t]?c=$:s["*"]?c=s["*"]:r["*"]&&(c=$),c?l=l.concat(c({key:(i?`${i}.`:i)+e,value:o[e],valueSpec:r[t]||r["*"],style:n,styleSpec:a,object:o,objectKey:e},o)):l.push(new E(i,o[e],`unknown property "${e}"`));}for(const e in r)s[e]||r[e].required&&void 0===r[e].default&&void 0===o[e]&&l.push(new T(i,o,`missing required property "${e}"`));return l}function C(t){const i=t.value,o=t.valueSpec,r=t.style,s=t.styleSpec,n=t.key,a=t.arrayElementValidator||$;if("array"!==e.i(i))return [new T(n,i,`array expected, ${e.i(i)} found`)];if(o.length&&i.length!==o.length)return [new T(n,i,`array length ${o.length} expected, length ${i.length} found`)];if(o["min-length"]&&i.length<o["min-length"])return [new T(n,i,`array length at least ${o["min-length"]} expected, length ${i.length} found`)];let l={type:o.value,values:o.values,minimum:o.minimum,maximum:o.maximum,function:void 0};s.$version<7&&(l.function=o.function),"object"===e.i(o.value)&&(l=o.value);let c=[];for(let e=0;e<i.length;e++)c=c.concat(a({array:i,arrayIndex:e,value:i[e],valueSpec:l,style:r,styleSpec:s,key:`${n}[${e}]`},!0));return c}function I(t){const i=t.key,o=t.value,r=t.valueSpec;let s=e.i(o);if("number"===s&&o!=o&&(s="NaN"),"number"!==s)return [new T(i,o,`number expected, ${s} found`)];if("minimum"in r){let s=r.minimum;if("array"===e.i(r.minimum)&&(s=r.minimum[t.arrayIndex]),o<s)return [new T(i,o,`${o} is less than the minimum value ${s}`)]}if("maximum"in r){let s=r.maximum;if("array"===e.i(r.maximum)&&(s=r.maximum[t.arrayIndex]),o>s)return [new T(i,o,`${o} is greater than the maximum value ${s}`)]}return []}function D(t){const i=t.valueSpec,o=e.u(t.value.type);let r,s,n,a={};const l="categorical"!==o&&void 0===t.value.property,c=!l,h="array"===e.i(t.value.stops)&&"array"===e.i(t.value.stops[0])&&"object"===e.i(t.value.stops[0][0]),u=S({key:t.key,value:t.value,valueSpec:t.styleSpec.function,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:function(t){if("identity"===o)return [new T(t.key,t.value,'identity function may not have a "stops" property')];let i=[];const r=t.value;return i=i.concat(C({key:t.key,value:r,valueSpec:t.valueSpec,style:t.style,styleSpec:t.styleSpec,arrayElementValidator:d})),"array"===e.i(r)&&0===r.length&&i.push(new T(t.key,r,"array must have at least one stop")),i},default:function(e){return $({key:e.key,value:e.value,valueSpec:i,style:e.style,styleSpec:e.styleSpec})}}});return "identity"===o&&l&&u.push(new T(t.key,t.value,'missing required property "property"')),"identity"===o||t.value.stops||u.push(new T(t.key,t.value,'missing required property "stops"')),"exponential"===o&&t.valueSpec.expression&&!e.s(t.valueSpec)&&u.push(new T(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(c&&!e.k(t.valueSpec)?u.push(new T(t.key,t.value,"property functions not supported")):l&&!e.m(t.valueSpec)&&u.push(new T(t.key,t.value,"zoom functions not supported"))),"categorical"!==o&&!h||void 0!==t.value.property||u.push(new T(t.key,t.value,'"property" property is required')),u;function d(t){let o=[];const r=t.value,l=t.key;if("array"!==e.i(r))return [new T(l,r,`array expected, ${e.i(r)} found`)];if(2!==r.length)return [new T(l,r,`array length 2 expected, length ${r.length} found`)];if(h){if("object"!==e.i(r[0]))return [new T(l,r,`object expected, ${e.i(r[0])} found`)];if(void 0===r[0].zoom)return [new T(l,r,"object stop key must have zoom")];if(void 0===r[0].value)return [new T(l,r,"object stop key must have value")];const i=e.u(r[0].zoom);if("number"!=typeof i)return [new T(l,r[0].zoom,"stop zoom values must be numbers")];if(n&&n>i)return [new T(l,r[0].zoom,"stop zoom values must appear in ascending order")];i!==n&&(n=i,s=void 0,a={}),o=o.concat(S({key:`${l}[0]`,value:r[0],valueSpec:{zoom:{}},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{zoom:I,value:_}}));}else o=o.concat(_({key:`${l}[0]`,value:r[0],valueSpec:{},style:t.style,styleSpec:t.styleSpec},r));return e.n(e.o(r[1]))?o.concat([new T(`${l}[1]`,r[1],"expressions are not allowed in function stops.")]):o.concat($({key:`${l}[1]`,value:r[1],valueSpec:i,style:t.style,styleSpec:t.styleSpec}))}function _(t,n){const l=e.i(t.value),c=e.u(t.value),h=null!==t.value?t.value:n;if(r){if(l!==r)return [new T(t.key,h,`${l} stop domain type must match previous stop domain type ${r}`)]}else r=l;if("number"!==l&&"string"!==l&&"boolean"!==l&&"number"!=typeof c&&"string"!=typeof c&&"boolean"!=typeof c)return [new T(t.key,h,"stop domain value must be a number, string, or boolean")];if("number"!==l&&"categorical"!==o){let r=`number expected, ${l} found`;return e.k(i)&&void 0===o&&(r+='\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),[new T(t.key,h,r)]}return "categorical"!==o||"number"!==l||"number"==typeof c&&isFinite(c)&&Math.floor(c)===c?"categorical"!==o&&"number"===l&&"number"==typeof c&&"number"==typeof s&&void 0!==s&&c<s?[new T(t.key,h,"stop domain values must appear in ascending order")]:(s=c,"categorical"===o&&c in a?[new T(t.key,h,"stop domain values must be unique")]:(a[c]=!0,[])):[new T(t.key,h,`integer expected, found ${String(c)}`)]}}function L(t){const i=("property"===t.expressionContext?e.q:e.r)(e.o(t.value),t.valueSpec);if("error"===i.result)return i.value.map((e=>new T(`${t.key}${e.key}`,t.value,e.message)));const o=i.value.expression||i.value._styleExpression.expression;if("property"===t.expressionContext&&"text-font"===t.propertyKey&&!o.outputDefined())return [new T(t.key,t.value,`Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];if("property"===t.expressionContext&&"layout"===t.propertyType&&!e.t(o))return [new T(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];if("filter"===t.expressionContext)return A(o,t);if(t.expressionContext&&0===t.expressionContext.indexOf("cluster")){if(!e.v(o,["zoom","feature-state"]))return [new T(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if("cluster-initial"===t.expressionContext&&!e.x(o))return [new T(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return []}function A(t,i){const o=new Set(["zoom","feature-state","pitch","distance-from-center"]);if(i.valueSpec&&i.valueSpec.expression)for(const e of i.valueSpec.expression.parameters)o.delete(e);if(0===o.size)return [];const r=[];return t instanceof e.C&&o.has(t.name)?[new T(i.key,i.value,`["${t.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)]:(t.eachChild((e=>{r.push(...A(e,i));})),r)}function R(t){const i=t.key,o=t.value,r=t.valueSpec,s=[];return Array.isArray(r.values)?-1===r.values.indexOf(e.u(o))&&s.push(new T(i,o,`expected one of [${r.values.join(", ")}], ${JSON.stringify(o)} found`)):-1===Object.keys(r.values).indexOf(e.u(o))&&s.push(new T(i,o,`expected one of [${Object.keys(r.values).join(", ")}], ${JSON.stringify(o)} found`)),s}function P(t){return e.z(e.o(t.value))?L(e.j({},t,{expressionContext:"filter",valueSpec:t.styleSpec[`filter_${t.layerType||"fill"}`]})):M(t)}function M(t){const i=t.value,o=t.key;if("array"!==e.i(i))return [new T(o,i,`array expected, ${e.i(i)} found`)];const r=t.styleSpec;let s,n=[];if(i.length<1)return [new T(o,i,"filter array must have at least 1 element")];switch(n=n.concat(R({key:`${o}[0]`,value:i[0],valueSpec:r.filter_operator,style:t.style,styleSpec:t.styleSpec})),e.u(i[0])){case"<":case"<=":case">":case">=":i.length>=2&&"$type"===e.u(i[1])&&n.push(new T(o,i,`"$type" cannot be use with operator "${i[0]}"`));case"==":case"!=":3!==i.length&&n.push(new T(o,i,`filter array for operator "${i[0]}" must have 3 elements`));case"in":case"!in":i.length>=2&&(s=e.i(i[1]),"string"!==s&&n.push(new T(`${o}[1]`,i[1],`string expected, ${s} found`)));for(let a=2;a<i.length;a++)s=e.i(i[a]),"$type"===e.u(i[1])?n=n.concat(R({key:`${o}[${a}]`,value:i[a],valueSpec:r.geometry_type,style:t.style,styleSpec:t.styleSpec})):"string"!==s&&"number"!==s&&"boolean"!==s&&n.push(new T(`${o}[${a}]`,i[a],`string, number, or boolean expected, ${s} found`));break;case"any":case"all":case"none":for(let e=1;e<i.length;e++)n=n.concat(M({key:`${o}[${e}]`,value:i[e],style:t.style,styleSpec:t.styleSpec}));break;case"has":case"!has":s=e.i(i[1]),2!==i.length?n.push(new T(o,i,`filter array for "${i[0]}" operator must have 2 elements`)):"string"!==s&&n.push(new T(`${o}[1]`,i[1],`string expected, ${s} found`));}return n}function z(t,i){const o=t.key,r=t.style,s=t.layer,n=t.styleSpec,a=t.value,l=t.objectKey,c=n[`${i}_${t.layerType}`];if(!c)return [];const h=l.match(/^(.*)-transition$/);if("paint"===i&&h&&c[h[1]]&&c[h[1]].transition)return $({key:o,value:a,valueSpec:n.transition,style:r,styleSpec:n});const u=t.valueSpec||c[l];if(!u)return [new E(o,a,`unknown property "${l}"`)];let d;if("string"===e.i(a)&&e.k(u)&&!u.tokens&&(d=/^{([^}]+)}$/.exec(a))){const e=`\`{ "type": "identity", "property": ${d?JSON.stringify(d[1]):'"_"'} }\``;return [new T(o,a,`"${l}" does not support interpolation syntax\nUse an identity property function instead: ${e}.`)]}const _=[];if("symbol"===t.layerType)"text-field"!==l||!r||r.glyphs||r.imports||_.push(new T(o,a,'use of "text-field" requires a style "glyphs" property')),"text-font"===l&&e.A(e.o(a))&&"identity"===e.u(a.type)&&_.push(new T(o,a,'"text-font" does not support identity functions'));else if("model"===t.layerType&&"paint"===i&&s&&s.layout&&s.layout.hasOwnProperty("model-id")&&e.k(u)&&(e.B(u)||e.m(u))){const t=e.q(e.o(a),u),i=t.value.expression||t.value._styleExpression.expression;i&&!e.v(i,["measure-light"])&&("model-emissive-strength"===l&&e.x(i)&&e.t(i)||_.push(new T(o,a,`${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));}return _.concat($({key:t.key,value:a,valueSpec:u,style:r,styleSpec:n,expressionContext:"property",propertyType:i,propertyKey:l}))}function O(e){return z(e,"paint")}function F(e){return z(e,"layout")}function B(t){let i=[];const o=t.value,r=t.key,s=t.style,n=t.styleSpec;o.type||o.ref||i.push(new T(r,o,'either "type" or "ref" is required'));let a=e.u(o.type);const l=e.u(o.ref);if(o.id){const n=e.u(o.id);for(let a=0;a<t.arrayIndex;a++){const t=s.layers[a];e.u(t.id)===n&&i.push(new T(r,o.id,`duplicate layer id "${o.id}", previously used at line ${t.id.__line__}`));}}if("ref"in o){let t;["type","source","source-layer","filter","layout"].forEach((e=>{e in o&&i.push(new T(r,o[e],`"${e}" is prohibited for ref layers`));})),s.layers.forEach((i=>{e.u(i.id)===l&&(t=i);})),t?t.ref?i.push(new T(r,o.ref,"ref cannot reference another ref layer")):a=e.u(t.type):"string"==typeof l&&i.push(new T(r,o.ref,`ref layer "${l}" not found`));}else if("background"!==a&&"sky"!==a&&"slot"!==a)if(o.source){const t=s.sources&&s.sources[o.source],n=t&&e.u(t.type);t?"vector"===n&&"raster"===a?i.push(new T(r,o.source,`layer "${o.id}" requires a raster source`)):"raster"===n&&"raster"!==a?i.push(new T(r,o.source,`layer "${o.id}" requires a vector source`)):"vector"!==n||o["source-layer"]?"raster-dem"===n&&"hillshade"!==a?i.push(new T(r,o.source,"raster-dem source can only be used with layer type 'hillshade'.")):"raster-array"!==n||["raster","raster-particle"].includes(a)?"line"!==a||!o.paint||!o.paint["line-gradient"]&&!o.paint["line-trim-offset"]||"geojson"===n&&t.lineMetrics?"raster-particle"===a&&"raster-array"!==n&&i.push(new T(r,o.source,`layer "${o.id}" requires a 'raster-array' source.`)):i.push(new T(r,o,`layer "${o.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)):i.push(new T(r,o.source,"raster-array source can only be used with layer type 'raster'.")):i.push(new T(r,o,`layer "${o.id}" must specify a "source-layer"`)):i.push(new T(r,o.source,`source "${o.source}" not found`));}else i.push(new T(r,o,'missing required property "source"'));return i=i.concat(S({key:r,value:o,valueSpec:n.layer,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":()=>[],type:()=>$({key:`${r}.type`,value:o.type,valueSpec:n.layer.type,style:t.style,styleSpec:t.styleSpec,object:o,objectKey:"type"}),filter:t=>P(e.j({layerType:a},t)),layout:t=>S({layer:o,key:t.key,value:t.value,valueSpec:{},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":t=>F(e.j({layerType:a},t))}}),paint:t=>S({layer:o,key:t.key,value:t.value,valueSpec:{},style:t.style,styleSpec:t.styleSpec,objectElementValidators:{"*":t=>O(e.j({layerType:a,layer:o},t))}})}})),i}function k(t){const i=t.value,o=t.key,r=e.i(i);return "string"!==r?[new T(o,i,`string expected, ${r} found`)]:[]}const N={promoteId:function({key:t,value:i}){if("string"===e.i(i))return k({key:t,value:i});{const e=[];for(const o in i)e.push(...k({key:`${t}.${o}`,value:i[o]}));return e}}};function U(t){const i=t.value,o=t.key,r=t.styleSpec,s=t.style;if(!i.type)return [new T(o,i,'"type" is required')];const n=e.u(i.type);let a=[];switch(["vector","raster","raster-dem","raster-array"].includes(n)&&(i.url||i.tiles||a.push(new E(o,i,'Either "url" or "tiles" is required.'))),n){case"vector":case"raster":case"raster-dem":case"raster-array":return a=a.concat(S({key:o,value:i,valueSpec:r[`source_${n.replace("-","_")}`],style:t.style,styleSpec:r,objectElementValidators:N})),a;case"geojson":if(a=S({key:o,value:i,valueSpec:r.source_geojson,style:s,styleSpec:r,objectElementValidators:N}),i.cluster)for(const e in i.clusterProperties){const[t,r]=i.clusterProperties[e],s="string"==typeof t?[t,["accumulated"],["get",e]]:t;a.push(...L({key:`${o}.${e}.map`,value:r,expressionContext:"cluster-map"})),a.push(...L({key:`${o}.${e}.reduce`,value:s,expressionContext:"cluster-reduce"}));}return a;case"video":return S({key:o,value:i,valueSpec:r.source_video,style:s,styleSpec:r});case"image":return S({key:o,value:i,valueSpec:r.source_image,style:s,styleSpec:r});case"canvas":return [new T(o,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return R({key:`${o}.type`,value:i.type,valueSpec:{values:G(r)},style:s,styleSpec:r})}}function G(e){return e.source.reduce(((t,i)=>{const o=e[i];return "enum"===o.type.type&&(t=t.concat(Object.keys(o.type.values))),t}),[])}function j(t){const i=t.value;let o=[];if(!i)return o;const r=e.i(i);return "string"!==r?(o=o.concat([new T(t.key,i,`string expected, "${r}" found`)]),o):(function(e){const t=-1===e.indexOf("://");try{return new URL(e,t?"http://example.com":void 0),!0}catch(e){return !1}}(i)||(o=o.concat([new T(t.key,i,`invalid url "${i}"`)])),o)}function V(t){const i=t.value,o=t.styleSpec,r=o.light,s=t.style;let n=[];const a=e.i(i);if(void 0===i)return n;if("object"!==a)return n=n.concat([new T("light",i,`object expected, ${a} found`)]),n;for(const e in i){const t=e.match(/^(.*)-transition$/);n=n.concat(t&&r[t[1]]&&r[t[1]].transition?$({key:e,value:i[e],valueSpec:o.transition,style:s,styleSpec:o}):r[e]?$({key:e,value:i[e],valueSpec:r[e],style:s,styleSpec:o}):[new T(e,i[e],`unknown property "${e}"`)]);}return n}function Z(t){const i=t.value;let o=[];if(!i)return o;const r=e.i(i);if("object"!==r)return o=o.concat([new T("light-3d",i,`object expected, ${r} found`)]),o;const s=t.styleSpec,n=s["light-3d"],a=t.key,l=t.style,c=t.style.lights;for(const e of ["type","id"])if(!(e in i))return o=o.concat([new T("light-3d",i,`missing property ${e} on light`)]),o;if(i.type&&c)for(let r=0;r<t.arrayIndex;r++){const t=e.u(i.type),s=c[r];e.u(s.type)===t&&o.push(new T(a,i.id,`duplicate light type "${i.type}", previously defined at line ${s.id.__line__}`));}const h=`properties_light_${i.type}`;if(!(h in s))return o=o.concat([new T("light-3d",i,`Invalid light type ${i.type}`)]),o;const u=s[h];for(const r in i)if("properties"===r){const n=i[r],a=e.i(n);if("object"!==a)return o=o.concat([new T("properties",n,`object expected, ${a} found`)]),o;for(const e in n)o=o.concat(u[e]?$({key:e,value:n[e],valueSpec:u[e],style:l,styleSpec:s}):[new E(t.key,n[e],`unknown property "${e}"`)]);}else {const e=r.match(/^(.*)-transition$/);o=o.concat(e&&n[e[1]]&&n[e[1]].transition?$({key:r,value:i[r],valueSpec:s.transition,style:l,styleSpec:s}):n[r]?$({key:r,value:i[r],valueSpec:n[r],style:l,styleSpec:s}):[new E(r,i[r],`unknown property "${r}"`)]);}return o}function H(t){const i=t.value,o=t.key,r=t.style,s=t.styleSpec,n=s.terrain;let a=[];const l=e.i(i);if(void 0===i)return a;if("null"===l)return a;if("object"!==l)return a=a.concat([new T("terrain",i,`object expected, ${l} found`)]),a;for(const e in i){const t=e.match(/^(.*)-transition$/);a=a.concat(t&&n[t[1]]&&n[t[1]].transition?$({key:e,value:i[e],valueSpec:s.transition,style:r,styleSpec:s}):n[e]?$({key:e,value:i[e],valueSpec:n[e],style:r,styleSpec:s}):[new E(e,i[e],`unknown property "${e}"`)]);}if(i.source){const t=r.sources&&r.sources[i.source],s=t&&e.u(t.type);t?"raster-dem"!==s&&a.push(new T(o,i.source,`terrain cannot be used with a source of type ${String(s)}, it only be used with a "raster-dem" source type`)):a.push(new T(o,i.source,`source "${i.source}" not found`));}else a.push(new T(o,i,'terrain is missing required property "source"'));return a}function W(t){const i=t.value,o=t.style,r=t.styleSpec,s=r.fog;let n=[];const a=e.i(i);if(void 0===i)return n;if("object"!==a)return n=n.concat([new T("fog",i,`object expected, ${a} found`)]),n;for(const e in i){const t=e.match(/^(.*)-transition$/);n=n.concat(t&&s[t[1]]&&s[t[1]].transition?$({key:e,value:i[e],valueSpec:r.transition,style:o,styleSpec:r}):s[e]?$({key:e,value:i[e],valueSpec:s[e],style:o,styleSpec:r}):[new E(e,i[e],`unknown property "${e}"`)]);}return n}const q={"*":()=>[],array:C,boolean:function(t){const i=t.value,o=t.key,r=e.i(i);return "boolean"!==r?[new T(o,i,`boolean expected, ${r} found`)]:[]},number:I,color:function(t){const i=t.key,o=t.value,r=e.i(o);return "string"!==r?[new T(i,o,`color expected, ${r} found`)]:null===e.y(o)?[new T(i,o,`color expected, "${o}" found`)]:[]},enum:R,filter:P,function:D,layer:B,object:S,source:U,model:j,light:V,"light-3d":Z,terrain:H,fog:W,string:k,formatted:function(e){return 0===k(e).length?[]:L(e)},resolvedImage:function(e){return 0===k(e).length?[]:L(e)},projection:function(t){const i=t.value,o=t.styleSpec,r=o.projection,s=t.style;let n=[];const a=e.i(i);if("object"===a)for(const e in i)n=n.concat($({key:e,value:i[e],valueSpec:r[e],style:s,styleSpec:o}));else "string"!==a&&(n=n.concat([new T("projection",i,`object or string expected, ${a} found`)]));return n},import:function(t){const{value:i,styleSpec:o}=t,{data:r,...s}=i;Object.defineProperty(s,"__line__",{value:i.__line__,enumerable:!1});let n=S(e.j({},t,{value:s,valueSpec:o.import}));return ""===e.u(s.id)&&n.push(new T(`${t.key}.id`,s,"import id can't be an empty string")),r&&(n=n.concat(K(r,o,{key:`${t.key}.data`}))),n}};function $(t,i=!1){const o=t.value,r=t.valueSpec,s=t.styleSpec;if(r.expression&&e.A(e.u(o)))return D(t);if(r.expression&&e.n(e.o(o)))return L(t);if(r.type&&q[r.type]){const o=q[r.type](t);return !0===i&&o.length>0&&"array"===e.i(t.value)?L(t):o}return S(e.j({},t,{valueSpec:r.type?s[r.type]:r}))}function X(e){const t=e.value,i=e.key,o=k(e);return o.length||(-1===t.indexOf("{fontstack}")&&o.push(new T(i,t,'"glyphs" url must include a "{fontstack}" token')),-1===t.indexOf("{range}")&&o.push(new T(i,t,'"glyphs" url must include a "{range}" token'))),o}function K(t,i=e.D,o={}){return $({key:o.key||"",value:t,valueSpec:i.$root,styleSpec:i,style:t,objectElementValidators:{glyphs:X,"*":()=>[]}})}function Y(t,i=e.D){return le(K(t,i))}const J=e=>le(U(e)),Q=e=>le(V(e)),ee=e=>le(Z(e)),te=e=>le(H(e)),ie=e=>le(W(e)),oe=e=>le(B(e)),re=e=>le(P(e)),se=e=>le(O(e)),ne=e=>le(F(e)),ae=e=>le(j(e));function le(e){return e.slice().sort(((e,t)=>e.line&&t.line?e.line-t.line:0))}function ce(t,i){let o=!1;if(i&&i.length)for(const r of i)r instanceof E?e.w(r.message):(t.fire(new e.a(new Error(r.message))),o=!0);return o}const he=new e.F({anchor:new e.G(e.D.light.anchor),position:new e.H(e.D.light.position),color:new e.G(e.D.light.color),intensity:new e.G(e.D.light.intensity)});class ue extends e.E{constructor(t,i="flat"){super(),this._transitionable=new e.J(he),this.setLight(t,i),this._transitioning=this._transitionable.untransitioned();}getLight(){return this._transitionable.serialize()}setLight(e,t,i={}){this._validate(Q,e,i)||(this._transitionable.setTransitionOrValue(e),this.id=t);}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}_validate(t,i,o){return (!o||!1!==o.validate)&&ce(this,t.call(Y,e.e({value:i,style:{glyphs:!0,sprite:!0},styleSpec:e.D})))}}const de=new e.F({source:new e.G(e.D.terrain.source),exaggeration:new e.G(e.D.terrain.exaggeration)});let _e=class extends e.E{constructor(t,i,o,r){super(),this.scope=o,this._transitionable=new e.J(de,o,r),this._transitionable.setTransitionOrValue(t,r),this._transitioning=this._transitionable.untransitioned(),this.drapeRenderMode=i;}get(){return this._transitionable.serialize()}set(e,t){this._transitionable.setTransitionOrValue(e,t);}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}getExaggeration(t){return this._transitioning.possiblyEvaluate(new e.K(t)).get("exaggeration")}isZoomDependent(){const t=this._transitionable._values.exaggeration;return null!=t&&null!=t.value&&null!=t.value.expression&&t.value.expression instanceof e.Z}};const pe=45,fe=65,me=.05;function ge(t,i,o,r){const s=e.O(pe,fe,o),[n,a]=ve(t,r);let l=1-Math.min(1,Math.exp((i-n)/(a-n)*-6));return l*=l*l,l=Math.min(1,1.00747*l),l*s*t.alpha}function ve(e,t){const i=.5/Math.tan(.5*t);return [e.range[0]+i,e.range[1]+i]}function xe(t,i,o,r,s){const n=e.N.transformMat4([],[i,o,r],s.mercatorFogMatrix);return ge(t,e.N.length(n),s.pitch,s._fov)}function ye(t,i,o,r,s,n,a){const l=[[o,r,0],[s,r,0],[s,n,0],[o,n,0]];let c=Number.MAX_VALUE,h=-Number.MAX_VALUE;for(const t of l){const o=e.N.transformMat4([],t,i),r=e.N.length(o);c=Math.min(c,r),h=Math.max(h,r);}return [ge(t,c,a.pitch,a._fov),ge(t,h,a.pitch,a._fov)]}const be=new e.F({range:new e.G(e.D.fog.range),color:new e.G(e.D.fog.color),"high-color":new e.G(e.D.fog["high-color"]),"space-color":new e.G(e.D.fog["space-color"]),"horizon-blend":new e.G(e.D.fog["horizon-blend"]),"star-intensity":new e.G(e.D.fog["star-intensity"]),"vertical-range":new e.G(e.D.fog["vertical-range"])});class we extends e.E{constructor(t,i,o,r){super(),this._transitionable=new e.J(be,o,new Map(r)),this.set(t,r),this._transitioning=this._transitionable.untransitioned(),this._transform=i,this.properties=new e.Q(be);}get state(){const t=this._transform,i="globe"===t.projection.name,o=e.S(t.zoom),r=this.properties.get("range"),s=[.5,3];return {range:i?[e.U(s[0],r[0],o),e.U(s[1],r[1],o)]:r,horizonBlend:this.properties.get("horizon-blend"),alpha:this.properties.get("color").a}}get(){return this._transitionable.serialize()}set(t,i,o={}){if(this._validate(ie,t,o))return;const r=e.e({},t);for(const t of Object.keys(e.D.fog))void 0===r[t]&&(r[t]=e.D.fog[t].default);this._options=r,this._transitionable.setTransitionOrValue(this._options,i);}getOpacity(t){if(!this._transform.projection.supportsFog)return 0;const i=this.properties&&this.properties.get("color")||1;return ("globe"===this._transform.projection.name?1:e.O(pe,fe,t))*i.a}getOpacityAtLatLng(t,i){return this._transform.projection.supportsFog?function(t,i,o){const r=e.L.fromLngLat(i),s=o.elevation?o.elevation.getAtPointOrZero(r):0;return xe(t,r.x,r.y,s,o)}(this.state,t,i):0}getOpacityForTile(t){if(!this._transform.projection.supportsFog)return [1,1];const i=this._transform.calculateFogTileMatrix(t.toUnwrapped());return ye(this.state,i,0,0,e.V,e.V,this._transform)}getOpacityForBounds(e,t,i,o,r){return this._transform.projection.supportsFog?ye(this.state,e,t,i,o,r,this._transform):[1,1]}getFovAdjustedRange(e){return this._transform.projection.supportsFog?ve(this.state,e):[0,1]}isVisibleOnFrustum(t){if(!this._transform.projection.supportsFog)return !1;const i=[4,5,6,7];for(const o of i){const i=t.points[o];let r;if(i[2]>=0)r=i;else {const s=t.points[o-4];r=e.W(s,i,s[2]/(s[2]-i[2]));}if(xe(this.state,r[0],r[1],0,this._transform)>=me)return !0}return !1}updateConfig(e){this._transitionable.setTransitionOrValue(this._options,new Map(e));}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}_validate(t,i,o){return (!o||!1!==o.validate)&&ce(this,t.call(Y,e.e({value:i,style:{glyphs:!0,sprite:!0},styleSpec:e.D})))}}class Te extends e.E{constructor(t,i,o,r){super(),this.scope=o,this._options=t,this.properties=new e.Q(i),this._transitionable=new e.J(i,o,new Map(r)),this._transitionable.setTransitionOrValue(t.properties),this._transitioning=this._transitionable.untransitioned();}updateConfig(e){this._transitionable.setTransitionOrValue(this._options.properties,new Map(e));}updateTransitions(e){this._transitioning=this._transitionable.transitioned(e,this._transitioning);}hasTransition(){return this._transitioning.hasTransition()}recalculate(e){this.properties=this._transitioning.possiblyEvaluate(e);}get(){return this._options.properties=this._transitionable.serialize(),this._options}set(e,t){this._options=e,this._transitionable.setTransitionOrValue(e.properties,t);}shadowsEnabled(){return !!this.properties&&!0===this.properties.get("cast-shadows")}}const Ee=new e.F({color:new e.G(e.D.properties_light_ambient.color),intensity:new e.G(e.D.properties_light_ambient.intensity)}),Se=new e.F({direction:new e.X(e.D.properties_light_directional.direction),color:new e.G(e.D.properties_light_directional.color),intensity:new e.G(e.D.properties_light_directional.intensity),"cast-shadows":new e.G(e.D.properties_light_directional["cast-shadows"]),"shadow-intensity":new e.G(e.D.properties_light_directional["shadow-intensity"])});class Ce{constructor(e,t,i,o){this.screenBounds=e,this.cameraPoint=t,this._screenRaycastCache={},this._cameraRaycastCache={},this.isAboveHorizon=i,this.screenGeometry=this.bufferedScreenGeometry(0),this.screenGeometryMercator=this._bufferedScreenMercator(0,o);}static createFromScreenPoints(t,i){let o,r;if(t instanceof e.P||"number"==typeof t[0]){const s=e.P.convert(t);o=[s],r=i.isPointAboveHorizon(s);}else {const s=e.P.convert(t[0]),n=e.P.convert(t[1]);o=[s,n],r=e.Y(s,n).every((e=>i.isPointAboveHorizon(e)));}return new Ce(o,i.getCameraPoint(),r,i)}isPointQuery(){return 1===this.screenBounds.length}bufferedScreenGeometry(t){return e.Y(this.screenBounds[0],1===this.screenBounds.length?this.screenBounds[0]:this.screenBounds[1],t)}bufferedCameraGeometry(t){const i=this.screenBounds[0],o=1===this.screenBounds.length?this.screenBounds[0].add(new e.P(1,1)):this.screenBounds[1],r=e.Y(i,o,0,!1);return this.cameraPoint.y>o.y&&(this.cameraPoint.x>i.x&&this.cameraPoint.x<o.x?r.splice(3,0,this.cameraPoint):this.cameraPoint.x>=o.x?r[2]=this.cameraPoint:this.cameraPoint.x<=i.x&&(r[3]=this.cameraPoint)),e._(r,t)}bufferedCameraGeometryGlobe(t){const i=this.screenBounds[0],o=1===this.screenBounds.length?this.screenBounds[0].add(new e.P(1,1)):this.screenBounds[1],r=e.Y(i,o,t),s=this.cameraPoint.clone();switch(3*((s.y>i.y)+(s.y>o.y))+((s.x>i.x)+(s.x>o.x))){case 0:r[0]=s,r[4]=s.clone();break;case 1:r.splice(1,0,s);break;case 2:r[1]=s;break;case 3:r.splice(4,0,s);break;case 5:r.splice(2,0,s);break;case 6:r[3]=s;break;case 7:r.splice(3,0,s);break;case 8:r[2]=s;}return r}containsTile(t,i,o,r=0){const s=t.queryPadding/i._pixelsPerMercatorPixel+1,n=o?this._bufferedCameraMercator(s,i):this._bufferedScreenMercator(s,i);let a=t.tileID.wrap+(n.unwrapped?r:0);const l=n.polygon.map((i=>e.$(t.tileTransform,i,a)));if(!e.a0(l,0,0,e.V,e.V))return;a=t.tileID.wrap+(this.screenGeometryMercator.unwrapped?r:0);const c=this.screenGeometryMercator.polygon.map((i=>e.a1(t.tileTransform,i,a))),h=c.map((t=>new e.P(t[0],t[1]))),u=i.getFreeCameraOptions().position||new e.L(0,0,0),d=e.a1(t.tileTransform,u,a),_=c.map((t=>{const i=e.N.sub(t,t,d);return e.N.normalize(i,i),new e.a2(d,i)})),p=e.a3(t,1,i.zoom)*i._pixelsPerMercatorPixel;return {queryGeometry:this,tilespaceGeometry:h,tilespaceRays:_,bufferedTilespaceGeometry:l,bufferedTilespaceBounds:(f=e.a4(l),f.min.x=e.aa(f.min.x,0,e.V),f.min.y=e.aa(f.min.y,0,e.V),f.max.x=e.aa(f.max.x,0,e.V),f.max.y=e.aa(f.max.y,0,e.V),f),tile:t,tileID:t.tileID,pixelToTileUnitsFactor:p};var f;}_bufferedScreenMercator(e,t){const i=Le(e);if(this._screenRaycastCache[i])return this._screenRaycastCache[i];{let o;return o="globe"===t.projection.name?this._projectAndResample(this.bufferedScreenGeometry(e),t):{polygon:this.bufferedScreenGeometry(e).map((e=>t.pointCoordinate3D(e))),unwrapped:!0},this._screenRaycastCache[i]=o,o}}_bufferedCameraMercator(e,t){const i=Le(e);if(this._cameraRaycastCache[i])return this._cameraRaycastCache[i];{let o;return o="globe"===t.projection.name?this._projectAndResample(this.bufferedCameraGeometryGlobe(e),t):{polygon:this.bufferedCameraGeometry(e).map((e=>t.pointCoordinate3D(e))),unwrapped:!0},this._cameraRaycastCache[i]=o,o}}_projectAndResample(t,i){const o=function(t,i){const o=e.a6.multiply([],i.pixelMatrix,i.globeMatrix),r=[0,-e.ab,0,1],s=[0,e.ab,0,1],n=[0,0,0,1];e.a7.transformMat4(r,r,o),e.a7.transformMat4(s,s,o),e.a7.transformMat4(n,n,o);const a=new e.P(r[0]/r[3],r[1]/r[3]),l=new e.P(s[0]/s[3],s[1]/s[3]),c=e.a8(t,a)&&r[3]<n[3],h=e.a8(t,l)&&s[3]<n[3];if(!c&&!h)return null;const u=function(e,t,i){for(let o=1;o<e.length;o++){const r=De(t.pointCoordinate3D(e[o-1]).x),s=De(t.pointCoordinate3D(e[o]).x);if(i<0){if(r<s)return {idx:o,t:-r/(s-1-r)}}else if(s<r)return {idx:o,t:(1-r)/(s+1-r)}}return null}(t,i,c?-1:1);if(!u)return null;const{idx:d,t:_}=u;let p=d>1?Ie(t.slice(0,d),i):[],f=d<t.length?Ie(t.slice(d),i):[];p=p.map((t=>new e.P(De(t.x),t.y))),f=f.map((t=>new e.P(De(t.x),t.y)));const m=[...p];0===m.length&&m.push(f[f.length-1]);const g=e.U(m[m.length-1].y,(0===f.length?p[0]:f[0]).y,_);let v;return v=c?[new e.P(0,g),new e.P(0,0),new e.P(1,0),new e.P(1,g)]:[new e.P(1,g),new e.P(1,1),new e.P(0,1),new e.P(0,g)],m.push(...v),0===f.length?m.push(p[0]):m.push(...f),{polygon:m.map((t=>new e.L(t.x,t.y))),unwrapped:!1}}(t,i);if(o)return o;const r=function(t,i){let o=!1,r=-1/0,s=0;for(let e=0;e<t.length-1;e++)t[e].x>r&&(r=t[e].x,s=e);for(let e=0;e<t.length-1;e++){const i=(s+e)%(t.length-1),r=t[i],n=t[i+1];Math.abs(r.x-n.x)>.5&&(r.x<n.x?(r.x+=1,0===i&&(t[t.length-1].x+=1)):(n.x+=1,i+1===t.length-1&&(t[0].x+=1)),o=!0);}const n=e.a5(i.center.lng);return o&&n<Math.abs(n-1)&&t.forEach((e=>{e.x-=1;})),{polygon:t,unwrapped:o}}(Ie(t,i).map((t=>new e.P(De(t.x),t.y))),i);return {polygon:r.polygon.map((t=>new e.L(t.x,t.y))),unwrapped:r.unwrapped}}}function Ie(t,i){return e.a9(t,(e=>{const t=i.pointCoordinate3D(e);e.x=t.x,e.y=t.y;}),1/256)}function De(e){return e<0?1+e%1:e%1}function Le(e){return 100*e|0}function Ae(t,i,o,r,s){const n=function(o,r){if(o)return s(o);if(r){t.url&&r.tiles&&t.tiles&&delete t.tiles;const o=e.ac(e.e(r,t),["tiles","minzoom","maxzoom","attribution","mapbox_logo","bounds","scheme","tileSize","encoding"]);r.vector_layers&&(o.vectorLayers=r.vector_layers,o.vectorLayerIds=o.vectorLayers.map((e=>e.id))),r.raster_layers&&(o.rasterLayers=r.raster_layers,o.rasterLayerIds=o.rasterLayers.map((e=>e.id))),o.tiles=i.canonicalizeTileset(o,t.url),s(null,o);}};return t.url?e.g(i.transformRequest(i.normalizeSourceURL(t.url,null,o,r),e.R.Source),n):e.f.frame((()=>n(null,t)))}class Re{constructor(t,i,o){this.bounds=e.ad.convert(this.validateBounds(t)),this.minzoom=i||0,this.maxzoom=o||24;}validateBounds(e){return Array.isArray(e)&&4===e.length?[Math.max(-180,e[0]),Math.max(-90,e[1]),Math.min(180,e[2]),Math.min(90,e[3])]:[-180,-90,180,90]}contains(t){const i=Math.pow(2,t.z),o=Math.floor(e.a5(this.bounds.getWest())*i),r=Math.floor(e.ae(this.bounds.getNorth())*i),s=Math.ceil(e.a5(this.bounds.getEast())*i),n=Math.ceil(e.ae(this.bounds.getSouth())*i);return t.x>=o&&t.x<s&&t.y>=r&&t.y<n}}class Pe extends e.E{constructor(t,i,o,r){if(super(),this.id=t,this.dispatcher=o,this.type="vector",this.minzoom=0,this.maxzoom=22,this.scheme="xyz",this.tileSize=512,this.reparseOverscaled=!0,this.isTileClipped=!0,this._loaded=!1,e.e(this,e.ac(i,["url","scheme","tileSize","promoteId"])),this._options=e.e({type:"vector"},i),this._collectResourceTiming=!!i.collectResourceTiming,512!==this.tileSize)throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(r),this._tileWorkers={},this._deduped=new e.af;}load(t){this._loaded=!1,this.fire(new e.b("dataloading",{dataType:"source"}));const i=Array.isArray(this.map._language)?this.map._language.join():this.map._language,o=this.map._worldview;this._tileJSONRequest=Ae(this._options,this.map._requestManager,i,o,((r,s)=>{this._tileJSONRequest=null,this._loaded=!0,r?(i&&console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`),o&&2!==o.length&&console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`),this.fire(new e.a(r))):s&&(e.e(this,s),s.bounds&&(this.tileBounds=new Re(s.bounds,this.minzoom,this.maxzoom)),e.aj(s.tiles,this.map._requestManager._customAccessToken),this.fire(new e.b("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.b("data",{dataType:"source",sourceDataType:"content"}))),t&&t(r);}));}loaded(){return this._loaded}hasTile(e){return !this.tileBounds||this.tileBounds.contains(e.canonical)}onAdd(e){this.map=e,this.load();}reload(){this.cancelTileJSONRequest();const t=e.ag(this.id,this.scope);this.load((()=>this.map.style.clearSource(t)));}setTiles(e){return this._options.tiles=e,this.reload(),this}setUrl(e){return this.url=e,this._options.url=e,this.reload(),this}onRemove(){this.cancelTileJSONRequest();}serialize(){return e.e({},this._options)}loadTile(t,i){const o=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme)),r={request:this.map._requestManager.transformRequest(o,e.R.Tile),data:void 0,uid:t.uid,tileID:t.tileID,tileZoom:t.tileZoom,zoom:t.tileID.overscaledZ,tileSize:this.tileSize*t.tileID.overscaleFactor(),type:this.type,source:this.id,scope:this.scope,pixelRatio:e.f.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId,isSymbolTile:t.isSymbolTile,brightness:this.map.style&&this.map.style.getBrightness()||0,extraShadowCaster:t.isExtraShadowCaster};if(r.request.collectResourceTiming=this._collectResourceTiming,t.actor&&"expired"!==t.state)"loading"===t.state?t.reloadCallback=i:t.request=t.actor.send("reloadTile",r,s.bind(this));else if(t.actor=this._tileWorkers[o]=this._tileWorkers[o]||this.dispatcher.getActor(),this.dispatcher.ready)t.request=t.actor.send("loadTile",r,s.bind(this),void 0,!0);else {const i=e.ah.call({deduped:this._deduped},r,((e,i)=>{e||!i?s.call(this,e):(r.data={cacheControl:i.cacheControl,expires:i.expires,rawData:i.rawData.slice(0)},t.actor&&t.actor.send("loadTile",r,s.bind(this),void 0,!0));}),!0);t.request={cancel:i};}function s(o,r){return delete t.request,t.aborted?i(null):o&&404!==o.status?i(o):(r&&r.resourceTiming&&(t.resourceTiming=r.resourceTiming),this.map._refreshExpiredTiles&&r&&t.setExpiryData(r),t.loadVectorData(r,this.map.painter),e.ai(this.dispatcher),i(null),void(t.reloadCallback&&(this.loadTile(t,t.reloadCallback),t.reloadCallback=null)))}}abortTile(e){e.request&&(e.request.cancel(),delete e.request),e.actor&&e.actor.send("abortTile",{uid:e.uid,type:this.type,source:this.id,scope:this.scope});}unloadTile(e){e.actor&&e.actor.send("removeTile",{uid:e.uid,type:this.type,source:this.id,scope:this.scope}),e.destroy();}hasTransition(){return !1}afterUpdate(){this._tileWorkers={};}cancelTileJSONRequest(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);}}class Me extends e.E{constructor(t,i,o,r){super(),this.id=t,this.dispatcher=o,this.setEventedParent(r),this.type="raster",this.minzoom=0,this.maxzoom=22,this.roundZoom=!0,this.scheme="xyz",this.tileSize=512,this._loaded=!1,this._options=e.e({type:"raster"},i),e.e(this,e.ac(i,["url","scheme","tileSize"]));}load(t){this._loaded=!1,this.fire(new e.b("dataloading",{dataType:"source"})),this._tileJSONRequest=Ae(this._options,this.map._requestManager,null,null,((i,o)=>{this._tileJSONRequest=null,this._loaded=!0,i?this.fire(new e.a(i)):o&&(e.e(this,o),o.bounds&&(this.tileBounds=new Re(o.bounds,this.minzoom,this.maxzoom)),e.aj(o.tiles),this.fire(new e.b("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.b("data",{dataType:"source",sourceDataType:"content"}))),t&&t(i);}));}loaded(){return this._loaded}onAdd(e){this.map=e,this.load();}reload(){this.cancelTileJSONRequest();const t=e.ag(this.id,this.scope);this.load((()=>this.map.style.clearSource(t)));}setTiles(e){return this._options.tiles=e,this.reload(),this}setUrl(e){return this.url=e,this._options.url=e,this.reload(),this}onRemove(){this.cancelTileJSONRequest();}serialize(){return e.e({},this._options)}hasTile(e){return !this.tileBounds||this.tileBounds.contains(e.canonical)}loadTile(t,i){const o=e.f.devicePixelRatio>=2,r=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme),o,this.tileSize);t.request=e.d(this.map._requestManager.transformRequest(r,e.R.Tile),((o,r,s,n)=>(delete t.request,t.aborted?(t.state="unloaded",i(null)):o?(t.state="errored",i(o)):r?(this.map._refreshExpiredTiles&&t.setExpiryData({cacheControl:s,expires:n}),t.setTexture(r,this.map.painter),t.state="loaded",e.ai(this.dispatcher),void i(null)):i(null))));}abortTile(e,t){e.request&&(e.request.cancel(),delete e.request),t();}unloadTile(t,i){t.texture&&t.texture instanceof e.T?(t.destroy(!0),t.texture&&t.texture instanceof e.T&&this.map.painter.saveTileTexture(t.texture)):t.destroy(),i();}hasTransition(){return !1}cancelTileJSONRequest(){this._tileJSONRequest&&(this._tileJSONRequest.cancel(),this._tileJSONRequest=null);}}class ze extends Me{constructor(t,i,o,r){super(t,i,o,r),this.type="raster-array",this.maxzoom=22,this._options=e.e({type:"raster-array"},i);}triggerRepaint(e){const t=this.map.painter._terrain,i=this.map.style.getSourceCache(this.id);t&&t.enabled&&i&&t._clearRenderCacheForTile(i.id,e.tileID),this.map.triggerRepaint();}loadTile(t,i){const o=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme),!1,this.tileSize),r=this.map._requestManager.transformRequest(o,e.R.Tile);t.requestParams=r,t.actor||(t.actor=this.dispatcher.getActor()),t.request=t.fetchHeader(void 0,((e,o,r,s)=>{if(delete t.request,t.aborted)return t.state="unloaded",i(null);if(e){if(20===e.code)return;return t.state="errored",i(e)}this.map._refreshExpiredTiles&&t.setExpiryData({cacheControl:r,expires:s}),t.state="empty",i(null);}));}unloadTile(t){const i=t.texture;i&&i instanceof e.T?(t.destroy(!0),this.map.painter.saveTileTexture(i)):(t.destroy(),t.flushQueues(),t._isHeaderLoaded=!1,delete t._mrt,delete t.textureDescriptor),t.fbo&&(t.fbo.destroy(),delete t.fbo),delete t.request,delete t.requestParams,delete t.neighboringTiles,t.state="unloaded";}prepareTile(t,i,o){t._isHeaderLoaded&&("empty"!==t.state&&(t.state="reloading"),t.fetchBand(i,o,((i,o)=>{if(i)return t.state="errored",this.fire(new e.a(i)),void this.triggerRepaint(t);o&&(t.setTexture(o,this.map.painter),t.state="loaded",this.triggerRepaint(t));})));}getInitialBand(e){if(!this.rasterLayers)return 0;const t=this.rasterLayers.find((({id:t})=>t===e)),i=t&&t.fields,o=i&&i.bands&&i.bands;return o?o[0]:0}getTextureDescriptor(t,i,o){if(!t)return;const r=i.sourceLayer||this.rasterLayerIds&&this.rasterLayerIds[0];if(!r)return;let s=null;i instanceof e.an?s=i.paint.get("raster-array-band"):i instanceof e.ao&&(s=i.paint.get("raster-particle-array-band"));const n=s||this.getInitialBand(r);if(null!=n)if(t.textureDescriptor){if(!t.updateNeeded(r,n)||o)return Object.assign({},t.textureDescriptor,{texture:t.texture})}else this.prepareTile(t,r,n);}}const Oe=32,Fe=33,Be=new Uint16Array(8184);for(let e=0;e<2046;e++){let t=e+2,i=0,o=0,r=0,s=0,n=0,a=0;for(1&t?r=s=n=Oe:i=o=a=Oe;(t>>=1)>1;){const e=i+r>>1,l=o+s>>1;1&t?(r=i,s=o,i=n,o=a):(i=r,o=s,r=n,s=a),n=e,a=l;}const l=4*e;Be[l+0]=i,Be[l+1]=o,Be[l+2]=r,Be[l+3]=s;}const ke=new Uint16Array(2178),Ne=new Uint8Array(1089),Ue=new Uint16Array(1089);function Ge(e){return 0===e?-.03125:32===e?.03125:0}class je{constructor(e,t,i,o){this.id=je.uniqueIdxCounter,je.uniqueIdxCounter++,this.context=e;const r=e.gl;this.buffer=r.createBuffer(),this.dynamicDraw=Boolean(i),this.context.unbindVAO(),e.bindElementBuffer.set(this.buffer),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t.arrayBuffer,this.dynamicDraw?r.DYNAMIC_DRAW:r.STATIC_DRAW),this.dynamicDraw||o||t.destroy();}bind(){this.context.bindElementBuffer.set(this.buffer);}updateData(e){this.id=je.uniqueIdxCounter,je.uniqueIdxCounter++;const t=this.context.gl;this.context.unbindVAO(),this.bind(),t.bufferSubData(t.ELEMENT_ARRAY_BUFFER,0,e.arrayBuffer);}destroy(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);}}je.uniqueIdxCounter=0;const Ve={Int8:"BYTE",Uint8:"UNSIGNED_BYTE",Int16:"SHORT",Uint16:"UNSIGNED_SHORT",Int32:"INT",Uint32:"UNSIGNED_INT",Float32:"FLOAT"};class Ze{constructor(e,t,i,o,r,s){this.length=t.length,this.attributes=i,this.itemSize=t.bytesPerElement,this.dynamicDraw=o,this.instanceCount=s,this.context=e;const n=e.gl;this.buffer=n.createBuffer(),e.bindVertexBuffer.set(this.buffer),n.bufferData(n.ARRAY_BUFFER,t.arrayBuffer,this.dynamicDraw?n.DYNAMIC_DRAW:n.STATIC_DRAW),this.dynamicDraw||r||t.destroy();}bind(){this.context.bindVertexBuffer.set(this.buffer);}updateData(e){const t=this.context.gl;this.bind(),t.bufferSubData(t.ARRAY_BUFFER,0,e.arrayBuffer);}enableAttributes(e,t){for(let i=0;i<this.attributes.length;i++){const o=t.attributes[this.attributes[i].name];void 0!==o&&e.enableVertexAttribArray(o);}}setVertexAttribPointers(e,t,i){for(let o=0;o<this.attributes.length;o++){const r=this.attributes[o],s=t.attributes[r.name];void 0!==s&&e.vertexAttribPointer(s,r.components,e[Ve[r.type]],!1,this.itemSize,r.offset+this.itemSize*(i||0));}}setVertexAttribDivisor(e,t,i){for(let o=0;o<this.attributes.length;o++){const r=t.attributes[this.attributes[o].name];void 0!==r&&this.instanceCount&&this.instanceCount>0&&e.vertexAttribDivisor(r,i);}}destroy(){this.buffer&&(this.context.gl.deleteBuffer(this.buffer),delete this.buffer);}}class He{constructor(e){this.gl=e.gl,this.default=this.getDefault(),this.current=this.default,this.dirty=!1;}get(){return this.current}set(e){}getDefault(){return this.default}setDefault(){this.set(this.default);}}class We extends He{getDefault(){return e.ax.transparent}set(e){const t=this.current;(e.r!==t.r||e.g!==t.g||e.b!==t.b||e.a!==t.a||this.dirty)&&(this.gl.clearColor(e.r,e.g,e.b,e.a),this.current=e,this.dirty=!1);}}class qe extends He{getDefault(){return 1}set(e){(e!==this.current||this.dirty)&&(this.gl.clearDepth(e),this.current=e,this.dirty=!1);}}class $e extends He{getDefault(){return 0}set(e){(e!==this.current||this.dirty)&&(this.gl.clearStencil(e),this.current=e,this.dirty=!1);}}class Xe extends He{getDefault(){return [!0,!0,!0,!0]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||e[3]!==t[3]||this.dirty)&&(this.gl.colorMask(e[0],e[1],e[2],e[3]),this.current=e,this.dirty=!1);}}class Ke extends He{getDefault(){return !0}set(e){(e!==this.current||this.dirty)&&(this.gl.depthMask(e),this.current=e,this.dirty=!1);}}class Ye extends He{getDefault(){return 255}set(e){(e!==this.current||this.dirty)&&(this.gl.stencilMask(e),this.current=e,this.dirty=!1);}}class Je extends He{getDefault(){return {func:this.gl.ALWAYS,ref:0,mask:255}}set(e){const t=this.current;(e.func!==t.func||e.ref!==t.ref||e.mask!==t.mask||this.dirty)&&(this.gl.stencilFunc(e.func,e.ref,e.mask),this.current=e,this.dirty=!1);}}class Qe extends He{getDefault(){const e=this.gl;return [e.KEEP,e.KEEP,e.KEEP]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||this.dirty)&&(this.gl.stencilOp(e[0],e[1],e[2]),this.current=e,this.dirty=!1);}}class et extends He{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.STENCIL_TEST):t.disable(t.STENCIL_TEST),this.current=e,this.dirty=!1;}}class tt extends He{getDefault(){return [0,1]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||this.dirty)&&(this.gl.depthRange(e[0],e[1]),this.current=e,this.dirty=!1);}}class it extends He{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.DEPTH_TEST):t.disable(t.DEPTH_TEST),this.current=e,this.dirty=!1;}}class ot extends He{getDefault(){return this.gl.LESS}set(e){(e!==this.current||this.dirty)&&(this.gl.depthFunc(e),this.current=e,this.dirty=!1);}}class rt extends He{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.BLEND):t.disable(t.BLEND),this.current=e,this.dirty=!1;}}class st extends He{getDefault(){const e=this.gl;return [e.ONE,e.ZERO,e.ONE,e.ZERO]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||e[3]!==t[3]||this.dirty)&&(this.gl.blendFuncSeparate(e[0],e[1],e[2],e[3]),this.current=e,this.dirty=!1);}}class nt extends He{getDefault(){return e.ax.transparent}set(e){const t=this.current;(e.r!==t.r||e.g!==t.g||e.b!==t.b||e.a!==t.a||this.dirty)&&(this.gl.blendColor(e.r,e.g,e.b,e.a),this.current=e,this.dirty=!1);}}class at extends He{getDefault(){return this.gl.FUNC_ADD}set(e){(e!==this.current||this.dirty)&&(this.gl.blendEquationSeparate(e,e),this.current=e,this.dirty=!1);}}class lt extends He{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;e?t.enable(t.CULL_FACE):t.disable(t.CULL_FACE),this.current=e,this.dirty=!1;}}class ct extends He{getDefault(){return this.gl.BACK}set(e){(e!==this.current||this.dirty)&&(this.gl.cullFace(e),this.current=e,this.dirty=!1);}}class ht extends He{getDefault(){return this.gl.CCW}set(e){(e!==this.current||this.dirty)&&(this.gl.frontFace(e),this.current=e,this.dirty=!1);}}let ut=class extends He{getDefault(){return null}set(e){(e!==this.current||this.dirty)&&(this.gl.useProgram(e),this.current=e,this.dirty=!1);}};class dt extends He{getDefault(){return this.gl.TEXTURE0}set(e){(e!==this.current||this.dirty)&&(this.gl.activeTexture(e),this.current=e,this.dirty=!1);}}class _t extends He{getDefault(){const e=this.gl;return [0,0,e.drawingBufferWidth,e.drawingBufferHeight]}set(e){const t=this.current;(e[0]!==t[0]||e[1]!==t[1]||e[2]!==t[2]||e[3]!==t[3]||this.dirty)&&(this.gl.viewport(e[0],e[1],e[2],e[3]),this.current=e,this.dirty=!1);}}class pt extends He{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e),this.current=e,this.dirty=!1;}}class ft extends He{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindRenderbuffer(t.RENDERBUFFER,e),this.current=e,this.dirty=!1;}}class mt extends He{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindTexture(t.TEXTURE_2D,e),this.current=e,this.dirty=!1;}}class gt extends He{getDefault(){return null}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,e),this.current=e,this.dirty=!1;}}class vt extends He{getDefault(){return null}set(e){const t=this.gl;t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e),this.current=e,this.dirty=!1;}}class xt extends He{getDefault(){return null}set(e){this.gl&&(e!==this.current||this.dirty)&&(this.gl.bindVertexArray(e),this.current=e,this.dirty=!1);}}class yt extends He{getDefault(){return 4}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.pixelStorei(t.UNPACK_ALIGNMENT,e),this.current=e,this.dirty=!1;}}class bt extends He{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e),this.current=e,this.dirty=!1;}}class wt extends He{getDefault(){return !1}set(e){if(e===this.current&&!this.dirty)return;const t=this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,e),this.current=e,this.dirty=!1;}}class Tt extends He{constructor(e,t){super(e),this.context=e,this.parent=t;}getDefault(){return null}}class Et extends Tt{setDirty(){this.dirty=!0;}set(e){if(e===this.current&&!this.dirty)return;this.context.bindFramebuffer.set(this.parent);const t=this.gl;t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),this.current=e,this.dirty=!1;}}class St extends Tt{attachment(){return this.gl.DEPTH_ATTACHMENT}set(e){if(e===this.current&&!this.dirty)return;this.context.bindFramebuffer.set(this.parent);const t=this.gl;t.framebufferRenderbuffer(t.FRAMEBUFFER,this.attachment(),t.RENDERBUFFER,e),this.current=e,this.dirty=!1;}}class Ct extends Tt{attachment(){return this.gl.DEPTH_ATTACHMENT}set(e){if(e===this.current&&!this.dirty)return;this.context.bindFramebuffer.set(this.parent);const t=this.gl;t.framebufferTexture2D(t.FRAMEBUFFER,this.attachment(),t.TEXTURE_2D,e,0),this.current=e,this.dirty=!1;}}class It extends St{attachment(){return this.gl.DEPTH_STENCIL_ATTACHMENT}}class Dt{constructor(e,t,i,o,r){this.context=e,this.width=t,this.height=i;const s=this.framebuffer=e.gl.createFramebuffer();o&&(this.colorAttachment=new Et(e,s)),r&&(this.depthAttachmentType=r,this.depthAttachment="renderbuffer"===r?new St(e,s):new Ct(e,s));}destroy(){const e=this.context.gl;if(this.colorAttachment){const t=this.colorAttachment.get();t&&e.deleteTexture(t);}if(this.depthAttachment&&this.depthAttachmentType)if("renderbuffer"===this.depthAttachmentType){const t=this.depthAttachment.get();t&&e.deleteRenderbuffer(t);}else {const t=this.depthAttachment.get();t&&e.deleteTexture(t);}e.deleteFramebuffer(this.framebuffer);}}class Lt{constructor(e,t,i){this.func=e,this.mask=t,this.range=i;}}Lt.ReadOnly=!1,Lt.ReadWrite=!0,Lt.disabled=new Lt(519,Lt.ReadOnly,[0,1]);const At=7680;class Rt{constructor(e,t,i,o,r,s){this.test=e,this.ref=t,this.mask=i,this.fail=o,this.depthFail=r,this.pass=s;}}Rt.disabled=new Rt({func:519,mask:0},0,0,At,At,At);const Pt=771;class Mt{constructor(e,t,i,o){this.blendFunction=e,this.blendColor=t,this.mask=i,this.blendEquation=o;}}Mt.Replace=[1,0,1,0],Mt.disabled=new Mt(Mt.Replace,e.ax.transparent,[!1,!1,!1,!1]),Mt.unblended=new Mt(Mt.Replace,e.ax.transparent,[!0,!0,!0,!0]),Mt.alphaBlended=new Mt([1,Pt,1,Pt],e.ax.transparent,[!0,!0,!0,!0]),Mt.multiply=new Mt([774,0,774,0],e.ax.transparent,[!0,!0,!0,!0]);const zt=1029,Ot=2305;class Ft{constructor(e,t,i){this.enable=e,this.mode=t,this.frontFace=i;}}Ft.disabled=new Ft(!1,zt,Ot),Ft.backCCW=new Ft(!0,zt,Ot),Ft.backCW=new Ft(!0,zt,2304),Ft.frontCW=new Ft(!0,1028,2304),Ft.frontCCW=new Ft(!0,1028,Ot);class Bt{constructor(e,t){this.gl=e,this.clearColor=new We(this),this.clearDepth=new qe(this),this.clearStencil=new $e(this),this.colorMask=new Xe(this),this.depthMask=new Ke(this),this.stencilMask=new Ye(this),this.stencilFunc=new Je(this),this.stencilOp=new Qe(this),this.stencilTest=new et(this),this.depthRange=new tt(this),this.depthTest=new it(this),this.depthFunc=new ot(this),this.blend=new rt(this),this.blendFunc=new st(this),this.blendColor=new nt(this),this.blendEquation=new at(this),this.cullFace=new lt(this),this.cullFaceSide=new ct(this),this.frontFace=new ht(this),this.program=new ut(this),this.activeTexture=new dt(this),this.viewport=new _t(this),this.bindFramebuffer=new pt(this),this.bindRenderbuffer=new ft(this),this.bindTexture=new mt(this),this.bindVertexBuffer=new gt(this),this.bindElementBuffer=new vt(this),this.bindVertexArrayOES=new xt(this),this.pixelStoreUnpack=new yt(this),this.pixelStoreUnpackPremultiplyAlpha=new bt(this),this.pixelStoreUnpackFlipY=new wt(this),this.options=t?{...t}:{},this.options.extTextureFilterAnisotropicForceOff||(this.extTextureFilterAnisotropic=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),this.extTextureFilterAnisotropic&&(this.extTextureFilterAnisotropicMax=e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))),this.extDebugRendererInfo=e.getExtension("WEBGL_debug_renderer_info"),this.extDebugRendererInfo&&(this.renderer=e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL),this.vendor=e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)),this.options.extTextureFloatLinearForceOff||(this.extTextureFloatLinear=e.getExtension("OES_texture_float_linear")),this.extRenderToTextureHalfFloat=e.getExtension("EXT_color_buffer_half_float"),this.extTimerQuery=e.getExtension("EXT_disjoint_timer_query_webgl2"),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxPointSize=e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];}setDefault(){this.unbindVAO(),this.clearColor.setDefault(),this.clearDepth.setDefault(),this.clearStencil.setDefault(),this.colorMask.setDefault(),this.depthMask.setDefault(),this.stencilMask.setDefault(),this.stencilFunc.setDefault(),this.stencilOp.setDefault(),this.stencilTest.setDefault(),this.depthRange.setDefault(),this.depthTest.setDefault(),this.depthFunc.setDefault(),this.blend.setDefault(),this.blendFunc.setDefault(),this.blendColor.setDefault(),this.blendEquation.setDefault(),this.cullFace.setDefault(),this.cullFaceSide.setDefault(),this.frontFace.setDefault(),this.program.setDefault(),this.activeTexture.setDefault(),this.bindFramebuffer.setDefault(),this.pixelStoreUnpack.setDefault(),this.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.pixelStoreUnpackFlipY.setDefault();}setDirty(){this.clearColor.dirty=!0,this.clearDepth.dirty=!0,this.clearStencil.dirty=!0,this.colorMask.dirty=!0,this.depthMask.dirty=!0,this.stencilMask.dirty=!0,this.stencilFunc.dirty=!0,this.stencilOp.dirty=!0,this.stencilTest.dirty=!0,this.depthRange.dirty=!0,this.depthTest.dirty=!0,this.depthFunc.dirty=!0,this.blend.dirty=!0,this.blendFunc.dirty=!0,this.blendColor.dirty=!0,this.blendEquation.dirty=!0,this.cullFace.dirty=!0,this.cullFaceSide.dirty=!0,this.frontFace.dirty=!0,this.program.dirty=!0,this.activeTexture.dirty=!0,this.viewport.dirty=!0,this.bindFramebuffer.dirty=!0,this.bindRenderbuffer.dirty=!0,this.bindTexture.dirty=!0,this.bindVertexBuffer.dirty=!0,this.bindElementBuffer.dirty=!0,this.bindVertexArrayOES.dirty=!0,this.pixelStoreUnpack.dirty=!0,this.pixelStoreUnpackPremultiplyAlpha.dirty=!0,this.pixelStoreUnpackFlipY.dirty=!0;}createIndexBuffer(e,t,i){return new je(this,e,t,i)}createVertexBuffer(e,t,i,o,r){return new Ze(this,e,t,i,o,r)}createRenderbuffer(e,t,i){const o=this.gl,r=o.createRenderbuffer();return this.bindRenderbuffer.set(r),o.renderbufferStorage(o.RENDERBUFFER,e,t,i),this.bindRenderbuffer.set(null),r}createFramebuffer(e,t,i,o){return new Dt(this,e,t,i,o)}clear({color:e,depth:t,stencil:i,colorMask:o}){const r=this.gl;let s=0;e&&(s|=r.COLOR_BUFFER_BIT,this.clearColor.set(e),this.colorMask.set(o||[!0,!0,!0,!0])),void 0!==t&&(s|=r.DEPTH_BUFFER_BIT,this.depthRange.set([0,1]),this.clearDepth.set(t),this.depthMask.set(!0)),void 0!==i&&(s|=r.STENCIL_BUFFER_BIT,this.clearStencil.set(i),this.stencilMask.set(255)),r.clear(s);}setCullFace(e){!1===e.enable?this.cullFace.set(!1):(this.cullFace.set(!0),this.cullFaceSide.set(e.mode),this.frontFace.set(e.frontFace));}setDepthMode(e){e.func!==this.gl.ALWAYS||e.mask?(this.depthTest.set(!0),this.depthFunc.set(e.func),this.depthMask.set(e.mask),this.depthRange.set(e.range)):this.depthTest.set(!1);}setStencilMode(e){e.test.func!==this.gl.ALWAYS||e.mask?(this.stencilTest.set(!0),this.stencilMask.set(e.mask),this.stencilOp.set([e.fail,e.depthFail,e.pass]),this.stencilFunc.set({func:e.test.func,ref:e.ref,mask:e.test.mask})):this.stencilTest.set(!1);}setColorMode(e){t(e.blendFunction,Mt.Replace)?this.blend.set(!1):(this.blend.set(!0),this.blendFunc.set(e.blendFunction),this.blendColor.set(e.blendColor),e.blendEquation?this.blendEquation.set(e.blendEquation):this.blendEquation.setDefault()),this.colorMask.set(e.mask);}unbindVAO(){this.bindVertexArrayOES.set(null);}}var kt=e.ay([{name:"a_pos",type:"Float32",components:3}]);class Nt{constructor(t,i,o,r){const s={width:o[0],height:o[1],data:null},n=t.gl;this.targetColorTexture=new e.T(t,s,n.RGBA,{useMipmap:!1}),this.backgroundColorTexture=new e.T(t,s,n.RGBA,{useMipmap:!1}),this.context=t,this.setNumParticles(i,r),this.lastInvalidatedAt=0;}setNumParticles(t,i){if(this.numParticles===i)return;(this.particleVertices0||this.particleVertices1||this.particleSegment)&&(this.particleVertices0.destroy(),this.particleVertices1.destroy(),this.particleSegment.destroy());const o=new e.az;o.reserve(Math.round(i));const r=e.aA(t.key);for(let e=0;e<i;e++)o.emplaceBack(r(),r(),r());this.particleVertices0=this.context.createVertexBuffer(o,kt.members,!0),this.particleVertices1=this.context.createVertexBuffer(o,kt.members,!0),this.particleSegment=e.aB.simpleSegment(0,0,this.particleVertices0.length,0),this.numParticles=i;}update(t){return !(this.lastInvalidatedAt<t&&(this.lastInvalidatedAt=e.f.now(),1))}destroy(){this.targetColorTexture.destroy(),this.backgroundColorTexture.destroy(),this.particleVertices0.destroy(),this.particleVertices1.destroy(),this.particleSegment.destroy();}}const Ut={type:2,extent:e.V,loadGeometry:()=>[[new e.P(0,0),new e.P(e.V+1,0),new e.P(e.V+1,e.V+1),new e.P(0,e.V+1),new e.P(0,0)]]};class Gt{constructor(t,i,o,r,s){this.tileID=t,this.uid=e.aC(),this.uses=0,this.tileSize=i,this.tileZoom=o,this.buckets={},this.expirationTime=null,this.queryPadding=0,this.hasSymbolBuckets=!1,this.hasRTLText=!1,this.dependencies={},this.isRaster=s,r&&r.style&&(this._lastUpdatedBrightness=r.style.getBrightness()),this.expiredRequestCount=0,this.state="loading",r&&r.transform&&(this.projection=r.transform.projection);}registerFadeDuration(t){const i=t+this.timeAdded;i<e.f.now()||this.fadeEndTime&&i<this.fadeEndTime||(this.fadeEndTime=i);}wasRequested(){return "errored"===this.state||"loaded"===this.state||"reloading"===this.state}get tileTransform(){return this._tileTransform||(this._tileTransform=e.as(this.tileID.canonical,this.projection)),this._tileTransform}loadVectorData(t,i,o){if(this.unloadVectorData(),this.state="loaded",t){t.featureIndex&&(this.latestFeatureIndex=t.featureIndex,t.rawTileData?(this.latestRawTileData=t.rawTileData,this.latestFeatureIndex.rawTileData=t.rawTileData):this.latestRawTileData&&(this.latestFeatureIndex.rawTileData=this.latestRawTileData)),this.collisionBoxArray=t.collisionBoxArray,this.buckets=function(e,t){const i={};if(!t)return i;for(const o of e){const e=o.layerIds.map((e=>t.getLayer(e))).filter(Boolean);if(0!==e.length){o.layers=e,o.stateDependentLayerIds&&(o.stateDependentLayers=o.stateDependentLayerIds.map((t=>e.filter((e=>e.id===t))[0])));for(const t of e)i[t.fqid]=o;}}return i}(t.buckets,i.style),this.hasSymbolBuckets=!1;for(const t in this.buckets){const i=this.buckets[t];if(i instanceof e.aE){if(this.hasSymbolBuckets=!0,!o)break;i.justReloaded=!0;}}if(this.hasRTLText=!1,this.hasSymbolBuckets)for(const t in this.buckets){const i=this.buckets[t];if(i instanceof e.aE&&i.hasRTLText){this.hasRTLText=!0,e.aF();break}}this.queryPadding=0;for(const e in this.buckets){const t=this.buckets[e],o=i.style.getOwnLayer(e);if(!o)continue;const r=o.queryRadius(t);this.queryPadding=Math.max(this.queryPadding,r);}t.imageAtlas&&(this.imageAtlas=t.imageAtlas),t.glyphAtlasImage&&(this.glyphAtlasImage=t.glyphAtlasImage),t.lineAtlas&&(this.lineAtlas=t.lineAtlas),this._lastUpdatedBrightness=t.brightness;}else this.collisionBoxArray=new e.aD;}unloadVectorData(){if(this.hasData()){for(const e in this.buckets)this.buckets[e].destroy();this.buckets={},this.imageAtlas&&(this.imageAtlas=null),this.lineAtlas&&(this.lineAtlas=null),this.imageAtlasTexture&&this.imageAtlasTexture.destroy(),this.glyphAtlasTexture&&this.glyphAtlasTexture.destroy(),this.lineAtlasTexture&&this.lineAtlasTexture.destroy(),this._tileBoundsBuffer&&(this._tileBoundsBuffer.destroy(),this._tileBoundsIndexBuffer.destroy(),this._tileBoundsSegments.destroy(),this._tileBoundsBuffer=null),this._tileDebugBuffer&&(this._tileDebugBuffer.destroy(),this._tileDebugSegments.destroy(),this._tileDebugBuffer=null),this._tileDebugIndexBuffer&&(this._tileDebugIndexBuffer.destroy(),this._tileDebugIndexBuffer=null),this._globeTileDebugBorderBuffer&&(this._globeTileDebugBorderBuffer.destroy(),this._globeTileDebugBorderBuffer=null),this._tileDebugTextBuffer&&(this._tileDebugTextBuffer.destroy(),this._tileDebugTextSegments.destroy(),this._tileDebugTextIndexBuffer.destroy(),this._tileDebugTextBuffer=null),this._globeTileDebugTextBuffer&&(this._globeTileDebugTextBuffer.destroy(),this._globeTileDebugTextBuffer=null),this.latestFeatureIndex=null,this.state="unloaded";}}getBucket(e){return this.buckets[e.fqid]}upload(t){for(const e in this.buckets){const i=this.buckets[e];i.uploadPending()&&i.upload(t);}const i=t.gl,o=this.imageAtlas;if(o&&!o.uploaded){const r=!!Object.keys(o.patternPositions).length;this.imageAtlasTexture=new e.T(t,o.image,i.RGBA,{useMipmap:r}),this.imageAtlas.uploaded=!0;}this.glyphAtlasImage&&(this.glyphAtlasTexture=new e.T(t,this.glyphAtlasImage,i.R8),this.glyphAtlasImage=null),this.lineAtlas&&!this.lineAtlas.uploaded&&(this.lineAtlasTexture=new e.T(t,this.lineAtlas.image,i.R8),this.lineAtlas.uploaded=!0);}prepare(e,t,i){if(this.imageAtlas&&this.imageAtlasTexture&&this.imageAtlas.patchUpdatedImages(e,this.imageAtlasTexture,i),!t||!this.latestFeatureIndex||!this.latestFeatureIndex.rawTileData)return;const o=t.style.getBrightness();(this._lastUpdatedBrightness||o)&&(this._lastUpdatedBrightness&&o&&Math.abs(this._lastUpdatedBrightness-o)<.001||(this._lastUpdatedBrightness=o,this.updateBuckets(void 0,t)));}queryRenderedFeatures(e,t,i,o,r,s,n,a){return this.latestFeatureIndex&&(this.latestFeatureIndex.rawTileData||this.latestFeatureIndex.is3DTile)?this.latestFeatureIndex.query({tileResult:o,pixelPosMatrix:n,transform:s,params:r,tileTransform:this.tileTransform},e,t,i):{}}querySourceFeatures(t,i){const o=this.latestFeatureIndex;if(!o||!o.rawTileData)return;const r=o.loadVTLayers(),s=i?i.sourceLayer:"",n=r._geojsonTileLayer||r[s];if(!n)return;const a=e.aG(i&&i.filter),{z:l,x:c,y:h}=this.tileID.canonical,u={z:l,x:c,y:h};for(let i=0;i<n.length;i++){const r=n.feature(i);if(a.needGeometry){const t=e.aH(r,!0);if(!a.filter(new e.K(this.tileID.overscaledZ),t,this.tileID.canonical))continue}else if(!a.filter(new e.K(this.tileID.overscaledZ),r))continue;const d=o.getId(r,s),_=new e.aI(r,l,c,h,d);_.tile=u,t.push(_);}}hasData(){return "loaded"===this.state||"reloading"===this.state||"expired"===this.state}bucketsLoaded(){for(const e in this.buckets)if(this.buckets[e].uploadPending())return !1;return !0}patternsLoaded(){return !!this.imageAtlas&&!!Object.keys(this.imageAtlas.patternPositions).length}setExpiryData(t){const i=this.expirationTime;if(t.cacheControl){const i=e.aJ(t.cacheControl);i["max-age"]&&(this.expirationTime=Date.now()+1e3*i["max-age"]);}else t.expires&&(this.expirationTime=new Date(t.expires).getTime());if(this.expirationTime){const e=Date.now();let t=!1;if(this.expirationTime>e)t=!1;else if(i)if(this.expirationTime<i)t=!0;else {const o=this.expirationTime-i;o?this.expirationTime=e+Math.max(o,3e4):t=!0;}else t=!0;t?(this.expiredRequestCount++,this.state="expired"):this.expiredRequestCount=0;}}getExpiryTimeout(){if(this.expirationTime)return this.expiredRequestCount?1e3*(1<<Math.min(this.expiredRequestCount-1,31)):Math.min(this.expirationTime-(new Date).getTime(),Math.pow(2,31)-1)}setFeatureState(e,t){this.latestFeatureIndex&&this.latestFeatureIndex.rawTileData&&0!==Object.keys(e).length&&t&&this.updateBuckets(e,t);}updateBuckets(t,i){if(!this.latestFeatureIndex)return;const o=this.latestFeatureIndex.loadVTLayers(),r=i.style.listImages(),s=i.style.getBrightness();for(const n in this.buckets){if(!i.style.hasLayer(n))continue;const a=this.buckets[n],l=a.layers[0].sourceLayer||"_geojsonTileLayer",c=o[l];let h={};if(t&&(h=t[l],!c||!h||0===Object.keys(h).length))continue;if(a.update(h,c,r,this.imageAtlas&&this.imageAtlas.patternPositions||{},s),a instanceof e.aK||a instanceof e.aL){const e=i.style.getOwnSourceCache(a.layers[0].source);i._terrain&&i._terrain.enabled&&e&&a.programConfigurations.needsUpload&&i._terrain._clearRenderCacheForTile(e.id,this.tileID);}const u=i&&i.style&&i.style.getOwnLayer(n);u&&(this.queryPadding=Math.max(this.queryPadding,u.queryRadius(a)));}}holdingForFade(){return void 0!==this.symbolFadeHoldUntil}symbolFadeFinished(){return !this.symbolFadeHoldUntil||this.symbolFadeHoldUntil<e.f.now()}clearFadeHold(){this.symbolFadeHoldUntil=void 0;}setHoldDuration(t){this.symbolFadeHoldUntil=e.f.now()+t;}setTexture(t,i){const o=i.context,r=o.gl;this.texture=this.texture||i.getTileTexture(t.width),this.texture&&this.texture instanceof e.T?this.texture.update(t,{useMipmap:!0}):(this.texture=new e.T(o,t,r.RGBA,{useMipmap:!0}),this.texture.bind(r.LINEAR,r.CLAMP_TO_EDGE));}setDependencies(e,t){const i={};for(const e of t)i[e]=!0;this.dependencies[e]=i;}hasDependency(e,t){for(const i of e){const e=this.dependencies[i];if(e)for(const i of t)if(e[i])return !0}return !1}clearQueryDebugViz(){}_makeDebugTileBoundsBuffers(t,i){if(!i||"mercator"===i.name||this._tileDebugBuffer)return;const o=e.aM(Ut,this.tileID.canonical,this.tileTransform)[0],r=new e.aN,s=new e.aO;for(let e=0;e<o.length;e++){const{x:t,y:i}=o[e];r.emplaceBack(t,i),s.emplaceBack(e);}s.emplaceBack(0),this._tileDebugIndexBuffer=t.createIndexBuffer(s),this._tileDebugBuffer=t.createVertexBuffer(r,e.aP.members),this._tileDebugSegments=e.aB.simpleSegment(0,0,r.length,s.length);}_makeTileBoundsBuffers(t,i){if(this._tileBoundsBuffer||!i||"mercator"===i.name)return;const o=e.aM(Ut,this.tileID.canonical,this.tileTransform)[0];let r,s;if(this.isRaster){const t=function(t,i){const o=e.as(t,i),r=Math.pow(2,t.z);for(let s=0;s<Fe;s++)for(let n=0;n<Fe;n++){const a=e.at((t.x+(n+Ge(n))/Oe)/r),l=e.au((t.y+(s+Ge(s))/Oe)/r),c=i.project(a,l),h=s*Fe+n;ke[2*h+0]=Math.round((c.x*o.scale-o.x)*e.V),ke[2*h+1]=Math.round((c.y*o.scale-o.y)*e.V);}Ne.fill(0),Ue.fill(0);for(let e=2045;e>=0;e--){const t=4*e,i=Be[t+0],o=Be[t+1],r=Be[t+2],s=Be[t+3],n=i+r>>1,a=o+s>>1,l=n+a-o,c=a+i-n,h=o*Fe+i,u=s*Fe+r,d=a*Fe+n,_=Math.hypot((ke[2*h+0]+ke[2*u+0])/2-ke[2*d+0],(ke[2*h+1]+ke[2*u+1])/2-ke[2*d+1])>=16;Ne[d]=Ne[d]||(_?1:0),e<1022&&(Ne[d]=Ne[d]||Ne[(o+c>>1)*Fe+(i+l>>1)]||Ne[(s+c>>1)*Fe+(r+l>>1)]);}const s=new e.av,n=new e.aw;let a=0;function l(t,i){const o=i*Fe+t;return 0===Ue[o]&&(s.emplaceBack(ke[2*o+0],ke[2*o+1],t*e.V/Oe,i*e.V/Oe),Ue[o]=++a),Ue[o]-1}function c(e,t,i,o,r,s){const a=e+i>>1,h=t+o>>1;if(Math.abs(e-r)+Math.abs(t-s)>1&&Ne[h*Fe+a])c(r,s,e,t,a,h),c(i,o,r,s,a,h);else {const a=l(e,t),c=l(i,o),h=l(r,s);n.emplaceBack(a,c,h);}}return c(0,0,Oe,Oe,Oe,0),c(Oe,Oe,0,0,0,Oe),{vertices:s,indices:n}}(this.tileID.canonical,i);r=t.vertices,s=t.indices;}else {r=new e.av,s=new e.aw;for(const{x:e,y:t}of o)r.emplaceBack(e,t,0,0);const t=e.aQ(r.int16,void 0,4);for(let e=0;e<t.length;e+=3)s.emplaceBack(t[e],t[e+1],t[e+2]);}this._tileBoundsBuffer=t.createVertexBuffer(r,e.aR.members),this._tileBoundsIndexBuffer=t.createIndexBuffer(s),this._tileBoundsSegments=e.aB.simpleSegment(0,0,r.length,s.length);}_makeGlobeTileDebugBuffers(t,i){const o=i.projection;if(!o||"globe"!==o.name||i.freezeTileCoverage)return;const r=this.tileID.canonical,s=e.aS(r,i),n=e.aT(s),a=e.S(i.zoom);let l;a>0&&(l=e.a6.invert(new Float64Array(16),i.globeMatrix)),this._makeGlobeTileDebugBorderBuffer(t,r,i,n,l,a),this._makeGlobeTileDebugTextBuffer(t,r,i,n,l,a);}_globePoint(t,i,o,r,s,n,a){let l=e.aU(t,i,o);if(n){const s=1<<o.z,c=e.a5(r.center.lng),h=e.ae(r.center.lat),u=(o.x+.5)/s-c;let d=0;u>.5?d=-1:u<-.5&&(d=1);let _=(t/e.V+o.x)/s+d,p=(i/e.V+o.y)/s;_=(_-c)*r._pixelsPerMercatorPixel+c,p=(p-h)*r._pixelsPerMercatorPixel+h;const f=[_*r.worldSize,p*r.worldSize,0];e.N.transformMat4(f,f,n),l=e.aV(l,f,a);}return e.N.transformMat4(l,l,s)}_makeGlobeTileDebugBorderBuffer(t,i,o,r,s,n){const a=new e.aN,l=new e.aO,c=new e.aW,h=(e,t,h,u,d)=>{const _=(h-e)/(d-1),p=(u-t)/(d-1),f=a.length;for(let h=0;h<d;h++){const u=e+h*_,d=t+h*p;a.emplaceBack(u,d);const m=this._globePoint(u,d,i,o,r,s,n);c.emplaceBack(m[0],m[1],m[2]),l.emplaceBack(f+h);}},u=e.V;h(0,0,u,0,16),h(u,0,u,u,16),h(u,u,0,u,16),h(0,u,0,0,16),this._tileDebugIndexBuffer=t.createIndexBuffer(l),this._tileDebugBuffer=t.createVertexBuffer(a,e.aP.members),this._globeTileDebugBorderBuffer=t.createVertexBuffer(c,e.aX.members),this._tileDebugSegments=e.aB.simpleSegment(0,0,a.length,l.length);}_makeGlobeTileDebugTextBuffer(t,i,o,r,s,n){const a=e.V/4,l=new e.aN,c=new e.aw,h=new e.aW,u=25;c.reserve(32),l.reserve(u),h.reserve(u);const d=(e,t)=>u*e+t;for(let e=0;e<u;e++){const t=e*a;for(let e=0;e<u;e++){const c=e*a;l.emplaceBack(c,t);const u=this._globePoint(c,t,i,o,r,s,n);h.emplaceBack(u[0],u[1],u[2]);}}for(let e=0;e<4;e++)for(let t=0;t<4;t++){const i=d(e,t),o=d(e,t+1),r=d(e+1,t),s=d(e+1,t+1);c.emplaceBack(i,o,r),c.emplaceBack(r,o,s);}this._tileDebugTextIndexBuffer=t.createIndexBuffer(c),this._tileDebugTextBuffer=t.createVertexBuffer(l,e.aP.members),this._globeTileDebugTextBuffer=t.createVertexBuffer(h,e.aX.members),this._tileDebugTextSegments=e.aB.simpleSegment(0,0,u,32);}destroy(t=!1){for(const e in this.buckets)this.buckets[e].destroy();this.buckets={},this.imageAtlas&&(this.imageAtlas=null),this.lineAtlas&&(this.lineAtlas=null),this.imageAtlasTexture&&(this.imageAtlasTexture.destroy(),delete this.imageAtlasTexture),this.glyphAtlasTexture&&(this.glyphAtlasTexture.destroy(),delete this.glyphAtlasTexture),this.lineAtlasTexture&&(this.lineAtlasTexture.destroy(),delete this.lineAtlasTexture),this._tileBoundsBuffer&&(this._tileBoundsBuffer.destroy(),this._tileBoundsIndexBuffer.destroy(),this._tileBoundsSegments.destroy(),this._tileBoundsBuffer=null),this._tileDebugBuffer&&(this._tileDebugBuffer.destroy(),this._tileDebugSegments.destroy(),this._tileDebugBuffer=null),this._tileDebugIndexBuffer&&(this._tileDebugIndexBuffer.destroy(),this._tileDebugIndexBuffer=null),this._globeTileDebugBorderBuffer&&(this._globeTileDebugBorderBuffer.destroy(),this._globeTileDebugBorderBuffer=null),this._tileDebugTextBuffer&&(this._tileDebugTextBuffer.destroy(),this._tileDebugTextSegments.destroy(),this._tileDebugTextIndexBuffer.destroy(),this._tileDebugTextBuffer=null),this._globeTileDebugTextBuffer&&(this._globeTileDebugTextBuffer.destroy(),this._globeTileDebugTextBuffer=null),!t&&this.texture&&this.texture instanceof e.T&&(this.texture.destroy(),delete this.texture),this.hillshadeFBO&&(this.hillshadeFBO.destroy(),delete this.hillshadeFBO),this.dem&&delete this.dem,this.neighboringTiles&&delete this.neighboringTiles,this.demTexture&&(this.demTexture.destroy(),delete this.demTexture),this.rasterParticleState&&(this.rasterParticleState.destroy(),delete this.rasterParticleState),this.latestFeatureIndex=null,this.state="unloaded";}}const jt={vector:Pe,raster:Me,"raster-dem":class extends Me{constructor(t,i,o,r){super(t,i,o,r),this.type="raster-dem",this.maxzoom=22,this._options=e.e({type:"raster-dem"},i),this.encoding=i.encoding||"mapbox";}loadTile(t,i){const o=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme),!1,this.tileSize);function r(e,o){e&&(t.state="errored",i(e)),o&&(t.dem=o,t.dem.onDeserialize(),t.needsHillshadePrepare=!0,t.needsDEMTextureUpload=!0,t.state="loaded",i(null));}t.request=e.d(this.map._requestManager.transformRequest(o,e.R.Tile),function(o,s,n,a){if(delete t.request,t.aborted)t.state="unloaded",i(null);else if(o)t.state="errored",i(o);else if(s){this.map._refreshExpiredTiles&&t.setExpiryData({cacheControl:n,expires:a});const i=ImageBitmap&&s instanceof ImageBitmap&&e.ak(),o=1-(s.width-e.al(s.width))/2;o<1||t.neighboringTiles||(t.neighboringTiles=this._getNeighboringTiles(t.tileID));const l=i?s:e.f.getImageData(s,o),c={uid:t.uid,coord:t.tileID,source:this.id,scope:this.scope,rawImageData:l,encoding:this.encoding,padding:o};t.actor&&"expired"!==t.state||(t.actor=this.dispatcher.getActor(),t.actor.send("loadDEMTile",c,r.bind(this),void 0,!0));}}.bind(this));}_getNeighboringTiles(t){const i=t.canonical,o=Math.pow(2,i.z),r=(i.x-1+o)%o,s=0===i.x?t.wrap-1:t.wrap,n=(i.x+1+o)%o,a=i.x+1===o?t.wrap+1:t.wrap,l={};return l[new e.am(t.overscaledZ,s,i.z,r,i.y).key]={backfilled:!1},l[new e.am(t.overscaledZ,a,i.z,n,i.y).key]={backfilled:!1},i.y>0&&(l[new e.am(t.overscaledZ,s,i.z,r,i.y-1).key]={backfilled:!1},l[new e.am(t.overscaledZ,t.wrap,i.z,i.x,i.y-1).key]={backfilled:!1},l[new e.am(t.overscaledZ,a,i.z,n,i.y-1).key]={backfilled:!1}),i.y+1<o&&(l[new e.am(t.overscaledZ,s,i.z,r,i.y+1).key]={backfilled:!1},l[new e.am(t.overscaledZ,t.wrap,i.z,i.x,i.y+1).key]={backfilled:!1},l[new e.am(t.overscaledZ,a,i.z,n,i.y+1).key]={backfilled:!1}),l}},"raster-array":ze,geojson:class extends e.E{constructor(t,i,o,r){super(),this.id=t,this.type="geojson",this.minzoom=0,this.maxzoom=18,this.tileSize=512,this.isTileClipped=!0,this.reparseOverscaled=!0,this._loaded=!1,this.actor=o.getActor(),this.setEventedParent(r),this._data=i.data,this._options=e.e({},i),this._collectResourceTiming=i.collectResourceTiming,void 0!==i.maxzoom&&(this.maxzoom=i.maxzoom),i.type&&(this.type=i.type),i.attribution&&(this.attribution=i.attribution),this.promoteId=i.promoteId;const s=e.V/this.tileSize;this.workerOptions=e.e({source:this.id,scope:this.scope,cluster:i.cluster||!1,geojsonVtOptions:{buffer:(void 0!==i.buffer?i.buffer:128)*s,tolerance:(void 0!==i.tolerance?i.tolerance:.375)*s,extent:e.V,maxZoom:this.maxzoom,lineMetrics:i.lineMetrics||!1,generateId:i.generateId||!1},superclusterOptions:{maxZoom:void 0!==i.clusterMaxZoom?i.clusterMaxZoom:this.maxzoom-1,minPoints:Math.max(2,i.clusterMinPoints||2),extent:e.V,radius:(void 0!==i.clusterRadius?i.clusterRadius:50)*s,log:!1,generateId:i.generateId||!1},clusterProperties:i.clusterProperties,filter:i.filter},i.workerOptions);}onAdd(e){this.map=e,this.setData(this._data);}setData(e){return this._data=e,this._updateWorkerData(),this}getClusterExpansionZoom(e,t){return this.actor.send("geojson.getClusterExpansionZoom",{clusterId:e,source:this.id,scope:this.scope},t),this}getClusterChildren(e,t){return this.actor.send("geojson.getClusterChildren",{clusterId:e,source:this.id,scope:this.scope},t),this}getClusterLeaves(e,t,i,o){return this.actor.send("geojson.getClusterLeaves",{source:this.id,scope:this.scope,clusterId:e,limit:t,offset:i},o),this}_updateWorkerData(){if(this._pendingLoad)return void(this._coalesce=!0);this.fire(new e.b("dataloading",{dataType:"source"})),this._loaded=!1;const t=e.e({},this.workerOptions);t.scope=this.scope;const i=this._data;"string"==typeof i?(t.request=this.map._requestManager.transformRequest(e.f.resolveURL(i),e.R.Source),t.request.collectResourceTiming=this._collectResourceTiming):t.data=JSON.stringify(i),this._pendingLoad=this.actor.send(`${this.type}.loadData`,t,((t,i)=>{if(this._loaded=!0,this._pendingLoad=null,t)this.fire(new e.a(t));else {const t={dataType:"source",sourceDataType:this._metadataFired?"content":"metadata"};this._collectResourceTiming&&i&&i.resourceTiming&&i.resourceTiming[this.id]&&(t.resourceTiming=i.resourceTiming[this.id]),this.fire(new e.b("data",t)),this._metadataFired=!0;}this._coalesce&&(this._updateWorkerData(),this._coalesce=!1);}));}loaded(){return this._loaded}loadTile(t,i){const o=t.actor?"reloadTile":"loadTile";t.actor=this.actor;const r={type:this.type,uid:t.uid,tileID:t.tileID,tileZoom:t.tileZoom,zoom:t.tileID.overscaledZ,maxZoom:this.maxzoom,tileSize:this.tileSize,source:this.id,scope:this.scope,pixelRatio:e.f.devicePixelRatio,showCollisionBoxes:this.map.showCollisionBoxes,promoteId:this.promoteId,brightness:this.map.style&&this.map.style.getBrightness()||0};t.request=this.actor.send(o,r,((e,r)=>(delete t.request,t.destroy(),t.aborted?i(null):e?i(e):(t.loadVectorData(r,this.map.painter,"reloadTile"===o),i(null)))),void 0,"loadTile"===o);}abortTile(e){e.request&&(e.request.cancel(),delete e.request),e.aborted=!0;}unloadTile(e){this.actor.send("removeTile",{uid:e.uid,type:this.type,source:this.id,scope:this.scope}),e.destroy();}onRemove(){this._pendingLoad&&this._pendingLoad.cancel();}serialize(){return e.e({},this._options,{type:this.type,data:this._data})}hasTransition(){return !1}},video:class extends e.ap{constructor(e,t,i,o){super(e,t,i,o),this.roundZoom=!0,this.type="video",this.options=t;}load(){this._loaded=!1;const t=this.options;this.urls=[];for(const i of t.urls)this.urls.push(this.map._requestManager.transformRequest(i,e.R.Source).url);e.aq(this.urls,((t,i)=>{this._loaded=!0,t?this.fire(new e.a(t)):i&&(this.video=i,this.video.loop=!0,this.video.setAttribute("playsinline",""),this.video.addEventListener("playing",(()=>{this.map.triggerRepaint();})),this.map&&this.video.play(),this._finishLoading());}));}pause(){this.video&&this.video.pause();}play(){this.video&&this.video.play();}seek(t){if(this.video){const i=this.video.seekable;t<i.start(0)||t>i.end(0)?this.fire(new e.a(new T(`sources.${this.id}`,null,`Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))):this.video.currentTime=t;}}getVideo(){return this.video}onAdd(e){this.map||(this.map=e,this.load(),this.video&&(this.video.play(),this.setCoordinates(this.coordinates)));}prepare(){if(0===Object.keys(this.tiles).length||this.video.readyState<2)return;const t=this.map.painter.context,i=t.gl;this.texture?this.video.paused||(this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,this.video)):(this.texture=new e.T(t,this.video,i.RGBA),this.texture.bind(i.LINEAR,i.CLAMP_TO_EDGE),this.width=this.video.videoWidth,this.height=this.video.videoHeight),this._prepareData(t);}serialize(){return {type:"video",urls:this.urls,coordinates:this.coordinates}}hasTransition(){return this.video&&!this.video.paused}},image:e.ap,model:class extends e.E{constructor(e,t,i,o){super(),this.id=e,this.type="model",this.models=[],this._loaded=!1,this._options=t;}load(){const t=[];for(const i in this._options.models){const o=this._options.models[i],r=e.l(this.map._requestManager.transformRequest(o.uri,e.R.Model).url).then((t=>{if(!t)return;const r=e.c(t),s=new e.M(i,o.position,o.orientation,r);s.computeBoundsAndApplyParent(),this.models.push(s);})).catch((t=>{this.fire(new e.a(new Error(`Could not load model ${i} from ${o.uri}: ${t.message}`)));}));t.push(r);}return Promise.allSettled(t).then((()=>{this._loaded=!0,this.fire(new e.b("data",{dataType:"source",sourceDataType:"metadata"}));})).catch((t=>{this.fire(new e.a(new Error(`Could not load models: ${t.message}`)));}))}onAdd(e){this.map=e,this.load();}hasTransition(){return !1}loaded(){return this._loaded}getModels(){return this.models}loadTile(e,t){}serialize(){return {type:"model"}}},"batched-model":class extends e.E{constructor(e,t,i,o){super(),this.type="batched-model",this.id=e,this.tileSize=512,this._options=t,this.tiles=this._options.tiles,this.maxzoom=t.maxzoom||19,this.minzoom=t.minzoom||0,this.roundZoom=!0,this.usedInConflation=!0,this.dispatcher=i,this.reparseOverscaled=!1,this.scheme="xyz",this._loaded=!1,this.setEventedParent(o);}onAdd(e){this.map=e,this.load();}load(t){this._loaded=!1,this.fire(new e.b("dataloading",{dataType:"source"}));const i=Array.isArray(this.map._language)?this.map._language.join():this.map._language,o=this.map._worldview;this._tileJSONRequest=Ae(this._options,this.map._requestManager,i,o,((r,s)=>{this._tileJSONRequest=null,this._loaded=!0,r?(i&&console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`),o&&2!==o.length&&console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`),this.fire(new e.a(r))):s&&(e.e(this,s),s.bounds&&(this.tileBounds=new Re(s.bounds,this.minzoom,this.maxzoom)),e.aj(s.tiles,this.map._requestManager._customAccessToken),this.fire(new e.b("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.b("data",{dataType:"source",sourceDataType:"content"}))),t&&t(r);}));}hasTransition(){return !1}hasTile(e){return !this.tileBounds||this.tileBounds.contains(e.canonical)}loaded(){return this._loaded}loadTile(t,i){const o=this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles,this.scheme)),r={request:this.map._requestManager.transformRequest(o,e.R.Tile),data:void 0,uid:t.uid,tileID:t.tileID,tileZoom:t.tileZoom,zoom:t.tileID.overscaledZ,tileSize:this.tileSize*t.tileID.overscaleFactor(),type:this.type,source:this.id,scope:this.scope,showCollisionBoxes:this.map.showCollisionBoxes,isSymbolTile:t.isSymbolTile,brightness:this.map.style&&this.map.style.getBrightness()||0};if(t.actor&&"expired"!==t.state)if("loading"===t.state)t.reloadCallback=i;else {if(t.buckets){const e=Object.values(t.buckets);for(const t of e)t.dirty=!0;return void(t.state="loaded")}t.request=t.actor.send("reloadTile",r,s.bind(this));}else t.actor=this.dispatcher.getActor(),t.request=t.actor.send("loadTile",r,s.bind(this),void 0,!0);function s(e,o){return t.aborted?i(null):e&&404!==e.status?i(e):(o&&(o.resourceTiming&&(t.resourceTiming=o.resourceTiming),this.map._refreshExpiredTiles&&t.setExpiryData(o),t.buckets={...t.buckets,...o.buckets},o.featureIndex&&(t.latestFeatureIndex=o.featureIndex)),t.state="loaded",void i(null))}}serialize(){return e.e({},this._options)}},canvas:class extends e.ap{constructor(t,i,o,r){super(t,i,o,r),i.coordinates?Array.isArray(i.coordinates)&&4===i.coordinates.length&&!i.coordinates.some((e=>!Array.isArray(e)||2!==e.length||e.some((e=>"number"!=typeof e))))||this.fire(new e.a(new T(`sources.${t}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))):this.fire(new e.a(new T(`sources.${t}`,null,'missing required property "coordinates"'))),i.animate&&"boolean"!=typeof i.animate&&this.fire(new e.a(new T(`sources.${t}`,null,'optional "animate" property must be a boolean value'))),i.canvas?"string"==typeof i.canvas||i.canvas instanceof HTMLCanvasElement||this.fire(new e.a(new T(`sources.${t}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))):this.fire(new e.a(new T(`sources.${t}`,null,'missing required property "canvas"'))),this.options=i,this.animate=void 0===i.animate||i.animate;}load(){this._loaded=!0,this.canvas||(this.canvas=this.options.canvas instanceof HTMLCanvasElement?this.options.canvas:document.getElementById(this.options.canvas)),this.width=this.canvas.width,this.height=this.canvas.height,this._hasInvalidDimensions()?this.fire(new e.a(new Error("Canvas dimensions cannot be less than or equal to zero."))):(this.play=function(){this._playing=!0,this.map.triggerRepaint();},this.pause=function(){this._playing&&(this.prepare(),this._playing=!1);},this._finishLoading());}getCanvas(){return this.canvas}onAdd(e){this.map=e,this.load(),this.canvas&&this.animate&&this.play();}onRemove(){this.pause();}prepare(){let t=!1;if(this.canvas.width!==this.width&&(this.width=this.canvas.width,t=!0),this.canvas.height!==this.height&&(this.height=this.canvas.height,t=!0),this._hasInvalidDimensions())return;if(0===Object.keys(this.tiles).length)return;const i=this.map.painter.context;this.texture?!t&&!this._playing||this.texture instanceof e.ar||this.texture.update(this.canvas,{premultiply:!0}):this.texture=new e.T(i,this.canvas,i.gl.RGBA,{premultiply:!0}),this._prepareData(i);}serialize(){return {type:"canvas",coordinates:this.coordinates}}hasTransition(){return this._playing}_hasInvalidDimensions(){for(const e of [this.canvas.width,this.canvas.height])if(isNaN(e)||e<=0)return !0;return !1}},custom:class extends e.E{constructor(t,i,o,r){super(),this.id=t,this.type="custom",this._dataType="raster",this._dispatcher=o,this._implementation=i,this.setEventedParent(r),this.scheme="xyz",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this._loaded=!1,this.roundZoom=!0,this._implementation||this.fire(new e.a(new Error(`Missing implementation for ${this.id} custom source`))),this._implementation.loadTile||this.fire(new e.a(new Error(`Missing loadTile implementation for ${this.id} custom source`))),this._implementation.bounds&&(this.tileBounds=new Re(this._implementation.bounds,this.minzoom,this.maxzoom)),i.update=this._update.bind(this),i.clearTiles=this._clearTiles.bind(this),i.coveringTiles=this._coveringTiles.bind(this),e.e(this,e.ac(i,["dataType","scheme","minzoom","maxzoom","tileSize","attribution","minTileCacheSize","maxTileCacheSize"]));}serialize(){return e.ac(this,["type","scheme","minzoom","maxzoom","tileSize","attribution"])}load(){this._loaded=!0,this.fire(new e.b("data",{dataType:"source",sourceDataType:"metadata"})),this.fire(new e.b("data",{dataType:"source",sourceDataType:"content"}));}loaded(){return this._loaded}onAdd(t){this._map=t,this._loaded=!1,this.fire(new e.b("dataloading",{dataType:"source"})),this._implementation.onAdd&&this._implementation.onAdd(t),this.load();}onRemove(e){this._implementation.onRemove&&this._implementation.onRemove(e);}hasTile(e){if(this._implementation.hasTile){const{x:t,y:i,z:o}=e.canonical;return this._implementation.hasTile({x:t,y:i,z:o})}return !this.tileBounds||this.tileBounds.contains(e.canonical)}loadTile(e,t){const{x:i,y:o,z:r}=e.tileID.canonical,s=new AbortController;e.request=Promise.resolve(this._implementation.loadTile({x:i,y:o,z:r},{signal:s.signal})).then(function(i){return delete e.request,e.aborted?(e.state="unloaded",t(null)):void 0===i?(e.state="errored",t(null)):null===i?(this.loadTileData(e,{width:this.tileSize,height:this.tileSize,data:null}),e.state="loaded",t(null)):function(e){return e instanceof ImageData||e instanceof HTMLCanvasElement||e instanceof ImageBitmap||e instanceof HTMLImageElement}(i)?(this.loadTileData(e,i),e.state="loaded",void t(null)):(e.state="errored",t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)))}.bind(this)).catch((i=>{20!==i.code&&(e.state="errored",t(i));})),e.request.cancel=()=>s.abort();}loadTileData(e,t){e.setTexture(t,this._map.painter);}unloadTile(t,i){if(t.texture&&t.texture instanceof e.T?(t.destroy(!0),t.texture&&t.texture instanceof e.T&&this._map.painter.saveTileTexture(t.texture)):t.destroy(),this._implementation.unloadTile){const{x:e,y:i,z:o}=t.tileID.canonical;this._implementation.unloadTile({x:e,y:i,z:o});}i();}abortTile(e,t){e.request&&e.request.cancel&&(e.request.cancel(),delete e.request),t();}hasTransition(){return !1}_coveringTiles(){return this._map.transform.coveringTiles({tileSize:this.tileSize,minzoom:this.minzoom,maxzoom:this.maxzoom,roundZoom:this.roundZoom}).map((e=>({x:e.canonical.x,y:e.canonical.y,z:e.canonical.z})))}_clearTiles(){const t=e.ag(this.id,this.scope);this._map.style.clearSource(t);}_update(){this.fire(new e.b("data",{dataType:"source",sourceDataType:"content"}));}}},Vt=function(t,i,o,r){const s=new jt[i.type](t,i,o,r);if(s.id!==t)throw new Error(`Expected Source id to be ${t} instead of ${s.id}`);return e.aY(["load","abort","unload","serialize","prepare"],s),s};function Zt(t,i){const o=e.a6.identity([]);return e.a6.scale(o,o,[.5*t.width,.5*-t.height,1]),e.a6.translate(o,o,[1,-1,0]),e.a6.multiply(o,o,t.calculateProjMatrix(i.toUnwrapped())),Float32Array.from(o)}function Ht(e,t,i,o,r,s,n,a=!1){const l=e.tilesIn(o,n,a);l.sort(qt);const c=[];for(const o of l)c.push({wrappedTileID:o.tile.tileID.wrapped().key,queryResults:o.tile.queryRenderedFeatures(t,i,e._state,o,r,s,Zt(e.transform,o.tile.tileID),a)});const h=function(e){const t={},i={};for(const o of e){const e=o.queryResults,r=o.wrappedTileID,s=i[r]=i[r]||{};for(const i in e){const o=e[i],r=s[i]=s[i]||{},n=t[i]=t[i]||[];for(const e of o)r[e.featureIndex]||(r[e.featureIndex]=!0,n.push(e));}}return t}(c);for(const t in h)h[t].forEach((t=>{const i=t.feature,o=i.layer;o&&"background"!==o.type&&"sky"!==o.type&&"slot"!==o.type&&(i.source=o.source,o["source-layer"]&&(i.sourceLayer=o["source-layer"]),i.state=void 0!==i.id?e.getFeatureState(o["source-layer"],i.id):{});}));return h}function Wt(e,t){const i=e.getRenderableIds().map((t=>e.getTileByID(t))),o=[],r={};for(let e=0;e<i.length;e++){const s=i[e],n=s.tileID.canonical.key;r[n]||(r[n]=!0,s.querySourceFeatures(o,t));}return o}function qt(e,t){const i=e.tileID,o=t.tileID;return i.overscaledZ-o.overscaledZ||i.canonical.y-o.canonical.y||i.wrap-o.wrap||i.canonical.x-o.canonical.x}class $t extends Gt{constructor(e,t,i,o,r){super(e,t,i,o,r),this._workQueue=[],this._fetchQueue=[],this._isHeaderLoaded=!1;}setTexture(t,i){const o=i.context,r=o.gl;this.texture=this.texture||i.getTileTexture(t.width),this.texture&&this.texture instanceof e.T?this.texture.update(t,{useMipmap:!1,premultiply:!1}):this.texture=new e.T(o,t,r.RGBA,{useMipmap:!1,premultiply:!1});}flushQueues(){for(;this._workQueue.length;)this._workQueue.pop()();for(;this._fetchQueue.length;)this._fetchQueue.pop()();}fetchHeader(t=16384,i){const o=this._mrt=new e.aZ(30),r=Object.assign({},this.requestParams,{headers:{Range:"bytes=0-"+(t-1)}});return this.entireBuffer=null,this.request=e.a_(r,((e,r,s,n)=>{if(e)i(e);else try{const e=o.getHeaderLength(r);if(e>t)return void(this.request=this.fetchHeader(e,i));o.parseHeader(r),this._isHeaderLoaded=!0;let a=0;for(const e of Object.values(o.layers))a=Math.max(a,e.dataIndex[e.dataIndex.length-1].last_byte);r.byteLength>=a&&(this.entireBuffer=r),i(null,this.entireBuffer||r,s,n);}catch(e){i(e);}})),this.request}fetchBand(t,i,o){const r=this._mrt;if(!this._isHeaderLoaded||!r)return void o(new Error("Tile header is not ready"));const s=this.actor;if(!s)return void o(new Error("Can't fetch tile band without an actor"));let n;const a=(e,r)=>{n.complete(e,r),e?o(e):(this.updateTextureDescriptor(t,i),o(null,this.textureDescriptor&&this.textureDescriptor.img));},l=(e,t)=>{if(e)return o(e);const i=s.send("decodeRasterArray",{buffer:t,task:n},a,void 0,!0);this._workQueue.push((()=>{i&&i.cancel(),n.cancel();}));},c=r.getLayer(t);if(!c)return void o(new Error(`Unknown sourceLayer "${t}"`));if(c.hasDataForBand(i))return this.updateTextureDescriptor(t,i),void o(null,this.textureDescriptor?this.textureDescriptor.img:null);const h=c.getDataRange([i]);if(n=r.createDecodingTask(h),!n||n.tasks.length)if(this.flushQueues(),this.entireBuffer)l(null,this.entireBuffer.slice(h.firstByte,h.lastByte+1));else {const t=Object.assign({},this.requestParams,{headers:{Range:`bytes=${h.firstByte}-${h.lastByte}`}}),i=e.a_(t,l);this._fetchQueue.push((()=>{i.cancel(),n.cancel();}));}else o(null);}updateNeeded(e,t){return (!this.textureDescriptor||this.textureDescriptor.band!==t||this.textureDescriptor.layer!==e)&&"errored"!==this.state}updateTextureDescriptor(t,i){if(!this._mrt)return;const o=this._mrt.getLayer(t);if(!o||!o.hasBand(i)||!o.hasDataForBand(i))return;const{bytes:r,tileSize:s,buffer:n,offset:a,scale:l}=o.getBandView(i),c=s+2*n,h={data:r,width:c,height:c},u=this.texture;u&&u instanceof e.T&&u.update(h,{useMipmap:!1,premultiply:!1}),this.textureDescriptor={layer:t,band:i,img:h,buffer:n,offset:a,tileSize:s,format:o.pixelFormat,mix:[l,256*l,65536*l,16777216*l]};}}class Xt{constructor(e,t){this.max=e,this.onRemove=t,this.reset();}reset(){for(const e in this.data)for(const t of this.data[e])t.timeout&&clearTimeout(t.timeout),this.onRemove(t.value);return this.data={},this.order=[],this}add(e,t,i){const o=e.wrapped().key;void 0===this.data[o]&&(this.data[o]=[]);const r={value:t,timeout:void 0};if(void 0!==i&&(r.timeout=setTimeout((()=>{this.remove(e,r);}),i)),this.data[o].push(r),this.order.push(o),this.order.length>this.max){const e=this._getAndRemoveByKey(this.order[0]);e&&this.onRemove(e);}return this}has(e){return e.wrapped().key in this.data}getAndRemove(e){return this.has(e)?this._getAndRemoveByKey(e.wrapped().key):null}_getAndRemoveByKey(e){const t=this.data[e].shift();return t.timeout&&clearTimeout(t.timeout),0===this.data[e].length&&delete this.data[e],this.order.splice(this.order.indexOf(e),1),t.value}getByKey(e){const t=this.data[e];return t?t[0].value:null}get(e){return this.has(e)?this.data[e.wrapped().key][0].value:null}remove(e,t){if(!this.has(e))return this;const i=e.wrapped().key,o=void 0===t?0:this.data[i].indexOf(t),r=this.data[i][o];return this.data[i].splice(o,1),r.timeout&&clearTimeout(r.timeout),0===this.data[i].length&&delete this.data[i],this.onRemove(r.value),this.order.splice(this.order.indexOf(i),1),this}setMaxSize(e){for(this.max=e;this.order.length>this.max;){const e=this._getAndRemoveByKey(this.order[0]);e&&this.onRemove(e);}return this}filter(e){const t=[];for(const i in this.data)for(const o of this.data[i])e(o.value)||t.push(o);for(const e of t)this.remove(e.value.tileID,e);}}class Kt extends e.E{constructor(e,t,i){super(),this.id=e,this._onlySymbols=i,t.on("data",(e=>{"source"===e.dataType&&"metadata"===e.sourceDataType&&(this._sourceLoaded=!0),this._sourceLoaded&&!this._paused&&"source"===e.dataType&&"content"===e.sourceDataType&&(this.reload(),this.transform&&this.update(this.transform));})),t.on("error",(()=>{this._sourceErrored=!0;})),this._source=t,this._tiles={},this._cache=new Xt(0,this._unloadTile.bind(this)),this._timers={},this._cacheTimers={},this._minTileCacheSize=t.minTileCacheSize,this._maxTileCacheSize=t.maxTileCacheSize,this._loadedParentTiles={},this.castsShadows=!1,this.tileCoverLift=0,this._coveredTiles={},this._shadowCasterTiles={},this._state=new y,this._isRaster="raster"===this._source.type||"raster-dem"===this._source.type||"raster-array"===this._source.type||"custom"===this._source.type&&"raster"===this._source._dataType;}onAdd(e){this.map=e,this._minTileCacheSize=void 0===this._minTileCacheSize&&e?e._minTileCacheSize:this._minTileCacheSize,this._maxTileCacheSize=void 0===this._maxTileCacheSize&&e?e._maxTileCacheSize:this._maxTileCacheSize;}loaded(){if(this._sourceErrored)return !0;if(!this._sourceLoaded)return !1;if(!this._source.loaded())return !1;for(const e in this._tiles){const t=this._tiles[e];if("errored"!==t.state&&("loaded"!==t.state||!t.bucketsLoaded()))return !1}return !0}getSource(){return this._source}pause(){this._paused=!0;}resume(){if(!this._paused)return;const e=this._shouldReloadOnResume;this._paused=!1,this._shouldReloadOnResume=!1,e&&this.reload(),this.transform&&this.update(this.transform);}_loadTile(e,t){return e.isSymbolTile=this._onlySymbols,e.isExtraShadowCaster=this._shadowCasterTiles[e.tileID.key],this._source.loadTile(e,t)}_unloadTile(e){if(this._source.unloadTile)return this._source.unloadTile(e,(()=>{}))}_abortTile(e){if(this._source.abortTile)return this._source.abortTile(e,(()=>{}))}serialize(){return this._source.serialize()}prepare(e){this._source.prepare&&this._source.prepare(),this._state.coalesceChanges(this._tiles,this.map?this.map.painter:null);for(const t in this._tiles){const i=this._tiles[t];i.upload(e),i.prepare(this.map.style.imageManager,this.map?this.map.painter:null,this._source.scope);}}getIds(){return e.a$(this._tiles).map((e=>e.tileID)).sort(Yt).map((e=>e.key))}getRenderableIds(t,i){const o=[];for(const e in this._tiles)this._isIdRenderable(+e,t,i)&&o.push(this._tiles[e]);return t?o.sort(((t,i)=>{const o=t.tileID,r=i.tileID,s=new e.P(o.canonical.x,o.canonical.y)._rotate(this.transform.angle),n=new e.P(r.canonical.x,r.canonical.y)._rotate(this.transform.angle);return o.overscaledZ-r.overscaledZ||n.y-s.y||n.x-s.x})).map((e=>e.tileID.key)):o.map((e=>e.tileID)).sort(Yt).map((e=>e.key))}hasRenderableParent(e){const t=this.findLoadedParent(e,0);return !!t&&this._isIdRenderable(t.tileID.key)}_isIdRenderable(e,t,i){return this._tiles[e]&&this._tiles[e].hasData()&&!this._coveredTiles[e]&&(t||!this._tiles[e].holdingForFade())&&(i||!this._shadowCasterTiles[e])}reload(){if(this._paused)this._shouldReloadOnResume=!0;else {this._cache.reset();for(const e in this._tiles)"errored"!==this._tiles[e].state&&this._reloadTile(+e,"reloading");}}_reloadTile(e,t){const i=this._tiles[e];i&&("loading"!==i.state&&(i.state=t),this._loadTile(i,this._tileLoaded.bind(this,i,e,t)));}_tileLoaded(t,i,o,r){if(r)if(t.state="errored",404!==r.status)this._source.fire(new e.a(r,{tile:t}));else {if(!(t.tileID.key in this._loadedParentTiles))return void this._source.fire(new e.b("data",{dataType:"source",sourceDataType:"error",sourceId:this._source.id}));if("raster-dem"===this._source.type&&this.usedForTerrain&&this.map.painter.terrain){const e=this.map.painter.terrain;this.update(this.transform,e.getScaledDemTileSize(),!0),e.resetTileLookupCache(this.id);}else this.update(this.transform);}else t.timeAdded=e.f.now(),"expired"===o&&(t.refreshedUponExpiration=!0),this._setTileReloadTimer(i,t),"raster-dem"===this._source.type&&t.dem&&this._backfillDEM(t),this._state.initializeTileState(t,this.map?this.map.painter:null),this._source.fire(new e.b("data",{dataType:"source",tile:t,coord:t.tileID,sourceCacheId:this.id}));}_backfillDEM(e){const t=this.getRenderableIds();for(let o=0;o<t.length;o++){const r=t[o];if(e.neighboringTiles&&e.neighboringTiles[r]){const t=this.getTileByID(r);i(e,t),i(t,e);}}function i(e,t){if(!e.dem||e.dem.borderReady)return;e.needsHillshadePrepare=!0,e.needsDEMTextureUpload=!0;let i=t.tileID.canonical.x-e.tileID.canonical.x;const o=t.tileID.canonical.y-e.tileID.canonical.y,r=Math.pow(2,e.tileID.canonical.z),s=t.tileID.key;0===i&&0===o||Math.abs(o)>1||(Math.abs(i)>1&&(1===Math.abs(i+r)?i+=r:1===Math.abs(i-r)&&(i-=r)),t.dem&&e.dem&&(e.dem.backfillBorder(t.dem,i,o),e.neighboringTiles&&e.neighboringTiles[s]&&(e.neighboringTiles[s].backfilled=!0)));}}getTile(e){return this.getTileByID(e.key)}getTileByID(e){return this._tiles[e]}_retainLoadedChildren(e,t,i,o){for(const r in this._tiles){let s=this._tiles[r];if(o[r]||!s.hasData()||s.tileID.overscaledZ<=t||s.tileID.overscaledZ>i)continue;let n=s.tileID;for(;s&&s.tileID.overscaledZ>t+1;){const e=s.tileID.scaledTo(s.tileID.overscaledZ-1);s=this._tiles[e.key],s&&s.hasData()&&(n=e);}let a=n;for(;a.overscaledZ>t;)if(a=a.scaledTo(a.overscaledZ-1),e[a.key]){o[n.key]=n;break}}}findLoadedParent(e,t){if(e.key in this._loadedParentTiles){const i=this._loadedParentTiles[e.key];return i&&i.tileID.overscaledZ>=t?i:null}for(let i=e.overscaledZ-1;i>=t;i--){const t=e.scaledTo(i),o=this._getLoadedTile(t);if(o)return o}}_getLoadedTile(e){const t=this._tiles[e.key];return t&&t.hasData()?t:this._cache.getByKey(this._source.reparseOverscaled?e.wrapped().key:e.canonical.key)}updateCacheSize(e,t){t=t||this._source.tileSize;const i=Math.ceil(e.width/t)+1,o=Math.ceil(e.height/t)+1,r=Math.floor(i*o*5),s="number"==typeof this._minTileCacheSize?Math.max(this._minTileCacheSize,r):r,n="number"==typeof this._maxTileCacheSize?Math.min(this._maxTileCacheSize,s):s;this._cache.setMaxSize(n);}handleWrapJump(e){const t=Math.round((e-(void 0===this._prevLng?e:this._prevLng))/360);if(this._prevLng=e,t){const e={};for(const i in this._tiles){const o=this._tiles[i];o.tileID=o.tileID.unwrapTo(o.tileID.wrap+t),e[o.tileID.key]=o;}this._tiles=e;for(const e in this._timers)clearTimeout(this._timers[e]),delete this._timers[e];for(const e in this._tiles)this._setTileReloadTimer(+e,this._tiles[e]);}}update(t,i,o,r){if(this.transform=t,!this._sourceLoaded||this._paused||this.transform.freezeTileCoverage)return;if(this.usedForTerrain&&!o)return;let s;if(this.updateCacheSize(t,i),"globe"!==this.transform.projection.name&&this.handleWrapJump(this.transform.center.lng),this._shadowCasterTiles={},this._coveredTiles={},this.used||this.usedForTerrain)if(this._source.tileID)s=t.getVisibleUnwrappedCoordinates(this._source.tileID).map((t=>new e.am(t.canonical.z,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y)));else if(0!==this.tileCoverLift){const r=t.clone();r.tileCoverLift=this.tileCoverLift,s=r.coveringTiles({tileSize:i||this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom&&!o,reparseOverscaled:this._source.reparseOverscaled,isTerrainDEM:this.usedForTerrain}),this._source.minzoom<=1&&"globe"===t.projection.name&&(s.push(new e.am(1,0,1,0,0)),s.push(new e.am(1,0,1,1,0)),s.push(new e.am(1,0,1,0,1)),s.push(new e.am(1,0,1,1,1)));}else s=t.coveringTiles({tileSize:i||this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom&&!o,reparseOverscaled:this._source.reparseOverscaled,isTerrainDEM:this.usedForTerrain}),this._source.hasTile&&(s=s.filter((e=>this._source.hasTile(e))));else s=[];if(s.length>0&&this.castsShadows&&r&&"globe"!==this.transform.projection.name&&!this.usedForTerrain&&!Jt(this._source.type)){const e=t.coveringZoomLevel({tileSize:i||this._source.tileSize,roundZoom:this._source.roundZoom&&!o}),n=Math.min(e,this._source.maxzoom),a=t.extendTileCoverForShadows(s,r,n);for(const e of a)this._shadowCasterTiles[e.key]=!0,s.push(e);}const n=this._updateRetainedTiles(s);if(Jt(this._source.type)&&0!==s.length){const t={},i={},o=Object.keys(n);for(const r of o){const o=n[r],s=this._tiles[r];if(!s||s.fadeEndTime&&s.fadeEndTime<=e.f.now())continue;const a=this.findLoadedParent(o,Math.max(o.overscaledZ-Kt.maxOverzooming,this._source.minzoom));a&&(this._addTile(a.tileID),t[a.tileID.key]=a.tileID),i[r]=o;}const r=s[s.length-1].overscaledZ;for(const e in this._tiles){const t=this._tiles[e];if(n[e]||!t.hasData())continue;let o=t.tileID;for(;o.overscaledZ>r;){o=o.scaledTo(o.overscaledZ-1);const r=this._tiles[o.key];if(r&&r.hasData()&&i[o.key]){n[e]=t.tileID;break}}}for(const e in t)n[e]||(this._coveredTiles[e]=!0,n[e]=t[e]);}for(const e in n)this._tiles[e].clearFadeHold();const a=e.b0(this._tiles,n);for(const e of a){const t=this._tiles[e];t.hasSymbolBuckets&&!t.holdingForFade()?t.setHoldDuration(this.map._fadeDuration):t.hasSymbolBuckets&&!t.symbolFadeFinished()||this._removeTile(+e);}this._updateLoadedParentTileCache(),this._onlySymbols&&this._source.afterUpdate&&this._source.afterUpdate();}releaseSymbolFadeTiles(){for(const e in this._tiles)this._tiles[e].holdingForFade()&&this._removeTile(+e);}_updateRetainedTiles(e){const t={};if(0===e.length)return t;const i={},o=e.reduce(((e,t)=>Math.min(e,t.overscaledZ)),1/0),r=e[0].overscaledZ,s=Math.max(r-Kt.maxOverzooming,this._source.minzoom),n=Math.max(r+Kt.maxUnderzooming,this._source.minzoom),a={};for(const i of e){const e=this._addTile(i);t[i.key]=i,e.hasData()||o<this._source.maxzoom&&(a[i.key]=i);}this._retainLoadedChildren(a,o,n,t);for(const o of e){let e=this._tiles[o.key];if(e.hasData())continue;if(o.canonical.z>=this._source.maxzoom){const e=o.children(this._source.maxzoom)[0],i=this.getTile(e);if(i&&i.hasData()){t[e.key]=e;continue}}else {const e=o.children(this._source.maxzoom);if(t[e[0].key]&&t[e[1].key]&&t[e[2].key]&&t[e[3].key])continue}let r=e.wasRequested();for(let n=o.overscaledZ-1;n>=s;--n){const s=o.scaledTo(n);if(i[s.key])break;if(i[s.key]=!0,e=this.getTile(s),!e&&r&&(e=this._addTile(s)),e&&(t[s.key]=s,r=e.wasRequested(),e.hasData()))break}}return t}_updateLoadedParentTileCache(){this._loadedParentTiles={};for(const e in this._tiles){const t=[];let i,o=this._tiles[e].tileID;for(;o.overscaledZ>0;){if(o.key in this._loadedParentTiles){i=this._loadedParentTiles[o.key];break}t.push(o.key);const e=o.scaledTo(o.overscaledZ-1);if(i=this._getLoadedTile(e),i)break;o=e;}for(const e of t)this._loadedParentTiles[e]=i;}}_addTile(t){let i=this._tiles[t.key];if(i)return !0!==i.isExtraShadowCaster||!!this._shadowCasterTiles[t.key]||this._reloadTile(t.key,"reloading"),i;i=this._cache.getAndRemove(t),i&&(this._setTileReloadTimer(t.key,i),i.tileID=t,this._state.initializeTileState(i,this.map?this.map.painter:null),this._cacheTimers[t.key]&&(clearTimeout(this._cacheTimers[t.key]),delete this._cacheTimers[t.key],this._setTileReloadTimer(t.key,i)));const o=Boolean(i);if(!o){const e=this.map?this.map.painter:null,o=this._source.tileSize*t.overscaleFactor();i="raster-array"===this._source.type?new $t(t,o,this.transform.tileZoom,e,this._isRaster):new Gt(t,o,this.transform.tileZoom,e,this._isRaster),this._loadTile(i,this._tileLoaded.bind(this,i,t.key,i.state));}return i?(i.uses++,this._tiles[t.key]=i,o||this._source.fire(new e.b("dataloading",{tile:i,coord:i.tileID,dataType:"source"})),i):null}_setTileReloadTimer(e,t){e in this._timers&&(clearTimeout(this._timers[e]),delete this._timers[e]);const i=t.getExpiryTimeout();i&&(this._timers[e]=setTimeout((()=>{this._reloadTile(e,"expired"),delete this._timers[e];}),i));}_removeTile(e){const t=this._tiles[e];t&&(t.uses--,delete this._tiles[e],this._timers[e]&&(clearTimeout(this._timers[e]),delete this._timers[e]),t.uses>0||(t.hasData()&&"reloading"!==t.state||"empty"===t.state?this._cache.add(t.tileID,t,t.getExpiryTimeout()):(t.aborted=!0,this._abortTile(t),this._unloadTile(t))));}clearTiles(){this._shouldReloadOnResume=!1,this._paused=!1;for(const e in this._tiles)this._removeTile(+e);this._source._clear&&this._source._clear(),this._cache.reset(),this.map&&this.usedForTerrain&&this.map.painter.terrain&&this.map.painter.terrain.resetTileLookupCache(this.id);}tilesIn(t,i,o){const r=[],s=this.transform;if(!s)return r;const n="globe"===s.projection.name,a=e.a5(s.center.lng);for(const l in this._tiles){const c=this._tiles[l];if(o&&c.clearQueryDebugViz(),c.holdingForFade())continue;let h;if(n){const t=c.tileID.canonical;if(0===t.z){const i=[Math.abs(e.aa(a,...Qt(t,-1))-a),Math.abs(e.aa(a,...Qt(t,1))-a)];h=[0,2*i.indexOf(Math.min(...i))-1];}else {const i=[Math.abs(e.aa(a,...Qt(t,-1))-a),Math.abs(e.aa(a,...Qt(t,0))-a),Math.abs(e.aa(a,...Qt(t,1))-a)];h=[i.indexOf(Math.min(...i))-1];}}else h=[0];for(const e of h){const o=t.containsTile(c,s,i,e);o&&r.push(o);}}return r}getShadowCasterCoordinates(){return this._getRenderableCoordinates(!1,!0)}getVisibleCoordinates(e){return this._getRenderableCoordinates(e)}_getRenderableCoordinates(e,t){const i=this.getRenderableIds(e,t).map((e=>this._tiles[e].tileID)),o="globe"===this.transform.projection.name;for(const e of i)e.projMatrix=this.transform.calculateProjMatrix(e.toUnwrapped()),e.expandedProjMatrix=o?this.transform.calculateProjMatrix(e.toUnwrapped(),!1,!0):e.projMatrix;return i}sortCoordinatesByDistance(e){const t=e.slice(),i=this.transform._camera.position,o=this.transform._camera.forward(),r={};for(const e of t){const t=1/(1<<e.canonical.z);r[e.key]=((e.canonical.x+.5)*t+e.wrap-i[0])*o[0]+((e.canonical.y+.5)*t-i[1])*o[1]-i[2]*o[2];}return t.sort(((e,t)=>r[e.key]-r[t.key])),t}hasTransition(){if(this._source.hasTransition())return !0;if(Jt(this._source.type))for(const t in this._tiles){const i=this._tiles[t];if(void 0!==i.fadeEndTime&&i.fadeEndTime>=e.f.now())return !0}return !1}setFeatureState(e,t,i){this._state.updateState(e=e||"_geojsonTileLayer",t,i);}removeFeatureState(e,t,i){this._state.removeFeatureState(e=e||"_geojsonTileLayer",t,i);}getFeatureState(e,t){return this._state.getState(e=e||"_geojsonTileLayer",t)}setDependencies(e,t,i){const o=this._tiles[e];o&&o.setDependencies(t,i);}reloadTilesForDependencies(e,t){for(const i in this._tiles)this._tiles[i].hasDependency(e,t)&&this._reloadTile(+i,"reloading");this._cache.filter((i=>!i.hasDependency(e,t)));}_preloadTiles(t,i){if(!this._sourceLoaded){const e=()=>{this._sourceLoaded&&(this._source.off("data",e),this._preloadTiles(t,i));};return void this._source.on("data",e)}const o=new Map,r=Array.isArray(t)?t:[t],s=this.map.painter.terrain,n=this.usedForTerrain&&s?s.getScaledDemTileSize():this._source.tileSize;for(const e of r){const t=e.coveringTiles({tileSize:n,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom&&!this.usedForTerrain,reparseOverscaled:this._source.reparseOverscaled,isTerrainDEM:this.usedForTerrain});for(const e of t)o.set(e.key,e);this.usedForTerrain&&e.updateElevation(!1);}const a=Array.from(o.values());e.b1(a,((e,t)=>{const i=new Gt(e,this._source.tileSize*e.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);this._loadTile(i,(e=>{"raster-dem"===this._source.type&&i.dem&&this._backfillDEM(i),t(e,i);}));}),i);}}function Yt(e,t){const i=Math.abs(2*e.wrap)-+(e.wrap<0),o=Math.abs(2*t.wrap)-+(t.wrap<0);return e.overscaledZ-t.overscaledZ||o-i||t.canonical.y-e.canonical.y||t.canonical.x-e.canonical.x}function Jt(e){return "raster"===e||"image"===e||"video"===e||"custom"===e}function Qt(e,t){const i=1<<e.z;return [e.x/i+t,(e.x+1)/i+t]}Kt.maxOverzooming=10,Kt.maxUnderzooming=3;class ei{constructor(e){this.style=e,this.layersGotHidden=!1,this.layers=[];}processLayersChanged(){this.layers=[];const e=!1,t=!1;for(const i in this.style._mergedLayers){const o=this.style._mergedLayers[i];if("fill-extrusion"===o.type)this.layers.push({layer:o,visible:e,visibilityChanged:t});else if("model"===o.type){const i=this.style.getLayerSource(o);i&&"batched-model"===i.type&&this.layers.push({layer:o,visible:e,visibilityChanged:t});}}}onNewFrame(e){this.layersGotHidden=!1;for(const t of this.layers){const i=t.layer;let o=!1;"fill-extrusion"===i.type?o=!i.isHidden(e)&&i.paint.get("fill-extrusion-opacity")>0:"model"===i.type&&(o=!i.isHidden(e)&&i.paint.get("model-opacity")>0),this.layersGotHidden=this.layersGotHidden||!o&&t.visible,t.visible=o;}}updateZOffset(e,t){this.currentBuildingBuckets=[];for(const e of this.layers){const i=e.layer,o=this.style.getLayerSourceCache(i);let r=1;"fill-extrusion"===i.type&&(r=e.visible?i.paint.get("fill-extrusion-vertical-scale"):0);let s=o?o.getTile(t):null;if(!s&&o&&t.canonical.z>o.getSource().minzoom){let e=t.scaledTo(Math.min(o.getSource().maxzoom,t.overscaledZ-1));for(;e.overscaledZ>=o.getSource().minzoom&&(s=o.getTile(e),!s&&0!==e.overscaledZ);)e=e.scaledTo(e.overscaledZ-1);}this.currentBuildingBuckets.push({bucket:s?s.getBucket(i):null,tileID:s?s.tileID:t,verticalScale:r});}e.hasAnyZOffset=!1;let i=!1;for(let o=0;o<e.symbolInstances.length;o++){const r=e.symbolInstances.get(o),s=r.zOffset,n=this._getHeightAtTileOffset(t,r.tileAnchorX,r.tileAnchorY);r.zOffset=n!==Number.NEGATIVE_INFINITY?n:s,i||s===r.zOffset||(i=!0),e.hasAnyZOffset||0===r.zOffset||(e.hasAnyZOffset=!0);}i&&(e.zOffsetBuffersNeedUpload=!0,e.zOffsetSortDirty=!0);}_mapCoordToOverlappingTile(t,i,o,r){let s=i,n=o;if(t.canonical.z!==r.canonical.z){const a=r.canonical,l=1/(1<<t.canonical.z-a.z);s=(i+t.canonical.x*e.V)*l-a.x*e.V|0,n=(o+t.canonical.y*e.V)*l-a.y*e.V|0;}return {tileX:s,tileY:n}}_getHeightAtTileOffset(e,t,i){let o,r;for(let s=0;s<this.layers.length;++s){if("fill-extrusion"!==this.layers[s].layer.type)continue;const{bucket:n,tileID:a,verticalScale:l}=this.currentBuildingBuckets[s];if(!n)continue;const{tileX:c,tileY:h}=this._mapCoordToOverlappingTile(e,t,i,a),u=n.getHeightAtTileCoord(c,h);u&&void 0!==u.height&&(u.hidden?o=u.height:r=Math.max(u.height*l,r||0));}if(void 0!==r)return r;for(let r=0;r<this.layers.length;++r){const s=this.layers[r];if("model"!==s.layer.type||!s.visible)continue;const{bucket:n,tileID:a}=this.currentBuildingBuckets[r];if(!n)continue;const{tileX:l,tileY:c}=this._mapCoordToOverlappingTile(e,t,i,a),h=n.getHeightAtTileCoord(l,c);if(h&&!h.hidden)return void 0===h.height&&void 0!==o?Math.min(h.maxHeight,o)*h.verticalScale:(h.height||0)*h.verticalScale}return this.layersGotHidden?0:Number.NEGATIVE_INFINITY}}function ti(t,i){const o={};for(const e in t)"ref"!==e&&(o[e]=t[e]);return e.b2.forEach((e=>{e in i&&(o[e]=i[e]);})),o}function ii(e){e=e.slice();const t=Object.create(null);for(let i=0;i<e.length;i++)t[e[i].id]=e[i];for(let i=0;i<e.length;i++)"ref"in e[i]&&(e[i]=ti(e[i],t[e[i].ref]));return e}const oi={setStyle:"setStyle",addLayer:"addLayer",removeLayer:"removeLayer",setPaintProperty:"setPaintProperty",setLayoutProperty:"setLayoutProperty",setSlot:"setSlot",setFilter:"setFilter",addSource:"addSource",removeSource:"removeSource",setGeoJSONSourceData:"setGeoJSONSourceData",setLayerZoomRange:"setLayerZoomRange",setLayerProperty:"setLayerProperty",setCenter:"setCenter",setZoom:"setZoom",setBearing:"setBearing",setPitch:"setPitch",setSprite:"setSprite",setGlyphs:"setGlyphs",setTransition:"setTransition",setLight:"setLight",setTerrain:"setTerrain",setFog:"setFog",setCamera:"setCamera",setLights:"setLights",setProjection:"setProjection",addImport:"addImport",removeImport:"removeImport",updateImport:"updateImport"};function ri(e,t,i){i.push({command:oi.addSource,args:[e,t[e]]});}function si(e,t,i){t.push({command:oi.removeSource,args:[e]}),i[e]=!0;}function ni(e,t,i,o){si(e,i,o),ri(e,t,i);}function ai(e,i,o){let r;for(r in e[o])if(e[o].hasOwnProperty(r)&&"data"!==r&&!t(e[o][r],i[o][r]))return !1;for(r in i[o])if(i[o].hasOwnProperty(r)&&"data"!==r&&!t(e[o][r],i[o][r]))return !1;return !0}function li(e,i,o,r,s,n){let a;for(a in i=i||{},e=e||{})e.hasOwnProperty(a)&&(t(e[a],i[a])||o.push({command:n,args:[r,a,i[a],s]}));for(a in i)i.hasOwnProperty(a)&&!e.hasOwnProperty(a)&&(t(e[a],i[a])||o.push({command:n,args:[r,a,i[a],s]}));}function ci(e){return e.id}function hi(e,t){return e[t.id]=t,e}class ui{constructor(e,t){this.reset(e,t);}reset(e,t){this.points=e||[],this._distances=[0];for(let e=1;e<this.points.length;e++)this._distances[e]=this._distances[e-1]+this.points[e].dist(this.points[e-1]);this.length=this._distances[this._distances.length-1],this.padding=Math.min(t||0,.5*this.length),this.paddedLength=this.length-2*this.padding;}lerp(t){if(1===this.points.length)return this.points[0];t=e.aa(t,0,1);let i=1,o=this._distances[i];const r=t*this.paddedLength+this.padding;for(;o<r&&i<this._distances.length;)o=this._distances[++i];const s=i-1,n=this._distances[s],a=o-n,l=a>0?(r-n)/a:0;return this.points[s].mult(1-l).add(this.points[i].mult(l))}}class di{constructor(e,t,i){const o=this.boxCells=[],r=this.circleCells=[];this.xCellCount=Math.ceil(e/i),this.yCellCount=Math.ceil(t/i);for(let e=0;e<this.xCellCount*this.yCellCount;e++)o.push([]),r.push([]);this.circleKeys=[],this.boxKeys=[],this.bboxes=[],this.circles=[],this.width=e,this.height=t,this.xScale=this.xCellCount/e,this.yScale=this.yCellCount/t,this.boxUid=0,this.circleUid=0;}keysLength(){return this.boxKeys.length+this.circleKeys.length}insert(e,t,i,o,r){this._forEachCell(t,i,o,r,this._insertBoxCell,this.boxUid++),this.boxKeys.push(e),this.bboxes.push(t),this.bboxes.push(i),this.bboxes.push(o),this.bboxes.push(r);}insertCircle(e,t,i,o){this._forEachCell(t-o,i-o,t+o,i+o,this._insertCircleCell,this.circleUid++),this.circleKeys.push(e),this.circles.push(t),this.circles.push(i),this.circles.push(o);}_insertBoxCell(e,t,i,o,r,s){this.boxCells[r].push(s);}_insertCircleCell(e,t,i,o,r,s){this.circleCells[r].push(s);}_query(e,t,i,o,r,s){if(i<0||e>this.width||o<0||t>this.height)return !r&&[];const n=[];if(e<=0&&t<=0&&this.width<=i&&this.height<=o){if(r)return !0;for(let e=0;e<this.boxKeys.length;e++)n.push({key:this.boxKeys[e],x1:this.bboxes[4*e],y1:this.bboxes[4*e+1],x2:this.bboxes[4*e+2],y2:this.bboxes[4*e+3]});for(let e=0;e<this.circleKeys.length;e++){const t=this.circles[3*e],i=this.circles[3*e+1],o=this.circles[3*e+2];n.push({key:this.circleKeys[e],x1:t-o,y1:i-o,x2:t+o,y2:i+o});}return s?n.filter(s):n}return this._forEachCell(e,t,i,o,this._queryCell,n,{hitTest:r,seenUids:{box:{},circle:{}}},s),r?n.length>0:n}_queryCircle(e,t,i,o,r){const s=e-i,n=e+i,a=t-i,l=t+i;if(n<0||s>this.width||l<0||a>this.height)return !o&&[];const c=[];return this._forEachCell(s,a,n,l,this._queryCellCircle,c,{hitTest:o,circle:{x:e,y:t,radius:i},seenUids:{box:{},circle:{}}},r),o?c.length>0:c}query(e,t,i,o,r){return this._query(e,t,i,o,!1,r)}hitTest(e,t,i,o,r){return this._query(e,t,i,o,!0,r)}hitTestCircle(e,t,i,o){return this._queryCircle(e,t,i,!0,o)}_queryCell(e,t,i,o,r,s,n,a){const l=n.seenUids,c=this.boxCells[r];if(null!==c){const r=this.bboxes;for(const h of c)if(!l.box[h]){l.box[h]=!0;const c=4*h;if(e<=r[c+2]&&t<=r[c+3]&&i>=r[c+0]&&o>=r[c+1]&&(!a||a(this.boxKeys[h]))){if(n.hitTest)return s.push(!0),!0;s.push({key:this.boxKeys[h],x1:r[c],y1:r[c+1],x2:r[c+2],y2:r[c+3]});}}}const h=this.circleCells[r];if(null!==h){const r=this.circles;for(const c of h)if(!l.circle[c]){l.circle[c]=!0;const h=3*c;if(this._circleAndRectCollide(r[h],r[h+1],r[h+2],e,t,i,o)&&(!a||a(this.circleKeys[c]))){if(n.hitTest)return s.push(!0),!0;{const e=r[h],t=r[h+1],i=r[h+2];s.push({key:this.circleKeys[c],x1:e-i,y1:t-i,x2:e+i,y2:t+i});}}}}}_queryCellCircle(e,t,i,o,r,s,n,a){const l=n.circle,c=n.seenUids,h=this.boxCells[r];if(null!==h){const e=this.bboxes;for(const t of h)if(!c.box[t]){c.box[t]=!0;const i=4*t;if(this._circleAndRectCollide(l.x,l.y,l.radius,e[i+0],e[i+1],e[i+2],e[i+3])&&(!a||a(this.boxKeys[t])))return s.push(!0),!0}}const u=this.circleCells[r];if(null!==u){const e=this.circles;for(const t of u)if(!c.circle[t]){c.circle[t]=!0;const i=3*t;if(this._circlesCollide(e[i],e[i+1],e[i+2],l.x,l.y,l.radius)&&(!a||a(this.circleKeys[t])))return s.push(!0),!0}}}_forEachCell(e,t,i,o,r,s,n,a){const l=this._convertToXCellCoord(e),c=this._convertToYCellCoord(t),h=this._convertToXCellCoord(i),u=this._convertToYCellCoord(o);for(let d=l;d<=h;d++)for(let l=c;l<=u;l++)if(r.call(this,e,t,i,o,this.xCellCount*l+d,s,n,a))return}_convertToXCellCoord(e){return Math.max(0,Math.min(this.xCellCount-1,Math.floor(e*this.xScale)))}_convertToYCellCoord(e){return Math.max(0,Math.min(this.yCellCount-1,Math.floor(e*this.yScale)))}_circlesCollide(e,t,i,o,r,s){const n=o-e,a=r-t,l=i+s;return l*l>n*n+a*a}_circleAndRectCollide(e,t,i,o,r,s,n){const a=(s-o)/2,l=Math.abs(e-(o+a));if(l>a+i)return !1;const c=(n-r)/2,h=Math.abs(t-(r+c));if(h>c+i)return !1;if(l<=a||h<=c)return !0;const u=l-a,d=h-c;return u*u+d*d<=i*i}}const _i={unknown:0,flipRequired:1,flipNotRequired:2},pi=Math.tan(85*Math.PI/180);function fi(t,i,o,r,s,n,a){const l=e.a6.create();if(o)if("globe"===n.name){const t=e.b3(s,i);e.a6.multiply(l,l,t);}else {const t=e.b4.invert([],a);l[0]=t[0],l[1]=t[1],l[4]=t[2],l[5]=t[3],r||e.a6.rotateZ(l,l,s.angle);}else e.a6.multiply(l,s.labelPlaneMatrix,t);return l}function mi(e,t,i,o,r,s,n){const a=fi(e,t,i,o,r,s,n);return "globe"===s.name&&i||(a[2]=a[6]=a[10]=a[14]=0),a}function gi(t,i,o,r,s,n,a){if(o){if("globe"===n.name){const l=fi(t,i,o,r,s,n,a);return e.a6.invert(l,l),e.a6.multiply(l,t,l),l}{const i=e.a6.clone(t),o=e.a6.identity([]);return o[0]=a[0],o[1]=a[1],o[4]=a[2],o[5]=a[3],e.a6.multiply(i,i,o),r||e.a6.rotateZ(i,i,-s.angle),i}}return s.glCoordMatrix}function vi(t,i,o,r){const s=[t,i,o,1];o?e.a7.transformMat4(s,s,r):Li(s,s,r);const n=s[3];return s[0]/=n,s[1]/=n,s[2]/=n,s}function xi(e,t){return Math.min(.5+e/t*.5,1.5)}function yi(e,t){const i=e[0]/e[3],o=e[1]/e[3];return i>=-t[0]&&i<=t[0]&&o>=-t[1]&&o<=t[1]}function bi(t,i,o,r,s,n,a,l,c,h){const u=o.transform,d=r?t.textSizeData:t.iconSizeData,_=e.b5(d,o.transform.zoom),p="globe"===u.projection.name,f=[256/o.width*2+1,256/o.height*2+1],m=r?t.text.dynamicLayoutVertexArray:t.icon.dynamicLayoutVertexArray;m.clear();let g=null;p&&(g=r?t.text.globeExtVertexArray:t.icon.globeExtVertexArray);const v=t.lineVertexArray,x=r?t.text.placedSymbolArray:t.icon.placedSymbolArray,y=o.transform.width/o.transform.height;let b,w=!1;for(let r=0;r<x.length;r++){const p=x.get(r),{numGlyphs:T,writingMode:E}=p;if(E!==e.b6.vertical||w||b===e.b6.horizontal||(w=!0),b=E,(p.hidden||E===e.b6.vertical)&&!w){Di(T,m);continue}w=!1;const S=new e.P(p.tileAnchorX,p.tileAnchorY);let{x:C,y:I,z:D}=u.projection.projectTilePoint(S.x,S.y,h.canonical);if(c){const[e,t,i]=c(S);C+=e,I+=t,D+=i;}const L=[C,I,D,1];if(e.a7.transformMat4(L,L,i),!yi(L,f)){Di(T,m);continue}const A=L[3],R=xi(o.transform.getCameraToCenterDistance(u.projection),A),P=e.b7(d,_,p),M=a?P/R:P*R,z=vi(C,I,D,s);if(z[3]<=0){Di(T,m);continue}let O={};const F=a?null:c,B=Ei(p,M,!1,l,i,s,n,t.glyphOffsetArray,v,m,g,z,S,O,y,F,u.projection,h,a);w=B.useVertical,F&&B.needsFlipping&&(O={}),(B.notEnoughRoom||w||B.needsFlipping&&Ei(p,M,!0,l,i,s,n,t.glyphOffsetArray,v,m,g,z,S,O,y,F,u.projection,h,a).notEnoughRoom)&&Di(T,m);}r?(t.text.dynamicLayoutVertexBuffer.updateData(m),g&&t.text.globeExtVertexBuffer&&t.text.globeExtVertexBuffer.updateData(g)):(t.icon.dynamicLayoutVertexBuffer.updateData(m),g&&t.icon.globeExtVertexBuffer&&t.icon.globeExtVertexBuffer.updateData(g));}function wi(e,t,i,o,r,s,n,a,l,c,h,u,d,_,p,f){const{lineStartIndex:m,glyphStartIndex:g,segment:v}=a,x=g+a.numGlyphs,y=m+a.lineLength,b=t.getoffsetX(g),w=t.getoffsetX(x-1),T=Ii(e*b,i,o,r,s,n,v,m,y,l,c,h,u,d,!0,_,p,f);if(!T)return null;const E=Ii(e*w,i,o,r,s,n,v,m,y,l,c,h,u,d,!0,_,p,f);return E?{first:T,last:E}:null}function Ti(t,i,o,r){return t===e.b6.horizontal&&Math.abs(r)>Math.abs(o)?{useVertical:!0}:t===e.b6.vertical?r>0?{needsFlipping:!0}:null:i!==_i.unknown&&function(e,t){return 0===e||Math.abs(t/e)>pi}(o,r)?i===_i.flipRequired?{needsFlipping:!0}:null:o<0?{needsFlipping:!0}:null}function Ei(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g,v,x){const y=i/24,b=t.lineOffsetX*y,w=t.lineOffsetY*y,{lineStartIndex:T,glyphStartIndex:E,numGlyphs:S,segment:C,writingMode:I,flipState:D}=t,L=T+t.lineLength,A=t=>{if(u){const[i,o,r]=t.up,s=h.length;e.b8(u,s+0,i,o,r),e.b8(u,s+1,i,o,r),e.b8(u,s+2,i,o,r),e.b8(u,s+3,i,o,r);}const[i,o,r]=t.point;e.b9(h,i,o,r,t.angle);};if(S>1){const e=wi(y,l,b,w,o,d,_,t,c,n,p,m,!1,g,v,x);if(!e)return {notEnoughRoom:!0};if(r&&!o){let[i,o,r]=e.first.point,[s,n,l]=e.last.point;[i,o]=vi(i,o,r,a),[s,n]=vi(s,n,l,a);const c=Ti(I,D,(s-i)*f,n-o);if(t.flipState=c&&c.needsFlipping?_i.flipRequired:_i.flipNotRequired,c)return c}A(e.first);for(let e=E+1;e<E+S-1;e++){const t=Ii(y*l.getoffsetX(e),b,w,o,d,_,C,T,L,c,n,p,m,!1,!1,g,v,x);if(!t)return h.length-=4*(e-E),{notEnoughRoom:!0};A(t);}A(e.last);}else {if(r&&!o){const i=vi(_.x,_.y,0,s),o=T+C+1,r=new e.P(c.getx(o),c.gety(o)),n=vi(r.x,r.y,0,s),a=n[3]>0?n:Ci(_,r,i,1,s,void 0,g,v.canonical),l=Ti(I,D,(a[0]-i[0])*f,a[1]-i[1]);if(t.flipState=l&&l.needsFlipping?_i.flipRequired:_i.flipNotRequired,l)return l}const i=Ii(y*l.getoffsetX(E),b,w,o,d,_,C,T,L,c,n,p,m,!1,!1,g,v,x);if(!i)return {notEnoughRoom:!0};A(i);}return {}}function Si(e,t,i,o,r){const{x:s,y:n,z:a}=o.projectTilePoint(e.x,e.y,t);if(!r)return vi(s,n,a,i);const[l,c,h]=r(e);return vi(s+l,n+c,a+h,i)}function Ci(t,i,o,r,s,n,a,l){const c=Si(t.sub(i)._unit()._add(t),l,s,a,n);return e.N.sub(c,o,c),e.N.normalize(c,c),e.N.scaleAndAdd(c,o,c,r)}function Ii(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g,v){const x=r?t-i:t+i;let y=x>0?1:-1,b=0;r&&(y*=-1,b=Math.PI),y<0&&(b+=Math.PI);let w=l+a+(y>0?0:1)|0,T=s,E=s,S=0,C=0;const I=Math.abs(x),D=[],L=[];let A=n,R=A;const P=()=>Ci(R,A,E,I-S+1,u,_,m,g.canonical);for(;S+C<=I;){if(w+=y,w<l||w>=c)return null;if(E=T,R=A,D.push(E),p&&L.push(R),A=new e.P(h.getx(w),h.gety(w)),T=d[w],!T){const e=Si(A,g.canonical,u,m,_);T=e[3]>0?d[w]=e:P();}S+=C,C=e.N.distance(E,T);}f&&_&&(d[w]&&(T=P(),C=e.N.distance(E,T)),d[w]=T);const M=(I-S)/C,z=A.sub(R)._mult(M)._add(R),O=e.N.sub([],T,E),F=e.N.scaleAndAdd([],E,O,M);let B=[0,0,1],k=O[0],N=O[1];if(v&&(B=m.upVector(g.canonical,z.x,z.y),0!==B[0]||0!==B[1]||1!==B[2])){const t=[B[2],0,-B[0]],i=e.N.cross([],B,t);e.N.normalize(t,t),e.N.normalize(i,i),k=e.N.dot(O,t),N=e.N.dot(O,i);}if(o){const t=e.N.cross([],B,O);e.N.normalize(t,t),e.N.scaleAndAdd(F,F,t,o*y);}const U=b+Math.atan2(N,k);return D.push(F),p&&L.push(z),{point:F,angle:U,path:D,tilePath:L,up:B}}function Di(e,t){const i=t.length,o=i+4*e;t.resize(o),t.float32.fill(-1/0,4*i,4*o);}function Li(e,t,i){const o=t[0],r=t[1];return e[0]=i[0]*o+i[4]*r+i[12],e[1]=i[1]*o+i[5]*r+i[13],e[3]=i[3]*o+i[7]*r+i[15],e}const Ai=100;class Ri{constructor(e,t,i=new di(e.width+200,e.height+200,25),o=new di(e.width+200,e.height+200,25)){this.transform=e,this.grid=i,this.ignoredGrid=o,this.pitchfactor=Math.cos(e._pitch)*e.cameraToCenterDistance,this.screenRightBoundary=e.width+Ai,this.screenBottomBoundary=e.height+Ai,this.gridRightBoundary=e.width+200,this.gridBottomBoundary=e.height+200,this.fogState=t;}placeCollisionBox(e,t,i,o,r,s,n,a){let l=i.projectedAnchorX,c=i.projectedAnchorY,h=i.projectedAnchorZ;const u=i.elevation,d=i.tileID,_=e.getProjection();if(u&&d){const[e,t,o]=_.upVector(d.canonical,i.tileAnchorX,i.tileAnchorY),r=_.upVectorScale(d.canonical,this.transform.center.lat,this.transform.worldSize).metersToTile;l+=e*u*r,c+=t*u*r,h+=o*u*r;}const p=this.projectAndGetPerspectiveRatio(n,l,c,h,i.tileID,"globe"===_.name||!!u||this.transform.pitch>0,_),f=s*p.perspectiveRatio,m=(i.x1*t+o.x-i.padding)*f+p.point.x,g=(i.y1*t+o.y-i.padding)*f+p.point.y,v=(i.x2*t+o.x+i.padding)*f+p.point.x,x=(i.y2*t+o.y+i.padding)*f+p.point.y,y=p.perspectiveRatio<=.55||p.occluded;return !this.isInsideGrid(m,g,v,x)||!r&&this.grid.hitTest(m,g,v,x,a)||y?{box:[],offscreen:!1,occluded:p.occluded}:{box:[m,g,v,x],offscreen:this.isOffscreen(m,g,v,x),occluded:!1}}placeCollisionCircles(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f){const m=[],g=this.transform.elevation,v=t.getProjection(),x=g?g.getAtTileOffsetFunc(f,this.transform.center.lat,this.transform.worldSize,v):null,y=new e.P(o.tileAnchorX,o.tileAnchorY);let{x:b,y:w,z:T}=v.projectTilePoint(y.x,y.y,f.canonical);if(x){const[e,t,i]=x(y);b+=e,w+=t,T+=i;}const E="globe"===v.name,S=this.projectAndGetPerspectiveRatio(a,b,w,T,f,E||!!g||this.transform.pitch>0,v),{perspectiveRatio:C}=S,I=(u?n/C:n*C)/e.bc,D=vi(b,w,T,l),L=S.signedDistanceFromCamera>0?wi(I,s,o.lineOffsetX*I,o.lineOffsetY*I,!1,D,y,o,r,l,{},g&&!u?x:null,u&&!!g,v,f,u):null;let A=!1,R=!1,P=!0;if(L&&!S.occluded){const t=.5*_*C+p,o=new e.P(-100,-100),r=new e.P(this.screenRightBoundary,this.screenBottomBoundary),s=new ui,{first:n,last:a}=L,l=n.path.length;let u=[];for(let e=l-1;e>=1;e--)u.push(n.path[e]);for(let e=1;e<a.path.length;e++)u.push(a.path[e]);const f=2.5*t;c&&(u=u.map((([e,t,i],o)=>(x&&!E&&(i=x(o<l-1?n.tilePath[l-1-o]:a.tilePath[o-l+2])[2]),vi(e,t,i,c)))),u.some((e=>e[3]<=0))&&(u=[]));let g=[];if(u.length>0){let t=1/0,i=-1/0,s=1/0,n=-1/0;for(const e of u)t=Math.min(t,e[0]),s=Math.min(s,e[1]),i=Math.max(i,e[0]),n=Math.max(n,e[1]);i>=o.x&&t<=r.x&&n>=o.y&&s<=r.y&&(g=[u.map((t=>new e.P(t[0],t[1])))],(t<o.x||i>r.x||s<o.y||n>r.y)&&(g=e.ba(g,o.x,o.y,r.x,r.y)));}for(const e of g){s.reset(e,.25*t);let o=0;o=s.length<=.5*t?1:Math.ceil(s.paddedLength/f)+1;for(let e=0;e<o;e++){const r=e/Math.max(o-1,1),n=s.lerp(r),a=n.x+Ai,l=n.y+Ai;m.push(a,l,t,0);const c=a-t,u=l-t,_=a+t,p=l+t;if(P=P&&this.isOffscreen(c,u,_,p),R=R||this.isInsideGrid(c,u,_,p),!i&&this.grid.hitTestCircle(a,l,t,d)&&(A=!0,!h))return {circles:[],offscreen:!1,collisionDetected:A,occluded:!1}}}}return {circles:!h&&A||!R?[]:m,offscreen:P,collisionDetected:A,occluded:S.occluded}}queryRenderedSymbols(t){if(0===t.length||0===this.grid.keysLength()&&0===this.ignoredGrid.keysLength())return {};const i=[];let o=1/0,r=1/0,s=-1/0,n=-1/0;for(const a of t){const t=new e.P(a.x+Ai,a.y+Ai);o=Math.min(o,t.x),r=Math.min(r,t.y),s=Math.max(s,t.x),n=Math.max(n,t.y),i.push(t);}const a=this.grid.query(o,r,s,n).concat(this.ignoredGrid.query(o,r,s,n)),l={},c={};for(const t of a){const o=t.key;if(void 0===l[o.bucketInstanceId]&&(l[o.bucketInstanceId]={}),l[o.bucketInstanceId][o.featureIndex])continue;const r=[new e.P(t.x1,t.y1),new e.P(t.x2,t.y1),new e.P(t.x2,t.y2),new e.P(t.x1,t.y2)];e.bb(i,r)&&(l[o.bucketInstanceId][o.featureIndex]=!0,void 0===c[o.bucketInstanceId]&&(c[o.bucketInstanceId]=[]),c[o.bucketInstanceId].push(o.featureIndex));}return c}insertCollisionBox(e,t,i,o,r){(t?this.ignoredGrid:this.grid).insert({bucketInstanceId:i,featureIndex:o,collisionGroupID:r},e[0],e[1],e[2],e[3]);}insertCollisionCircles(e,t,i,o,r){const s=t?this.ignoredGrid:this.grid,n={bucketInstanceId:i,featureIndex:o,collisionGroupID:r};for(let t=0;t<e.length;t+=4)s.insertCircle(n,e[t],e[t+1],e[t+2]);}projectAndGetPerspectiveRatio(t,i,o,r,s,n,a){const l=[i,o,r,1];let c=!1;if(r||this.transform.pitch>0){if(e.a7.transformMat4(l,l,t),this.fogState&&s&&"globe"!==a.name){const t=function(t,i,o,r,s,n){const a=n.calculateFogTileMatrix(s),l=[i,o,r];return e.N.transformMat4(l,l,a),ge(t,e.N.length(l),n.pitch,n._fov)}(this.fogState,i,o,r,s.toUnwrapped(),this.transform);c=t>.9;}}else Li(l,l,t);const h=l[3];return {point:new e.P((l[0]/h+1)/2*this.transform.width+Ai,(-l[1]/h+1)/2*this.transform.height+Ai),perspectiveRatio:Math.min(.5+this.transform.getCameraToCenterDistance(a)/h*.5,1.5),signedDistanceFromCamera:h,occluded:n&&l[2]>h||c}}isOffscreen(e,t,i,o){return i<Ai||e>=this.screenRightBoundary||o<Ai||t>this.screenBottomBoundary}isInsideGrid(e,t,i,o){return i>=0&&e<this.gridRightBoundary&&o>=0&&t<this.gridBottomBoundary}getViewportMatrix(){const t=e.a6.identity([]);return e.a6.translate(t,t,[-100,-100,0]),t}}function Pi(t,i,o){const r=i.createTileMatrix(t,t.worldSize,o.toUnwrapped());return e.a6.multiply(new Float32Array(16),t.projMatrix,r)}function Mi(e,t,i){if(t.projection.name===i.projection.name)return e.projMatrix;const o=i.clone();return o.setProjection(t.projection),Pi(o,t.getProjection(),e)}function zi(e,t,i){return t.name===i.projection.name?e.projMatrix:Pi(i,t,e)}class Oi{constructor(e,t,i,o){this.opacity=e?Math.max(0,Math.min(1,e.opacity+(e.placed?t:-t))):o&&i?1:0,this.placed=i;}isHidden(){return 0===this.opacity&&!this.placed}}class Fi{constructor(e,t,i,o,r,s=!1){this.text=new Oi(e?e.text:null,t,i,r),this.icon=new Oi(e?e.icon:null,t,o,r),this.clipped=s;}isHidden(){return this.text.isHidden()&&this.icon.isHidden()}}class Bi{constructor(e,t,i,o=!1){this.text=e,this.icon=t,this.skipFade=i,this.clipped=o;}}class ki{constructor(){this.invProjMatrix=e.a6.create(),this.viewportMatrix=e.a6.create(),this.circles=[];}}class Ni{constructor(e,t,i,o,r){this.bucketInstanceId=e,this.featureIndex=t,this.sourceLayerIndex=i,this.bucketIndex=o,this.tileID=r;}}class Ui{constructor(e){this.crossSourceCollisions=e,this.maxGroupID=0,this.collisionGroups={};}get(e){if(this.crossSourceCollisions)return {ID:0,predicate:null};if(!this.collisionGroups[e]){const t=++this.maxGroupID;this.collisionGroups[e]={ID:t,predicate:e=>e.collisionGroupID===t};}return this.collisionGroups[e]}}function Gi(t,i,o,r,s){const{horizontalAlign:n,verticalAlign:a}=e.bf(t),l=-(n-.5)*i,c=-(a-.5)*o,h=e.bd(t,r);return new e.P(l+h[0]*s,c+h[1]*s)}function ji(t,i,o,r,s){const n=new e.P(t,i);return o&&n._rotate(r?s:-s),n}class Vi{constructor(e,t,i,o,r,s){this.transform=e.clone(),this.projection=e.projection.name,this.collisionIndex=new Ri(this.transform,r),this.buildingIndex=s,this.placements={},this.opacities={},this.variableOffsets={},this.stale=!1,this.commitTime=0,this.fadeDuration=t,this.retainedQueryData={},this.collisionGroups=new Ui(i),this.collisionCircleArrays={},this.prevPlacement=o,o&&(o.prevPlacement=void 0),this.placedOrientations={};}getBucketParts(t,i,o,r){const s=o.getBucket(i),n=o.latestFeatureIndex;if(!s||!n||i.fqid!==s.layerIds[0])return;const a=s.layers[0].layout,l=o.collisionBoxArray,c=Math.pow(2,this.transform.zoom-o.tileID.overscaledZ),h=o.tileSize/e.V,u=o.tileID.toUnwrapped();this.transform.setProjection(s.projection);const d=(_=o.tileID,p=s.getProjection(),f=this.transform,p.name===this.projection?f.calculateProjMatrix(_.toUnwrapped()):Pi(f,p,_));var _,p,f;const m="map"===a.get("text-pitch-alignment"),g="map"===a.get("text-rotation-alignment");i.compileFilter();const v=i.dynamicFilter(),x=i.dynamicFilterNeedsFeature(),y=this.transform.calculatePixelsToTileUnitsMatrix(o),b=mi(d,o.tileID.canonical,m,g,this.transform,s.getProjection(),y);let w=null;if(m){const t=gi(d,o.tileID.canonical,m,g,this.transform,s.getProjection(),y);w=e.a6.multiply([],this.transform.labelPlaneMatrix,t);}let T=null;v&&o.latestFeatureIndex&&(T={unwrappedTileID:u,dynamicFilter:v,dynamicFilterNeedsFeature:x,featureIndex:o.latestFeatureIndex}),this.retainedQueryData[s.bucketInstanceId]=new Ni(s.bucketInstanceId,n,s.sourceLayerIndex,s.index,o.tileID);const E={bucket:s,layout:a,posMatrix:d,textLabelPlaneMatrix:b,labelToScreenMatrix:w,clippingData:T,scale:c,textPixelRatio:h,holdingForFade:o.holdingForFade(),collisionBoxArray:l,partiallyEvaluatedTextSize:e.b5(s.textSizeData,this.transform.zoom),partiallyEvaluatedIconSize:e.b5(s.iconSizeData,this.transform.zoom),collisionGroup:this.collisionGroups.get(s.sourceID)};if(r)for(const e of s.sortKeyRanges){const{sortKey:i,symbolInstanceStart:o,symbolInstanceEnd:r}=e;t.push({sortKey:i,symbolInstanceStart:o,symbolInstanceEnd:r,parameters:E});}else t.push({symbolInstanceStart:0,symbolInstanceEnd:s.symbolInstances.length,parameters:E});}attemptAnchorPlacement(e,t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g){const{textOffset0:v,textOffset1:x,crossTileID:y}=u,b=[v,x],w=Gi(e,i,o,b,r),T=this.collisionIndex.placeCollisionBox(_,r,t,ji(w.x,w.y,s,n,this.transform.angle),h,a,l,c.predicate);if(f){const e=_.getSymbolInstanceIconSize(g,this.transform.zoom,u.placedIconSymbolIndex);if(0===this.collisionIndex.placeCollisionBox(_,e,f,ji(w.x,w.y,s,n,this.transform.angle),h,a,l,c.predicate).box.length)return}if(T.box.length>0){let t;return this.prevPlacement&&this.prevPlacement.variableOffsets[y]&&this.prevPlacement.placements[y]&&this.prevPlacement.placements[y].text&&(t=this.prevPlacement.variableOffsets[y].anchor),this.variableOffsets[y]={textOffset:b,width:i,height:o,anchor:e,textScale:r,prevAnchor:t},this.markUsedJustification(_,e,u,p),_.allowVerticalPlacement&&(this.markUsedOrientation(_,p,u),this.placedOrientations[y]=p),{shift:w,placedGlyphBoxes:T}}}placeLayerBucketPart(t,i,o,r){const{bucket:s,layout:n,posMatrix:a,textLabelPlaneMatrix:l,labelToScreenMatrix:c,clippingData:h,textPixelRatio:u,holdingForFade:d,collisionBoxArray:_,partiallyEvaluatedTextSize:p,partiallyEvaluatedIconSize:f,collisionGroup:m}=t.parameters,g=n.get("text-optional"),v=n.get("icon-optional"),x=n.get("text-allow-overlap"),y=n.get("icon-allow-overlap"),b="map"===n.get("text-rotation-alignment"),w="map"===n.get("text-pitch-alignment"),T="viewport-y"===n.get("symbol-z-order"),E=n.get("symbol-z-elevate");this.transform.setProjection(s.projection);let S=x&&(y||!s.hasIconData()||v),C=y&&(x||!s.hasTextData()||g);!s.collisionArrays&&_&&s.deserializeCollisionBoxes(_),o&&r&&s.updateCollisionDebugBuffers(this.transform.zoom,_);const I=(t,r,_)=>{const{crossTileID:T,numVerticalGlyphVertices:E}=t;if(h){const o={zoom:this.transform.zoom,pitch:this.transform.pitch};let r=null;if(h.dynamicFilterNeedsFeature){const e=this.retainedQueryData[s.bucketInstanceId];r=h.featureIndex.loadFeature({featureIndex:t.featureIndex,bucketIndex:e.bucketIndex,sourceLayerIndex:e.sourceLayerIndex,layoutVertexArrayOffset:0});}if(!(0, h.dynamicFilter)(o,r,this.retainedQueryData[s.bucketInstanceId].tileID.canonical,new e.P(t.tileAnchorX,t.tileAnchorY),this.transform.calculateDistanceTileData(h.unwrappedTileID)))return this.placements[T]=new Bi(!1,!1,!1,!0),void i.add(T)}if(i.has(T))return;if(d)return void(this.placements[T]=new Bi(!1,!1,!1));let I=!1,D=!1,L=!0,A=!1,R=!1,P=null,M={box:null,offscreen:null,occluded:null},z={box:null,offscreen:null,occluded:null},O=null,F=null,B=null,k=0,N=0,U=0;_.textFeatureIndex?k=_.textFeatureIndex:t.useRuntimeCollisionCircles&&(k=t.featureIndex),_.verticalTextFeatureIndex&&(N=_.verticalTextFeatureIndex);const G=e=>{e.tileID=this.retainedQueryData[s.bucketInstanceId].tileID;const i=this.transform.elevation;e.elevation=t.zOffset+(i?i.getAtTileOffset(e.tileID,e.tileAnchorX,e.tileAnchorY):0);},j=_.textBox;if(j){G(j);const i=i=>{let o=e.b6.horizontal;if(s.allowVerticalPlacement&&!i&&this.prevPlacement){const e=this.prevPlacement.placedOrientations[T];e&&(this.placedOrientations[T]=e,o=e,this.markUsedOrientation(s,o,t));}return o},o=(t,i)=>{if(s.allowVerticalPlacement&&E>0&&_.verticalTextBox){for(const o of s.writingModes)if(o===e.b6.vertical?(M=i(),z=M):M=t(),M&&M.box&&M.box.length)break}else M=t();};if(n.get("text-variable-anchor")){let l=n.get("text-variable-anchor");if(this.prevPlacement&&this.prevPlacement.variableOffsets[T]){const e=this.prevPlacement.variableOffsets[T];l.indexOf(e.anchor)>0&&(l=l.filter((t=>t!==e.anchor)),l.unshift(e.anchor));}const c=(e,i,o)=>{const n=s.getSymbolInstanceTextSize(p,t,this.transform.zoom,r),c=(e.x2-e.x1)*n+2*e.padding,h=(e.y2-e.y1)*n+2*e.padding,d=t.hasIconTextFit&&!y?i:null;d&&G(d);let _={box:[],offscreen:!1,occluded:!1};const g=x?2*l.length:l.length;for(let i=0;i<g;++i){const g=this.attemptAnchorPlacement(l[i%l.length],e,c,h,n,b,w,u,a,m,i>=l.length,t,r,s,o,d,p,f);if(g&&(_=g.placedGlyphBoxes,_&&_.box&&_.box.length)){I=!0,P=g.shift;break}}return _};o((()=>c(j,_.iconBox,e.b6.horizontal)),(()=>{const t=_.verticalTextBox;return t&&G(t),s.allowVerticalPlacement&&!(M&&M.box&&M.box.length)&&E>0&&t?c(t,_.verticalIconBox,e.b6.vertical):{box:null,offscreen:null,occluded:null}})),M&&(I=M.box,L=M.offscreen,A=M.occluded);const h=i(!(!M||!M.box));if(!I&&this.prevPlacement){const e=this.prevPlacement.variableOffsets[T];e&&(this.variableOffsets[T]=e,this.markUsedJustification(s,e.anchor,t,h));}}else {const n=(i,o)=>{const n=s.getSymbolInstanceTextSize(p,t,this.transform.zoom,r),l=this.collisionIndex.placeCollisionBox(s,n,i,new e.P(0,0),x,u,a,m.predicate);return l&&l.box&&l.box.length&&(this.markUsedOrientation(s,o,t),this.placedOrientations[T]=o),l};o((()=>n(j,e.b6.horizontal)),(()=>{const t=_.verticalTextBox;return s.allowVerticalPlacement&&E>0&&t?(G(t),n(t,e.b6.vertical)):{box:null,offscreen:null,occluded:null}})),i(!!(M&&M.box&&M.box.length));}}if(O=M,I=O&&O.box&&O.box.length>0,L=O&&O.offscreen,A=O&&O.occluded,t.useRuntimeCollisionCircles){const i=s.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex>=0?t.centerJustifiedTextSymbolIndex:t.verticalPlacedTextSymbolIndex),r=e.b7(s.textSizeData,p,i),h=n.get("text-padding");F=this.collisionIndex.placeCollisionCircles(s,x,i,s.lineVertexArray,s.glyphOffsetArray,r,a,l,c,o,w,m.predicate,t.collisionCircleDiameter*r/e.bc,h,this.retainedQueryData[s.bucketInstanceId].tileID),I=x||F.circles.length>0&&!F.collisionDetected,L=L&&F.offscreen,A=F.occluded;}if(_.iconFeatureIndex&&(U=_.iconFeatureIndex),_.iconBox){const i=i=>{G(i);const o=t.hasIconTextFit&&P?ji(P.x,P.y,b,w,this.transform.angle):new e.P(0,0),r=s.getSymbolInstanceIconSize(f,this.transform.zoom,t.placedIconSymbolIndex);return this.collisionIndex.placeCollisionBox(s,r,i,o,y,u,a,m.predicate)};z&&z.box&&z.box.length&&_.verticalIconBox?(B=i(_.verticalIconBox),D=B.box.length>0):(B=i(_.iconBox),D=B.box.length>0),L=L&&B.offscreen,R=B.occluded;}const V=g||0===t.numHorizontalGlyphVertices&&0===E,Z=v||0===t.numIconVertices;if(V||Z?Z?V||(D=D&&I):I=D&&I:D=I=D&&I,I&&O&&O.box&&this.collisionIndex.insertCollisionBox(O.box,n.get("text-ignore-placement"),s.bucketInstanceId,z&&z.box&&N?N:k,m.ID),D&&B&&this.collisionIndex.insertCollisionBox(B.box,n.get("icon-ignore-placement"),s.bucketInstanceId,U,m.ID),F&&(I&&this.collisionIndex.insertCollisionCircles(F.circles,n.get("text-ignore-placement"),s.bucketInstanceId,k,m.ID),o)){const e=s.bucketInstanceId;let t=this.collisionCircleArrays[e];void 0===t&&(t=this.collisionCircleArrays[e]=new ki);for(let e=0;e<F.circles.length;e+=4)t.circles.push(F.circles[e+0]),t.circles.push(F.circles[e+1]),t.circles.push(F.circles[e+2]),t.circles.push(F.collisionDetected?1:0);}const H="globe"!==s.projection.name;S=S&&(H||!A),C=C&&(H||!R),this.placements[T]=new Bi(I||S,D||C,L||s.justReloaded),i.add(T);};if(E&&this.buildingIndex&&(this.buildingIndex.updateZOffset(s,this.retainedQueryData[s.bucketInstanceId].tileID),s.updateZOffset()),T){const t=s.getSortedSymbolIndexes(this.transform.angle);for(let e=t.length-1;e>=0;--e){const i=t[e];I(s.symbolInstances.get(i),i,s.collisionArrays[i]);}s.hasAnyZOffset&&e.w(`${s.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);}else if(s.hasAnyZOffset){const e=s.getSortedIndexesByZOffset();for(let t=0;t<e.length;++t){const i=e[t];I(s.symbolInstances.get(i),i,s.collisionArrays[i]);}}else for(let e=t.symbolInstanceStart;e<t.symbolInstanceEnd;e++)I(s.symbolInstances.get(e),e,s.collisionArrays[e]);if(o&&s.bucketInstanceId in this.collisionCircleArrays){const t=this.collisionCircleArrays[s.bucketInstanceId];e.a6.invert(t.invProjMatrix,a),t.viewportMatrix=this.collisionIndex.getViewportMatrix();}s.justReloaded=!1;}markUsedJustification(t,i,o,r){const{leftJustifiedTextSymbolIndex:s,centerJustifiedTextSymbolIndex:n,rightJustifiedTextSymbolIndex:a,verticalPlacedTextSymbolIndex:l,crossTileID:c}=o,h=e.be(i),u=r===e.b6.vertical?l:"left"===h?s:"center"===h?n:"right"===h?a:-1;s>=0&&(t.text.placedSymbolArray.get(s).crossTileID=u>=0&&s!==u?0:c),n>=0&&(t.text.placedSymbolArray.get(n).crossTileID=u>=0&&n!==u?0:c),a>=0&&(t.text.placedSymbolArray.get(a).crossTileID=u>=0&&a!==u?0:c),l>=0&&(t.text.placedSymbolArray.get(l).crossTileID=u>=0&&l!==u?0:c);}markUsedOrientation(t,i,o){const r=i===e.b6.horizontal||i===e.b6.horizontalOnly?i:0,s=i===e.b6.vertical?i:0,{leftJustifiedTextSymbolIndex:n,centerJustifiedTextSymbolIndex:a,rightJustifiedTextSymbolIndex:l,verticalPlacedTextSymbolIndex:c}=o,h=t.text.placedSymbolArray;n>=0&&(h.get(n).placedOrientation=r),a>=0&&(h.get(a).placedOrientation=r),l>=0&&(h.get(l).placedOrientation=r),c>=0&&(h.get(c).placedOrientation=s);}commit(e){this.commitTime=e,this.zoomAtLastRecencyCheck=this.transform.zoom;const t=this.prevPlacement;let i=!1;this.prevZoomAdjustment=t?t.zoomAdjustment(this.transform.zoom):0;const o=t?t.symbolFadeChange(e):1,r=t?t.opacities:{},s=t?t.variableOffsets:{},n=t?t.placedOrientations:{};for(const e in this.placements){const t=this.placements[e],s=r[e];s?(this.opacities[e]=new Fi(s,o,t.text,t.icon,null,t.clipped),i=i||t.text!==s.text.placed||t.icon!==s.icon.placed):(this.opacities[e]=new Fi(null,o,t.text,t.icon,t.skipFade,t.clipped),i=i||t.text||t.icon);}for(const e in r){const t=r[e];if(!this.opacities[e]){const r=new Fi(t,o,!1,!1);r.isHidden()||(this.opacities[e]=r,i=i||t.text.placed||t.icon.placed);}}for(const e in s)this.variableOffsets[e]||!this.opacities[e]||this.opacities[e].isHidden()||(this.variableOffsets[e]=s[e]);for(const e in n)this.placedOrientations[e]||!this.opacities[e]||this.opacities[e].isHidden()||(this.placedOrientations[e]=n[e]);i?this.lastPlacementChangeTime=e:"number"!=typeof this.lastPlacementChangeTime&&(this.lastPlacementChangeTime=t?t.lastPlacementChangeTime:e);}updateLayerOpacities(e,t){const i=new Set;for(const o of t){const t=o.getBucket(e);t&&o.latestFeatureIndex&&e.fqid===t.layerIds[0]&&(this.updateBucketOpacities(t,i,o.collisionBoxArray),t.layers[0].layout.get("symbol-z-elevate")&&this.buildingIndex&&(this.buildingIndex.updateZOffset(t,o.tileID),t.updateZOffset()));}}updateBucketOpacities(t,i,o){t.hasTextData()&&t.text.opacityVertexArray.clear(),t.hasIconData()&&t.icon.opacityVertexArray.clear(),t.hasIconCollisionBoxData()&&t.iconCollisionBox.collisionVertexArray.clear(),t.hasTextCollisionBoxData()&&t.textCollisionBox.collisionVertexArray.clear();const r=t.layers[0].layout,s=!!t.layers[0].dynamicFilter(),n=new Fi(null,0,!1,!1,!0),a=r.get("text-allow-overlap"),l=r.get("icon-allow-overlap"),c=r.get("text-variable-anchor"),h="map"===r.get("text-rotation-alignment"),u="map"===r.get("text-pitch-alignment"),d=new Fi(null,0,a&&(l||!t.hasIconData()||r.get("icon-optional")),l&&(a||!t.hasTextData()||r.get("text-optional")),!0);!t.collisionArrays&&o&&(t.hasIconCollisionBoxData()||t.hasTextCollisionBoxData())&&t.deserializeCollisionBoxes(o);const _=(e,t,i)=>{for(let o=0;o<t/4;o++)e.opacityVertexArray.emplaceBack(i);};let p=0;for(let o=0;o<t.symbolInstances.length;o++){const r=t.symbolInstances.get(o),{numHorizontalGlyphVertices:a,numVerticalGlyphVertices:l,crossTileID:f,numIconVertices:m}=r,g=i.has(f);let v=this.opacities[f];g?v=n:v||(v=d,this.opacities[f]=v),i.add(f);const x=a>0||l>0,y=m>0,b=this.placedOrientations[f],w=b===e.b6.vertical,T=b===e.b6.horizontal||b===e.b6.horizontalOnly;if(!x&&!y||v.isHidden()||p++,x){const e=Ji(v.text);_(t.text,a,w?Qi:e),_(t.text,l,T?Qi:e);const i=v.text.isHidden(),{leftJustifiedTextSymbolIndex:o,centerJustifiedTextSymbolIndex:s,rightJustifiedTextSymbolIndex:n,verticalPlacedTextSymbolIndex:c}=r,h=t.text.placedSymbolArray,u=i||w?1:0;o>=0&&(h.get(o).hidden=u),s>=0&&(h.get(s).hidden=u),n>=0&&(h.get(n).hidden=u),c>=0&&(h.get(c).hidden=i||T?1:0);const d=this.variableOffsets[f];d&&this.markUsedJustification(t,d.anchor,r,b);const p=this.placedOrientations[f];p&&(this.markUsedJustification(t,"left",r,p),this.markUsedOrientation(t,p,r));}if(y){const e=Ji(v.icon),{placedIconSymbolIndex:i,verticalPlacedIconSymbolIndex:o}=r,s=t.icon.placedSymbolArray,n=v.icon.isHidden()?1:0;i>=0&&(_(t.icon,m,w?Qi:e),s.get(i).hidden=n),o>=0&&(_(t.icon,r.numVerticalIconVertices,T?Qi:e),s.get(o).hidden=n);}if(t.hasIconCollisionBoxData()||t.hasTextCollisionBoxData()){const i=t.collisionArrays[o];if(i){let o=new e.P(0,0),n=!0;if(i.textBox||i.verticalTextBox){if(c){const e=this.variableOffsets[f];e?(o=Gi(e.anchor,e.width,e.height,e.textOffset,e.textScale),h&&o._rotate(u?this.transform.angle:-this.transform.angle)):n=!1;}s&&(n=!v.clipped),i.textBox&&Zi(t.textCollisionBox.collisionVertexArray,v.text.placed,!n||w,o.x,o.y),i.verticalTextBox&&Zi(t.textCollisionBox.collisionVertexArray,v.text.placed,!n||T,o.x,o.y);}const a=n&&Boolean(!T&&i.verticalIconBox);i.iconBox&&Zi(t.iconCollisionBox.collisionVertexArray,v.icon.placed,a,r.hasIconTextFit?o.x:0,r.hasIconTextFit?o.y:0),i.verticalIconBox&&Zi(t.iconCollisionBox.collisionVertexArray,v.icon.placed,!a,r.hasIconTextFit?o.x:0,r.hasIconTextFit?o.y:0);}}}if(t.fullyClipped=0===p,t.sortFeatures(this.transform.angle),this.retainedQueryData[t.bucketInstanceId]&&(this.retainedQueryData[t.bucketInstanceId].featureSortOrder=t.featureSortOrder),t.hasTextData()&&t.text.opacityVertexBuffer&&t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray),t.hasIconData()&&t.icon.opacityVertexBuffer&&t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray),t.hasIconCollisionBoxData()&&t.iconCollisionBox.collisionVertexBuffer&&t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray),t.hasTextCollisionBoxData()&&t.textCollisionBox.collisionVertexBuffer&&t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray),t.bucketInstanceId in this.collisionCircleArrays){const e=this.collisionCircleArrays[t.bucketInstanceId];t.placementInvProjMatrix=e.invProjMatrix,t.placementViewportMatrix=e.viewportMatrix,t.collisionCircleArray=e.circles,delete this.collisionCircleArrays[t.bucketInstanceId];}}symbolFadeChange(e){return 0===this.fadeDuration?1:(e-this.commitTime)/this.fadeDuration+this.prevZoomAdjustment}zoomAdjustment(e){return Math.max(0,(this.transform.zoom-e)/1.5)}hasTransitions(e){return this.stale||e-this.lastPlacementChangeTime<this.fadeDuration}stillRecent(e,t){const i=this.zoomAtLastRecencyCheck===t?1-this.zoomAdjustment(t):1;return this.zoomAtLastRecencyCheck=t,this.commitTime+this.fadeDuration*i>e}setStale(){this.stale=!0;}}function Zi(e,t,i,o,r){e.emplaceBack(t?1:0,i?1:0,o||0,r||0),e.emplaceBack(t?1:0,i?1:0,o||0,r||0),e.emplaceBack(t?1:0,i?1:0,o||0,r||0),e.emplaceBack(t?1:0,i?1:0,o||0,r||0);}const Hi=Math.pow(2,25),Wi=Math.pow(2,24),qi=Math.pow(2,17),$i=Math.pow(2,16),Xi=Math.pow(2,9),Ki=Math.pow(2,8),Yi=Math.pow(2,1);function Ji(e){if(0===e.opacity&&!e.placed)return 0;if(1===e.opacity&&e.placed)return 4294967295;const t=e.placed?1:0,i=Math.floor(127*e.opacity);return i*Hi+t*Wi+i*qi+t*$i+i*Xi+t*Ki+i*Yi+t}const Qi=0;class eo{constructor(e){this._sortAcrossTiles="viewport-y"!==e.layout.get("symbol-z-order")&&void 0!==e.layout.get("symbol-sort-key").constantOr(1),this._currentTileIndex=0,this._currentPartIndex=0,this._seenCrossTileIDs=new Set,this._bucketParts=[];}continuePlacement(e,t,i,o,r){const s=this._bucketParts;for(;this._currentTileIndex<e.length;)if(t.getBucketParts(s,o,e[this._currentTileIndex],this._sortAcrossTiles),this._currentTileIndex++,r())return !0;for(this._sortAcrossTiles&&(this._sortAcrossTiles=!1,s.sort(((e,t)=>e.sortKey-t.sortKey)));this._currentPartIndex<s.length;){const e=s[this._currentPartIndex];if(t.placeLayerBucketPart(e,this._seenCrossTileIDs,i,0===e.symbolInstanceStart),this._currentPartIndex++,r())return !0}return !1}}class to{constructor(e,t,i,o,r,s,n,a,l){this.placement=new Vi(e,r,s,n,a,l),this._currentPlacementIndex=t.length-1,this._forceFullPlacement=i,this._showCollisionBoxes=o,this._done=!1;}isDone(){return this._done}continuePlacement(t,i,o,r){const s=e.f.now(),n=()=>{const t=e.f.now()-s;return !this._forceFullPlacement&&t>2};for(;this._currentPlacementIndex>=0;){const s=i[t[this._currentPlacementIndex]],a=this.placement.collisionIndex.transform.zoom;if("symbol"===s.type&&(!s.minzoom||s.minzoom<=a)&&(!s.maxzoom||s.maxzoom>a)){const t=s,i=t.layout.get("symbol-z-elevate"),a=this._inProgressLayer=this._inProgressLayer||new eo(t),l=e.ag(s.source,s.scope);if(a.continuePlacement(i?r[l]:o[l],this.placement,this._showCollisionBoxes,s,n))return;delete this._inProgressLayer;}this._currentPlacementIndex--;}this._done=!0;}commit(e){return this.placement.commit(e),this.placement}}const io=512/e.V/2;class oo{constructor(t,i,o){this.tileID=t,this.bucketInstanceId=o,this.index=new e.bg(i.length,16,Int32Array),this.keys=[],this.crossTileIDs=[];const r=t.canonical.x*e.V,s=t.canonical.y*e.V;for(let e=0;e<i.length;e++){const{key:t,crossTileID:o,tileAnchorX:n,tileAnchorY:a}=i.get(e),l=Math.floor((r+n)*io),c=Math.floor((s+a)*io);this.index.add(l,c),this.keys.push(t),this.crossTileIDs.push(o);}this.index.finish();}findMatches(t,i,o){const r=this.tileID.canonical.z<i.canonical.z?1:Math.pow(2,this.tileID.canonical.z-i.canonical.z),s=io/Math.pow(2,i.canonical.z-this.tileID.canonical.z),n=i.canonical.x*e.V,a=i.canonical.y*e.V;for(let e=0;e<t.length;e++){const i=t.get(e);if(i.crossTileID)continue;const{key:l,tileAnchorX:c,tileAnchorY:h}=i,u=Math.floor((n+c)*s),d=Math.floor((a+h)*s),_=this.index.range(u-r,d-r,u+r,d+r);for(const e of _){const t=this.crossTileIDs[e];if(this.keys[e]===l&&!o.has(t)){o.add(t),i.crossTileID=t;break}}}}}class ro{constructor(){this.maxCrossTileID=0;}generate(){return ++this.maxCrossTileID}}class so{constructor(){this.indexes={},this.usedCrossTileIDs={},this.lng=0;}handleWrapJump(e){const t=Math.round((e-this.lng)/360);if(0!==t)for(const e in this.indexes){const i=this.indexes[e],o={};for(const e in i){const r=i[e];r.tileID=r.tileID.unwrapTo(r.tileID.wrap+t),o[r.tileID.key]=r;}this.indexes[e]=o;}this.lng=e;}addBucket(e,t,i){if(this.indexes[e.overscaledZ]&&this.indexes[e.overscaledZ][e.key]){if(this.indexes[e.overscaledZ][e.key].bucketInstanceId===t.bucketInstanceId)return !1;this.removeBucketCrossTileIDs(e.overscaledZ,this.indexes[e.overscaledZ][e.key]);}for(let e=0;e<t.symbolInstances.length;e++)t.symbolInstances.get(e).crossTileID=0;this.usedCrossTileIDs[e.overscaledZ]||(this.usedCrossTileIDs[e.overscaledZ]=new Set);const o=this.usedCrossTileIDs[e.overscaledZ];for(const i in this.indexes){const r=this.indexes[i];if(Number(i)>e.overscaledZ)for(const i in r){const s=r[i];s.tileID.isChildOf(e)&&s.findMatches(t.symbolInstances,e,o);}else {const s=r[e.scaledTo(Number(i)).key];s&&s.findMatches(t.symbolInstances,e,o);}}for(let e=0;e<t.symbolInstances.length;e++){const r=t.symbolInstances.get(e);r.crossTileID||(r.crossTileID=i.generate(),o.add(r.crossTileID));}return void 0===this.indexes[e.overscaledZ]&&(this.indexes[e.overscaledZ]={}),this.indexes[e.overscaledZ][e.key]=new oo(e,t.symbolInstances,t.bucketInstanceId),!0}removeBucketCrossTileIDs(e,t){for(const i of t.crossTileIDs)this.usedCrossTileIDs[e].delete(i);}removeStaleBuckets(e){let t=!1;for(const i in this.indexes){const o=this.indexes[i];for(const r in o)e[o[r].bucketInstanceId]||(this.removeBucketCrossTileIDs(i,o[r]),delete o[r],t=!0);}return t}}class no{constructor(){this.layerIndexes={},this.crossTileIDs=new ro,this.maxBucketInstanceId=0,this.bucketsInCurrentPlacement={};}addLayer(e,t,i,o){let r=this.layerIndexes[e.fqid];void 0===r&&(r=this.layerIndexes[e.fqid]=new so);let s=!1;const n={};"globe"!==o.name&&r.handleWrapJump(i);for(const i of t){const t=i.getBucket(e);t&&e.fqid===t.layerIds[0]&&(t.bucketInstanceId||(t.bucketInstanceId=++this.maxBucketInstanceId),r.addBucket(i.tileID,t,this.crossTileIDs)&&(s=!0),n[t.bucketInstanceId]=!0);}return r.removeStaleBuckets(n)&&(s=!0),s}pruneUnusedLayers(e){const t={};e.forEach((e=>{t[e]=!0;}));for(const e in this.layerIndexes)t[e]||delete this.layerIndexes[e];}}class ao{constructor(e=0,t=0,i=0,o=0){if(isNaN(e)||e<0||isNaN(t)||t<0||isNaN(i)||i<0||isNaN(o)||o<0)throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");this.top=e,this.bottom=t,this.left=i,this.right=o;}interpolate(t,i,o){return null!=i.top&&null!=t.top&&(this.top=e.U(t.top,i.top,o)),null!=i.bottom&&null!=t.bottom&&(this.bottom=e.U(t.bottom,i.bottom,o)),null!=i.left&&null!=t.left&&(this.left=e.U(t.left,i.left,o)),null!=i.right&&null!=t.right&&(this.right=e.U(t.right,i.right,o)),this}getCenter(t,i){const o=e.aa((this.left+t-this.right)/2,0,t),r=e.aa((this.top+i-this.bottom)/2,0,i);return new e.P(o,r)}equals(e){return this.top===e.top&&this.bottom===e.bottom&&this.left===e.left&&this.right===e.right}clone(){return new ao(this.top,this.bottom,this.left,this.right)}toJSON(){return {top:this.top,bottom:this.bottom,left:this.left,right:this.right}}}function lo(t,i){const o=e.bk(t,3);e.a6.fromQuat(t,i),e.bm(t,3,o);}function co(t,i){const o=e.bi.identity([]);return e.bi.rotateZ(o,o,-i),e.bi.rotateX(o,o,-t),o}function ho(t,i){const o=[t[0],t[1],0],r=[i[0],i[1],0];if(e.N.length(o)>=1e-15){const t=e.N.normalize([],o);e.N.scale(r,t,e.N.dot(r,t)),i[0]=r[0],i[1]=r[1];}const s=e.N.cross([],i,t);if(e.N.len(s)<1e-15)return null;const n=Math.atan2(-s[1],s[0]);return co(Math.atan2(Math.sqrt(t[0]*t[0]+t[1]*t[1]),-t[2]),n)}class uo{constructor(e,t){this.position=e,this.orientation=t;}get position(){return this._position}set position(t){if(t){const i=t instanceof e.L?t:new e.L(t[0],t[1],t[2]);this._renderWorldCopies&&(i.x=e.bh(i.x,0,1)),this._position=i;}else this._position=null;}lookAtPoint(t,i){if(this.orientation=null,!this.position)return;const o=this.position,r=this._elevation?this._elevation.getAtPointOrZero(e.L.fromLngLat(t)):0,s=e.L.fromLngLat(t,r),n=[s.x-o.x,s.y-o.y,s.z-o.z];i||(i=[0,0,1]),i[2]=Math.abs(i[2]),this.orientation=ho(n,i);}setPitchBearing(t,i){this.orientation=co(e.bj(t),e.bj(-i));}}class _o{constructor(t,i){this._transform=e.a6.identity([]),this.orientation=i,this.position=t;}get mercatorPosition(){const t=this.position;return new e.L(t[0],t[1],t[2])}get position(){const t=e.bk(this._transform,3);return [t[0],t[1],t[2]]}set position(t){var i;t&&e.bm(this._transform,3,[(i=t)[0],i[1],i[2],1]);}get orientation(){return this._orientation}set orientation(t){this._orientation=t||e.bi.identity([]),t&&lo(this._transform,this._orientation);}getPitchBearing(){const e=this.forward(),t=this.right();return {bearing:Math.atan2(-t[1],t[0]),pitch:Math.atan2(Math.sqrt(e[0]*e[0]+e[1]*e[1]),-e[2])}}setPitchBearing(e,t){this._orientation=co(e,t),lo(this._transform,this._orientation);}forward(){const t=e.bk(this._transform,2);return [-t[0],-t[1],-t[2]]}up(){const t=e.bk(this._transform,1);return [-t[0],-t[1],-t[2]]}right(){const t=e.bk(this._transform,0);return [t[0],t[1],t[2]]}getCameraToWorld(t,i){const o=new Float64Array(16);return e.a6.invert(o,this.getWorldToCamera(t,i)),o}getCameraToWorldMercator(){return this._transform}getWorldToCameraPosition(t,i,o){const r=this.position;e.N.scale(r,r,-t);const s=new Float64Array(16);return e.a6.fromScaling(s,[o,o,o]),e.a6.translate(s,s,r),s[10]*=i,s}getWorldToCamera(t,i){const o=new Float64Array(16),r=new Float64Array(4),s=this.position;return e.bi.conjugate(r,this._orientation),e.N.scale(s,s,-t),e.a6.fromQuat(o,r),e.a6.translate(o,o,s),o[1]*=-1,o[5]*=-1,o[9]*=-1,o[13]*=-1,o[8]*=i,o[9]*=i,o[10]*=i,o[11]*=i,o}getCameraToClipPerspective(t,i,o,r){const s=new Float64Array(16);return e.a6.perspective(s,t,i,o,r),s}getCameraToClipOrthographic(t,i,o,r,s,n){const a=new Float64Array(16);return e.a6.ortho(a,t,i,o,r,s,n),a}getDistanceToElevation(t,i=!1){const o=0===t?0:e.bl(t,i?e.au(this.position[1]):this.position[1]),r=this.forward();return (o-this.position[2])/r[2]}clone(){return new _o([...this.position],[...this.orientation])}}const po=(e,t,i)=>(1-i)*e+i*t,fo=e=>e*e*e*e*e;class mo{constructor(t,i,o,r,s,n,a){this.tileSize=512,this._renderWorldCopies=void 0===s||s,this._minZoom=t||0,this._maxZoom=i||22,this._minPitch=null==o?0:o,this._maxPitch=null==r?60:r,this.setProjection(n),this.setMaxBounds(a),this.width=0,this.height=0,this._center=new e.bn(0,0),this.zoom=0,this.angle=0,this._fov=.6435011087932844,this._pitch=0,this._nearZ=0,this._farZ=0,this._unmodified=!0,this._edgeInsets=new ao,this._projMatrixCache={},this._alignedProjMatrixCache={},this._fogTileMatrixCache={},this._expandedProjMatrixCache={},this._distanceTileDataCache={},this._camera=new _o,this._centerAltitude=0,this._averageElevation=0,this.cameraElevationReference="ground",this._pixelsPerMercatorPixel=1,this.globeRadius=0,this.globeCenterInViewSpace=[0,0,0],this._tileCoverLift=0,this._horizonShift=.1,this._orthographicProjectionAtLowPitch=!1;}clone(){const e=new mo(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());return e._elevation=this._elevation,e._centerAltitude=this._centerAltitude,e._centerAltitudeValidForExaggeration=this._centerAltitudeValidForExaggeration,e.tileSize=this.tileSize,e.mercatorFromTransition=this.mercatorFromTransition,e.width=this.width,e.height=this.height,e.cameraElevationReference=this.cameraElevationReference,e._center=this._center,e._setZoom(this.zoom),e._seaLevelZoom=this._seaLevelZoom,e.angle=this.angle,e._fov=this._fov,e._pitch=this._pitch,e._nearZ=this._nearZ,e._farZ=this._farZ,e._averageElevation=this._averageElevation,e._orthographicProjectionAtLowPitch=this._orthographicProjectionAtLowPitch,e._unmodified=this._unmodified,e._edgeInsets=this._edgeInsets.clone(),e._camera=this._camera.clone(),e._calcMatrices(),e.freezeTileCoverage=this.freezeTileCoverage,e.frustumCorners=this.frustumCorners,e}get isOrthographic(){return "globe"!==this.projection.name&&this._orthographicProjectionAtLowPitch&&this.pitch<15}get elevation(){return this._elevation}set elevation(e){this._elevation!==e&&(this._elevation=e,this._updateCameraOnTerrain(),this._calcMatrices());}get depthOcclusionForSymbolsAndCircles(){return "globe"!==this.projection.name&&!this.isOrthographic}updateElevation(e,t=!1){const i=this._elevation&&this._elevation.exaggeration()!==this._centerAltitudeValidForExaggeration;(null==this._seaLevelZoom||i)&&this._updateCameraOnTerrain(),(e||i)&&this._constrainCamera(t),this._calcMatrices();}getProjection(){return e.ac(this.projection,["name","center","parallels"])}setProjection(i){this.projectionOptions=i||{name:"mercator"};const o=this.projection?this.getProjection():void 0;this.projection=e.bo(this.projectionOptions);const r=!t(o,this.getProjection());return r&&this._calcMatrices(),this.mercatorFromTransition=!1,r}setOrthographicProjectionAtLowPitch(e){return this._orthographicProjectionAtLowPitch!==e&&(this._orthographicProjectionAtLowPitch=e,this._calcMatrices(),!0)}setMercatorFromTransition(){const t=this.projection.name;this.mercatorFromTransition=!0,this.projectionOptions={name:"mercator"},this.projection=e.bo({name:"mercator"});const i=t!==this.projection.name;return i&&this._calcMatrices(),i}get minZoom(){return this._minZoom}set minZoom(e){this._minZoom!==e&&(this._minZoom=e,this.zoom=Math.max(this.zoom,e));}get maxZoom(){return this._maxZoom}set maxZoom(e){this._maxZoom!==e&&(this._maxZoom=e,this.zoom=Math.min(this.zoom,e));}get minPitch(){return this._minPitch}set minPitch(e){this._minPitch!==e&&(this._minPitch=e,this.pitch=Math.max(this.pitch,e));}get maxPitch(){return this._maxPitch}set maxPitch(e){this._maxPitch!==e&&(this._maxPitch=e,this.pitch=Math.min(this.pitch,e));}get renderWorldCopies(){return this._renderWorldCopies&&!0===this.projection.supportsWorldCopies}set renderWorldCopies(e){void 0===e?e=!0:null===e&&(e=!1),this._renderWorldCopies=e;}get worldSize(){return this.tileSize*this.scale}get cameraWorldSizeForFog(){const e=Math.max(this._camera.getDistanceToElevation(this._averageElevation),Number.EPSILON);return this._worldSizeFromZoom(this._zoomFromMercatorZ(e))}get cameraWorldSize(){const e=Math.max(this._camera.getDistanceToElevation(this._averageElevation,!0),Number.EPSILON);return this._worldSizeFromZoom(this._zoomFromMercatorZ(e))}get pixelsPerMeter(){return this.projection.pixelsPerMeter(this.center.lat,this.worldSize)}get cameraPixelsPerMeter(){return e.bl(1,this.center.lat)*this.cameraWorldSizeForFog}get centerOffset(){return this.centerPoint._sub(this.size._div(2))}get size(){return new e.P(this.width,this.height)}get bearing(){return e.bh(this.rotation,-180,180)}set bearing(e){this.rotation=e;}get rotation(){return -this.angle/Math.PI*180}set rotation(t){const i=-t*Math.PI/180;this.angle!==i&&(this._unmodified=!1,this.angle=i,this._calcMatrices(),this.rotationMatrix=e.b4.create(),e.b4.rotate(this.rotationMatrix,this.rotationMatrix,this.angle));}get pitch(){return this._pitch/Math.PI*180}set pitch(t){const i=e.aa(t,this.minPitch,this.maxPitch)/180*Math.PI;this._pitch!==i&&(this._unmodified=!1,this._pitch=i,this._calcMatrices());}get aspect(){return this.width/this.height}get fov(){return this._fov/Math.PI*180}get fovX(){return this._fov}get fovY(){const e=1/Math.tan(.5*this.fovX);return 2*Math.atan(1/this.aspect/e)}set fov(t){t=Math.max(.01,Math.min(60,t)),this._fov!==t&&(this._unmodified=!1,this._fov=e.bj(t),this._calcMatrices());}get averageElevation(){return this._averageElevation}set averageElevation(e){this._averageElevation=e,this._calcFogMatrices(),this._distanceTileDataCache={};}get zoom(){return this._zoom}set zoom(e){const t=Math.min(Math.max(e,this.minZoom),this.maxZoom);this._zoom!==t&&(this._unmodified=!1,this._setZoom(t),this._updateSeaLevelZoom(),this._constrain(),this._calcMatrices());}_setZoom(e){this._zoom=e,this.scale=this.zoomScale(e),this.tileZoom=Math.floor(e),this.zoomFraction=e-this.tileZoom;}get tileCoverLift(){return this._tileCoverLift}set tileCoverLift(e){this._tileCoverLift!==e&&(this._tileCoverLift=e);}_updateCameraOnTerrain(){const e=this.elevation?this.elevation.getAtPoint(this.locationCoordinate(this.center),Number.NEGATIVE_INFINITY):Number.NEGATIVE_INFINITY,t=this.elevation&&e===Number.NEGATIVE_INFINITY&&this.elevation.visibleDemTiles.length>0&&this.elevation.exaggeration()>0&&this._centerAltitudeValidForExaggeration;if(!this._elevation||e===Number.NEGATIVE_INFINITY&&(!t||!this._centerAltitude))return this._centerAltitude=0,this._seaLevelZoom=null,void(this._centerAltitudeValidForExaggeration=void 0);const i=this._elevation;t||this._centerAltitude&&this._centerAltitudeValidForExaggeration&&i.exaggeration()&&this._centerAltitudeValidForExaggeration!==i.exaggeration()?(this._centerAltitude=this._centerAltitude/this._centerAltitudeValidForExaggeration*i.exaggeration(),this._centerAltitudeValidForExaggeration=i.exaggeration()):(this._centerAltitude=e||0,this._centerAltitudeValidForExaggeration=i.exaggeration()),this._updateSeaLevelZoom();}_updateSeaLevelZoom(){void 0!==this._centerAltitudeValidForExaggeration&&(this._seaLevelZoom=this._zoomFromMercatorZ((this.pixelsPerMeter*this._centerAltitude+this.cameraToCenterDistance)/this.worldSize));}sampleAverageElevation(){if(!this._elevation)return 0;const t=this._elevation,i=[[.5,.2],[.3,.5],[.5,.5],[.7,.5],[.5,.8]],o=this.horizonLineFromTop();let r=0,s=0;for(let n=0;n<i.length;n++){const a=new e.P(i[n][0]*this.width,o+i[n][1]*(this.height-o)),l=t.pointCoordinate(a);if(!l)continue;const c=1/Math.hypot(l[0]-this._camera.position[0],l[1]-this._camera.position[1]);r+=l[3]*c,s+=c;}return 0===s?NaN:r/s}get center(){return this._center}set center(e){e.lat===this._center.lat&&e.lng===this._center.lng||(this._unmodified=!1,this._center=e,this._terrainEnabled()&&("ground"===this.cameraElevationReference?this._updateCameraOnTerrain():this._updateZoomFromElevation()),this._constrain(),this._calcMatrices());}_updateZoomFromElevation(){if(null==this._seaLevelZoom||!this._elevation)return;const e=this._seaLevelZoom,t=this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),i=this.pixelsPerMeter/this.worldSize*t,o=this._mercatorZfromZoom(e),r=this._mercatorZfromZoom(this._maxZoom),s=Math.max(o-i,r);this._setZoom(this._zoomFromMercatorZ(s));}get padding(){return this._edgeInsets.toJSON()}set padding(e){this._edgeInsets.equals(e)||(this._unmodified=!1,this._edgeInsets.interpolate(this._edgeInsets,e,1),this._calcMatrices());}computeZoomRelativeTo(t){const i=this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint,t.toAltitude()));let o;o=t.z<this._camera.position[2]?[i.x,i.y,i.z]:[t.x,t.y,t.z];const r=e.N.length(e.N.sub([],this._camera.position,o));return e.aa(this._zoomFromMercatorZ(r),this._minZoom,this._maxZoom)}setFreeCameraOptions(t){if(!this.height)return;if(!t.position&&!t.orientation)return;this._updateCameraState();let i=!1;if(t.orientation&&!e.bi.exactEquals(t.orientation,this._camera.orientation)&&(i=this._setCameraOrientation(t.orientation)),t.position){const o=[t.position.x,t.position.y,t.position.z];e.N.exactEquals(o,this._camera.position)||(this._setCameraPosition(o),i=!0);}i&&(this._updateStateFromCamera(),this.recenterOnTerrain());}getFreeCameraOptions(){this._updateCameraState();const t=this._camera.position,i=new uo;return i.position=new e.L(t[0],t[1],t[2]),i.orientation=this._camera.orientation,i._elevation=this.elevation,i._renderWorldCopies=this.renderWorldCopies,i}_setCameraOrientation(t){if(!e.bi.length(t))return !1;e.bi.normalize(t,t);const i=e.N.transformQuat([],[0,0,-1],t),o=e.N.transformQuat([],[0,-1,0],t);if(o[2]<0)return !1;const r=ho(i,o);return !!r&&(this._camera.orientation=r,!0)}_setCameraPosition(t){const i=this.zoomScale(this.minZoom)*this.tileSize,o=this.zoomScale(this.maxZoom)*this.tileSize,r=this.cameraToCenterDistance;t[2]=e.aa(t[2],r/o,r/i),this._camera.position=t;}get centerPoint(){return this._edgeInsets.getCenter(this.width,this.height)}get fovAboveCenter(){return this._fov*(.5+this.centerOffset.y/this.height)}isPaddingEqual(e){return this._edgeInsets.equals(e)}interpolatePadding(e,t,i){this._unmodified=!1,this._edgeInsets.interpolate(e,t,i),this._constrain(),this._calcMatrices();}coveringZoomLevel(e){const t=(e.roundZoom?Math.round:Math.floor)(this.zoom+this.scaleZoom(this.tileSize/e.tileSize));return Math.max(0,t)}getVisibleUnwrappedCoordinates(t){const i=[new e.bp(0,t)];if(this.renderWorldCopies){const o=this.pointCoordinate(new e.P(0,0)),r=this.pointCoordinate(new e.P(this.width,0)),s=this.pointCoordinate(new e.P(this.width,this.height)),n=this.pointCoordinate(new e.P(0,this.height)),a=Math.floor(Math.min(o.x,r.x,s.x,n.x)),l=Math.floor(Math.max(o.x,r.x,s.x,n.x)),c=1;for(let o=a-c;o<=l+c;o++)0!==o&&i.push(new e.bp(o,t));}return i}isLODDisabled(e){return (!e||this.pitch<=60)&&this._edgeInsets.top<=this._edgeInsets.bottom&&!this._elevation&&!this.projection.isReprojectedInTileSpace}extendTileCoverForShadows(t,i,o){let r=[];if(0===i[0]&&0===i[1])return r;for(const o of t){const t=o.canonical,s=o.overscaledZ,n=o.wrap,a=1<<t.z,l=t.x+1<a,c=t.x>0,h=t.y+1<a,u=t.y>0,d=o.wrap-(c?0:1),_=o.wrap+(l?0:1),p=c?t.x-1:a-1,f=l?t.x+1:0;i[0]<0?(r.push(new e.am(s,_,t.z,f,t.y)),i[1]<0&&h&&(r.push(new e.am(s,n,t.z,t.x,t.y+1)),r.push(new e.am(s,_,t.z,f,t.y+1))),i[1]>0&&u&&(r.push(new e.am(s,n,t.z,t.x,t.y-1)),r.push(new e.am(s,_,t.z,f,t.y-1)))):i[0]>0?(r.push(new e.am(s,d,t.z,p,t.y)),i[1]<0&&h&&(r.push(new e.am(s,n,t.z,t.x,t.y+1)),r.push(new e.am(s,d,t.z,p,t.y+1))),i[1]>0&&u&&(r.push(new e.am(s,n,t.z,t.x,t.y-1)),r.push(new e.am(s,d,t.z,p,t.y-1)))):i[1]<0&&h?r.push(new e.am(s,n,t.z,t.x,t.y+1)):u&&r.push(new e.am(s,n,t.z,t.x,t.y-1));}if(r.length>1){r.sort(((e,t)=>e.overscaledZ-t.overscaledZ||e.wrap-t.wrap||e.canonical.z-t.canonical.z||e.canonical.x-t.canonical.x||e.canonical.y-t.canonical.y));let e=0,t=0;for(;t<r.length;)r[t].equals(r[e])?++t:r[++e]=r[t++];r.length=e+1;}const s=[];for(const e of r)r.some((t=>e.isChildOf(t)))||s.push(e);return r=s.filter((e=>!t.some((t=>!!(e.overscaledZ<o&&t.isChildOf(e))||e.equals(t)||e.isChildOf(t))))),r}coveringTiles(t){let i=this.coveringZoomLevel(t);const o=i,r=this.elevation&&this.elevation.exaggeration(),s=r&&!t.isTerrainDEM,n="mercator"===this.projection.name;if(void 0!==t.minzoom&&i<t.minzoom)return [];void 0!==t.maxzoom&&i>t.maxzoom&&(i=t.maxzoom);const a=this.locationCoordinate(this.center),l=this.center.lat,c=1<<i,h=[c*a.x,c*a.y,0],u="globe"===this.projection.name,d=!u,_=e.bq.fromInvProjectionMatrix(this.invProjMatrix,this.worldSize,i,d),p=u?this._camera.mercatorPosition:this.pointCoordinate(this.getCameraPoint()),f=c*e.bl(1,this.center.lat),m=this._camera.position[2]/e.bl(1,this.center.lat),g=[c*p.x,c*p.y,m*(d?1:f)],v=u||r,x=this.cameraToCenterDistance/t.tileSize*(t.roundZoom?1:.502),y=this.isLODDisabled(!0)?i:0;let b;if(this._elevation&&t.isTerrainDEM)b=1e4*this._elevation.exaggeration();else if(this._elevation){const e=this._elevation.getMinMaxForVisibleTiles();b=e?e.max:this._centerAltitude;}else b=this._centerAltitude;const w=t.isTerrainDEM?-b:this._elevation?this._elevation.getMinElevationBelowMSL():0,T=this.projection.isReprojectedInTileSpace?e.br(this):1,E=t=>{const i=1/4e4,o=new e.L(t.x+i,t.y,t.z),r=new e.L(t.x,t.y+i,t.z),s=t.toLngLat(),n=o.toLngLat(),a=r.toLngLat(),l=this.locationCoordinate(s),c=this.locationCoordinate(n),h=this.locationCoordinate(a),u=Math.hypot(c.x-l.x,c.y-l.y),d=Math.hypot(h.x-l.x,h.y-l.y);return Math.sqrt(u*d)*T/i},S=t=>{const i=b,o=w;return {aabb:e.bu(this,c,0,0,0,t,o,i,this.projection),zoom:0,x:0,y:0,minZ:o,maxZ:i,wrap:t,fullyVisible:!1}},C=[];let I=[];const D=i,L=t.reparseOverscaled?o:i,A=e=>e*e,R=A((m-this._centerAltitude)*f),P=e=>{if(!this._elevation||!e.tileID||!n)return;const t=this._elevation.getMinMaxForTile(e.tileID),i=e.aabb;t?(i.min[2]=t.min,i.max[2]=t.max,i.center[2]=(i.min[2]+i.max[2])/2):(e.shouldSplit=M(e),e.shouldSplit||(i.min[2]=i.max[2]=i.center[2]=this._centerAltitude));},M=t=>{if(t.zoom<y)return !0;if(t.zoom===D)return !1;if(null!=t.shouldSplit)return t.shouldSplit;const i=t.aabb.distanceX(g),r=t.aabb.distanceY(g);let n=R,a=1;if(u){n=A(t.aabb.distanceZ(g));const i=Math.pow(2,t.zoom),o=e.au((t.y+1)/i),r=e.au(t.y/i),s=Math.min(Math.max(l,o),r),c=e.bJ(s)/e.bJ(l);if(a=s===l?1/Math.max(1,this._mercatorScaleRatio-.3):Math.min(1,c/this._mercatorScaleRatio),this.zoom<=e.bG&&t.zoom===D-1&&c>=.9)return !0}else if(s&&(n=A(t.aabb.distanceZ(g)*f)),this.projection.isReprojectedInTileSpace&&o<=5){const i=Math.pow(2,t.zoom),o=E(new e.L((t.x+.5)/i,(t.y+.5)/i));a=o>.85?1:o;}const c=i*i+r*r+n,h=A((1<<D-t.zoom)*x*a*((e,t)=>{if(t*A(.707)<e)return 1;const i=Math.sqrt(t/e);return i/(1.4144271570014144+(Math.pow(1.1,i-1.4144271570014144+1)-1)/(1.1-1)-1)})(Math.max(n,R),c));return c<h};if(this.renderWorldCopies)for(let e=1;e<=3;e++)C.push(S(-e)),C.push(S(e));for(C.push(S(0));C.length>0;){const o=C.pop(),r=o.x,a=o.y;let l=o.fullyVisible;const d=()=>"globe"===this.projection.name&&(0===o.y||o.y===(1<<o.zoom)-1);if(!l){let t=v?o.aabb.intersects(_):o.aabb.intersectsFlat(_);if(0===t&&d()){const i=new e.bs(o.zoom,r,a);t=e.bt(this,c,i,!0).intersects(_);}if(0===t)continue;l=2===t;}if(o.zoom!==D&&M(o))for(let t=0;t<4;t++){const i=(r<<1)+t%2,h=(a<<1)+(t>>1),d={aabb:n?o.aabb.quadrant(t):e.bu(this,c,o.zoom+1,i,h,o.wrap,o.minZ,o.maxZ,this.projection),zoom:o.zoom+1,x:i,y:h,wrap:o.wrap,fullyVisible:l,tileID:void 0,shouldSplit:void 0,minZ:o.minZ,maxZ:o.maxZ};s&&!u&&(d.tileID=new e.am(o.zoom+1===D?L:o.zoom+1,o.wrap,o.zoom+1,i,h),P(d)),C.push(d);}else {const s=o.zoom===D?L:o.zoom;if(t.minzoom&&t.minzoom>s)continue;if(!l){let t=v?o.aabb.intersectsPrecise(_):o.aabb.intersectsPreciseFlat(_);if(0===t&&d()){const i=new e.bs(o.zoom,r,a);t=e.bt(this,c,i,!0).intersectsPrecise(_);}if(0===t)continue}const n=h[0]-(.5+r+(o.wrap<<o.zoom))*(1<<i-o.zoom),u=h[1]-.5-a,p=o.tileID?o.tileID:new e.am(s,o.wrap,o.zoom,r,a);I.push({tileID:p,distanceSq:n*n+u*u});}}if(this.fogCullDistSq){const i=this.fogCullDistSq,o=this.horizonLineFromTop();I=I.filter((r=>{const s=[0,0,0,1],n=[e.V,e.V,0,1],a=this.calculateFogTileMatrix(r.tileID.toUnwrapped());e.a7.transformMat4(s,s,a),e.a7.transformMat4(n,n,a);const l=e.a7.min([],s,n),c=e.a7.max([],s,n),h=e.bv(l,c);if(0===h)return !0;let u=!1;const d=this._elevation;if(d&&h>i&&0!==o){const i=this.calculateProjMatrix(r.tileID.toUnwrapped());let s;t.isTerrainDEM||(s=d.getMinMaxForTile(r.tileID)),s||(s={min:w,max:b});const n=e.bH(this.rotation),a=[n[0]*e.V,n[1]*e.V,s.max];e.N.transformMat4(a,a,i),u=(1-a[1])*this.height*.5<o;}return h<i||u}));}return I.sort(((e,t)=>e.distanceSq-t.distanceSq)).map((e=>e.tileID))}resize(e,t){this.width=e,this.height=t,this.pixelsToGLUnits=[2/e,-2/t],this._constrain(),this._calcMatrices();}get unmodified(){return this._unmodified}zoomScale(e){return Math.pow(2,e)}scaleZoom(e){return Math.log(e)/Math.LN2}project(t){const i=e.aa(t.lat,-e.bw,e.bw),o=this.projection.project(t.lng,i);return new e.P(o.x*this.worldSize,o.y*this.worldSize)}unproject(e){return this.projection.unproject(e.x/this.worldSize,e.y/this.worldSize)}get point(){return this.project(this.center)}get pointMerc(){return this.point._div(this.worldSize)}get pixelsPerMeterRatio(){return this.pixelsPerMeter/e.bl(1,this.center.lat)/this.worldSize}setLocationAtPoint(t,i){let o,r;const s=this.centerPoint;if("globe"===this.projection.name){const e=this.worldSize;o=(i.x-s.x)/e,r=(i.y-s.y)/e;}else {const e=this.pointCoordinate(i),t=this.pointCoordinate(s);o=e.x-t.x,r=e.y-t.y;}const n=this.locationCoordinate(t);this.setLocation(new e.L(n.x-o,n.y-r));}setLocation(e){this.center=this.coordinateLocation(e),this.projection.wrap&&(this.center=this.center.wrap());}locationPoint(e){return this.projection.locationPoint(this,e)}locationPoint3D(e){return this.projection.locationPoint(this,e,!0)}pointLocation(e){return this.coordinateLocation(this.pointCoordinate(e))}pointLocation3D(e){return this.coordinateLocation(this.pointCoordinate3D(e))}locationCoordinate(t,i){const o=i?e.bl(i,t.lat):void 0,r=this.projection.project(t.lng,t.lat);return new e.L(r.x,r.y,o)}coordinateLocation(e){return this.projection.unproject(e.x,e.y)}pointRayIntersection(t,i){const o=null!=i?i:this._centerAltitude,r=[t.x,t.y,0,1],s=[t.x,t.y,1,1];e.a7.transformMat4(r,r,this.pixelMatrixInverse),e.a7.transformMat4(s,s,this.pixelMatrixInverse);const n=s[3];e.a7.scale(r,r,1/r[3]),e.a7.scale(s,s,1/n);const a=r[2],l=s[2];return {p0:r,p1:s,t:a===l?0:(o-a)/(l-a)}}screenPointToMercatorRay(t){const i=[t.x,t.y,0,1],o=[t.x,t.y,1,1];return e.a7.transformMat4(i,i,this.pixelMatrixInverse),e.a7.transformMat4(o,o,this.pixelMatrixInverse),e.a7.scale(i,i,1/i[3]),e.a7.scale(o,o,1/o[3]),i[2]=e.bl(i[2],this._center.lat)*this.worldSize,o[2]=e.bl(o[2],this._center.lat)*this.worldSize,e.a7.scale(i,i,1/this.worldSize),e.a7.scale(o,o,1/this.worldSize),new e.a2([i[0],i[1],i[2]],e.N.normalize([],e.N.sub([],o,i)))}rayIntersectionCoordinate(t){const{p0:i,p1:o,t:r}=t,s=e.bl(i[2],this._center.lat),n=e.bl(o[2],this._center.lat);return new e.L(e.U(i[0],o[0],r)/this.worldSize,e.U(i[1],o[1],r)/this.worldSize,e.U(s,n,r))}pointCoordinate(e,t=this._centerAltitude){return this.projection.pointCoordinate(this,e.x,e.y,t)}pointCoordinate3D(t){if(!this.elevation)return this.pointCoordinate(t);let i=this.projection.pointCoordinate3D(this,t.x,t.y);if(i)return new e.L(i[0],i[1],i[2]);let o=0,r=this.horizonLineFromTop();if(t.y>r)return this.pointCoordinate(t);const s=.02*r,n=t.clone();for(let t=0;t<10&&r-o>s;t++){n.y=e.U(o,r,.66);const t=this.projection.pointCoordinate3D(this,n.x,n.y);t?(r=n.y,i=t):o=n.y;}return i?new e.L(i[0],i[1],i[2]):this.pointCoordinate(t)}isPointAboveHorizon(e){return this.projection.isPointAboveHorizon(this,e)}isPointOnSurface(t){if(t.y<0||t.y>this.height||t.x<0||t.x>this.width)return !1;if(this.elevation||this.zoom>=e.bx)return !this.isPointAboveHorizon(t);const i=this.pointCoordinate(t);return i.y>=0&&i.y<=1}_coordinatePoint(t,i){const o=i&&this.elevation?this.elevation.getAtPointOrZero(t,this._centerAltitude):this._centerAltitude,r=[t.x*this.worldSize,t.y*this.worldSize,o+t.toAltitude(),1];return e.a7.transformMat4(r,r,this.pixelMatrix),r[3]>0?new e.P(r[0]/r[3],r[1]/r[3]):new e.P(Number.MAX_VALUE,Number.MAX_VALUE)}_getBoundsNonRectangular(){const{top:t,left:i}=this._edgeInsets,o=this.height-this._edgeInsets.bottom,r=this.width-this._edgeInsets.right,s=this.pointLocation3D(new e.P(i,t)),n=this.pointLocation3D(new e.P(r,t)),a=this.pointLocation3D(new e.P(r,o)),l=this.pointLocation3D(new e.P(i,o));let c=Math.min(s.lng,n.lng,a.lng,l.lng),h=Math.max(s.lng,n.lng,a.lng,l.lng),u=Math.min(s.lat,n.lat,a.lat,l.lat),d=Math.max(s.lat,n.lat,a.lat,l.lat);const _=Math.pow(2,-this.zoom)/16*270,p="globe"===this.projection.name?1:4,f=(t,i,o,r,s)=>{const n=(t+o)/2,a=(i+r)/2,l=new e.P(n,a),{lng:m,lat:g}=this.pointLocation3D(l),v=Math.max(0,c-m,u-g,m-h,g-d);c=Math.min(c,m),h=Math.max(h,m),u=Math.min(u,g),d=Math.max(d,g),(s<p||v>_)&&(f(t,i,n,a,s+1),f(n,a,o,r,s+1));};if(f(i,t,r,t,1),f(r,t,r,o,1),f(r,o,i,o,1),f(i,o,i,t,1),"globe"===this.projection.name){const[t,i]=e.by(this);t?(d=90,h=180,c=-180):i&&(u=-90,h=180,c=-180);}return new e.ad(new e.bn(c,u),new e.bn(h,d))}_getBoundsRectangular(t,i){const{top:o,left:r}=this._edgeInsets,s=this.height-this._edgeInsets.bottom,n=this.width-this._edgeInsets.right,a=new e.P(r,o),l=new e.P(n,o),c=new e.P(n,s),h=new e.P(r,s);let u=this.pointCoordinate(a,t),d=this.pointCoordinate(l,t);const _=this.pointCoordinate(c,i),p=this.pointCoordinate(h,i),f=(e,t)=>(t.y-e.y)/(t.x-e.x);return u.y>1&&d.y>=0?u=new e.L((1-p.y)/f(p,u)+p.x,1):u.y<0&&d.y<=1&&(u=new e.L(-p.y/f(p,u)+p.x,0)),d.y>1&&u.y>=0?d=new e.L((1-_.y)/f(_,d)+_.x,1):d.y<0&&u.y<=1&&(d=new e.L(-_.y/f(_,d)+_.x,0)),(new e.ad).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_))}_getBoundsRectangularTerrain(){const e=this.elevation;if(!e.visibleDemTiles.length||e.isUsingMockSource())return this._getBoundsRectangular(0,0);const t=e.visibleDemTiles.reduce(((e,t)=>{if(t.dem){const i=t.dem.tree;e.min=Math.min(e.min,i.minimums[0]),e.max=Math.max(e.max,i.maximums[0]);}return e}),{min:Number.MAX_VALUE,max:0});return this._getBoundsRectangular(t.min*e.exaggeration(),t.max*e.exaggeration())}getBounds(){return "mercator"===this.projection.name||"equirectangular"===this.projection.name?this._terrainEnabled()?this._getBoundsRectangularTerrain():this._getBoundsRectangular(0,0):this._getBoundsNonRectangular()}horizonLineFromTop(e=!0){const t=this.height/2/Math.tan(this._fov/2)/Math.tan(Math.max(this._pitch,.1))-this.centerOffset.y,i=this.height/2-t*(1-this._horizonShift);return e?Math.max(0,i):i}getMaxBounds(){return this.maxBounds}setMaxBounds(t){this.maxBounds=t,this.minLat=-e.bw,this.maxLat=e.bw,this.minLng=-180,this.maxLng=180,t&&(this.minLat=t.getSouth(),this.maxLat=t.getNorth(),this.minLng=t.getWest(),this.maxLng=t.getEast(),this.maxLng<this.minLng&&(this.maxLng+=360)),this.worldMinX=e.a5(this.minLng)*this.tileSize,this.worldMaxX=e.a5(this.maxLng)*this.tileSize,this.worldMinY=e.ae(this.maxLat)*this.tileSize,this.worldMaxY=e.ae(this.minLat)*this.tileSize,this._constrain();}calculatePosMatrix(e,t){return this.projection.createTileMatrix(this,t,e)}calculateDistanceTileData(t){const i=t.key,o=this._distanceTileDataCache;if(o[i])return o[i];const r=t.canonical,s=1/this.height,n=this.cameraWorldSize,a=n/this.zoomScale(r.z),l=(r.x+Math.pow(2,r.z)*t.wrap)*a,c=r.y*a,h=this.point;h.x*=n/this.worldSize,h.y*=n/this.worldSize;const u=this.angle,d=Math.sin(-u),_=-Math.cos(-u);return o[i]={bearing:[d,_],center:[(h.x-l)*s,(h.y-c)*s],scale:a/e.V*s},o[i]}calculateFogTileMatrix(t){const i=t.key,o=this._fogTileMatrixCache;if(o[i])return o[i];const r=this.projection.createTileMatrix(this,this.cameraWorldSizeForFog,t);return e.a6.multiply(r,this.worldToFogMatrix,r),o[i]=new Float32Array(r),o[i]}calculateProjMatrix(t,i=!1,o=!1){const r=t.key;let s;if(s=o?this._expandedProjMatrixCache:i?this._alignedProjMatrixCache:this._projMatrixCache,s[r])return s[r];const n=this.calculatePosMatrix(t,this.worldSize);let a;return a=this.projection.isReprojectedInTileSpace?this.mercatorMatrix:o?this.expandedFarZProjMatrix:i?this.alignedProjMatrix:this.projMatrix,e.a6.multiply(n,a,n),s[r]=new Float32Array(n),s[r]}calculatePixelsToTileUnitsMatrix(t){const i=t.tileID.key,o=this._pixelsToTileUnitsCache;if(o[i])return o[i];const r=e.bz(t,this);return o[i]=r,o[i]}customLayerMatrix(){return this.mercatorMatrix.slice()}globeToMercatorMatrix(){if("globe"===this.projection.name){const t=1/this.worldSize,i=e.a6.fromScaling([],[t,t,t]);return e.a6.multiply(i,i,this.globeMatrix),i}}recenterOnTerrain(){if(!this._elevation||"globe"===this.projection.name)return;const t=this._elevation;this._updateCameraState();const i=e.bl(1,this._center.lat)*this.worldSize,o=this._computeCameraPosition(i),r=this._camera.forward(),s=e.bl(1,this._center.lat);o[2]/=s,r[2]/=s,e.N.normalize(r,r);const n=t.raycast(o,r,t.exaggeration());if(n){const t=e.N.scaleAndAdd([],o,r,n),i=new e.L(t[0],t[1],e.bl(t[2],e.au(t[1]))),a=(i.z+e.N.length([i.x-o[0],i.y-o[1],i.z-o[2]*s]))*this._pixelsPerMercatorPixel;this._seaLevelZoom=this._zoomFromMercatorZ(a),this._centerAltitude=i.toAltitude(),this._center=this.coordinateLocation(i),this._updateZoomFromElevation(),this._constrain(),this._calcMatrices();}}_constrainCamera(t=!1){if(!this._elevation)return;const i=this._elevation,o=e.bl(1,this._center.lat)*this.worldSize,r=this._computeCameraPosition(o),s=i.getAtPointOrZero(new e.L(...r)),n=this.pixelsPerMeter/this.worldSize*s,a=this._minimumHeightOverTerrain(),l=r[2]-n;if(l<=a)if(l<0||t){const t=this.locationCoordinate(this._center,this._centerAltitude),i=[r[0],r[1],t.z-r[2]],o=e.N.length(i);i[2]-=(a-l)/this._pixelsPerMercatorPixel;const s=e.N.length(i);if(0===s)return;e.N.scale(i,i,o/s*this._pixelsPerMercatorPixel),this._camera.position=[r[0],r[1],t.z*this._pixelsPerMercatorPixel-i[2]],this._updateStateFromCamera();}else this._isCameraConstrained=!0;}_constrain(){if(!this.center||!this.width||!this.height||this._constraining)return;this._constraining=!0;const t="globe"===this.projection.name||this.mercatorFromTransition;if(this.projection.isReprojectedInTileSpace||t){const i=this.center;return i.lat=e.aa(i.lat,this.minLat,this.maxLat),(this.maxBounds||!this.renderWorldCopies&&!t)&&(i.lng=e.aa(i.lng,this.minLng,this.maxLng)),this.center=i,void(this._constraining=!1)}const i=this._unmodified,{x:o,y:r}=this.point;let s=0,n=o,a=r;const l=this.width/2,c=this.height/2,h=this.worldMinY*this.scale,u=this.worldMaxY*this.scale;if(r-c<h&&(a=h+c),r+c>u&&(a=u-c),u-h<this.height&&(s=Math.max(s,this.height/(u-h)),a=(u+h)/2),this.maxBounds||!this._renderWorldCopies||!this.projection.wrap){const e=this.worldMinX*this.scale,t=this.worldMaxX*this.scale,i=this.worldSize/2-(e+t)/2;n=(o+i+this.worldSize)%this.worldSize-i,n-l<e&&(n=e+l),n+l>t&&(n=t-l),t-e<this.width&&(s=Math.max(s,this.width/(t-e)),n=(t+e)/2);}n===o&&a===r||(this.center=this.unproject(new e.P(n,a))),s&&(this.zoom+=this.scaleZoom(s)),this._constrainCamera(),this._unmodified=i,this._constraining=!1;}_minZoomForBounds(){let e=Math.max(0,this.scaleZoom(this.height/(this.worldMaxY-this.worldMinY)));return this.maxBounds&&(e=Math.max(e,this.scaleZoom(this.width/(this.worldMaxX-this.worldMinX)))),e}_maxCameraBoundsDistance(){return this._mercatorZfromZoom(this._minZoomForBounds())}_calcMatrices(){if(!this.height)return;const t=this.centerOffset,i="globe"===this.projection.name,o=this.pixelsPerMeter;"globe"===this.projection.name&&(this._mercatorScaleRatio=e.bl(1,this.center.lat)/e.bl(1,e.bI));const r=e.bA(this.projection,this.zoom,this.width,this.height,1024);this._pixelsPerMercatorPixel=this.projection.pixelSpaceConversion(this.center.lat,this.worldSize,r),this.cameraToCenterDistance=.5/Math.tan(.5*this._fov)*this.height*this._pixelsPerMercatorPixel,this._updateCameraState(),this._farZ=this.projection.farthestPixelDistance(this),this._nearZ=this.height/50;const s="meters"===this.projection.zAxisUnit?o:1,n=this._camera.getWorldToCamera(this.worldSize,s);let a;const l=this._camera.getCameraToClipPerspective(this._fov,this.width/this.height,this._nearZ,this._farZ);if(l[8]=2*-t.x/this.width,l[9]=2*t.y/this.height,this.isOrthographic){let e=.5*this.height/Math.tan(this._fov/2)*1*Math.tan(.5*this._fov),i=e*this.aspect,o=-i,r=-e;i-=t.x,o-=t.x,e+=t.y,r+=t.y,a=this._camera.getCameraToClipOrthographic(o,i,r,e,this._nearZ,this._farZ),((e,t,i,o)=>{for(let r=0;r<16;r++)e[r]=po(t[r],i[r],o);})(a,a,l,fo(this.pitch>=15?1:this.pitch/15));}else a=l;const c=e.a6.mul([],l,n);let h=e.a6.mul([],a,n);if(this.projection.isReprojectedInTileSpace){const t=this.locationCoordinate(this.center),i=e.a6.identity([]);e.a6.translate(i,i,[t.x*this.worldSize,t.y*this.worldSize,0]),e.a6.multiply(i,i,e.bB(this)),e.a6.translate(i,i,[-t.x*this.worldSize,-t.y*this.worldSize,0]),e.a6.multiply(h,h,i),e.a6.multiply(c,c,i),this.inverseAdjustmentMatrix=e.bC(this);}else this.inverseAdjustmentMatrix=[1,0,0,1];if(this.mercatorMatrix=e.a6.scale([],h,[this.worldSize,this.worldSize,this.worldSize/s,1]),this.projMatrix=h,this.invProjMatrix=e.a6.invert(new Float64Array(16),this.projMatrix),i){const i=this._camera.getCameraToClipPerspective(this._fov,this.width/this.height,this._nearZ,1/0);i[8]=2*-t.x/this.width,i[9]=2*t.y/this.height,this.expandedFarZProjMatrix=e.a6.mul([],i,n);}else this.expandedFarZProjMatrix=this.projMatrix;const u=e.a6.invert([],a);this.frustumCorners=e.bD.fromInvProjectionMatrix(u,this.horizonLineFromTop(),this.height),this.cameraFrustum=e.bq.fromInvProjectionMatrix(this.invProjMatrix,this.worldSize,0,!i);const d=new Float32Array(16);e.a6.identity(d),e.a6.scale(d,d,[1,-1,1]),e.a6.rotateX(d,d,this._pitch),e.a6.rotateZ(d,d,this.angle);const _=e.a6.perspective(new Float32Array(16),this._fov,this.width/this.height,this._nearZ,this._farZ);this.starsProjMatrix=e.a6.clone(_);const p=(Math.PI/2-this._pitch)*(this.height/this._fov)*this._horizonShift;_[8]=2*-t.x/this.width,_[9]=2*(t.y+p)/this.height,this.skyboxMatrix=e.a6.multiply(d,_,d);const f=this.point,m=f.x,g=f.y,v=this.width%2/2,x=this.height%2/2,y=Math.cos(this.angle),b=Math.sin(this.angle),w=m-Math.round(m)+y*v+b*x,T=g-Math.round(g)+y*x+b*v,E=new Float64Array(h);if(e.a6.translate(E,E,[w>.5?w-1:w,T>.5?T-1:T,0]),this.alignedProjMatrix=E,h=e.a6.create(),e.a6.scale(h,h,[this.width/2,-this.height/2,1]),e.a6.translate(h,h,[1,-1,0]),this.labelPlaneMatrix=h,h=e.a6.create(),e.a6.scale(h,h,[1,-1,1]),e.a6.translate(h,h,[-1,-1,0]),e.a6.scale(h,h,[2/this.width,2/this.height,1]),this.glCoordMatrix=h,this.pixelMatrix=e.a6.multiply(new Float64Array(16),this.labelPlaneMatrix,c),this._calcFogMatrices(),this._distanceTileDataCache={},h=e.a6.invert(new Float64Array(16),this.pixelMatrix),!h)throw new Error("failed to invert matrix");if(this.pixelMatrixInverse=h,"globe"===this.projection.name||this.mercatorFromTransition){this.globeMatrix=e.bE(this);const t=[this.globeMatrix[12],this.globeMatrix[13],this.globeMatrix[14]];this.globeCenterInViewSpace=e.N.transformMat4(t,t,n),this.globeRadius=this.worldSize/2/Math.PI-1;}else this.globeMatrix=h;this._projMatrixCache={},this._alignedProjMatrixCache={},this._pixelsToTileUnitsCache={},this._expandedProjMatrixCache={};}_calcFogMatrices(){this._fogTileMatrixCache={};const t=this.cameraWorldSizeForFog,i=this.cameraPixelsPerMeter,o=this._camera.position,r=1/this.height/this._pixelsPerMercatorPixel,s=[t,t,i];e.N.scale(s,s,r),e.N.scale(o,o,-1),e.N.multiply(o,o,s);const n=e.a6.create();e.a6.translate(n,n,o),e.a6.scale(n,n,s),this.mercatorFogMatrix=n,this.worldToFogMatrix=this._camera.getWorldToCameraPosition(t,i,r);}_computeCameraPosition(e){const t=(e=e||this.pixelsPerMeter)/this.pixelsPerMeter,i=this._camera.forward(),o=this.point,r=this._mercatorZfromZoom(this._seaLevelZoom?this._seaLevelZoom:this._zoom)*t-e/this.worldSize*this._centerAltitude;return [o.x/this.worldSize-i[0]*r,o.y/this.worldSize-i[1]*r,e/this.worldSize*this._centerAltitude-i[2]*r]}_updateCameraState(){this.height&&(this._camera.setPitchBearing(this._pitch,this.angle),this._camera.position=this._computeCameraPosition());}_translateCameraConstrained(t){const i=this._maxCameraBoundsDistance()*Math.cos(this._pitch),o=this._camera.position[2],r=t[2];let s=1;this.projection.wrap&&(this.center=this.center.wrap()),r>0&&(s=Math.min((i-o)/r,1)),this._camera.position=e.N.scaleAndAdd([],this._camera.position,t,s),this._updateStateFromCamera();}_updateStateFromCamera(){const t=this._camera.position,i=this._camera.forward(),{pitch:o,bearing:r}=this._camera.getPitchBearing(),s=e.bl(this._centerAltitude,this.center.lat)*this._pixelsPerMercatorPixel,n=this._mercatorZfromZoom(this._maxZoom)*Math.cos(e.bj(this._maxPitch)),a=Math.max((t[2]-s)/Math.cos(o),n),l=this._zoomFromMercatorZ(a);e.N.scaleAndAdd(t,t,i,a),this._pitch=e.aa(o,e.bj(this.minPitch),e.bj(this.maxPitch)),this.angle=e.bh(r,-Math.PI,Math.PI),this._setZoom(e.aa(l,this._minZoom,this._maxZoom)),this._updateSeaLevelZoom(),this._center=this.coordinateLocation(new e.L(t[0],t[1],t[2])),this._unmodified=!1,this._constrain(),this._calcMatrices();}_worldSizeFromZoom(e){return Math.pow(2,e)*this.tileSize}_mercatorZfromZoom(e){return this.cameraToCenterDistance/this._worldSizeFromZoom(e)}_minimumHeightOverTerrain(){const e=Math.min(null!=this._seaLevelZoom?this._seaLevelZoom:this._zoom,this._maxZoom)+4;return this._mercatorZfromZoom(e)}_zoomFromMercatorZ(e){return this.scaleZoom(this.cameraToCenterDistance/(e*this.tileSize))}zoomFromMercatorZAdjusted(t){let i=0,o=e.bx,r=0,s=1/0;for(;o-i>1e-6&&o>i;){const e=i+.5*(o-i),n=this.tileSize*Math.pow(2,e),a=this.getCameraToCenterDistance(this.projection,e,n),l=this.scaleZoom(a/(t*this.tileSize)),c=Math.abs(e-l);c<s&&(s=c,r=e),e<l?i=e:o=e;}return r}_terrainEnabled(){return !(!this._elevation||!this.projection.supportsTerrain&&(e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),1))}anyCornerOffEdge(t,i){const o=Math.min(t.x,i.x),r=Math.max(t.x,i.x),s=Math.min(t.y,i.y),n=Math.max(t.y,i.y);if(s<this.horizonLineFromTop(!1))return !0;if("mercator"!==this.projection.name)return !1;const a=[new e.P(o,s),new e.P(r,n),new e.P(o,n),new e.P(r,s)],l=this.renderWorldCopies?-3:0,c=this.renderWorldCopies?4:1;for(const e of a){const t=this.pointRayIntersection(e);if(t.t<0)return !0;const i=this.rayIntersectionCoordinate(t);if(i.x<l||i.y<0||i.x>c||i.y>1)return !0}return !1}isHorizonVisible(){return this.pitch+e.bF(this.fovAboveCenter)>88||this.anyCornerOffEdge(new e.P(0,0),new e.P(this.width,this.height))}zoomDeltaToMovement(t,i){const o=e.N.length(e.N.sub([],this._camera.position,t)),r=this._zoomFromMercatorZ(o)+i;return o-this._mercatorZfromZoom(r)}getCameraPoint(){if("globe"===this.projection.name){const t=function([t,i,o],r){const s=[t,i,o,1];e.a7.transformMat4(s,s,r);const n=s[3]=Math.max(s[3],1e-6);return s[0]/=n,s[1]/=n,s[2]/=n,s}([this.globeMatrix[12],this.globeMatrix[13],this.globeMatrix[14]],this.pixelMatrix);return new e.P(t[0],t[1])}{const t=Math.tan(this._pitch)*(this.cameraToCenterDistance||1);return this.centerPoint.add(new e.P(0,t))}}getCameraToCenterDistance(t,i=this.zoom,o=this.worldSize){const r=e.bA(t,i,this.width,this.height,1024),s=t.pixelSpaceConversion(this.center.lat,o,r);let n=.5/Math.tan(.5*this._fov)*this.height*s;return this.isOrthographic&&(n=po(1,n,fo(this.pitch>=15?1:this.pitch/15))),n}getWorldToCameraMatrix(){const t=this._camera.getWorldToCamera(this.worldSize,"meters"===this.projection.zAxisUnit?this.pixelsPerMeter:1);return "globe"===this.projection.name&&e.a6.multiply(t,t,this.globeMatrix),t}getFrustum(t){return e.bq.fromInvProjectionMatrix(this.invProjMatrix,this.worldSize,t,"meters"===this.projection.zAxisUnit)}}const go={BaseColor:5,MetallicRoughness:6,Normal:7,Occlusion:8,Emission:9,ShadowMap0:10},vo=(t,i)=>{if(i>0&&t.terrain&&e.w("Cutoff is currently disabled on terrain"),i<=0||t.terrain)return {shouldRenderCutoff:!1,uniformValues:{u_cutoff_params:[0,0,0,1]}};const o=t.transform,r=Math.max(Math.abs(o._zoom-(t.minCutoffZoom-1)),1),s=o.isLODDisabled(!1)?e.O(60,45,o.pitch):e.O(30,15,o.pitch),n=o._farZ-o._nearZ,a=i*o.height,l=((1-(c=s))*o.cameraToCenterDistance+c*(o._farZ+a))*r;var c;return {shouldRenderCutoff:s<1,uniformValues:{u_cutoff_params:[o._nearZ,o._farZ,(l-o._nearZ)/n,(l-a-o._nearZ)/n]}}},xo={cascadeCount:2,shadowMapResolution:2048};class yo{constructor(e,t){this.aabb=e,this.lastCascade=t;}}class bo{add(e,t){const i=this.receivers[e.key];void 0!==i?(i.aabb.min[0]=Math.min(i.aabb.min[0],t.min[0]),i.aabb.min[1]=Math.min(i.aabb.min[1],t.min[1]),i.aabb.min[2]=Math.min(i.aabb.min[2],t.min[2]),i.aabb.max[0]=Math.max(i.aabb.max[0],t.max[0]),i.aabb.max[1]=Math.max(i.aabb.max[1],t.max[1]),i.aabb.max[2]=Math.max(i.aabb.max[2],t.max[2])):this.receivers[e.key]=new yo(t,null);}clear(){this.receivers={};}get(e){return this.receivers[e.key]}computeRequiredCascades(t,i,o){const r=e.bS.fromPoints(t.points);let s=0;for(const t in this.receivers){const n=this.receivers[t];if(!n)continue;if(!r.intersectsAabb(n.aabb))continue;n.aabb.min=r.closestPoint(n.aabb.min),n.aabb.max=r.closestPoint(n.aabb.max);const a=n.aabb.getCorners();for(let t=0;t<o.length;t++){let r=!0;for(const s of a){const n=[s[0]*i,s[1]*i,s[2]];if(e.N.transformMat4(n,n,o[t].matrix),n[0]<-1||n[0]>1||n[1]<-1||n[1]>1){r=!1;break}}if(n.lastCascade=t,s=Math.max(s,t),r)break}}return s+1}}class wo{constructor(e){this.painter=e,this._enabled=!1,this._shadowLayerCount=0,this._numCascadesToRender=0,this._cascades=[],this._groundShadowTiles=[],this._receivers=new bo,this._depthMode=new Lt(e.context.gl.LEQUAL,Lt.ReadWrite,[0,1]),this._uniformValues={u_light_matrix_0:new Float32Array(16),u_light_matrix_1:new Float32Array(16),u_shadow_intensity:0,u_fade_range:[0,0],u_shadow_normal_offset:[1,1,1],u_shadow_texel_size:1,u_shadow_map_resolution:1,u_shadow_direction:[0,0,1],u_shadow_bias:[36e-5,.0012,.012],u_shadowmap_0:0,u_shadowmap_1:0},this.useNormalOffset=!1,e.tp.registerParameter(xo,["Shadows"],"cascadeCount",{min:1,max:2,step:1}),e.tp.registerParameter(xo,["Shadows"],"shadowMapResolution",{min:32,max:2048,step:32});}destroy(){for(const e of this._cascades)e.texture.destroy(),e.framebuffer.destroy();this._cascades=[];}updateShadowParameters(t,i){const o=this.painter;if(this._enabled=!1,this._shadowLayerCount=0,this._receivers.clear(),!i||!i.properties)return;const r=i.properties.get("shadow-intensity");if(!i.shadowsEnabled()||r<=0)return;if(this._shadowLayerCount=o.style.order.reduce(((e,i)=>{const r=o.style._mergedLayers[i];return e+(r.hasShadowPass()&&!r.isHidden(t.zoom)?1:0)}),0),this._enabled=this._shadowLayerCount>0,!this._enabled)return;const s=o.context,n=xo.shadowMapResolution,a=xo.shadowMapResolution;if(0===this._cascades.length||xo.shadowMapResolution!==this._cascades[0].texture.size[0]){this._cascades=[];for(let t=0;t<xo.cascadeCount;++t){const t=o._shadowMapDebug,i=s.gl,r=s.createFramebuffer(n,a,t,"texture"),l=new e.T(s,{width:n,height:a,data:null},i.DEPTH_COMPONENT);if(r.depthAttachment.set(l.texture),t){const t=new e.T(s,{width:n,height:a,data:null},i.RGBA);r.colorAttachment.set(t.texture);}this._cascades.push({framebuffer:r,texture:l,matrix:[],far:0,boundingSphereRadius:0,frustum:new e.bq,scale:0});}}this.shadowDirection=Eo(i);let l=0;if(t.elevation){const e=t.elevation,i=[1e4,-1e4];e.visibleDemTiles.filter((e=>e.dem)).forEach((e=>{const t=e.dem.tree;i[0]=Math.min(i[0],t.minimums[0]),i[1]=Math.max(i[1],t.maximums[0]);})),1e4!==i[0]&&(l=(i[1]-i[0])*e.exaggeration());}const c=1.5*t.cameraToCenterDistance,h=3*c,u=new Float64Array(16);for(let i=0;i<this._cascades.length;++i){const o=this._cascades[i];let r=t.height/50,s=1;1===xo.cascadeCount?s=h:0===i?s=c:(r=c,s=h);const[n,a]=Co(t,this.shadowDirection,r,s,xo.shadowMapResolution,l);o.scale=t.scale,o.matrix=n,o.boundingSphereRadius=a,e.a6.invert(u,o.matrix),o.frustum=e.bq.fromInvProjectionMatrix(u,1,0,!0),o.far=s;}const d=this._cascades.length-1;this._uniformValues.u_fade_range=[.75*this._cascades[d].far,this._cascades[d].far],this._uniformValues.u_shadow_intensity=r,this._uniformValues.u_shadow_direction=[this.shadowDirection[0],this.shadowDirection[1],this.shadowDirection[2]],this._uniformValues.u_shadow_texel_size=1/xo.shadowMapResolution,this._uniformValues.u_shadow_map_resolution=xo.shadowMapResolution,this._uniformValues.u_shadowmap_0=go.ShadowMap0,this._uniformValues.u_shadowmap_1=go.ShadowMap0+1,this._groundShadowTiles=o.transform.coveringTiles({tileSize:512,renderWorldCopies:!0});const _=o.transform.elevation;for(const e of this._groundShadowTiles){let t={min:0,max:0};if(_){const i=_.getMinMaxForTile(e);i&&(t=i);}this.addShadowReceiver(e.toUnwrapped(),t.min,t.max);}}get enabled(){return this._enabled}set enabled(e){this._enabled=e;}drawShadowPass(t,i){if(!this._enabled)return;const o=this.painter,r=o.context;this._numCascadesToRender=this._receivers.computeRequiredCascades(o.transform.getFrustum(0),o.transform.worldSize,this._cascades),r.viewport.set([0,0,xo.shadowMapResolution,xo.shadowMapResolution]);for(let s=0;s<this._numCascadesToRender;++s){o.currentShadowCascade=s,r.bindFramebuffer.set(this._cascades[s].framebuffer.framebuffer),r.clear({color:e.ax.white,depth:1});for(const e of t.order){const r=t._mergedLayers[e];if(!r.hasShadowPass()||r.isHidden(o.transform.zoom))continue;const s=t.getLayerSourceCache(r),n=s?i[s.id]:void 0;("model"===r.type||n&&n.length)&&o.renderLayer(o,s,r,n);}}o.currentShadowCascade=0;}drawGroundShadows(){if(!this._enabled)return;const e=this.painter,t=e.style,i=e.context,o=t.directionalLight,r=t.ambientLight;if(!o||!r)return;const s=[],n=vo(e,e.longestCutoffRange);n.shouldRenderCutoff&&s.push("RENDER_CUTOFF");const a=So(o,r),l=new Lt(i.gl.LEQUAL,Lt.ReadOnly,e.depthRangeFor3D);for(const t of this._groundShadowTiles){const o=t.toUnwrapped(),r=e.isTileAffectedByFog(t),c=e.getOrCreateProgram("groundShadow",{defines:s,overrideFog:r});this.setupShadows(o,c),e.uploadCommonUniforms(i,c,o,null,n);const h={u_matrix:e.transform.calculateProjMatrix(o),u_ground_shadow_factor:a};c.draw(e,i.gl.TRIANGLES,l,Rt.disabled,Mt.multiply,Ft.disabled,h,"ground_shadow",e.tileExtentBuffer,e.quadTriangleIndexBuffer,e.tileExtentSegments,{},e.transform.zoom,null,null);}}getShadowPassColorMode(){return this.painter._shadowMapDebug?Mt.unblended:Mt.disabled}getShadowPassDepthMode(){return this._depthMode}getShadowCastingLayerCount(){return this._shadowLayerCount}calculateShadowPassMatrixFromTile(t){const i=this.painter.transform,o=i.calculatePosMatrix(t,i.worldSize);return e.a6.multiply(o,this._cascades[this.painter.currentShadowCascade].matrix,o),Float32Array.from(o)}calculateShadowPassMatrixFromMatrix(t){return e.a6.multiply(t,this._cascades[this.painter.currentShadowCascade].matrix,t),Float32Array.from(t)}setupShadows(t,i,o,r=0){if(!this._enabled)return;const s=this.painter.transform,n=this.painter.context,a=n.gl,l=this._uniformValues,c=new Float64Array(16),h=s.calculatePosMatrix(t,s.worldSize);for(let t=0;t<this._cascades.length;t++)e.a6.multiply(c,this._cascades[t].matrix,h),l[0===t?"u_light_matrix_0":"u_light_matrix_1"]=Float32Array.from(c),n.activeTexture.set(a.TEXTURE0+go.ShadowMap0+t),this._cascades[t].texture.bind(a.NEAREST,a.CLAMP_TO_EDGE);if(this.useNormalOffset=!!o,this.useNormalOffset){const i=e.bR(t.canonical),n=2/s.tileSize*e.V/xo.shadowMapResolution,a=n*this._cascades[0].boundingSphereRadius,c=n*this._cascades[this._cascades.length-1].boundingSphereRadius,h=("vector-tile"===o?1:3)/Math.pow(2,r-t.canonical.z-(1-s.zoom+Math.floor(s.zoom)));l.u_shadow_normal_offset=[i,a*h,c*h],l.u_shadow_bias=[6e-5,.0012,.012];}else l.u_shadow_bias=[36e-5,.0012,.012];i.setShadowUniformValues(n,l);}setupShadowsFromMatrix(t,i,o=!1){if(!this._enabled)return;const r=this.painter.context,s=r.gl,n=this._uniformValues,a=new Float64Array(16);for(let i=0;i<xo.cascadeCount;i++)e.a6.multiply(a,this._cascades[i].matrix,t),n[0===i?"u_light_matrix_0":"u_light_matrix_1"]=Float32Array.from(a),r.activeTexture.set(s.TEXTURE0+go.ShadowMap0+i),this._cascades[i].texture.bind(s.NEAREST,s.CLAMP_TO_EDGE);if(this.useNormalOffset=o,o){const e=5;n.u_shadow_normal_offset=[1,e,e],n.u_shadow_bias=[6e-5,.0012,.012];}else n.u_shadow_bias=[36e-5,.0012,.012];i.setShadowUniformValues(r,n);}getShadowUniformValues(){return this._uniformValues}getCurrentCascadeFrustum(){return this._cascades[this.painter.currentShadowCascade].frustum}computeSimplifiedTileShadowVolume(t,i,o,r){if(r[2]>=0)return {};const s=function(t,i,o){const r=o/(1<<t.canonical.z);return new e.bS([t.canonical.x*r+t.wrap*o,t.canonical.y*r+t.wrap*o,0],[(t.canonical.x+1)*r+t.wrap*o,(t.canonical.y+1)*r+t.wrap*o,i])}(t,i,o).getCorners(),n=i/-r[2];r[0]<0?(e.N.add(s[0],s[0],[r[0]*n,0,0]),e.N.add(s[3],s[3],[r[0]*n,0,0])):r[0]>0&&(e.N.add(s[1],s[1],[r[0]*n,0,0]),e.N.add(s[2],s[2],[r[0]*n,0,0])),r[1]<0?(e.N.add(s[0],s[0],[0,r[1]*n,0]),e.N.add(s[1],s[1],[0,r[1]*n,0])):r[1]>0&&(e.N.add(s[2],s[2],[0,r[1]*n,0]),e.N.add(s[3],s[3],[0,r[1]*n,0]));const a={};return a.vertices=s,a.planes=[To(s[1],s[0],s[4]),To(s[2],s[1],s[5]),To(s[3],s[2],s[6]),To(s[0],s[3],s[7])],a}addShadowReceiver(t,i,o){this._receivers.add(t,e.bS.fromTileIdAndHeight(t,i,o));}getMaxCascadeForTile(e){const t=this._receivers.get(e);return t&&t.lastCascade?t.lastCascade:0}}function To(t,i,o){const r=e.N.sub([],o,i),s=e.N.sub([],t,i),n=e.N.cross([],r,s),a=e.N.length(n);return 0===a?[0,0,1,0]:(e.N.scale(n,n,1/a),[n[0],n[1],n[2],-e.N.dot(n,i)])}function Eo(t){const i=t.properties.get("direction"),o=e.bQ(i.x,i.y,i.z);o[2]=e.aa(o[2],0,75);const r=e.bT([o[0],o[1],o[2]]);return e.N.fromValues(r.x,r.y,r.z)}function So(t,i){const o=t.properties.get("color"),r=t.properties.get("intensity"),s=t.properties.get("direction"),n=[s.x,s.y,s.z],a=i.properties.get("color"),l=i.properties.get("intensity"),c=Math.max(e.N.dot([0,0,1],n),0),h=[0,0,0];e.N.scale(h,a.toArray01Linear().slice(0,3),l);const u=[0,0,0];return e.N.scale(u,o.toArray01Linear().slice(0,3),c*r),e.bU([h[0]>0?h[0]/(h[0]+u[0]):0,h[1]>0?h[1]/(h[1]+u[1]):0,h[2]>0?h[2]/(h[2]+u[2]):0])}function Co(t,i,o,r,s,n){const a=t.zoom,l=t.scale,c=t.worldSize,h=1/c,u=t.aspect,d=Math.sqrt(1+u*u)*Math.tan(.5*t.fovX),_=d*d,p=r-o,f=r+o;let m,g;_>p/f?(m=r,g=r*d):(m=.5*f*(1+_),g=.5*Math.sqrt(p*p+2*(r*r+o*o)*_+f*f*_*_));const v=t.projection.pixelsPerMeter(t.center.lat,c),x=t._camera.getCameraToWorldMercator(),y=[0,0,-m*h];e.N.transformMat4(y,y,x);let b=g*h;const w=t._edgeInsets;if(!(0===w.left&&0===w.top&&0===w.right&&0===w.bottom||w.left===w.right&&w.top===w.bottom)){const i=t._camera.getWorldToCamera(t.worldSize,"meters"===t.projection.zAxisUnit?v:1),s=t._camera.getCameraToClipPerspective(t._fov,t.width/t.height,o,r);s[8]=2*-t.centerOffset.x/t.width,s[9]=2*t.centerOffset.y/t.height;const n=new Float64Array(16);e.a6.mul(n,s,i);const h=new Float64Array(16);e.a6.invert(h,n);const u=e.bq.fromInvProjectionMatrix(h,c,a,!0);for(const i of u.points){const o=((T=i)[0]/=l,T[1]/=l,T[2]=e.bl(T[2],t._center.lat),T);b=Math.max(b,e.N.len(e.N.subtract([],y,o)));}}var T;b*=s/(s-1);const E=Math.acos(i[2]),S=Math.atan2(-i[0],-i[1]),C=new _o;C.position=y,C.setPitchBearing(E,S);const I=C.getWorldToCamera(c,v),D=b*c,L=Math.min(t._mercatorZfromZoom(17)*c*-2,-2*D),A=C.getCameraToClipOrthographic(-D,D,-D,D,L,(D+n*v)/i[2]),R=new Float64Array(16);e.a6.multiply(R,A,I);const P=e.N.fromValues(Math.floor(1e6*y[0])/1e6*c,Math.floor(1e6*y[1])/1e6*c,0),M=.5*s,z=[0,0,0];e.N.transformMat4(z,P,R),e.N.scale(z,z,M);const O=[Math.floor(z[0]),Math.floor(z[1]),Math.floor(z[2])],F=[0,0,0];e.N.sub(F,z,O),e.N.scale(F,F,-1/M);const B=new Float64Array(16);return e.a6.identity(B),e.a6.translate(B,B,F),e.a6.multiply(R,B,R),[R,D]}const Io=(e,t)=>ce(e,t&&t.filter((e=>"source.canvas"!==e.identifier))),Do=e.ac(oi,["addLayer","removeLayer","setLights","setPaintProperty","setLayoutProperty","setSlot","setFilter","addSource","removeSource","setLayerZoomRange","setLight","setTransition","setGeoJSONSourceData","setTerrain","setFog","setProjection","setCamera","addImport","removeImport","updateImport"]),Lo=e.ac(oi,["setCenter","setZoom","setBearing","setPitch"]),Ao={version:8,layers:[],sources:{}},Ro={duration:300,delay:0},Po=new Set(["fill","line","background","hillshade","raster"]);class Mo extends e.E{constructor(t,i={}){super(),this.map=t,this.scope=i.scope||"",this.fragments=[],this.importDepth=i.importDepth||0,this.importsCache=i.importsCache||new Map,this.resolvedImports=i.resolvedImports||new Set,this.transition=e.e({},Ro),this._buildingIndex=new ei(this),this.crossTileSymbolIndex=new no,this._mergedOrder=[],this._drapedFirstOrder=[],this._mergedLayers={},this._mergedSourceCaches={},this._mergedOtherSourceCaches={},this._mergedSymbolSourceCaches={},this._has3DLayers=!1,this._hasCircleLayers=!1,this._hasSymbolLayers=!1,this._changes=i.styleChanges||new v,this.dispatcher=i.dispatcher?i.dispatcher:new e.bW(e.bX(),this),i.imageManager?this.imageManager=i.imageManager:(this.imageManager=new w,this.imageManager.setEventedParent(this)),this.imageManager.createScope(this.scope),this.glyphManager=i.glyphManager?i.glyphManager:new e.bY(t._requestManager,i.localFontFamily?e.bZ.all:i.localIdeographFontFamily?e.bZ.ideographs:e.bZ.none,i.localFontFamily||i.localIdeographFontFamily),i.modelManager?this.modelManager=i.modelManager:(this.modelManager=new x(t._requestManager),this.modelManager.setEventedParent(this)),this._layers={},this._serializedLayers={},this._sourceCaches={},this._otherSourceCaches={},this._symbolSourceCaches={},this._loaded=!1,this._precompileDone=!1,this._shouldPrecompile=!1,this._availableImages=[],this._order=[],this._markersNeedUpdate=!1,this.options=i.configOptions?i.configOptions:new Map,this._configDependentLayers=i.configDependentLayers?i.configDependentLayers:new Set,this._config=i.config,this.dispatcher.broadcast("setReferrer",e.b_());const o=this;this._rtlTextPluginCallback=Mo.registerForPluginStateChange((t=>{o.dispatcher.broadcast("syncRTLPluginState",{pluginStatus:t.pluginStatus,pluginURL:t.pluginURL},((t,i)=>{if(e.b$(t),i&&i.every((e=>e)))for(const e in o._sourceCaches){const t=o._sourceCaches[e],i=t.getSource().type;"vector"!==i&&"geojson"!==i||t.reload();}}));})),this.on("data",(e=>{if("source"!==e.dataType||"metadata"!==e.sourceDataType)return;const t=this.getOwnSource(e.sourceId);if(t&&t.vectorLayerIds)for(const e in this._layers){const i=this._layers[e];i.source===t.id&&this._validateLayer(i);}}));}loadURL(t,i={}){this.fire(new e.b("dataloading",{dataType:"style"}));const o="boolean"==typeof i.validate?i.validate:!e.c0(t);t=this.map._requestManager.normalizeStyleURL(t,i.accessToken),this.resolvedImports.add(t);const r=this.importsCache.get(t);if(r)return this._load(r,o);const s=this.map._requestManager.transformRequest(t,e.R.Style);this._request=e.g(s,((i,r)=>{if(this._request=null,i)this.fire(new e.a(i));else if(r)return this.importsCache.set(t,r),this._load(r,o)}));}loadJSON(t,i={}){this.fire(new e.b("dataloading",{dataType:"style"})),this._request=e.f.frame((()=>{this._request=null,this._load(t,!1!==i.validate);}));}loadEmpty(){this.fire(new e.b("dataloading",{dataType:"style"})),this._load(Ao,!1);}_loadImports(t,i,o){if(this.importDepth>=4)return e.w("Style doesn't support nesting deeper than 5"),Promise.resolve();const r=[];for(const e of t){const t=this._createFragmentStyle(e),s=new Promise((e=>{t.once("style.import.load",e),t.once("error",e);})).then((()=>this.mergeAll()));if(r.push(s),this.resolvedImports.has(e.url)){t.loadEmpty();continue}const n=e.data||this.importsCache.get(e.url);n?t.loadJSON(n,{validate:i}):e.url?t.loadURL(e.url,{validate:i}):t.loadEmpty();const a={style:t,id:e.id,config:e.config};if(o){const e=this.fragments.findIndex((({id:e})=>e===o));this.fragments=this.fragments.slice(0,e).concat(a).concat(this.fragments.slice(e));}else this.fragments.push(a);}return Promise.allSettled(r)}_createFragmentStyle(t){const i=this.scope?e.ag(t.id,this.scope):t.id,o=new Mo(this.map,{scope:i,styleChanges:this._changes,importDepth:this.importDepth+1,importsCache:this.importsCache,resolvedImports:new Set(this.resolvedImports),dispatcher:this.dispatcher,imageManager:this.imageManager,glyphManager:this.glyphManager,modelManager:this.modelManager,config:t.config,configOptions:this.options,configDependentLayers:this._configDependentLayers});return o.setEventedParent(this.map,{style:o}),o}_reloadImports(){this.mergeAll(),this._updateMapProjection(),this.updateConfigDependencies(),this.map._triggerCameraUpdate(this.camera),this.dispatcher.broadcast("setLayers",{layers:this._serializeLayers(this._order),scope:this.scope,options:this.options});const t=this.isRootStyle();this._shouldPrecompile=t,this.fire(new e.b(t?"style.load":"style.import.load"));}_load(t,i){const o=t.schema;if(this.isRootStyle()&&(t.fragment||o&&!1!==t.fragment)){const o=e.e({},Ao,{imports:[{id:"basemap",data:t,url:""}]});return void this._load(o,i)}if(this.setConfig(this._config,o),i&&Io(this,Y(t)))return;this._loaded=!0,this.stylesheet=e.c1(t);for(const e in t.sources)this.addSource(e,t.sources[e],{validate:!1,isInitialLoad:!0});t.sprite?this._loadSprite(t.sprite):(this.imageManager.setLoaded(!0,this.scope),this.dispatcher.broadcast("spriteLoaded",{scope:this.scope,isLoaded:!0})),this.glyphManager.setURL(t.glyphs,this.scope);const r=ii(this.stylesheet.layers);if(this._order=r.map((e=>e.id)),this.stylesheet.light&&e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."),this.stylesheet.lights)if(1===this.stylesheet.lights.length&&"flat"===this.stylesheet.lights[0].type){const e=this.stylesheet.lights[0];this.light=new ue(e.properties,e.id);}else this.setLights(this.stylesheet.lights);this.light||(this.light=new ue(this.stylesheet.light)),this._layers={},this._serializedLayers={};for(const t of r){const i=e.c2(t,this.scope,this.options);i.isConfigDependent&&this._configDependentLayers.add(i.fqid),i.setEventedParent(this,{layer:{id:i.id}}),this._layers[i.id]=i,this._serializedLayers[i.id]=i.serialize();const o=this.getOwnLayerSourceCache(i),r=!!this.directionalLight&&this.directionalLight.shadowsEnabled();o&&i.canCastShadows()&&r&&(o.castsShadows=!0);}this.stylesheet.models&&this.modelManager.addModels(this.stylesheet.models,this.scope);const s=this.stylesheet.terrain;s&&(void 0===this.disableElevatedTerrain&&(this.disableElevatedTerrain=e.f.hasCanvasFingerprintNoise()),this.disableElevatedTerrain?e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."):this.terrainSetForDrapingOnly()||this._createTerrain(s,1)),this.stylesheet.fog&&this._createFog(this.stylesheet.fog),this.stylesheet.transition&&this.setTransition(this.stylesheet.transition),this.fire(new e.b("data",{dataType:"style"})),t.imports?this._loadImports(t.imports,i).then((()=>this._reloadImports())):this._reloadImports();}isRootStyle(){return 0===this.importDepth}mergeAll(){let t,i,o,r,s,n,a,l;this.terrain&&this.terrain.scope!==this.scope&&delete this.terrain,this.forEachFragmentStyle((e=>{if(e.stylesheet){if(null!=e.light&&(t=e.light),e.stylesheet.lights)for(const t of e.stylesheet.lights)"ambient"===t.type&&null!=e.ambientLight&&(i=e.ambientLight),"directional"===t.type&&null!=e.directionalLight&&(o=e.directionalLight);r=this._prioritizeTerrain(r,e.terrain,e.stylesheet.terrain),e.stylesheet.fog&&null!=e.fog&&(s=e.fog),null!=e.stylesheet.camera&&(l=e.stylesheet.camera),null!=e.stylesheet.projection&&(n=e.stylesheet.projection),null!=e.stylesheet.transition&&(a=e.stylesheet.transition);}})),this.light=t,this.ambientLight=i,this.directionalLight=o,this.fog=s,null===r?delete this.terrain:this.terrain=r,this.camera=l||{"camera-projection":"perspective"},this.projection=n||{name:"mercator"},this.transition=e.e({},Ro,a),this.mergeSources(),this.mergeLayers();}forEachFragmentStyle(e){const t=i=>{for(const e of i.fragments)t(e.style);e(i);};t(this);}_prioritizeTerrain(e,t,i){const o=e&&0===e.drapeRenderMode;return null===i?t&&0===t.drapeRenderMode?t:o?e:null:null!=t&&(!e||o||t&&1===t.drapeRenderMode)?t:e}mergeTerrain(){let e;this.terrain&&this.terrain.scope!==this.scope&&delete this.terrain,this.forEachFragmentStyle((t=>{e=this._prioritizeTerrain(e,t.terrain,t.stylesheet.terrain);})),null===e?delete this.terrain:this.terrain=e;}mergeProjection(){let e;this.forEachFragmentStyle((t=>{null!=t.stylesheet.projection&&(e=t.stylesheet.projection);})),this.projection=e||{name:"mercator"};}mergeSources(){const t={},i={},o={};this.forEachFragmentStyle((r=>{for(const i in r._sourceCaches){const o=e.ag(i,r.scope);t[o]=r._sourceCaches[i];}for(const t in r._otherSourceCaches){const o=e.ag(t,r.scope);i[o]=r._otherSourceCaches[t];}for(const t in r._symbolSourceCaches){const i=e.ag(t,r.scope);o[i]=r._symbolSourceCaches[t];}})),this._mergedSourceCaches=t,this._mergedOtherSourceCaches=i,this._mergedSymbolSourceCaches=o;}mergeLayers(){const t={},i=[],o={};this._has3DLayers=!1,this._hasCircleLayers=!1,this._hasSymbolLayers=!1,this.forEachFragmentStyle((o=>{for(const r of o._order){const s=o._layers[r];if("slot"===s.type){const i=e.c3(r);if(t[i])continue;t[i]=[];}s.slot&&t[s.slot]?t[s.slot].push(s):i.push(s);}})),this._mergedOrder=[];const r=(i=[])=>{for(const s of i)if("slot"===s.type){const i=e.c3(s.id);t[i]&&r(t[i]);}else {const t=e.ag(s.id,s.scope);this._mergedOrder.push(t),o[t]=s,s.is3D()&&(this._has3DLayers=!0),"circle"===s.type&&(this._hasCircleLayers=!0),"symbol"===s.type&&(this._hasSymbolLayers=!0);}};r(i),this._mergedLayers=o,this.updateDrapeFirstLayers(),this._buildingIndex.processLayersChanged();}terrainSetForDrapingOnly(){return !!this.terrain&&0===this.terrain.drapeRenderMode}getCamera(){return this.stylesheet.camera}setCamera(t){return this.stylesheet.camera=e.e({},this.stylesheet.camera,t),this.camera=this.stylesheet.camera,this}setProjection(e){e?this.stylesheet.projection=e:delete this.stylesheet.projection,this.mergeProjection(),this._updateMapProjection();}applyProjectionUpdate(){this._loaded&&(this.dispatcher.broadcast("setProjection",this.map.transform.projectionOptions),this.map.transform.projection.requiresDraping?(this.getTerrain()||this.stylesheet.terrain)&&!this.disableElevatedTerrain||this.setTerrainForDraping():this.terrainSetForDrapingOnly()&&this.setTerrain(null,0));}_updateMapProjection(){this.isRootStyle()&&(this.map._useExplicitProjection?this.applyProjectionUpdate():this.map._prioritizeAndUpdateProjection(null,this.projection));}_loadSprite(t){this._spriteRequest=function(t,i,o){let r,s,n;const a=e.f.devicePixelRatio>1?"@2x":"";let l=e.g(i.transformRequest(i.normalizeSpriteURL(t,a,".json"),e.R.SpriteJSON),((e,t)=>{l=null,n||(n=e,r=t,h());})),c=e.d(i.transformRequest(i.normalizeSpriteURL(t,a,".png"),e.R.SpriteImage),((e,t)=>{c=null,n||(n=e,s=t,h());}));function h(){if(n)o(n);else if(r&&s){const t=e.f.getImageData(s),i={};for(const o in r){const{width:s,height:n,x:a,y:l,sdf:c,pixelRatio:h,stretchX:u,stretchY:d,content:_}=r[o],p=new e.h({width:s,height:n});e.h.copy(t,p,{x:a,y:l},{x:0,y:0},{width:s,height:n}),i[o]={data:p,pixelRatio:h,sdf:c,stretchX:u,stretchY:d,content:_};}o(null,i);}}return {cancel(){l&&(l.cancel(),l=null),c&&(c.cancel(),c=null);}}}(t,this.map._requestManager,((t,i)=>{if(this._spriteRequest=null,t)this.fire(new e.a(t));else if(i)for(const e in i)this.imageManager.addImage(e,this.scope,i[e]);this.imageManager.setLoaded(!0,this.scope),this._availableImages=this.imageManager.listImages(this.scope),this.dispatcher.broadcast("setImages",{scope:this.scope,images:this._availableImages}),this.dispatcher.broadcast("spriteLoaded",{scope:this.scope,isLoaded:!0}),this.fire(new e.b("data",{dataType:"style"}));}));}_validateLayer(t){const i=this.getOwnSource(t.source);if(!i)return;const o=t.sourceLayer;o&&("geojson"===i.type||i.vectorLayerIds&&-1===i.vectorLayerIds.indexOf(o))&&this.fire(new e.a(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`)));}loaded(){if(!this._loaded)return !1;if(Object.keys(this._changes.getUpdatedSourceCaches()).length)return !1;for(const e in this._sourceCaches)if(!this._sourceCaches[e].loaded())return !1;if(!this.imageManager.isLoaded())return !1;if(!this.modelManager.isLoaded())return !1;for(const{style:e}of this.fragments)if(!e.loaded())return !1;return !0}_serializeImports(){if(this.stylesheet.imports)return this.stylesheet.imports.map(((e,t)=>{const i=this.fragments[t];return i&&i.style&&(e.data=i.style.serialize()),e}))}_serializeSources(){const e={};for(const t in this._sourceCaches){const i=this._sourceCaches[t].getSource();e[i.id]||(e[i.id]=i.serialize());}return e}_serializeLayers(e){const t=[];for(const i of e){const e=this._layers[i];e&&"custom"!==e.type&&t.push(e.serialize());}return t}hasLightTransitions(){return !(!this.light||!this.light.hasTransition())||!(!this.ambientLight||!this.ambientLight.hasTransition())||!(!this.directionalLight||!this.directionalLight.hasTransition())}hasFogTransition(){return !!this.fog&&this.fog.hasTransition()}hasTransitions(){if(this.hasLightTransitions())return !0;if(this.hasFogTransition())return !0;for(const e in this._sourceCaches)if(this._sourceCaches[e].hasTransition())return !0;for(const e in this._layers)if(this._layers[e].hasTransition())return !0;return !1}get order(){return this.terrain?this._drapedFirstOrder:this._mergedOrder}isLayerDraped(e){return !!this.terrain&&("function"==typeof e.isLayerDraped?e.isLayerDraped(this.getLayerSourceCache(e)):Po.has(e.type))}_checkLoaded(){if(!this._loaded)throw new Error("Style is not done loading")}_checkLayer(t){const i=this.getOwnLayer(t);if(i)return i;this.fire(new e.a(new Error(`The layer '${t}' does not exist in the map's style.`)));}_checkSource(t){const i=this.getOwnSource(t);if(i)return i;this.fire(new e.a(new Error(`The source '${t}' does not exist in the map's style.`)));}update(t){if(!this._loaded)return;this.ambientLight&&this.ambientLight.recalculate(t),this.directionalLight&&this.directionalLight.recalculate(t);const i=this.calculateLightsBrightness();t.brightness=i||0,i!==this._brightness&&(this._brightness=i,this.dispatcher.broadcast("setBrightness",i));const o=this._changes.isDirty();if(this._changes.isDirty()){const e=this._changes.getLayerUpdatesByScope();for(const t in e){const{updatedIds:i,removedIds:o}=e[t];(i||o)&&this._updateWorkerLayers(t,i,o);}this.updateSourceCaches(),this._updateTilesForChangedImages(),this.updateLayers(t),this.light&&this.light.updateTransitions(t),this.ambientLight&&this.ambientLight.updateTransitions(t),this.directionalLight&&this.directionalLight.updateTransitions(t),this.fog&&this.fog.updateTransitions(t),this._changes.reset();}const r={};for(const e in this._mergedSourceCaches){const t=this._mergedSourceCaches[e];r[e]=t.used,t.used=!1,t.tileCoverLift=0;}for(const e of this._mergedOrder){const i=this._mergedLayers[e];if(i.recalculate(t,this._availableImages),!i.isHidden(t.zoom)){const e=this.getLayerSourceCache(i);e&&(e.used=!0,e.tileCoverLift=Math.max(e.tileCoverLift,i.tileCoverLift()));}if(!this._precompileDone&&this._shouldPrecompile)for(let e=i.minzoom||0;e<(i.maxzoom||25.5);e++){const e=this.map.painter;if(e){const o=i.getProgramIds();if(!o)continue;for(const r of o){const o=i.getDefaultProgramParams(r,t.zoom);o&&(e.style=this,this.fog&&(e._fogVisible=!0,o.overrideFog=!0,e.getOrCreateProgram(r,o)),e._fogVisible=!1,o.overrideFog=!1,e.getOrCreateProgram(r,o),(this.stylesheet.terrain||this.stylesheet.projection&&"globe"===this.stylesheet.projection.name)&&(o.overrideRtt=!0,e.getOrCreateProgram(r,o)));}}}}this._shouldPrecompile&&(this._precompileDone=!0);for(const t in r){const i=this._mergedSourceCaches[t];r[t]!==i.used&&i.getSource().fire(new e.b("data",{sourceDataType:"visibility",dataType:"source",sourceId:i.getSource().id}));}this.light&&this.light.recalculate(t),this.terrain&&this.terrain.recalculate(t),this.fog&&this.fog.recalculate(t),this.z=t.zoom,this._markersNeedUpdate&&(this._updateMarkersOpacity(),this._markersNeedUpdate=!1),o&&this.fire(new e.b("data",{dataType:"style"}));}_updateTilesForChangedImages(){const e=this._changes.getUpdatedImages();if(e.length){for(const t in this._sourceCaches)this._sourceCaches[t].reloadTilesForDependencies(["icons","patterns"],e);this._changes.resetUpdatedImages();}}_updateWorkerLayers(e,t,i){const o=this.getFragmentStyle(e);o&&this.dispatcher.broadcast("updateLayers",{layers:t?o._serializeLayers(t):[],scope:e,removedIds:i||[],options:o.options});}setState(i){if(this._checkLoaded(),Io(this,Y(i)))return !1;(i=e.c1(i)).layers=ii(i.layers);const o=function(e,i){if(!e)return [{command:oi.setStyle,args:[i]}];let o=[];try{if(!t(e.version,i.version))return [{command:oi.setStyle,args:[i]}];t(e.center,i.center)||o.push({command:oi.setCenter,args:[i.center]}),t(e.zoom,i.zoom)||o.push({command:oi.setZoom,args:[i.zoom]}),t(e.bearing,i.bearing)||o.push({command:oi.setBearing,args:[i.bearing]}),t(e.pitch,i.pitch)||o.push({command:oi.setPitch,args:[i.pitch]}),t(e.sprite,i.sprite)||o.push({command:oi.setSprite,args:[i.sprite]}),t(e.glyphs,i.glyphs)||o.push({command:oi.setGlyphs,args:[i.glyphs]}),t(e.imports,i.imports)||function(e=[],i=[],o){i=i||[];const r=(e=e||[]).map(ci),s=i.map(ci),n=e.reduce(hi,{}),a=i.reduce(hi,{}),l=r.slice();let c,h,u,d;for(c=0,h=0;c<r.length;c++)u=r[c],a.hasOwnProperty(u)?h++:(o.push({command:oi.removeImport,args:[u]}),l.splice(l.indexOf(u,h),1));for(c=0,h=0;c<s.length;c++)u=s[s.length-1-c],l[l.length-1-c]!==u&&(n.hasOwnProperty(u)?(o.push({command:oi.removeImport,args:[u]}),l.splice(l.lastIndexOf(u,l.length-h),1)):h++,d=l[l.length-c],o.push({command:oi.addImport,args:[a[u],d]}),l.splice(l.length-c,0,u));for(const e of i){const i=n[e.id];i&&!t(i,e)&&o.push({command:oi.updateImport,args:[e.id,e]});}}(e.imports,i.imports,o),t(e.transition,i.transition)||o.push({command:oi.setTransition,args:[i.transition]}),t(e.light,i.light)||o.push({command:oi.setLight,args:[i.light]}),t(e.fog,i.fog)||o.push({command:oi.setFog,args:[i.fog]}),t(e.projection,i.projection)||o.push({command:oi.setProjection,args:[i.projection]}),t(e.lights,i.lights)||o.push({command:oi.setLights,args:[i.lights]}),t(e.camera,i.camera)||o.push({command:oi.setCamera,args:[i.camera]});const r={},s=[];!function(e,i,o,r){let s;for(s in i=i||{},e=e||{})e.hasOwnProperty(s)&&(i.hasOwnProperty(s)||si(s,o,r));for(s in i){if(!i.hasOwnProperty(s))continue;const n=i[s];e.hasOwnProperty(s)?t(e[s],n)||("geojson"===e[s].type&&"geojson"===n.type&&ai(e,i,s)?o.push({command:oi.setGeoJSONSourceData,args:[s,n.data]}):ni(s,i,o,r)):ri(s,i,o);}}(e.sources,i.sources,s,r);const n=[];e.layers&&e.layers.forEach((e=>{e.source&&r[e.source]?o.push({command:oi.removeLayer,args:[e.id]}):n.push(e);}));let a=e.terrain;a&&r[a.source]&&(o.push({command:oi.setTerrain,args:[void 0]}),a=void 0),o=o.concat(s),t(a,i.terrain)||o.push({command:oi.setTerrain,args:[i.terrain]}),function(e,i,o){i=i||[];const r=(e=e||[]).map(ci),s=i.map(ci),n=e.reduce(hi,{}),a=i.reduce(hi,{}),l=r.slice(),c=Object.create(null);let h,u,d,_,p,f,m;for(h=0,u=0;h<r.length;h++)d=r[h],a.hasOwnProperty(d)?u++:(o.push({command:oi.removeLayer,args:[d]}),l.splice(l.indexOf(d,u),1));for(h=0,u=0;h<s.length;h++)d=s[s.length-1-h],l[l.length-1-h]!==d&&(n.hasOwnProperty(d)?(o.push({command:oi.removeLayer,args:[d]}),l.splice(l.lastIndexOf(d,l.length-u),1)):u++,f=l[l.length-h],o.push({command:oi.addLayer,args:[a[d],f]}),l.splice(l.length-h,0,d),c[d]=!0);for(h=0;h<s.length;h++)if(d=s[h],_=n[d],p=a[d],!c[d]&&!t(_,p))if(t(_.source,p.source)&&t(_["source-layer"],p["source-layer"])&&t(_.type,p.type)){for(m in li(_.layout,p.layout,o,d,null,oi.setLayoutProperty),li(_.paint,p.paint,o,d,null,oi.setPaintProperty),t(_.slot,p.slot)||o.push({command:oi.setSlot,args:[d,p.slot]}),t(_.filter,p.filter)||o.push({command:oi.setFilter,args:[d,p.filter]}),t(_.minzoom,p.minzoom)&&t(_.maxzoom,p.maxzoom)||o.push({command:oi.setLayerZoomRange,args:[d,p.minzoom,p.maxzoom]}),_)_.hasOwnProperty(m)&&"layout"!==m&&"paint"!==m&&"filter"!==m&&"metadata"!==m&&"minzoom"!==m&&"maxzoom"!==m&&"slot"!==m&&(0===m.indexOf("paint.")?li(_[m],p[m],o,d,m.slice(6),oi.setPaintProperty):t(_[m],p[m])||o.push({command:oi.setLayerProperty,args:[d,m,p[m]]}));for(m in p)p.hasOwnProperty(m)&&!_.hasOwnProperty(m)&&"layout"!==m&&"paint"!==m&&"filter"!==m&&"metadata"!==m&&"minzoom"!==m&&"maxzoom"!==m&&"slot"!==m&&(0===m.indexOf("paint.")?li(_[m],p[m],o,d,m.slice(6),oi.setPaintProperty):t(_[m],p[m])||o.push({command:oi.setLayerProperty,args:[d,m,p[m]]}));}else o.push({command:oi.removeLayer,args:[d]}),f=l[l.lastIndexOf(d)+1],o.push({command:oi.addLayer,args:[p,f]});}(n,i.layers,o);}catch(e){console.warn("Unable to compute style diff:",e),o=[{command:oi.setStyle,args:[i]}];}return o}(this.serialize(),i).filter((e=>!(e.command in Lo)));if(0===o.length)return !1;const r=o.filter((e=>!(e.command in Do)));if(r.length>0)throw new Error(`Unimplemented: ${r.map((e=>e.command)).join(", ")}.`);return o.forEach((e=>{this[e.command].apply(this,e.args);})),this.stylesheet=i,this.mergeAll(),this.dispatcher.broadcast("setLayers",{layers:this._serializeLayers(this._order),scope:this.scope,options:this.options}),!0}addImage(t,i){return this.getImage(t)?this.fire(new e.a(new Error("An image with this name already exists."))):(this.imageManager.addImage(t,this.scope,i),this._afterImageUpdated(t),this)}updateImage(e,t){this.imageManager.updateImage(e,this.scope,t);}getImage(e){return this.imageManager.getImage(e,this.scope)}removeImage(t){return this.getImage(t)?(this.imageManager.removeImage(t,this.scope),this._afterImageUpdated(t),this):this.fire(new e.a(new Error("No image with this name exists.")))}_afterImageUpdated(t){this._availableImages=this.imageManager.listImages(this.scope),this._changes.updateImage(t),this.dispatcher.broadcast("setImages",{scope:this.scope,images:this._availableImages}),this.fire(new e.b("data",{dataType:"style"}));}listImages(){return this._checkLoaded(),this._availableImages.slice()}addModel(e,t,i={}){return this._checkLoaded(),this._validate(ae,`models.${e}`,t,null,i)||(this.modelManager.addModel(e,t,this.scope),this._changes.setDirty()),this}hasModel(e){return this.modelManager.hasModel(e,this.scope)}removeModel(t){return this.hasModel(t)?(this.modelManager.removeModel(t,this.scope),this):this.fire(new e.a(new Error("No model with this ID exists.")))}listModels(){return this._checkLoaded(),this.modelManager.listModels(this.scope)}addSource(t,i,o={}){if(this._checkLoaded(),void 0!==this.getOwnSource(t))throw new Error(`There is already a source with ID "${t}".`);if(!i.type)throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);if(["vector","raster","geojson","video","image"].indexOf(i.type)>=0&&this._validate(J,`sources.${t}`,i,null,o))return;this.map&&this.map._collectResourceTiming&&(i.collectResourceTiming=!0);const r=Vt(t,i,this.dispatcher,this);r.scope=this.scope,r.setEventedParent(this,(()=>({isSourceLoaded:this._isSourceCacheLoaded(r.id),source:r.serialize(),sourceId:r.id})));const s=t=>{const i=(t?"symbol:":"other:")+r.id,o=e.ag(i,this.scope),s=this._sourceCaches[i]=new Kt(o,r,t);(t?this._symbolSourceCaches:this._otherSourceCaches)[r.id]=s,s.onAdd(this.map);};s(!1),"vector"!==i.type&&"geojson"!==i.type||s(!0),r.onAdd&&r.onAdd(this.map),o.isInitialLoad||(this.mergeSources(),this._changes.setDirty());}removeSource(t){this._checkLoaded();const i=this.getOwnSource(t);if(!i)throw new Error("There is no source with this ID");for(const i in this._layers)if(this._layers[i].source===t)return this.fire(new e.a(new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`)));if(this.terrain&&this.terrain.scope===this.scope&&this.terrain.get().source===t)return this.fire(new e.a(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));const o=this.getOwnSourceCaches(t);for(const t of o){const i=e.c3(t.id);delete this._sourceCaches[i],this._changes.discardSourceCacheUpdate(t.id),t.fire(new e.b("data",{sourceDataType:"metadata",dataType:"source",sourceId:t.getSource().id})),t.setEventedParent(null),t.clearTiles();}return delete this._otherSourceCaches[t],delete this._symbolSourceCaches[t],this.mergeSources(),i.setEventedParent(null),i.onRemove&&i.onRemove(this.map),this._changes.setDirty(),this}setGeoJSONSourceData(e,t){this._checkLoaded(),this.getOwnSource(e).setData(t),this._changes.setDirty();}getOwnSource(e){const t=this.getOwnSourceCache(e);return t&&t.getSource()}getOwnSources(){const e=[];for(const t in this._otherSourceCaches){const i=this.getOwnSourceCache(t);i&&e.push(i.getSource());}return e}areTilesLoaded(){const e=this._mergedSourceCaches;for(const t in e){const i=e[t]._tiles;for(const e in i){const t=i[e];if("loaded"!==t.state&&"errored"!==t.state)return !1}}return !0}setLights(t){if(this._checkLoaded(),!t)return delete this.ambientLight,void delete this.directionalLight;const i=this._getTransitionParameters();for(const e of t){if(this._validate(ee,"lights",e))return;switch(e.type){case"ambient":if(this.ambientLight){const t=this.ambientLight;t.set(e),t.updateTransitions(i);}else this.ambientLight=new Te(e,Ee,this.scope,this.options);break;case"directional":if(this.directionalLight){const t=this.directionalLight;t.set(e),t.updateTransitions(i);}else this.directionalLight=new Te(e,Se,this.scope,this.options);}}const o=new e.K(this.z||0,i);this.ambientLight&&this.ambientLight.recalculate(o),this.directionalLight&&this.directionalLight.recalculate(o),this._brightness=this.calculateLightsBrightness(),this.dispatcher.broadcast("setBrightness",this._brightness);}calculateLightsBrightness(){const t=this.directionalLight,i=this.ambientLight;if(!t||!i)return;const o=e=>.2126*(e[0]<=.03928?e[0]/12.92:Math.pow((e[0]+.055)/1.055,2.4))+.7152*(e[1]<=.03928?e[1]/12.92:Math.pow((e[1]+.055)/1.055,2.4))+.0722*(e[2]<=.03928?e[2]/12.92:Math.pow((e[2]+.055)/1.055,2.4)),r=t.properties.get("color").toArray01(),s=t.properties.get("intensity"),n=t.properties.get("direction"),a=1-e.bQ(n.x,n.y,n.z)[2]/90,l=o(r)*s*a,c=i.properties.get("color").toArray01(),h=i.properties.get("intensity");return (l+o(c)*h)/2}getBrightness(){return this._brightness}getLights(){if(!this.enable3dLights())return null;const e=[];return this.directionalLight&&e.push(this.directionalLight.get()),this.ambientLight&&e.push(this.ambientLight.get()),e}enable3dLights(){return !!this.ambientLight&&!!this.directionalLight}getFragmentStyle(t){if(!t)return this;if(e.c4(t)){const i=e.c5(t),o=this.fragments.find((({id:e})=>e===i));if(!o)throw new Error(`Style import not found: ${t}`);const r=e.c3(t);return o.style.getFragmentStyle(r)}{const e=this.fragments.find((({id:e})=>e===t));if(!e)throw new Error(`Style import not found: ${t}`);return e.style}}getConfigProperty(t,i){const o=this.getFragmentStyle(t);if(!o)return null;const r=e.ag(i,o.scope),s=o.options.get(r),n=s?s.value||s.default:null;return n?n.serialize():null}setConfigProperty(t,i,o){const r=e.r(o);if("success"!==r.result)return void Io(this,r.value);const s=r.value.expression,n=this.getFragmentStyle(t);if(!n)return;const a=e.ag(i,n.scope),l=n.options.get(a);l&&(this.options.set(a,{...l,value:s}),this.updateConfigDependencies());}setConfig(t,i){if(this._config=t,t||i)if(i)for(const o in i){let r,s;const n=e.r(i[o].default);if("success"===n.result&&(r=n.value.expression),t&&void 0!==t[o]){const i=e.r(t[o]);"success"===i.result&&(s=i.value.expression);}const{minValue:a,maxValue:l,stepValue:c,type:h,values:u}=i[o];if(r){const t=e.ag(o,this.scope);this.options.set(t,{default:r,value:s,minValue:a,maxValue:l,stepValue:c,type:h,values:u});}else this.fire(new e.a(new Error(`No schema defined for config option "${o}".`)));}else this.fire(new e.a(new Error("Attempting to set config for a style without schema.")));}updateConfigDependencies(){for(const e of this._configDependentLayers){const t=this.getLayer(e);t&&(t.possiblyEvaluateVisibility(),this._updateLayer(t));}this.ambientLight&&this.ambientLight.updateConfig(this.options),this.directionalLight&&this.directionalLight.updateConfig(this.options),this.fog&&this.fog.updateConfig(this.options),this._changes.setDirty();}addLayer(t,i,o={}){this._checkLoaded();const r=t.id;if(this._layers[r])return void this.fire(new e.a(new Error(`Layer with id "${r}" already exists on this map`)));let s;if("custom"===t.type){if(Io(this,e.c6(t)))return;s=e.c2(t,this.scope,this.options);}else {if("object"==typeof t.source&&(this.addSource(r,t.source),t=e.c1(t),t=e.e(t,{source:r})),this._validate(oe,`layers.${r}`,t,{arrayIndex:-1},o))return;s=e.c2(t,this.scope,this.options),this._validateLayer(s),s.setEventedParent(this,{layer:{id:r}}),this._serializedLayers[s.id]=s.serialize();}s.isConfigDependent&&this._configDependentLayers.add(s.fqid);let n=this._order.length;if(i){const t=this._order.indexOf(i);if(-1===t)return void this.fire(new e.a(new Error(`Layer with id "${i}" does not exist on this map.`)));s.slot===this._layers[i].slot?n=t:e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);}this._order.splice(n,0,r),this._layerOrderChanged=!0,this._layers[r]=s;const a=this.getOwnLayerSourceCache(s),l=!!this.directionalLight&&this.directionalLight.shadowsEnabled();a&&s.canCastShadows()&&l&&(a.castsShadows=!0);const c=this._changes.getRemovedLayer(s);if(c&&s.source&&a&&"custom"!==s.type){this._changes.discardLayerRemoval(s);const t=e.ag(s.source,s.scope);c.type!==s.type?this._changes.updateSourceCache(t,"clear"):(this._changes.updateSourceCache(t,"reload"),a.pause());}this._updateLayer(s),s.onAdd&&s.onAdd(this.map),s.scope=this.scope,this.mergeLayers();}moveLayer(t,i){this._checkLoaded();const o=this._checkLayer(t);if(!o)return;if(t===i)return;const r=this._order.indexOf(t);this._order.splice(r,1);let s=this._order.length;if(i){const t=this._order.indexOf(i);if(-1===t)return void this.fire(new e.a(new Error(`Layer with id "${i}" does not exist on this map.`)));o.slot===this._layers[i].slot?s=t:e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);}this._order.splice(s,0,t),this._changes.setDirty(),this._layerOrderChanged=!0,this.mergeLayers();}removeLayer(e){this._checkLoaded();const t=this._checkLayer(e);if(!t)return;t.setEventedParent(null);const i=this._order.indexOf(e);this._order.splice(i,1),delete this._layers[e],delete this._serializedLayers[e],this._changes.setDirty(),this._layerOrderChanged=!0,this._configDependentLayers.delete(t.fqid),this._changes.removeLayer(t);const o=this.getOwnLayerSourceCache(t);if(o&&o.castsShadows){let e=!1;for(const i in this._layers)if(this._layers[i].source===t.source&&this._layers[i].canCastShadows()){e=!0;break}o.castsShadows=e;}t.onRemove&&t.onRemove(this.map),this.mergeLayers();}getOwnLayer(e){return this._layers[e]}hasLayer(e){return e in this._mergedLayers}hasLayerType(e){for(const t in this._layers)if(this._layers[t].type===e)return !0;return !1}setLayerZoomRange(e,t,i){this._checkLoaded();const o=this._checkLayer(e);o&&(o.minzoom===t&&o.maxzoom===i||(null!=t&&(o.minzoom=t),null!=i&&(o.maxzoom=i),this._updateLayer(o)));}setSlot(e,t){this._checkLoaded();const i=this._checkLayer(e);i&&i.slot!==t&&(i.slot=t,this._updateLayer(i));}setFilter(i,o,r={}){this._checkLoaded();const s=this._checkLayer(i);if(s&&!t(s.filter,o))return null==o?(s.filter=void 0,void this._updateLayer(s)):void(this._validate(re,`layers.${s.id}.filter`,o,{layerType:s.type},r)||(s.filter=e.c1(o),this._updateLayer(s)))}getFilter(t){const i=this._checkLayer(t);if(i)return e.c1(i.filter)}setLayoutProperty(i,o,r,s={}){this._checkLoaded();const n=this._checkLayer(i);if(n&&!t(n.getLayoutProperty(o),r)){if(null!=r&&(!s||!1!==s.validate)&&Io(n,ne.call(Y,{key:`layers.${i}.layout.${o}`,layerType:n.type,objectKey:o,value:r,styleSpec:e.D,style:{glyphs:!0,sprite:!0}})))return;n.setLayoutProperty(o,r),n.isConfigDependent&&this._configDependentLayers.add(n.fqid),this._updateLayer(n);}}getLayoutProperty(e,t){const i=this._checkLayer(e);if(i)return i.getLayoutProperty(t)}setPaintProperty(i,o,r,s={}){this._checkLoaded();const n=this._checkLayer(i);if(!n)return;if(t(n.getPaintProperty(o),r))return;if(null!=r&&(!s||!1!==s.validate)&&Io(n,se.call(Y,{key:`layers.${i}.paint.${o}`,layerType:n.type,objectKey:o,value:r,styleSpec:e.D})))return;const a=n.setPaintProperty(o,r);n.isConfigDependent&&this._configDependentLayers.add(n.fqid),a&&this._updateLayer(n),this._changes.updatePaintProperties(n);}getPaintProperty(e,t){const i=this._checkLayer(e);if(i)return i.getPaintProperty(t)}setFeatureState(t,i){this._checkLoaded();const o=t.source,r=t.sourceLayer,s=this._checkSource(o);if(!s)return;const n=s.type;if("geojson"===n&&r)return void this.fire(new e.a(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));if("vector"===n&&!r)return void this.fire(new e.a(new Error("The sourceLayer parameter must be provided for vector source types.")));void 0===t.id&&this.fire(new e.a(new Error("The feature id parameter must be provided.")));const a=this.getOwnSourceCaches(o);for(const e of a)e.setFeatureState(r,t.id,i);}removeFeatureState(t,i){this._checkLoaded();const o=t.source,r=this._checkSource(o);if(!r)return;const s=r.type,n="vector"===s?t.sourceLayer:void 0;if("vector"===s&&!n)return void this.fire(new e.a(new Error("The sourceLayer parameter must be provided for vector source types.")));if(i&&"string"!=typeof t.id&&"number"!=typeof t.id)return void this.fire(new e.a(new Error("A feature id is required to remove its specific state property.")));const a=this.getOwnSourceCaches(o);for(const e of a)e.removeFeatureState(n,t.id,i);}getFeatureState(t){this._checkLoaded();const i=t.source,o=t.sourceLayer,r=this._checkSource(i);if(r){if("vector"!==r.type||o)return void 0===t.id&&this.fire(new e.a(new Error("The feature id parameter must be provided."))),this.getOwnSourceCaches(i)[0].getFeatureState(o,t.id);this.fire(new e.a(new Error("The sourceLayer parameter must be provided for vector source types.")));}}setTransition(t){return this.stylesheet.transition=e.e({},this.stylesheet.transition,t),this.transition=this.stylesheet.transition,this}getTransition(){return e.e({},this.stylesheet.transition)}serialize(){this._checkLoaded();const t=this.getTerrain(),i=t&&this.terrain&&this.terrain.scope===this.scope?t:this.stylesheet.terrain;return e.c7({version:this.stylesheet.version,name:this.stylesheet.name,metadata:this.stylesheet.metadata,imports:this._serializeImports(),schema:this.stylesheet.schema,camera:this.stylesheet.camera,light:this.stylesheet.light,lights:this.stylesheet.lights,terrain:i,fog:this.stylesheet.fog,center:this.stylesheet.center,zoom:this.stylesheet.zoom,bearing:this.stylesheet.bearing,pitch:this.stylesheet.pitch,sprite:this.stylesheet.sprite,glyphs:this.stylesheet.glyphs,transition:this.stylesheet.transition,projection:this.stylesheet.projection,sources:this._serializeSources(),layers:this._serializeLayers(this._order)},(e=>void 0!==e))}_updateLayer(t){this._changes.updateLayer(t);const i=this.getLayerSourceCache(t),o=e.ag(t.source,t.scope),r=this._changes.getUpdatedSourceCaches();t.source&&!r[o]&&i&&"raster"!==i.getSource().type&&(this._changes.updateSourceCache(o,"reload"),i.pause()),t.invalidateCompiledFilter();}_flattenAndSortRenderedFeatures(e){const t=e=>"fill-extrusion"===this._mergedLayers[e].type||"model"===this._mergedLayers[e].type,i=this.order,o={},r=[];for(let s=i.length-1;s>=0;s--){const n=i[s];if(t(n)){o[n]=s;for(const t of e){const e=t[n];if(e)for(const t of e)r.push(t);}}}r.sort(((e,t)=>t.intersectionZ-e.intersectionZ));const s=[];for(let n=i.length-1;n>=0;n--){const a=i[n];if(t(a))for(let e=r.length-1;e>=0;e--){const t=r[e].feature;if(o[t.layer.id]<n)break;s.push(t),r.pop();}else for(const t of e){const e=t[a];if(e)for(const t of e)s.push(t.feature);}}return s}queryRenderedFeatures(t,i,o){i&&i.filter&&this._validate(re,"queryRenderedFeatures.filter",i.filter,null,i),i.scope=this.scope,i.availableImages=this._availableImages,i.serializedLayers=this._serializedLayers;const r={};if(i&&i.layers){if(!Array.isArray(i.layers))return this.fire(new e.a(new Error("parameters.layers must be an Array."))),[];for(const t of i.layers){const i=this._mergedLayers[t];if(!i)return this.fire(new e.a(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))),[];r[i.source]=!0;}}const s=[],n=i.serializedLayers||{},a=i&&i.layers?i.layers.some((e=>{const t=this.getLayer(e);return t&&t.is3D()})):this.has3DLayers(),l=Ce.createFromScreenPoints(t,o);for(const e in this._mergedSourceCaches){const t=this._mergedSourceCaches[e].getSource();if(!t||t.scope!==i.scope)continue;const c=this._mergedSourceCaches[e].getSource().id;i.layers&&!r[c]||s.push(Ht(this._mergedSourceCaches[e],this._mergedLayers,n,l,i,o,a,!!this.map._showQueryGeometry));}return this.placement&&s.push(function(e,t,i,o,r,s,n){const a={},l=s.queryRenderedSymbols(o),c=[];for(const e of Object.keys(l).map(Number))c.push(n[e]);c.sort(qt);for(const i of c){const o=i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId],t,i.bucketIndex,i.sourceLayerIndex,r.filter,r.layers,r.availableImages,e);for(const e in o){const t=a[e]=a[e]||[],r=o[e];r.sort(((e,t)=>{const o=i.featureSortOrder;if(o){const i=o.indexOf(e.featureIndex);return o.indexOf(t.featureIndex)-i}return t.featureIndex-e.featureIndex}));for(const e of r)t.push(e);}}for(const t in a)a[t].forEach((o=>{const r=o.feature,s=i(e[t]);if(!s)return;const n=s.getFeatureState(r.layer["source-layer"],r.id);r.source=r.layer.source,r.layer["source-layer"]&&(r.sourceLayer=r.layer["source-layer"]),r.state=n;}));return a}(this._mergedLayers,n,this.getLayerSourceCache.bind(this),l.screenGeometry,i,this.placement.collisionIndex,this.placement.retainedQueryData)),this._flattenAndSortRenderedFeatures(s)}querySourceFeatures(e,t){t&&t.filter&&this._validate(re,"querySourceFeatures.filter",t.filter,null,t);const i=this.getOwnSourceCaches(e);let o=[];for(const e of i)o=o.concat(Wt(e,t));return o}addSourceType(e,t,i){return Mo.getSourceType(e)?i(new Error(`A source type called "${e}" already exists.`)):(Mo.setSourceType(e,t),t.workerSourceURL?void this.dispatcher.broadcast("loadWorkerSource",{name:e,url:t.workerSourceURL},i):i(null,null))}getFlatLight(){return this.light.getLight()}setFlatLight(e,i,o={}){this._checkLoaded();const r=this.light.getLight();let s=!1;for(const i in e)if(!t(e[i],r[i])){s=!0;break}if(!s)return;const n=this._getTransitionParameters();this.light.setLight(e,i,o),this.light.updateTransitions(n);}getTerrain(){return this.terrain&&1===this.terrain.drapeRenderMode?this.terrain.get():null}setTerrainForDraping(){this.setTerrain({source:"",exaggeration:0},0);}setTerrain(i,o=1){if(this._checkLoaded(),!i)return this.terrainSetForDrapingOnly()&&0!==o||delete this.terrain,null===i?this.stylesheet.terrain=null:delete this.stylesheet.terrain,this._force3DLayerUpdate(),void(this._markersNeedUpdate=!0);let r=i;const s=null==i.source;if(1===o){if("object"==typeof r.source){const t="terrain-dem-src";this.addSource(t,r.source),r=e.c1(r),r=e.e(r,{source:t});}const t=e.e({},r),i={};if(this.terrain&&s){t.source=this.terrain.get().source;const e=this.terrain?this.getFragmentStyle(this.terrain.scope):null;e&&(i.style=e.serialize());}if(this._validate(te,"terrain",t,i))return}if(!this.terrain||this.terrain.scope!==this.scope&&!s||this.terrain&&o!==this.terrain.drapeRenderMode){if(!r)return;this._createTerrain(r,o),this.fire(new e.b("data",{dataType:"style"}));}else {const o=this.terrain,s=o.get();for(const t of Object.keys(e.D.terrain))!r.hasOwnProperty(t)&&e.D.terrain[t].default&&(r[t]=e.D.terrain[t].default);for(const r in i)if(!t(i[r],s[r])){o.set(i,this.options),this.stylesheet.terrain=i;const t=this._getTransitionParameters({duration:0});o.updateTransitions(t),this.fire(new e.b("data",{dataType:"style"}));break}}this.mergeTerrain(),this.updateDrapeFirstLayers(),this._markersNeedUpdate=!0;}_createFog(e){const t=this.fog=new we(e,this.map.transform,this.scope,this.options);this.stylesheet.fog=t.get();const i=this._getTransitionParameters({duration:0});t.updateTransitions(i);}_updateMarkersOpacity(){0!==this.map._markers.length&&this.map._requestDomTask((()=>{for(const e of this.map._markers)e._evaluateOpacity();}));}getFog(){return this.fog?this.fog.get():null}setFog(e){if(this._checkLoaded(),!e)return delete this.fog,delete this.stylesheet.fog,void(this._markersNeedUpdate=!0);if(this.fog){const i=this.fog;if(!t(i.get(),e)){i.set(e,this.options),this.stylesheet.fog=i.get();const t=this._getTransitionParameters({duration:0});i.updateTransitions(t);}}else this._createFog(e);this._markersNeedUpdate=!0;}_getTransitionParameters(t){return {now:e.f.now(),transition:e.e(this.transition,t)}}updateDrapeFirstLayers(){if(!this.terrain)return;const e=[],t=[];for(const i in this._mergedLayers)this.isLayerDraped(this._mergedLayers[i])?e.push(i):t.push(i);this._drapedFirstOrder=[],this._drapedFirstOrder.push(...e),this._drapedFirstOrder.push(...t);}_createTerrain(e,t){const i=this.terrain=new _e(e,t,this.scope,this.options);1===t&&(this.stylesheet.terrain=e),this.mergeTerrain(),this.updateDrapeFirstLayers(),this._force3DLayerUpdate();const o=this._getTransitionParameters({duration:0});i.updateTransitions(o);}_force3DLayerUpdate(){for(const e in this._layers){const t=this._layers[e];"fill-extrusion"===t.type&&this._updateLayer(t);}}_forceSymbolLayerUpdate(){for(const e in this._layers){const t=this._layers[e];"symbol"===t.type&&this._updateLayer(t);}}_validate(t,i,o,r,s={}){if(s&&!1===s.validate)return !1;const n=e.e({},this.serialize());return Io(this,t.call(Y,e.e({key:i,style:n,value:o,styleSpec:e.D},r)))}_remove(){this._request&&(this._request.cancel(),this._request=null),this._spriteRequest&&(this._spriteRequest.cancel(),this._spriteRequest=null),e.c8.off("pluginStateChange",this._rtlTextPluginCallback);for(const e in this._mergedLayers)this._mergedLayers[e].setEventedParent(null);for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles(),this._mergedSourceCaches[e].setEventedParent(null);this.setEventedParent(null),delete this.fog,delete this.terrain,delete this.ambientLight,delete this.directionalLight,this.isRootStyle()&&(this.imageManager.setEventedParent(null),this.modelManager.setEventedParent(null),this.dispatcher.remove());}clearSource(e){const t=this.getSourceCaches(e);for(const e of t)e.clearTiles();}clearSources(){for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles();}reloadSource(e){const t=this.getSourceCaches(e);for(const e of t)e.resume(),e.reload();}reloadSources(){for(const e of this.getSources())e.reload&&e.reload();}updateSources(e){let t;this.directionalLight&&(t=Eo(this.directionalLight));for(const i in this._mergedSourceCaches)this._mergedSourceCaches[i].update(e,void 0,void 0,t);}_generateCollisionBoxes(){for(const e in this._sourceCaches){const t=this._sourceCaches[e];t.resume(),t.reload();}}_updatePlacement(t,i,o,r,s=!1){let n=!1,a=!1;const l={},c={};for(const i of this._mergedOrder){const o=this._mergedLayers[i];if("symbol"!==o.type)continue;const r=e.ag(o.source,o.scope);let s=l[r];if(!s){const e=this.getLayerSourceCache(o);if(!e)continue;const t=e.getRenderableIds(!0).map((t=>e.getTileByID(t)));c[r]=t.slice(),s=l[r]=t.sort(((e,t)=>t.tileID.overscaledZ-e.tileID.overscaledZ||(e.tileID.isLessThan(t.tileID)?-1:1)));}const a=this.crossTileSymbolIndex.addLayer(o,s,t.center.lng,t.projection);n=n||a;}if(this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder),s=s||this._layerOrderChanged||0===o,this._layerOrderChanged&&this.fire(new e.b("neworder")),(s||!this.pauseablePlacement||this.pauseablePlacement.isDone()&&!this.placement.stillRecent(e.f.now(),t.zoom))&&(this.pauseablePlacement=new to(t,this._mergedOrder,s,i,o,r,this.placement,this.fog&&t.projection.supportsFog?this.fog.state:null,this._buildingIndex),this._layerOrderChanged=!1),this.pauseablePlacement.isDone()?this.placement.setStale():(this.pauseablePlacement.continuePlacement(this._mergedOrder,this._mergedLayers,l,c),this.pauseablePlacement.isDone()&&(this.placement=this.pauseablePlacement.commit(e.f.now()),a=!0),n&&this.pauseablePlacement.placement.setStale()),a||n){this._buildingIndex.onNewFrame(t.zoom);for(const t of this._mergedOrder){const i=this._mergedLayers[t];"symbol"===i.type&&this.placement.updateLayerOpacities(i,l[e.ag(i.source,i.scope)]);}}return !this.pauseablePlacement.isDone()||this.placement.hasTransitions(e.f.now())}_releaseSymbolFadeTiles(){for(const e in this._sourceCaches)this._sourceCaches[e].releaseSymbolFadeTiles();}addImport(t,i){this._checkLoaded();const o=this.stylesheet.imports=this.stylesheet.imports||[];if(-1!==o.findIndex((({id:e})=>e===t.id)))return this.fire(new e.a(new Error(`Import with id '${t.id}' already exists in the map's style.`)));if(!i)return o.push(t),this._loadImports([t],!0),this;const r=o.findIndex((({id:e})=>e===i));return -1===r?this.fire(new e.a(new Error(`Import with id "${i}" does not exist on this map.`))):(this.stylesheet.imports=o.slice(0,r).concat(t).concat(o.slice(r)),this._loadImports([t],!0,i),this)}updateImport(e,i){this._checkLoaded();const o=this.stylesheet.imports||[],r=this.getImportIndex(e);return -1===r?this:"string"==typeof i?(this.setImportUrl(e,i),this):(i.url&&i.url!==o[r].url&&this.setImportUrl(e,i.url),t(i.config,o[r].config)||this.setImportConfig(e,i.config),t(i.data,o[r].data)||this.setImportData(e,i.data),this)}moveImport(e,t){this._checkLoaded();let i=this.stylesheet.imports||[];const o=this.getImportIndex(e);if(-1===o)return this;const r=this.getImportIndex(t);if(-1===r)return this;const s=i[o],n=this.fragments[o];return i=i.filter((({id:t})=>t!==e)),this.fragments=this.fragments.filter((({id:t})=>t!==e)),this.stylesheet.imports=i.slice(0,r).concat(s).concat(i.slice(r)),this.fragments=this.fragments.slice(0,r).concat(n).concat(this.fragments.slice(r)),this.mergeLayers(),this}setImportUrl(e,t){this._checkLoaded();const i=this.stylesheet.imports||[],o=this.getImportIndex(e);if(-1===o)return this;i[o].url=t;const r=this.fragments[o];return r.style=this._createFragmentStyle(i[o]),r.style.on("style.import.load",(()=>this.mergeAll())),r.style.loadURL(t),this}setImportData(e,t){this._checkLoaded();const i=this.getImportIndex(e),o=this.stylesheet.imports||[];return -1===i?this:t?(this.fragments[i].style.setState(t),this._reloadImports(),this):(delete o[i].data,this.setImportUrl(e,o[i].url))}setImportConfig(e,t){this._checkLoaded();const i=this.getImportIndex(e),o=this.stylesheet.imports||[];if(-1===i)return this;t?o[i].config=t:delete o[i].config;const r=this.fragments[i],s=r.style.stylesheet&&r.style.stylesheet.schema;return r.config=t,r.style.setConfig(t,s),this.updateConfigDependencies(),this}removeImport(e){this._checkLoaded();const t=this.stylesheet.imports||[],i=this.getImportIndex(e);return -1===i||(t.splice(i,1),this.fragments[i].style._remove(),this.fragments.splice(i,1),this._reloadImports()),this}getImportIndex(t){const i=(this.stylesheet.imports||[]).findIndex((e=>e.id===t));return -1===i&&this.fire(new e.a(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))),i}getLayer(e){return this._mergedLayers[e]}getSources(){const e=[];for(const t in this._mergedOtherSourceCaches){const i=this._mergedOtherSourceCaches[t];i&&e.push(i.getSource());}return e}getSource(e,t){const i=this.getSourceCache(e,t);return i&&i.getSource()}getLayerSource(e){const t=this.getLayerSourceCache(e);return t&&t.getSource()}getSourceCache(t,i){const o=e.ag(t,i);return this._mergedOtherSourceCaches[o]}getLayerSourceCache(t){const i=e.ag(t.source,t.scope);return "symbol"===t.type?this._mergedSymbolSourceCaches[i]:this._mergedOtherSourceCaches[i]}getSourceCaches(e){const t=[];return this._mergedOtherSourceCaches[e]&&t.push(this._mergedOtherSourceCaches[e]),this._mergedSymbolSourceCaches[e]&&t.push(this._mergedSymbolSourceCaches[e]),t}updateSourceCaches(){const e=this._changes.getUpdatedSourceCaches();for(const t in e){const i=e[t];"reload"===i?this.reloadSource(t):"clear"===i&&this.clearSource(t);}}updateLayers(e){const t=this._changes.getUpdatedPaintProperties();for(const i of t){const t=this.getLayer(i);t&&t.updateTransitions(e);}}getImages(e,t,i){this.imageManager.getImages(t.icons,t.scope,i),this._updateTilesForChangedImages();const o=e=>{e&&e.setDependencies(t.tileID.key,t.type,t.icons);};o(this._otherSourceCaches[t.source]),o(this._symbolSourceCaches[t.source]);}getGlyphs(e,t,i){this.glyphManager.getGlyphs(t.stacks,t.scope,i);}getResource(t,i,o){return e.c9(i,o)}getOwnSourceCache(e){return this._otherSourceCaches[e]}getOwnLayerSourceCache(e){return "symbol"===e.type?this._symbolSourceCaches[e.source]:this._otherSourceCaches[e.source]}getOwnSourceCaches(e){const t=[];return this._otherSourceCaches[e]&&t.push(this._otherSourceCaches[e]),this._symbolSourceCaches[e]&&t.push(this._symbolSourceCaches[e]),t}_isSourceCacheLoaded(t){const i=this.getOwnSourceCaches(t);return 0===i.length?(this.fire(new e.a(new Error(`There is no source with ID '${t}'`))),!1):i.every((e=>e.loaded()))}has3DLayers(){return this._has3DLayers}hasSymbolLayers(){return this._hasSymbolLayers}hasCircleLayers(){return this._hasCircleLayers}_clearWorkerCaches(){this.dispatcher.broadcast("clearCaches");}destroy(){this._clearWorkerCaches(),this.fragments.forEach((e=>{e.style._remove();})),this.terrainSetForDrapingOnly()&&(delete this.terrain,delete this.stylesheet.terrain);}}Mo.getSourceType=function(e){return jt[e]},Mo.setSourceType=function(e,t){jt[e]=t;},Mo.registerForPluginStateChange=e.bV;var zo="\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif",Oo="\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,vec2 pos,vec2 lod_coord) {vec2 size=vec2(textureSize(image,0));vec2 dx=dFdx(lod_coord.xy*size);vec2 dy=dFdy(lod_coord.xy*size);float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}",Fo="\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}",Bo="in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",ko="\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",No="#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",Uo="highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif",Go="#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif",jo="#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform vec2 u_velocity_res;uniform float u_max_speed;const vec2 INVALID_VELOCITY=vec2(-1);uniform vec2 u_texture_offset;uniform float u_data_offset;uniform vec4 u_data_scale;vec2 lookup_velocity(vec2 uv) {uv=u_texture_offset.x+u_texture_offset.y*uv;vec2 fxy;ivec4 c=_raTexLinearCoord(uv,u_velocity_res,fxy);vec4 tl=texelFetch(u_velocity,c.yz,0);vec4 tr=texelFetch(u_velocity,c.xz,0);vec4 bl=texelFetch(u_velocity,c.yw,0);vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NODATA) {return INVALID_VELOCITY;}if (tr==NODATA) {return INVALID_VELOCITY;}if (bl==NODATA) {return INVALID_VELOCITY;}if (br==NODATA) {return INVALID_VELOCITY;}vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);\n#ifdef DATA_FORMAT_UINT32\nvec2 velocity=vec2(u_data_offset+dot(t,u_data_scale),0);return velocity;\n#else\nvec2 velocity=vec2(u_data_offset+dot(t.rg,u_data_scale.yx),-(u_data_offset+dot(t.ba,u_data_scale.yx)));\n#endif\nreturn velocity/max(u_max_speed,length(velocity));}\n#endif",Vo="#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS",Zo="#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";const Ho=[];Yo(zo,Ho),Yo(Fo,Ho),Yo(Oo,Ho);const Wo={"_prelude_fog.vertex.glsl":No,"_prelude_terrain.vertex.glsl":ko,"_prelude_shadow.vertex.glsl":Vo,"_prelude_fog.fragment.glsl":Uo,"_prelude_shadow.fragment.glsl":Zo,"_prelude_lighting.glsl":"\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE","_prelude_raster_array.glsl":Go,"_prelude_raster_particle.glsl":jo},qo={};Jo("",ko),Jo(Uo,No),Jo(Zo,Vo),Jo(Go,""),Jo(jo,"");const $o=Jo(Oo,Fo),Xo=zo;var Ko={background:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),backgroundPattern:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),circle:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'),clippingMask:Jo("void main() {glFragColor=vec4(1.0);}","in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),heatmap:Jo('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),heatmapTexture:Jo("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}","in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),collisionBox:Jo("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}",'#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),collisionCircle:Jo("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}","in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),debug:Jo("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}",'#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'),fill:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),fillOutline:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),fillOutlinePattern:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),fillPattern:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),fillExtrusion:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nuniform float u_emissive_strength;in float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=max(0.01,cutoff_opacity(u_cutoff_params,ground.z));if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff < 0.01 && centroid_pos.x !=0.0));gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),fillExtrusionDepth:Jo("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}",'#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),fillExtrusionPattern:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'),groundShadow:Jo('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'),fillExtrusionGroundEffect:Jo("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}",'#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'),hillshadePrepare:Jo("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}","uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),hillshade:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),line:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),linePattern:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float pattern_x=v_linesofar/pattern_size.x*aspect;float x=mod(pattern_x,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),raster:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'),rasterParticle:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;vec2 uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nvec2 uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),rasterParticleDraw:Jo("precision highp float;uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}",'precision highp float;\n#include "_prelude_raster_array.glsl"\n#include "_prelude_raster_particle.glsl"\nin vec3 a_pos;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {vec2 pos=a_pos.xy+u_tile_offset;vec2 tex_coords=fract(pos);gl_PointSize=1.0;vec2 velocity=lookup_velocity(tex_coords);if (velocity==INVALID_VELOCITY) {v_particle_speed=0.0;gl_Position=vec4(2.0,2.0,2.0,1.0);} else {v_particle_speed=length(velocity);gl_Position=vec4(2.0*pos-vec2(1.0),0.0,1.0);}}'),rasterParticleTexture:Jo("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}","in vec2 a_pos;out vec2 v_tex_pos;void main() {v_tex_pos=0.5*a_pos+vec2(0.5);gl_Position=vec4(a_pos,0.0,1.0);}"),rasterParticleUpdate:Jo("void main() {}",'#include "_prelude_raster_array.glsl"\n#include "_prelude_raster_particle.glsl"\nin vec3 a_pos;uniform float u_speed_factor;uniform float u_lifetime_delta;uniform float u_rand_seed;out vec3 v_new_particle;const vec3 rand_constants=vec3(12.9898,78.233,4375.85453);float rand(const vec2 co) {float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {float lifetime=a_pos.z;vec2 pos=a_pos.xy;vec2 uv=clamp(pos,vec2(0.0),vec2(1.0));vec2 velocity=lookup_velocity(uv);float next_lifetime=lifetime-u_lifetime_delta;float t=step(0.0,next_lifetime);\n#ifdef DATA_FORMAT_UINT32\nvec2 dp=vec2(0);\n#else\nvec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;\n#endif\nvec2 seed=pos*u_rand_seed;vec2 next_pos=pos+dp;vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));v_new_particle=vec3(\nvec2(mix(random_pos,next_pos,t)),mix(1.0,next_lifetime,t)\n);}'),symbolIcon:Jo('#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nin float v_fade_opacity;in vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nuniform mediump float u_icon_saturation;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b)*alpha;\n#else\nout_color=texture(u_texture,v_tex_a)*alpha;\n#endif\n#ifdef SATURATION\nvec3 luma=vec3(dot(out_color.rgb,vec3(0.2126,0.7152,0.0722)));out_color.rgb=mix(luma,out_color.rgb,u_icon_saturation);\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;}'),symbolSDF:Jo('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'),symbolTextAndIcon:Jo('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'),terrainRaster:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'),terrainDepth:Jo("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}",'#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),skybox:Jo('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}',Bo),skyboxGradient:Jo('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}',Bo),skyboxCapture:Jo("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}","in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),globeRaster:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'),globeAtmosphere:Jo('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}',"in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),model:Jo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}','#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=local_pos;\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1);v_depth_shadows=gl_Position.w;\n#endif\n}'),modelDepth:Jo("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}","in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),stars:Jo("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}","\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}")};function Yo(e,t){const i=e.replace(/\s*\/\/[^\n]*\n/g,"\n").split("\n");for(let e of i)if(e=e.trim(),"#"===e[0]&&e.includes("if")&&!e.includes("endif")){e=e.replace("#","").replace(/ifdef|ifndef|elif|if/g,"").replace(/!|defined|\(|\)|\|\||&&/g,"").replace(/\s+/g," ").trim();const i=e.split(" ");for(const e of i)t.includes(e)||t.push(e);}}function Jo(e,t){const i=/#include\s+"([^"]+)"/g,o=/#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;let r=t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);r&&(r=r.map((e=>{const t=e.split(" ");return t[t.length-1]})),r=[...new Set(r)]);const s={},n=[],a=[];if(e=e.replace(i,((e,t)=>(a.push(t),""))),(t=t.replace(i,((e,t)=>(n.push(t),"")))).includes("flat out"))return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');let l=[...Ho];Yo(e,l),Yo(t,l);for(const e of [...n,...a])Wo[e]||console.error(`Undefined include: ${e}`),qo[e]||(qo[e]=[],Yo(Wo[e],qo[e])),l=[...l,...qo[e]];return {fragmentSource:e=e.replace(o,((e,t,i,o,r)=>(s[r]=!0,"define"===t?`\n#ifndef HAS_UNIFORM_u_${r}\nin ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n`:"initialize"===t?`\n#ifdef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = u_${r};\n#endif\n`:"define-attribute"===t?`\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${i} ${o} ${r};\n#endif\n`:"initialize-attribute"===t?"":void 0))),vertexSource:t=t.replace(o,((e,t,i,o,r)=>{const n="float"===o?"vec2":o,a=r.match(/color/)?"color":n;return "define-attribute-vertex-shader-only"===t?`\n#ifdef HAS_ATTRIBUTE_a_${r}\nin ${i} ${o} a_${r};\n#endif\n`:s[r]?"define"===t?`\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nin ${i} ${n} a_${r};\nout ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n`:"initialize"===t?"vec4"===a?`\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`:`\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`:"define-attribute"===t?`\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${i} ${o} a_${r};\n    out ${i} ${o} ${r};\n#endif\n`:"initialize-attribute"===t?`\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${r} = a_${r};\n#endif\n`:void 0:"define"===t?`\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nin ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n`:"define-instanced"===t?"mat4"===a?`\n#ifdef INSTANCED_ARRAYS\nin vec4 a_${r}0;\nin vec4 a_${r}1;\nin vec4 a_${r}2;\nin vec4 a_${r}3;\n#else\nuniform ${i} ${o} u_${r};\n#endif\n`:`\n#ifdef INSTANCED_ARRAYS\nin ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n`:"initialize-attribute-custom"===t?`\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${i} ${o} ${r} = a_${r};\n#endif\n`:"vec4"===a?`\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`:`\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`})),staticAttributes:r,usedDefines:l,vertexIncludes:n,fragmentIncludes:a}}class Qo{constructor(){this.boundProgram=null,this.boundLayoutVertexBuffer=null,this.boundPaintVertexBuffers=[],this.boundIndexBuffer=null,this.boundVertexOffset=null,this.boundDynamicVertexBuffers=[],this.vao=null;}bind(e,t,i,o,r,s,n,a){this.context=e;let l=this.boundPaintVertexBuffers.length!==o.length;for(let e=0;!l&&e<o.length;e++)this.boundPaintVertexBuffers[e]!==o[e]&&(l=!0);let c=this.boundDynamicVertexBuffers.length!==n.length;for(let e=0;!c&&e<n.length;e++)this.boundDynamicVertexBuffers[e]!==n[e]&&(c=!0);if(!this.vao||this.boundProgram!==t||this.boundLayoutVertexBuffer!==i||l||c||this.boundIndexBuffer!==r||this.boundVertexOffset!==s)this.freshBind(t,i,o,r,s,n,a);else {e.bindVertexArrayOES.set(this.vao);for(const i of n)i&&(i.bind(),a&&i.instanceCount&&i.setVertexAttribDivisor(e.gl,t,a));r&&r.dynamicDraw&&r.bind();}}freshBind(e,t,i,o,r,s,n){const a=e.numAttributes,l=this.context,c=l.gl;this.vao&&this.destroy(),this.vao=l.gl.createVertexArray(),l.bindVertexArrayOES.set(this.vao),this.boundProgram=e,this.boundLayoutVertexBuffer=t,this.boundPaintVertexBuffers=i,this.boundIndexBuffer=o,this.boundVertexOffset=r,this.boundDynamicVertexBuffers=s,t.enableAttributes(c,e),t.bind(),t.setVertexAttribPointers(c,e,r);for(const t of i)t.enableAttributes(c,e),t.bind(),t.setVertexAttribPointers(c,e,r);for(const t of s)t&&(t.enableAttributes(c,e),t.bind(),t.setVertexAttribPointers(c,e,r),n&&t.instanceCount&&t.setVertexAttribDivisor(c,e,n));o&&o.bind(),l.currentNumAttributes=a;}destroy(){this.vao&&(this.context.gl.deleteVertexArray(this.vao),this.vao=null);}}function er(t,i){const o=Math.pow(2,i.canonical.z),r=i.canonical.y;return [new e.L(0,r/o).toLngLat().lat,new e.L(0,(r+1)/o).toLngLat().lat]}function tr(t,i,o,r,s,n,a){const l=t.context,c=l.gl,h=o.hillshadeFBO;if(!h)return;t.prepareDrawTile();const u=t.isTileAffectedByFog(i),d=t.getOrCreateProgram("hillshade",{overrideFog:u});l.activeTexture.set(c.TEXTURE0),c.bindTexture(c.TEXTURE_2D,h.colorAttachment.get());const _=((t,i,o,r)=>{const s=o.paint.get("hillshade-shadow-color"),n=o.paint.get("hillshade-highlight-color"),a=o.paint.get("hillshade-accent-color"),l=o.paint.get("hillshade-emissive-strength");let c=e.bj(o.paint.get("hillshade-illumination-direction"));if("viewport"===o.paint.get("hillshade-illumination-anchor"))c-=t.transform.angle;else if(t.style&&t.style.enable3dLights()&&t.style.directionalLight){const i=t.style.directionalLight.properties.get("direction"),o=e.bQ(i.x,i.y,i.z);c=e.bj(o[1]);}const h=!t.options.moving;return {u_matrix:r||t.transform.calculateProjMatrix(i.tileID.toUnwrapped(),h),u_image:0,u_latrange:er(0,i.tileID),u_light:[o.paint.get("hillshade-exaggeration"),c],u_shadow:s,u_highlight:n,u_emissive_strength:l,u_accent:a}})(t,o,r,t.terrain?i.projMatrix:null);t.uploadCommonUniforms(l,d,i.toUnwrapped());const{tileBoundsBuffer:p,tileBoundsIndexBuffer:f,tileBoundsSegments:m}=t.getTileBoundsBuffers(o);d.draw(t,c.TRIANGLES,s,n,a,Ft.disabled,_,r.id,p,f,m);}function ir(t,i,o){if(!i.needsDEMTextureUpload)return;const r=t.context,s=r.gl;r.pixelStoreUnpackPremultiplyAlpha.set(!1),i.demTexture=i.demTexture||t.getTileTexture(o.stride);const n=o.getPixels();i.demTexture?i.demTexture.update(n,{premultiply:!1}):i.demTexture=new e.T(r,n,s.R32F,{premultiply:!1}),i.needsDEMTextureUpload=!1;}function or(t,i,o){const r=t.context,s=r.gl;if(!i.dem)return;const n=i.dem;if(r.activeTexture.set(s.TEXTURE1),ir(t,i,n),!i.demTexture)return;i.demTexture.bind(s.NEAREST,s.CLAMP_TO_EDGE);const a=n.dim;r.activeTexture.set(s.TEXTURE0);let l=i.hillshadeFBO;if(!l){const t=new e.T(r,{width:a,height:a,data:null},s.RGBA);t.bind(s.LINEAR,s.CLAMP_TO_EDGE),l=i.hillshadeFBO=r.createFramebuffer(a,a,!0,"renderbuffer"),l.colorAttachment.set(t.texture);}r.bindFramebuffer.set(l.framebuffer),r.viewport.set([0,0,a,a]);const{tileBoundsBuffer:c,tileBoundsIndexBuffer:h,tileBoundsSegments:u}=t.getMercatorTileBoundsBuffers(),d=[];t.linearFloatFilteringSupported()&&d.push("TERRAIN_DEM_FLOAT_FORMAT"),t.getOrCreateProgram("hillshadePrepare",{defines:d}).draw(t,s.TRIANGLES,Lt.disabled,Rt.disabled,Mt.unblended,Ft.disabled,((t,i)=>{const o=i.stride,r=e.a6.create();return e.a6.ortho(r,0,e.V,-e.V,0,0,1),e.a6.translate(r,r,[0,-e.V,0]),{u_matrix:r,u_image:1,u_dimension:[o,o],u_zoom:t.overscaledZ}})(i.tileID,n),o.id,c,h,u),i.needsHillshadePrepare=!1;}const rr=t=>({u_matrix:new e.bK(t),u_image0:new e.bO(t),u_skirt_height:new e.bN(t),u_ground_shadow_factor:new e.bM(t)}),sr=(e,t,i)=>({u_matrix:e,u_image0:0,u_skirt_height:t,u_ground_shadow_factor:i}),nr=(e,t,i,o,r,s,n,a,l,c,h,u,d,_,p,f)=>({u_proj_matrix:Float32Array.from(e),u_globe_matrix:t,u_normalize_matrix:Float32Array.from(o),u_merc_matrix:i,u_zoom_transition:r,u_merc_center:s,u_image0:0,u_frustum_tl:n,u_frustum_tr:a,u_frustum_br:l,u_frustum_bl:c,u_globe_pos:h,u_globe_radius:u,u_viewport:d,u_grid_matrix:f?Float32Array.from(f):new Float32Array(9),u_skirt_height:_,u_far_z_cutoff:p});function ar(e,t){return null!=e&&null!=t&&!(!e.hasData()||!t.hasData())&&null!=e.demTexture&&null!=t.demTexture&&e.tileID.key!==t.tileID.key}const lr=new class{constructor(){this.operations={};}newMorphing(e,t,i,o,r){if(e in this.operations){const t=this.operations[e];t.to.tileID.key!==i.tileID.key&&(t.queued=i);}else this.operations[e]={startTime:o,phase:0,duration:r,from:t,to:i,queued:null};}getMorphValuesForProxy(e){if(!(e in this.operations))return null;const t=this.operations[e];return {from:t.from,to:t.to,phase:t.phase}}update(e){for(const t in this.operations){const i=this.operations[t];for(i.phase=(e-i.startTime)/i.duration;i.phase>=1||!this._validOp(i);)if(!this._nextOp(i,e)){delete this.operations[t];break}}}_nextOp(e,t){return !!e.queued&&(e.from=e.to,e.to=e.queued,e.queued=null,e.phase=0,e.startTime=t,!0)}_validOp(e){return e.from.hasData()&&e.to.hasData()}},cr={0:null,1:"TERRAIN_VERTEX_MORPHING"};function hr(e,t,i){if(0===t)return 0;const o=t<1&&514===i?.25/t:1;return 6*Math.pow(1.5,22-e)*Math.max(t,1)*o}function ur(e,t){const i=1<<e.z;return !t&&(0===e.x||e.x===i-1)||0===e.y||e.y===i-1}const dr=e=>({u_matrix:e});function _r(t,i,o,r,s){if(s>0){const n=e.f.now(),a=(n-t.timeAdded)/s,l=i?(n-i.timeAdded)/s:-1,c=o.getSource(),h=r.coveringZoomLevel({tileSize:c.tileSize,roundZoom:c.roundZoom}),u=!i||Math.abs(i.tileID.overscaledZ-h)>Math.abs(t.tileID.overscaledZ-h),d=u&&t.refreshedUponExpiration?1:e.aa(u?a:1-l,0,1);return t.refreshedUponExpiration&&a>=1&&(t.refreshedUponExpiration=!1),i?{opacity:1,mix:1-d}:{opacity:d,mix:0}}return {opacity:1,mix:0}}class pr extends Kt{constructor(t){const i={type:"raster-dem",maxzoom:t.transform.maxZoom},o=new e.bW(e.bX(),null),r=Vt("mock-dem",i,o,t.style);super("mock-dem",r,!1),r.setEventedParent(this),this._sourceLoaded=!0;}_loadTile(e,t){e.state="loaded",t(null);}}class fr extends Kt{constructor(t){const i=Vt("proxy",{type:"geojson",maxzoom:t.transform.maxZoom},new e.bW(e.bX(),null),t.style);super("proxy",i,!1),i.setEventedParent(this),this.map=this.getSource().map=t,this.used=this._sourceLoaded=!0,this.renderCache=[],this.renderCachePool=[],this.proxyCachedFBO={};}update(e,t,i){if(e.freezeTileCoverage)return;this.transform=e;const o=e.coveringTiles({tileSize:this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom,reparseOverscaled:this._source.reparseOverscaled}).reduce(((t,i)=>{if(t[i.key]="",!this._tiles[i.key]){const t=new Gt(i,this._source.tileSize*i.overscaleFactor(),e.tileZoom);t.state="loaded",this._tiles[i.key]=t;}return t}),{});for(const e in this._tiles)e in o||(this.freeFBO(e),this._tiles[e].unloadVectorData(),delete this._tiles[e]);}freeFBO(e){const t=this.proxyCachedFBO[e];if(void 0!==t){const i=Object.values(t);this.renderCachePool.push(...i),delete this.proxyCachedFBO[e];}}deallocRenderCache(){this.renderCache.forEach((e=>e.fb.destroy())),this.renderCache=[],this.renderCachePool=[],this.proxyCachedFBO={};}}class mr extends e.am{constructor(e,t,i){super(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y),this.proxyTileKey=t,this.projMatrix=i;}}class gr extends e.ck{constructor(t,i){super(),this._debugParams={sortTilesHiZFirst:!0,disableRenderCache:!1},t.tp.registerParameter(this._debugParams,["Terrain"],"sortTilesHiZFirst",{},(()=>{this._style.map.triggerRepaint();})),t.tp.registerParameter(this._debugParams,["Terrain"],"disableRenderCache",{},(()=>{this._style.map.triggerRepaint();})),t.tp.registerButton(["Terrain"],"Invalidate Render Cache",(()=>{this.invalidateRenderCache=!0,this._style.map.triggerRepaint();})),this.painter=t,this.terrainTileForTile={},this.prevTerrainTileForTile={};const[o,r,s]=function(t){const i=new e.aN,o=new e.aw,r=131;i.reserve(17161),o.reserve(33800);const s=e.V/128,n=e.V+s/2,a=n+s;for(let t=-s;t<a;t+=s)for(let o=-s;o<a;o+=s){const r=o<0||o>n||t<0||t>n?24575:0,s=e.aa(Math.round(o),0,e.V),a=e.aa(Math.round(t),0,e.V);i.emplaceBack(s+r,a);}const l=(e,t)=>{const i=t*r+e;o.emplaceBack(i+1,i,i+r),o.emplaceBack(i+r,i+r+1,i+1);};for(let e=1;e<129;e++)for(let t=1;t<129;t++)l(t,e);return [0,129].forEach((e=>{for(let t=0;t<130;t++)l(t,e),l(e,t);})),[i,o,32768]}(),n=t.context;this.gridBuffer=n.createVertexBuffer(o,e.aP.members),this.gridIndexBuffer=n.createIndexBuffer(r),this.gridSegments=e.aB.simpleSegment(0,0,o.length,r.length),this.gridNoSkirtSegments=e.aB.simpleSegment(0,0,o.length,s),this.proxyCoords=[],this.proxiedCoords={},this._visibleDemTiles=[],this._drapedRenderBatches=[],this._sourceTilesOverlap={},this.proxySourceCache=new fr(i.map),this.orthoMatrix=e.a6.create(),e.a6.ortho(this.orthoMatrix,"globe"===this.painter.transform.projection.name?.015:0,e.V,0,e.V,0,1);const a=n.gl;this._overlapStencilMode=new Rt({func:a.GEQUAL,mask:255},0,255,a.KEEP,a.KEEP,a.REPLACE),this._previousZoom=t.transform.zoom,this.pool=[],this._findCoveringTileCache={},this._tilesDirty={},this.style=i,this._useVertexMorphing=!0,this._exaggeration=1,this._mockSourceCache=new pr(i.map),this._pendingGroundEffectLayers=[];}set style(e){e.on("data",this._onStyleDataEvent.bind(this)),this._style=e,this._style.map.on("moveend",(()=>{this._clearLineLayersFromRenderCache();}));}update(t,i,o){if(t&&t.terrain){this._style!==t&&(this.style=t,this._evaluationZoom=void 0);const r=t.terrain.properties,s=0===t.terrain.drapeRenderMode,n=t.terrain.isZoomDependent();this._previousUpdateTimestamp=this.enabled?this._updateTimestamp:void 0,this._updateTimestamp=e.f.now();const a=t.terrain&&t.terrain.scope,l=r.get("source"),c=s?this._mockSourceCache:t.getSourceCache(l,a);if(!c)return void e.w(`Couldn't find terrain source "${l}".`);if(this.sourceCache=c,this._exaggeration=n?this.calculateExaggeration(i):r.get("exaggeration"),!i.projection.requiresDraping&&n&&0===this._exaggeration)return void this._disable();this.enabled=!0;const h=()=>{this.sourceCache.used&&e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);const t=this.getScaledDemTileSize();this.sourceCache.update(i,t,!0),this.resetTileLookupCache(this.sourceCache.id);};this.sourceCache.usedForTerrain||(this.resetTileLookupCache(this.sourceCache.id),this.sourceCache.usedForTerrain=!0,h(),this._initializing=!0),h(),i.updateElevation(!0,o),this.resetTileLookupCache(this.proxySourceCache.id),this.proxySourceCache.update(i),this._emptyDEMTextureDirty=!0,this._previousZoom=i.zoom;}else this._disable();}calculateExaggeration(t){const i=this._previousCameraAltitude,o=t.getFreeCameraOptions().position.z/t.pixelsPerMeter*t.worldSize;this._previousCameraAltitude=o;const r=null!=i?o-i:Number.MAX_VALUE;if(Math.abs(r)<2)return this._exaggeration;const s=t.zoom,n=this._style.terrain;if(!this._previousUpdateTimestamp)return n.getExaggeration(s);let a=s-this._previousZoom;const l=this._previousUpdateTimestamp;let c=s;null!=this._evaluationZoom&&(c=this._evaluationZoom,Math.abs(s-c)>.5&&(a=.5*(s-c+a)),a*r<0&&(c+=a)),this._evaluationZoom=c;const h=n.getExaggeration(c),u=h===n.getExaggeration(Math.max(0,c-.1));if(u&&Math.abs(h-this._exaggeration)<.01)return h;let d=Math.min(.1,.00375*(this._updateTimestamp-l));return (u||h<.1||Math.abs(a)<1e-4)&&(d=Math.min(.2,4*d)),e.U(this._exaggeration,h,d)}resetTileLookupCache(e){this._findCoveringTileCache[e]={};}getScaledDemTileSize(){return this.sourceCache.getSource().tileSize/128*this.proxySourceCache.getSource().tileSize}_onStyleDataEvent(e){e.coord&&"source"===e.dataType?this._clearRenderCacheForTile(e.sourceCacheId,e.coord):"style"===e.dataType&&(this.invalidateRenderCache=!0,this._evaluationZoom=void 0,this._previousUpdateTimestamp=void 0,this._previousCameraAltitude=void 0);}_disable(){if(this.enabled&&(this.enabled=!1,this._sharedDepthStencil=void 0,this._evaluationZoom=void 0,this._previousUpdateTimestamp=void 0,this.proxySourceCache.deallocRenderCache(),this._style))for(const e in this._style._mergedSourceCaches)this._style._mergedSourceCaches[e].usedForTerrain=!1;}destroy(){this._disable(),this._emptyDEMTexture&&this._emptyDEMTexture.destroy(),this._emptyDepthBufferTexture&&this._emptyDepthBufferTexture.destroy(),this.pool.forEach((e=>e.fb.destroy())),this.pool=[],this._depthFBO&&(this._depthFBO.destroy(),this._depthFBO=void 0,this._depthTexture=void 0),this.framebufferCopyTexture&&this.framebufferCopyTexture.destroy();}_source(){return this.enabled?this.sourceCache:null}isUsingMockSource(){return this.sourceCache===this._mockSourceCache}exaggeration(){return this._exaggeration}get visibleDemTiles(){return this._visibleDemTiles}get drapeBufferSize(){const e=2*this.proxySourceCache.getSource().tileSize;return [e,e]}set useVertexMorphing(e){this._useVertexMorphing=e;}updateTileBinding(t){if(!this.enabled)return;this.prevTerrainTileForTile=this.terrainTileForTile;const i=this.proxySourceCache,o=this.painter.transform;this._initializing&&(this._initializing=0===o._centerAltitude&&-1===this.getAtPointOrZero(e.L.fromLngLat(o.center),-1),this._emptyDEMTextureDirty=!this._initializing);const r=this.proxyCoords=i.getIds().map((e=>{const t=i.getTileByID(e).tileID;return t.projMatrix=o.calculateProjMatrix(t.toUnwrapped()),t}));!function(t,i){const o=i.transform.pointCoordinate(i.transform.getCameraPoint()),r=new e.P(o.x,o.y);t.sort(((t,i)=>{if(i.overscaledZ-t.overscaledZ)return i.overscaledZ-t.overscaledZ;const o=new e.P(t.canonical.x+(1<<t.canonical.z)*t.wrap,t.canonical.y),s=new e.P(i.canonical.x+(1<<i.canonical.z)*i.wrap,i.canonical.y),n=r.mult(1<<t.canonical.z);return n.x-=.5,n.y-=.5,n.distSqr(o)-n.distSqr(s)}));}(r,this.painter);const s=this.proxyToSource||{};this.proxyToSource={},r.forEach((e=>{this.proxyToSource[e.key]={};})),this.terrainTileForTile={};const n=this._style._mergedSourceCaches;for(const e in n){const i=n[e];if(!i.used)continue;if(i!==this.sourceCache&&this.resetTileLookupCache(i.id),this._setupProxiedCoordsForOrtho(i,t[e],s),i.usedForTerrain)continue;const o=t[e];i.getSource().reparseOverscaled&&this._assignTerrainTiles(o);}this.proxiedCoords[i.id]=r.map((e=>new mr(e,e.key,this.orthoMatrix))),this._assignTerrainTiles(r),this._prepareDEMTextures(),this._setupDrapedRenderBatches(),this._initFBOPool(),this._setupRenderCache(s),this.renderingToTexture=!1;const a={};this._visibleDemTiles=[];for(const e of this.proxyCoords){const t=this.terrainTileForTile[e.key];if(!t)continue;const i=t.tileID.key;i in a||(this._visibleDemTiles.push(t),a[i]=i);}}_assignTerrainTiles(e){this._initializing||e.forEach((e=>{if(this.terrainTileForTile[e.key])return;const t=this._findTileCoveringTileID(e,this.sourceCache);t&&(this.terrainTileForTile[e.key]=t);}));}_prepareDEMTextures(){const e=this.painter.context,t=e.gl;for(const i in this.terrainTileForTile){const o=this.terrainTileForTile[i],r=o.dem;!r||o.demTexture&&!o.needsDEMTextureUpload||(e.activeTexture.set(t.TEXTURE1),ir(this.painter,o,r));}}_prepareDemTileUniforms(e,t,i,o){if(!t||null==t.demTexture)return !1;const r=e.tileID.canonical,s=Math.pow(2,t.tileID.canonical.z-r.z),n=o||"";return i[`u_dem_tl${n}`]=[r.x*s%1,r.y*s%1],i[`u_dem_scale${n}`]=s,!0}get emptyDEMTexture(){return !this._emptyDEMTextureDirty&&this._emptyDEMTexture?this._emptyDEMTexture:this._updateEmptyDEMTexture()}get emptyDepthBufferTexture(){const t=this.painter.context,i=t.gl;if(!this._emptyDepthBufferTexture){const o=new e.h({width:1,height:1},Uint8Array.of(255,255,255,255));this._emptyDepthBufferTexture=new e.T(t,o,i.RGBA,{premultiply:!1});}return this._emptyDepthBufferTexture}_getLoadedAreaMinimum(){let e=0;const t=this._visibleDemTiles.reduce(((t,i)=>{if(!i.dem)return t;const o=i.dem.tree.minimums[0];return o>0&&e++,t+o}),0);return e?t/e:0}_updateEmptyDEMTexture(){const t=this.painter.context,i=t.gl;t.activeTexture.set(i.TEXTURE2);const o=this._getLoadedAreaMinimum(),[r,s]=(()=>{const t=new e.cm({width:1,height:1},new Float32Array([o]));return [i.R32F,t]})();this._emptyDEMTextureDirty=!1;let n=this._emptyDEMTexture;return n?n.update(s,{premultiply:!1}):n=this._emptyDEMTexture=new e.T(t,s,r,{premultiply:!1}),n}setupElevationDraw(t,i,o){const r=this.painter.context,s=r.gl,n={u_dem:2,u_dem_prev:4,u_dem_tl:[0,0],u_dem_tl_prev:[0,0],u_dem_scale:0,u_dem_scale_prev:0,u_dem_size:0,u_dem_lerp:1,u_depth:3,u_depth_size_inv:[0,0],u_exaggeration:0};n.u_exaggeration=this.exaggeration();let a=null,l=null,c=1;if(o&&o.morphing&&this._useVertexMorphing){const e=o.morphing.srcDemTile,i=o.morphing.dstDemTile;c=o.morphing.phase,e&&i&&(this._prepareDemTileUniforms(t,e,n,"_prev")&&(l=e),this._prepareDemTileUniforms(t,i,n)&&(a=i));}const h=e=>e&&e.demTexture&&this.painter.linearFloatFilteringSupported()?s.LINEAR:s.NEAREST,u=e=>{n.u_dem_size=1===e.size[0]?1:e.size[0]-2;};if(l&&a)r.activeTexture.set(s.TEXTURE2),a.demTexture.bind(h(a),s.CLAMP_TO_EDGE),r.activeTexture.set(s.TEXTURE4),l.demTexture.bind(h(l),s.CLAMP_TO_EDGE),a.demTexture&&u(a.demTexture),n.u_dem_lerp=c;else {a=this.terrainTileForTile[t.tileID.key],r.activeTexture.set(s.TEXTURE2);const e=this._prepareDemTileUniforms(t,a,n)?a.demTexture:this.emptyDEMTexture;e.bind(h(a),s.CLAMP_TO_EDGE),u(e);}if(r.activeTexture.set(s.TEXTURE3),o&&o.useDepthForOcclusion?(this._depthTexture&&this._depthTexture.bind(s.NEAREST,s.CLAMP_TO_EDGE),this._depthFBO&&(n.u_depth_size_inv=[1/this._depthFBO.width,1/this._depthFBO.height])):(this.emptyDepthBufferTexture.bind(s.NEAREST,s.CLAMP_TO_EDGE),n.u_depth_size_inv=[1,1]),o&&o.useMeterToDem&&a){const t=(1<<a.tileID.canonical.z)*e.bl(1,this.painter.transform.center.lat)*this.sourceCache.getSource().tileSize;n.u_meter_to_dem=t;}if(o&&o.labelPlaneMatrixInv&&(n.u_label_plane_matrix_inv=o.labelPlaneMatrixInv),i.setTerrainUniformValues(r,n),"globe"===this.painter.transform.projection.name){const e=this.globeUniformValues(this.painter.transform,t.tileID.canonical,o&&o.useDenormalizedUpVectorScale);i.setGlobeUniformValues(r,e);}}globeUniformValues(t,i,o){const r=t.projection;return {u_tile_tl_up:r.upVector(i,0,0),u_tile_tr_up:r.upVector(i,e.V,0),u_tile_br_up:r.upVector(i,e.V,e.V),u_tile_bl_up:r.upVector(i,0,e.V),u_tile_up_scale:o?e.cl(1):r.upVectorScale(i,t.center.lat,t.worldSize).metersToTile}}renderToBackBuffer(t){const i=this.painter,o=this.painter.context;0!==t.length&&(o.bindFramebuffer.set(null),o.viewport.set([0,0,i.width,i.height]),i.gpuTimingDeferredRenderStart(),this.renderingToTexture=!1,function(t,i,o,r,s){if("globe"===t.transform.projection.name)!function(t,i,o,r,s){const n=t.context,a=n.gl;let l,c;const h=t.transform,u=e.cd(t,n,h),d=(e,i)=>{if(c===i)return;const o=[cr[i],"PROJECTION_GLOBE_VIEW"];u&&o.push("CUSTOM_ANTIALIASING");const r=t.isTileAffectedByFog(e);l=t.getOrCreateProgram("globeRaster",{defines:o,overrideFog:r}),c=i;},_=t.colorModeForRenderPass(),p=new Lt(a.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D);lr.update(s);const f=e.ce(h),m=[e.a5(h.center.lng),e.ae(h.center.lat)],g=t.globeSharedBuffers,v=[h.width*e.f.devicePixelRatio,h.height*e.f.devicePixelRatio],x=Float32Array.from(h.globeMatrix),y={useDenormalizedUpVectorScale:!0};{const h=t.transform,u=hr(h.zoom,i.exaggeration(),i.sourceCache._source.tileSize);c=-1;const b=a.TRIANGLES;for(const c of r){const r=o.getTile(c),w=Rt.disabled,T=i.prevTerrainTileForTile[c.key],E=i.terrainTileForTile[c.key];ar(T,E)&&lr.newMorphing(c.key,T,E,s,250),n.activeTexture.set(a.TEXTURE0),r.texture&&r.texture.bind(a.LINEAR,a.CLAMP_TO_EDGE);const S=lr.getMorphValuesForProxy(c.key),C=S?1:0;S&&e.j(y,{morphing:{srcDemTile:S.from,dstDemTile:S.to,phase:e.cc(S.phase)}});const I=e.cf(c.canonical),D=e.cg(I.getCenter().lat),L=e.ch(c.canonical,I,D,h.worldSize/h._pixelsPerMercatorPixel),A=e.aT(e.ci(c.canonical)),R=nr(h.expandedFarZProjMatrix,x,f,A,e.S(h.zoom),m,h.frustumCorners.TL,h.frustumCorners.TR,h.frustumCorners.BR,h.frustumCorners.BL,h.globeCenterInViewSpace,h.globeRadius,v,u,h._farZ,L);if(d(c,C),l&&(i.setupElevationDraw(r,l,y),t.uploadCommonUniforms(n,l,c.toUnwrapped()),g)){const[e,i,o]=g.getGridBuffers(D,0!==u);l.draw(t,b,p,w,_,Ft.backCCW,R,"globe_raster",e,i,o);}}}if(g&&(t.renderDefaultNorthPole||t.renderDefaultSouthPole)){const s=["GLOBE_POLES","PROJECTION_GLOBE_VIEW"];u&&s.push("CUSTOM_ANTIALIASING"),l=t.getOrCreateProgram("globeRaster",{defines:s});for(const s of r){const{x:r,y:c,z:u}=s.canonical,d=0===c,f=c===(1<<u)-1,[x,b,w,T]=g.getPoleBuffers(u,!1);if(T&&(d||f)){const c=o.getTile(s);n.activeTexture.set(a.TEXTURE0),c.texture&&c.texture.bind(a.LINEAR,a.CLAMP_TO_EDGE);let g=e.cj(u,r,h);const E=e.aT(e.ci(s.canonical)),S=(e,i)=>e.draw(t,a.TRIANGLES,p,Rt.disabled,_,Ft.disabled,nr(h.expandedFarZProjMatrix,g,g,E,0,m,h.frustumCorners.TL,h.frustumCorners.TR,h.frustumCorners.BR,h.frustumCorners.BL,h.globeCenterInViewSpace,h.globeRadius,v,0,h._farZ),"globe_pole_raster",i,w,T);i.setupElevationDraw(c,l,y),t.uploadCommonUniforms(n,l,s.toUnwrapped()),d&&t.renderDefaultNorthPole&&S(l,x),f&&t.renderDefaultSouthPole&&(g=e.a6.scale(e.a6.create(),g,[1,-1,1]),S(l,b));}}}}(t,i,o,r,s);else {const n=t.context,a=n.gl;let l,c;const h=t.shadowRenderer,u=vo(t,t.longestCutoffRange),d=e=>{if(c===e)return;const i=[];i.push(cr[e]),u.shouldRenderCutoff&&i.push("RENDER_CUTOFF"),l=t.getOrCreateProgram("terrainRaster",{defines:i}),c=e;},_=t.colorModeForRenderPass(),p=new Lt(a.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D);lr.update(s);const f=t.transform,m=hr(f.zoom,i.exaggeration(),i.sourceCache._source.tileSize);let g=[0,0,0];if(h){const e=t.style.directionalLight,i=t.style.ambientLight;e&&i&&(g=So(e,i));}{c=-1;const v=a.TRIANGLES,[x,y]=[i.gridIndexBuffer,i.gridSegments];for(const c of r){const r=o.getTile(c),b=Rt.disabled,w=i.prevTerrainTileForTile[c.key],T=i.terrainTileForTile[c.key];ar(w,T)&&lr.newMorphing(c.key,w,T,s,250),n.activeTexture.set(a.TEXTURE0),r.texture&&r.texture.bind(a.LINEAR,a.CLAMP_TO_EDGE);const E=lr.getMorphValuesForProxy(c.key),S=E?1:0;let C;E&&(C={morphing:{srcDemTile:E.from,dstDemTile:E.to,phase:e.cc(E.phase)}});const I=sr(c.projMatrix,ur(c.canonical,f.renderWorldCopies)?m/10:m,g);if(d(S),!l)continue;i.setupElevationDraw(r,l,C);const D=c.toUnwrapped();h&&h.setupShadows(D,l),t.uploadCommonUniforms(n,l,D,null,u),l.draw(t,v,p,b,_,Ft.backCCW,I,"terrain_raster",i.gridBuffer,x,y);}}}}(i,this,this.proxySourceCache,t,this._updateTimestamp),this.renderingToTexture=!0,i.gpuTimingDeferredRenderEnd(),t.splice(0,t.length));}renderBatch(t){if(0===this._drapedRenderBatches.length)return t+1;this.renderingToTexture=!0;const i=this.painter,o=this.painter.context,r=this.proxySourceCache,s=this.proxiedCoords[r.id],n=this._drapedRenderBatches.shift(),a=i.style.order,l=[];let c=0;for(const h of s){const s=r.getTileByID(h.proxyTileKey),u=r.proxyCachedFBO[h.key]?r.proxyCachedFBO[h.key][t]:void 0,d=void 0!==u?r.renderCache[u]:this.pool[c++],_=void 0!==u;if(s.texture=d.tex,_&&!d.dirty){l.push(s.tileID);continue}let p;o.bindFramebuffer.set(d.fb.framebuffer),this.renderedToTile=!1,d.dirty&&(o.clear({color:e.ax.transparent,stencil:0}),d.dirty=!1);for(let e=n.start;e<=n.end;++e){const t=i.style._mergedLayers[a[e]];if(t.isHidden(i.transform.zoom))continue;const r=i.style.getLayerSourceCache(t),s=r?this.proxyToSource[h.key][r.id]:[h];if(!s)continue;const n=s;o.viewport.set([0,0,d.fb.width,d.fb.height]),p!==(r?r.id:null)&&(this._setupStencil(d,s,t,r),p=r?r.id:null),i.renderLayer(i,r,t,n);}if(0===this._drapedRenderBatches.length)for(const e of this._pendingGroundEffectLayers){const t=i.style._mergedLayers[a[e]];if(t.isHidden(i.transform.zoom))continue;const r=i.style.getLayerSourceCache(t),s=r?this.proxyToSource[h.key][r.id]:[h];if(!s)continue;const n=s;o.viewport.set([0,0,d.fb.width,d.fb.height]),p!==(r?r.id:null)&&(this._setupStencil(d,s,t,r),p=r?r.id:null),i.renderLayer(i,r,t,n);}this.renderedToTile?(d.dirty=!0,l.push(s.tileID)):_||--c,5===c&&(c=0,this.renderToBackBuffer(l));}return this.renderToBackBuffer(l),this.renderingToTexture=!1,o.bindFramebuffer.set(null),o.viewport.set([0,0,i.width,i.height]),n.end+1}postRender(){}isLayerOrderingCorrect(e){const t=e.order.length;let i=-1,o=t;for(let r=0;r<t;++r)this._style.isLayerDraped(e._mergedLayers[e.order[r]])?i=Math.max(i,r):o=Math.min(o,r);return o>i}getMinElevationBelowMSL(){let e=0;return this._visibleDemTiles.filter((e=>e.dem)).forEach((t=>{e=Math.min(e,t.dem.tree.minimums[0]);})),0===e?e:(e-30)*this._exaggeration}raycast(e,t,i){if(!this._visibleDemTiles)return null;const o=this._visibleDemTiles.filter((e=>e.dem)).map((o=>{const r=o.tileID,s=1<<r.overscaledZ,{x:n,y:a}=r.canonical,l=n/s,c=(n+1)/s,h=a/s,u=(a+1)/s;return {minx:l,miny:h,maxx:c,maxy:u,t:o.dem.tree.raycastRoot(l,h,c,u,e,t,i),tile:o}}));o.sort(((e,t)=>(null!==e.t?e.t:Number.MAX_VALUE)-(null!==t.t?t.t:Number.MAX_VALUE)));for(const r of o){if(null==r.t)return null;const o=r.tile.dem.tree.raycast(r.minx,r.miny,r.maxx,r.maxy,e,t,i);if(null!=o)return o}return null}_createFBO(){const t=this.painter.context,i=t.gl,o=this.drapeBufferSize;t.activeTexture.set(i.TEXTURE0);const r=new e.T(t,{width:o[0],height:o[1],data:null},i.RGBA);r.bind(i.LINEAR,i.CLAMP_TO_EDGE);const s=t.createFramebuffer(o[0],o[1],!0,null);return s.colorAttachment.set(r.texture),s.depthAttachment=new It(t,s.framebuffer),void 0===this._sharedDepthStencil?(this._sharedDepthStencil=t.createRenderbuffer(t.gl.DEPTH_STENCIL,o[0],o[1]),this._stencilRef=0,s.depthAttachment.set(this._sharedDepthStencil),t.clear({stencil:0})):s.depthAttachment.set(this._sharedDepthStencil),t.extTextureFilterAnisotropic&&i.texParameterf(i.TEXTURE_2D,t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,t.extTextureFilterAnisotropicMax),{fb:s,tex:r,dirty:!1}}_initFBOPool(){for(;this.pool.length<Math.min(5,this.proxyCoords.length);)this.pool.push(this._createFBO());}_shouldDisableRenderCache(){if(this._debugParams.disableRenderCache)return !0;if(this._style.hasLightTransitions())return !0;for(const e in this._style._mergedSourceCaches)if(this._style._mergedSourceCaches[e].hasTransition())return !0;return this._style.order.some((e=>{const t=this._style._mergedLayers[e],i=t.isHidden(this.painter.transform.zoom);return "custom"===t.type?!i&&t.shouldRedrape():!i&&t.hasTransition()}))}_clearLineLayersFromRenderCache(){let t=!1;for(const e of this._style.getSources())if(e instanceof Pe){t=!0;break}if(!t)return;const i={};for(let t=0;t<this._style.order.length;++t){const o=this._style._mergedLayers[this._style.order[t]],r=this._style.getLayerSourceCache(o);if(r&&!i[r.id]&&!o.isHidden(this.painter.transform.zoom)&&"line"===o.type&&o.widthExpression()instanceof e.Z){i[r.id]=!0;for(const e of this.proxyCoords){const t=this.proxyToSource[e.key][r.id];if(t)for(const e of t)this._clearRenderCacheForTile(r.id,e);}}}}_clearRasterLayersFromRenderCache(){let e=!1;for(const t in this._style._mergedSourceCaches)if(this._style._mergedSourceCaches[t]._source instanceof Me){e=!0;break}if(!e)return;const t={};for(let e=0;e<this._style.order.length;++e){const i=this._style._mergedLayers[this._style.order[e]],o=this._style.getLayerSourceCache(i);if(!o||t[o.id])continue;if(i.isHidden(this.painter.transform.zoom)||"raster"!==i.type)continue;const r=i.paint.get("raster-fade-duration");for(const e of this.proxyCoords){const t=this.proxyToSource[e.key][o.id];if(t)for(const e of t){const t=_r(o.getTile(e),o.findLoadedParent(e,0),o,this.painter.transform,r);(1!==t.opacity||0!==t.mix)&&this._clearRenderCacheForTile(o.id,e);}}}}_setupDrapedRenderBatches(){const t=this._style.order,i=t.length;if(0===i)return;const o=[];this._pendingGroundEffectLayers=[];let r,s=0,n=this._style._mergedLayers[t[s]];for(;!this._style.isLayerDraped(n)&&n.isHidden(this.painter.transform.zoom)&&++s<i;)n=this._style._mergedLayers[t[s]];for(;s<i;++s){const e=this._style._mergedLayers[t[s]];e.isHidden(this.painter.transform.zoom)||(this._style.isLayerDraped(e)?void 0===r&&(r=s):("fill-extrusion"===e.type&&this._pendingGroundEffectLayers.push(s),void 0!==r&&(o.push({start:r,end:s-1}),r=void 0)));}if(void 0!==r&&o.push({start:r,end:s-1}),0!==o.length){const t=o[o.length-1];this._pendingGroundEffectLayers.every((e=>e>t.end))||e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");}this._drapedRenderBatches=o;}_setupRenderCache(e){const t=this.proxySourceCache;if(this._shouldDisableRenderCache()||this.invalidateRenderCache){if(this.invalidateRenderCache=!1,t.renderCache.length>t.renderCachePool.length){const e=Object.values(t.proxyCachedFBO);t.proxyCachedFBO={};for(let i=0;i<e.length;++i){const o=Object.values(e[i]);t.renderCachePool.push(...o);}}return}this._clearRasterLayersFromRenderCache();const i=this.proxyCoords,o=this._tilesDirty;for(let r=i.length-1;r>=0;r--){const s=i[r];if(t.getTileByID(s.key),void 0!==t.proxyCachedFBO[s.key]){const i=e[s.key],r=this.proxyToSource[s.key];let n=0;for(const e in r){const t=r[e],s=i[e];if(!s||s.length!==t.length||t.some(((t,i)=>t!==s[i]||o[e]&&o[e].hasOwnProperty(t.key)))){n=-1;break}++n;}for(const e in t.proxyCachedFBO[s.key])t.renderCache[t.proxyCachedFBO[s.key][e]].dirty=n<0||n!==Object.values(i).length;}}const r=[...this._drapedRenderBatches];r.sort(((e,t)=>t.end-t.start-(e.end-e.start)));for(const e of r)for(const o of i){if(t.proxyCachedFBO[o.key])continue;let i=t.renderCachePool.pop();void 0===i&&t.renderCache.length<50&&(i=t.renderCache.length,t.renderCache.push(this._createFBO())),void 0!==i&&(t.proxyCachedFBO[o.key]={},t.proxyCachedFBO[o.key][e.start]=i,t.renderCache[i].dirty=!0);}this._tilesDirty={};}_setupStencil(e,t,i,o){if(!o||!this._sourceTilesOverlap[o.id])return void(this._overlapStencilType&&(this._overlapStencilType=!1));const r=this.painter.context,s=r.gl;if(t.length<=1)return void(this._overlapStencilType=!1);let n;if(i.isTileClipped())n=t.length,this._overlapStencilMode.test={func:s.EQUAL,mask:255},this._overlapStencilType="Clip";else {if(!(t[0].overscaledZ>t[t.length-1].overscaledZ))return void(this._overlapStencilType=!1);n=1,this._overlapStencilMode.test={func:s.GREATER,mask:255},this._overlapStencilType="Mask";}this._stencilRef+n>255&&(r.clear({stencil:0}),this._stencilRef=0),this._stencilRef+=n,this._overlapStencilMode.ref=this._stencilRef,i.isTileClipped()&&this._renderTileClippingMasks(t,this._overlapStencilMode.ref);}clipOrMaskOverlapStencilType(){return "Clip"===this._overlapStencilType||"Mask"===this._overlapStencilType}stencilModeForRTTOverlap(e){return this.renderingToTexture&&this._overlapStencilType?("Clip"===this._overlapStencilType&&(this._overlapStencilMode.ref=this.painter._tileClippingMaskIDs[e.key]),this._overlapStencilMode):Rt.disabled}_renderTileClippingMasks(e,t){const i=this.painter,o=this.painter.context,r=o.gl;i._tileClippingMaskIDs={},o.setColorMode(Mt.disabled),o.setDepthMode(Lt.disabled);const s=i.getOrCreateProgram("clippingMask");for(const o of e){const e=i._tileClippingMaskIDs[o.key]=--t;s.draw(i,r.TRIANGLES,Lt.disabled,new Rt({func:r.ALWAYS,mask:0},e,255,r.KEEP,r.KEEP,r.REPLACE),Mt.disabled,Ft.disabled,dr(o.projMatrix),"$clipping",i.tileExtentBuffer,i.quadTriangleIndexBuffer,i.tileExtentSegments);}}pointCoordinate(t){const i=this.painter.transform;if(t.x<0||t.x>i.width||t.y<0||t.y>i.height)return null;const o=[t.x,t.y,1,1];e.a7.transformMat4(o,o,i.pixelMatrixInverse),e.a7.scale(o,o,1/o[3]),o[0]/=i.worldSize,o[1]/=i.worldSize;const r=i._camera.position,s=e.bl(1,i.center.lat),n=[r[0],r[1],r[2]/s,0],a=e.N.subtract([],o.slice(0,3),n);e.N.normalize(a,a);const l=this.raycast(n,a,this._exaggeration);return null!==l&&l?(e.N.scaleAndAdd(n,n,a,l),n[3]=n[2],n[2]*=s,n):null}drawDepth(){const t=this.painter,i=t.context,o=this.proxySourceCache,r=Math.ceil(t.width),s=Math.ceil(t.height);if(!this._depthFBO||this._depthFBO.width===r&&this._depthFBO.height===s||(this._depthFBO.destroy(),this._depthFBO=void 0,this._depthTexture=void 0),!this._depthFBO){const t=i.gl,o=i.createFramebuffer(r,s,!0,"renderbuffer");i.activeTexture.set(t.TEXTURE0);const n=new e.T(i,{width:r,height:s,data:null},t.RGBA);n.bind(t.NEAREST,t.CLAMP_TO_EDGE),o.colorAttachment.set(n.texture);const a=i.createRenderbuffer(i.gl.DEPTH_COMPONENT16,r,s);o.depthAttachment.set(a),this._depthFBO=o,this._depthTexture=n;}i.bindFramebuffer.set(this._depthFBO.framebuffer),i.viewport.set([0,0,r,s]),function(e,t,i,o){if("globe"===e.transform.projection.name)return;const r=e.context,s=r.gl;r.clear({depth:1});const n=e.getOrCreateProgram("terrainDepth"),a=new Lt(s.LESS,Lt.ReadWrite,e.depthRangeFor3D);for(const r of o){const o=i.getTile(r),l=sr(r.projMatrix,0,[0,0,0]);t.setupElevationDraw(o,n),n.draw(e,s.TRIANGLES,a,Rt.disabled,Mt.unblended,Ft.backCCW,l,"terrain_depth",t.gridBuffer,t.gridIndexBuffer,t.gridNoSkirtSegments);}}(t,this,o,this.proxyCoords);}_setupProxiedCoordsForOrtho(t,i,o){if(t.getSource()instanceof e.ap)return this._setupProxiedCoordsForImageSource(t,i,o);this._findCoveringTileCache[t.id]=this._findCoveringTileCache[t.id]||{};const r=this.proxiedCoords[t.id]=[],s=this.proxyCoords;for(let e=0;e<s.length;e++){const i=s[e],n=this._findTileCoveringTileID(i,t);if(n){const e=this._createProxiedId(i,n,o[i.key]&&o[i.key][t.id]);r.push(e),this.proxyToSource[i.key][t.id]=[e];}}let n=!1;const a=new Set;for(let e=0;e<i.length;e++){const s=t.getTile(i[e]);if(!s||!s.hasData())continue;const l=this._findTileCoveringTileID(s.tileID,this.proxySourceCache);if(l&&l.tileID.canonical.z!==s.tileID.canonical.z){const e=this.proxyToSource[l.tileID.key][t.id],i=this._createProxiedId(l.tileID,s,o[l.tileID.key]&&o[l.tileID.key][t.id]);e?e.splice(e.length-1,0,i):this.proxyToSource[l.tileID.key][t.id]=[i];const c=this.proxyToSource[l.tileID.key][t.id];a.has(c)||a.add(c),r.push(i),n=!0;}}if(this._sourceTilesOverlap[t.id]=n,n&&this._debugParams.sortTilesHiZFirst)for(const e of a)e.sort(((e,t)=>t.overscaledZ-e.overscaledZ));}_setupProxiedCoordsForImageSource(t,i,o){if(!t.getSource().loaded())return;const r=this.proxiedCoords[t.id]=[],s=this.proxyCoords,n=t.getSource(),a=n.tileID;if(!a)return;const l=new e.P(a.x,a.y)._div(1<<a.z),c=n.coordinates.map(e.L.fromLngLat).reduce(((e,t)=>(e.min.x=Math.min(e.min.x,t.x-l.x),e.min.y=Math.min(e.min.y,t.y-l.y),e.max.x=Math.max(e.max.x,t.x-l.x),e.max.y=Math.max(e.max.y,t.y-l.y),e)),{min:new e.P(Number.MAX_VALUE,Number.MAX_VALUE),max:new e.P(-Number.MAX_VALUE,-Number.MAX_VALUE)}),h=(t,i)=>{const o=t.wrap+t.canonical.x/(1<<t.canonical.z),r=t.canonical.y/(1<<t.canonical.z),s=e.V/(1<<t.canonical.z),n=i.wrap+i.canonical.x/(1<<i.canonical.z),a=i.canonical.y/(1<<i.canonical.z);return o+s<n+c.min.x||o>n+c.max.x||r+s<a+c.min.y||r>a+c.max.y};for(let e=0;e<s.length;e++){const n=s[e];for(let e=0;e<i.length;e++){const s=t.getTile(i[e]);if(!s||!s.hasData())continue;if(h(n,s.tileID))continue;const a=this._createProxiedId(n,s,o[n.key]&&o[n.key][t.id]),l=this.proxyToSource[n.key][t.id];l?l.push(a):this.proxyToSource[n.key][t.id]=[a],r.push(a);}}}_createProxiedId(t,i,o){let r=this.orthoMatrix;if(o){const e=o.find((e=>e.key===i.tileID.key));if(e)return e}if(i.tileID.key!==t.key){const o=t.canonical.z-i.tileID.canonical.z;let s,n,a;r=e.a6.create();const l=i.tileID.wrap-t.wrap<<t.overscaledZ;o>0?(s=e.V>>o,n=s*((i.tileID.canonical.x<<o)-t.canonical.x+l),a=s*((i.tileID.canonical.y<<o)-t.canonical.y)):(s=e.V<<-o,n=e.V*(i.tileID.canonical.x-(t.canonical.x+l<<-o)),a=e.V*(i.tileID.canonical.y-(t.canonical.y<<-o))),e.a6.ortho(r,0,s,0,s,0,1),e.a6.translate(r,r,[n,a,0]);}return new mr(i.tileID,t.key,r)}_findTileCoveringTileID(t,i){let o=i.getTile(t);if(o&&o.hasData())return o;const r=this._findCoveringTileCache[i.id],s=r[t.key];if(o=s?i.getTileByID(s):null,o&&o.hasData()||null===s)return o;let n=o?o.tileID:t,a=n.overscaledZ;const l=i.getSource().minzoom,c=[];if(!s){const r=i.getSource().maxzoom;if(t.canonical.z>=r){const o=t.canonical.z-r;i.getSource().reparseOverscaled?(a=Math.max(t.canonical.z+2,i.transform.tileZoom),n=new e.am(a,t.wrap,r,t.canonical.x>>o,t.canonical.y>>o)):0!==o&&(a=r,n=new e.am(a,t.wrap,r,t.canonical.x>>o,t.canonical.y>>o));}n.key!==t.key&&(c.push(n.key),o=i.getTile(n));}const h=e=>{c.forEach((t=>{r[t]=e;})),c.length=0;};for(a-=1;a>=l&&(!o||!o.hasData());a--){o&&h(o.tileID.key);const e=n.calculateScaledKey(a);if(o=i.getTileByID(e),o&&o.hasData())break;const t=r[e];if(null===t)break;void 0===t?c.push(e):o=i.getTileByID(t);}return h(o?o.tileID.key:null),o&&o.hasData()?o:null}findDEMTileFor(e){return this.enabled?this._findTileCoveringTileID(e,this.sourceCache):null}prepareDrawTile(){this.renderedToTile=!0;}_clearRenderCacheForTile(e,t){let i=this._tilesDirty[e];i||(i=this._tilesDirty[e]={}),i[t.key]=!0;}}function vr(t,i,o){const r=function(t,i,o){const r=e.N.dot(i,t),s=e.N.dot(o,[.2126,.7152,.0722]),n=(e,t,i)=>(1-i)*e+i*t,a=n(1-.3*Math.min(s,1),1,Math.min(r+1,1));return n(.92,1,Math.asin(e.aa(i[2],-1,1))/Math.PI+.5)*a}(t,[0,0,1],i),s=[0,0,0];e.N.scale(s,o.slice(0,3),r);const n=[0,0,0];e.N.scale(n,i.slice(0,3),t[2]);const a=[0,0,0];return e.N.add(a,s,n),e.bU(a)}const xr=["fill","fillOutline","fillPattern","line","linePattern","background","backgroundPattern","hillshade","raster"],yr=["stars","fillExtrusion","fillExtrusionGroundEffect","model","symbolSDF","symbolIcon","symbolTextAndIcon"];class br{static cacheKey(e,t,i,o){let r=`${t}${o?o.cacheKey:""}`;for(const t of i)e.usedDefines.includes(t)&&(r+=`/${t}`);return r}constructor(t,i,o,r,s,n,a){const l=t.gl;this.program=l.createProgram(),this.configuration=r,this.name=i,this.fixedDefines=[...n];const c=r?r.getBinderAttributes():[],h=(o.staticAttributes||[]).concat(c);let u=r?r.defines():[];u=u.concat(n.map((e=>`#define ${e}`)));const d="#version 300 es\n";let _=d+u.concat("precision mediump float;",Xo,$o.fragmentSource).join("\n");for(const e of o.fragmentIncludes)_+=`\n${Wo[e]}`;_+=`\n${o.fragmentSource}`;let p=d+u.concat("precision highp float;",Xo,$o.vertexSource).join("\n");for(const e of o.vertexIncludes)p+=`\n${Wo[e]}`;p+=`\n${o.vertexSource}`;const f=l.createShader(l.FRAGMENT_SHADER);if(l.isContextLost())return void(this.failedToCreate=!0);l.shaderSource(f,_),l.compileShader(f),l.attachShader(this.program,f);const m=l.createShader(l.VERTEX_SHADER);if(l.isContextLost())this.failedToCreate=!0;else {l.shaderSource(m,p),l.compileShader(m),l.attachShader(this.program,m),this.attributes={},this.numAttributes=h.length;for(let e=0;e<this.numAttributes;e++)if(h[e]){const t=h[e].startsWith("a_")?h[e]:`a_${h[e]}`;l.bindAttribLocation(this.program,e,t),this.attributes[t]=e;}a&&a.shaderVaryings.length>0&&l.transformFeedbackVaryings(this.program,a.shaderVaryings,a.bufferMode),l.linkProgram(this.program),l.deleteShader(m),l.deleteShader(f),this.fixedUniforms=s(t),this.binderUniforms=r?r.getUniforms(t):[],n.includes("TERRAIN")&&(this.terrainUniforms=(t=>({u_dem:new e.bO(t),u_dem_prev:new e.bO(t),u_dem_tl:new e.bL(t),u_dem_scale:new e.bN(t),u_dem_tl_prev:new e.bL(t),u_dem_scale_prev:new e.bN(t),u_dem_size:new e.bN(t),u_dem_lerp:new e.bN(t),u_exaggeration:new e.bN(t),u_depth:new e.bO(t),u_depth_size_inv:new e.bL(t),u_meter_to_dem:new e.bN(t),u_label_plane_matrix_inv:new e.bK(t)}))(t)),n.includes("GLOBE")&&(this.globeUniforms=(t=>({u_tile_tl_up:new e.bM(t),u_tile_tr_up:new e.bM(t),u_tile_br_up:new e.bM(t),u_tile_bl_up:new e.bM(t),u_tile_up_scale:new e.bN(t)}))(t)),n.includes("FOG")&&(this.fogUniforms=(t=>({u_fog_matrix:new e.bK(t),u_fog_range:new e.bL(t),u_fog_color:new e.bP(t),u_fog_horizon_blend:new e.bN(t),u_fog_vertical_limit:new e.bL(t),u_fog_temporal_offset:new e.bN(t),u_frustum_tl:new e.bM(t),u_frustum_tr:new e.bM(t),u_frustum_br:new e.bM(t),u_frustum_bl:new e.bM(t),u_globe_pos:new e.bM(t),u_globe_radius:new e.bN(t),u_globe_transition:new e.bN(t),u_is_globe:new e.bO(t),u_viewport:new e.bL(t)}))(t)),n.includes("RENDER_CUTOFF")&&(this.cutoffUniforms=(t=>({u_cutoff_params:new e.bP(t)}))(t)),n.includes("LIGHTING_3D_MODE")&&(this.lightsUniforms=(t=>({u_lighting_ambient_color:new e.bM(t),u_lighting_directional_dir:new e.bM(t),u_lighting_directional_color:new e.bM(t),u_ground_radiance:new e.bM(t)}))(t)),n.includes("RENDER_SHADOWS")&&(this.shadowUniforms=(t=>({u_light_matrix_0:new e.bK(t),u_light_matrix_1:new e.bK(t),u_fade_range:new e.bL(t),u_shadow_normal_offset:new e.bM(t),u_shadow_intensity:new e.bN(t),u_shadow_texel_size:new e.bN(t),u_shadow_map_resolution:new e.bN(t),u_shadow_direction:new e.bM(t),u_shadow_bias:new e.bM(t),u_shadowmap_0:new e.bO(t),u_shadowmap_1:new e.bO(t)}))(t));}}setTerrainUniformValues(e,t){if(!this.terrainUniforms)return;const i=this.terrainUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e]&&i[e].set(this.program,e,t[e]);}}setGlobeUniformValues(e,t){if(!this.globeUniforms)return;const i=this.globeUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e]&&i[e].set(this.program,e,t[e]);}}setFogUniformValues(e,t){if(!this.fogUniforms)return;const i=this.fogUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e].set(this.program,e,t[e]);}}setCutoffUniformValues(e,t){if(!this.cutoffUniforms)return;const i=this.cutoffUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e].set(this.program,e,t[e]);}}setLightsUniformValues(e,t){if(!this.lightsUniforms)return;const i=this.lightsUniforms;if(!this.failedToCreate){e.program.set(this.program);for(const e in t)i[e].set(this.program,e,t[e]);}}setShadowUniformValues(e,t){if(this.failedToCreate||!this.shadowUniforms)return;const i=this.shadowUniforms;e.program.set(this.program);for(const e in t)i[e].set(this.program,e,t[e]);}_drawDebugWireframe(t,i,o,r,s,n,a,l,c,h){const u=t.options.wireframe;if(!1===u.terrain&&!1===u.layers2D&&!1===u.layers3D)return;const d=t.context;if(!(()=>!(!u.terrain||"terrainRaster"!==this.name&&"globeRaster"!==this.name)||!(!u.layers2D||t._terrain&&t._terrain.renderingToTexture||!xr.includes(this.name))||!(!u.layers3D||!yr.includes(this.name)))())return;const _=d.gl,p=t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter,s,d);if(!p)return;const f=[...this.fixedDefines];f.push("DEBUG_WIREFRAME");const m=t.getOrCreateProgram(this.name,{config:this.configuration,defines:f});d.program.set(m.program);const g=(e,t,i)=>{if(t[e]&&i[e])for(const o in t[e])i[e][o]&&i[e][o].set(i.program,o,t[e][o].current);};c&&c.setUniforms(m.program,d,m.binderUniforms,a,{zoom:l}),g("fixedUniforms",this,m),g("terrainUniforms",this,m),g("globeUniforms",this,m),g("fogUniforms",this,m),g("lightsUniforms",this,m),g("shadowUniforms",this,m),p.bind(),d.setColorMode(new Mt([_.ONE,_.ONE_MINUS_SRC_ALPHA,_.ZERO,_.ONE],e.ax.transparent,[!0,!0,!0,!1])),d.setDepthMode(new Lt(i.func===_.LESS?_.LEQUAL:i.func,Lt.ReadOnly,i.range)),d.setStencilMode(Rt.disabled);const v=3*n.primitiveLength*2,x=3*n.primitiveOffset*2*2;h&&h>1?_.drawElementsInstanced(_.LINES,v,_.UNSIGNED_SHORT,x,h):_.drawElements(_.LINES,v,_.UNSIGNED_SHORT,x),s.bind(),d.program.set(this.program),d.setDepthMode(i),d.setStencilMode(o),d.setColorMode(r);}draw(e,t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m){const g=e.context,v=g.gl;if(this.failedToCreate)return;g.program.set(this.program),g.setDepthMode(i),g.setStencilMode(o),g.setColorMode(r),g.setCullFace(s);for(const e of Object.keys(this.fixedUniforms))this.fixedUniforms[e].set(this.program,e,n[e]);_&&_.setUniforms(this.program,g,this.binderUniforms,u,{zoom:d});const x={[v.POINTS]:1,[v.LINES]:2,[v.TRIANGLES]:3,[v.LINE_STRIP]:1}[t],y=m&&m.length>0;if(y){for(const e of m)v.bindBufferBase(v.TRANSFORM_FEEDBACK_BUFFER,e.targetIndex,e.buffer.buffer);v.beginTransformFeedback(t);}const b=f&&f>0?1:void 0;for(const s of h.get()){const n=s.vaos||(s.vaos={});(n[a]||(n[a]=new Qo)).bind(g,this,l,_?_.getPaintVertexBuffers():[],c,s.vertexOffset,p||[],b),f&&f>1?v.drawElementsInstanced(t,s.primitiveLength*x,v.UNSIGNED_SHORT,s.primitiveOffset*x*2,f):c?v.drawElements(t,s.primitiveLength*x,v.UNSIGNED_SHORT,s.primitiveOffset*x*2):v.drawArrays(t,s.vertexOffset,s.vertexLength),t===v.TRIANGLES&&c&&this._drawDebugWireframe(e,i,o,r,c,s,u,d,_,f);}y&&v.endTransformFeedback();}}function wr(t,i){const o=Math.pow(2,i.tileID.overscaledZ),r=i.tileSize*Math.pow(2,t.transform.tileZoom)/o,s=r*(i.tileID.canonical.x+i.tileID.wrap*o),n=r*i.tileID.canonical.y;return {u_image:0,u_texsize:i.imageAtlasTexture?i.imageAtlasTexture.size:[0,0],u_tile_units_to_pixels:1/e.a3(i,1,t.transform.tileZoom),u_pixel_coord_upper:[s>>16,n>>16],u_pixel_coord_lower:[65535&s,65535&n]}}const Tr=e.a6.create(),Er=(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m)=>{const g=i.style.light,v=g.properties.get("position"),x=[v.x,v.y,v.z],y=e.co.create();"viewport"===g.properties.get("anchor")&&(e.co.fromRotation(y,-i.transform.angle),e.N.transformMat3(x,x,y));const b=g.properties.get("color"),w=i.transform,T={u_matrix:t,u_lightpos:x,u_lightintensity:g.properties.get("intensity"),u_lightcolor:[b.r,b.g,b.b],u_vertical_gradient:+o,u_opacity:r,u_tile_id:[0,0,0],u_zoom_transition:0,u_inv_rot_matrix:Tr,u_merc_center:[0,0],u_up_dir:[0,0,0],u_height_lift:0,u_ao:s,u_edge_radius:n,u_flood_light_color:d,u_vertical_scale:_,u_flood_light_intensity:p,u_ground_shadow_factor:f,u_emissive_strength:m};return "globe"===w.projection.name&&(T.u_tile_id=[a.canonical.x,a.canonical.y,1<<a.canonical.z],T.u_zoom_transition=c,T.u_inv_rot_matrix=u,T.u_merc_center=h,T.u_up_dir=w.projection.upVector(new e.bs(0,0,0),h[0]*e.V,h[1]*e.V),T.u_height_lift=l),T},Sr=(e,t,i)=>({u_matrix:e,u_edge_radius:t,u_vertical_scale:i}),Cr=(t,i,o,r,s,n,a,l,c,h,u,d,_,p)=>{const f=Er(t,i,o,r,s,n,a,c,h,u,d,_,p,1,[0,0,0],0),m={u_height_factor:-Math.pow(2,a.overscaledZ)/l.tileSize/8};return e.e(f,wr(i,l),m)},Ir=(e,t)=>({u_matrix:e,u_emissive_strength:t}),Dr=(t,i,o,r)=>e.e(Ir(t,i),wr(o,r)),Lr=(e,t,i)=>({u_matrix:e,u_world:i,u_emissive_strength:t}),Ar=(t,i,o,r,s)=>e.e(Dr(t,i,o,r),{u_world:s}),Rr=(t,i,o,r)=>{const s=e.V/o.tileSize;return {u_matrix:t,u_camera_to_center_distance:i.getCameraToCenterDistance(r),u_extrude_scale:[i.pixelsToGLUnits[0]/s,i.pixelsToGLUnits[1]/s]}},Pr=(e,t,i=1)=>({u_matrix:e,u_color:t,u_overlay:0,u_overlay_scale:i}),Mr=e.a6.create(),zr=(t,i,o,r,s,n,a)=>{const l=t.transform,c="globe"===l.projection.name,h=c?e.cp(l.zoom,i.canonical)*l._pixelsPerMercatorPixel:e.a3(o,1,n),u={u_matrix:i.projMatrix,u_extrude_scale:h,u_intensity:a,u_inv_rot_matrix:Mr,u_merc_center:[0,0],u_tile_id:[0,0,0],u_zoom_transition:0,u_up_dir:[0,0,0]};if(c){u.u_inv_rot_matrix=r,u.u_merc_center=s,u.u_tile_id=[i.canonical.x,i.canonical.y,1<<i.canonical.z],u.u_zoom_transition=e.S(l.zoom);const t=s[0]*e.V,o=s[1]*e.V;u.u_up_dir=l.projection.upVector(new e.bs(0,0,0),t,o);}return u};function Or(e,[t,i,o,r],[s,n]){if(s===n)return [0,0,0,0];const a=255*(e-1)/(e*(n-s));return [t*a,i*a,o*a,r*a]}function Fr(e,t,[i,o]){return i===o?0:.5/e+(t-i)*(e-1)/(e*(o-i))}const Br=(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g,v,x,y,b)=>{return {u_matrix:t,u_normalize_matrix:i,u_globe_matrix:o,u_merc_matrix:r,u_grid_matrix:s,u_tl_parent:n,u_scale_parent:h,u_fade_t:u.mix,u_opacity:u.opacity*d.paint.get("raster-opacity"),u_image0:0,u_image1:1,u_brightness_low:d.paint.get("raster-brightness-min"),u_brightness_high:d.paint.get("raster-brightness-max"),u_saturation_factor:(T=d.paint.get("raster-saturation"),T>0?1-1/(1.001-T):-T),u_contrast_factor:(w=d.paint.get("raster-contrast"),w>0?1/(1-w):1+w),u_spin_weights:kr(d.paint.get("raster-hue-rotate")),u_perspective_transform:_,u_raster_elevation:p,u_zoom_transition:a,u_merc_center:l,u_cutoff_params:c,u_colorization_mix:Or(e.cq,m,v),u_colorization_offset:Fr(e.cq,g,v),u_color_ramp:f,u_texture_offset:[y/(x+2*y),x/(x+2*y)],u_texture_res:[x+2*y,x+2*y],u_emissive_strength:b};var w,T;};function kr(e){e*=Math.PI/180;const t=Math.sin(e),i=Math.cos(e);return [(2*i+1)/3,(-Math.sqrt(3)*t-i+1)/3,(Math.sqrt(3)*t-i+1)/3]}const Nr=(e,t,i,o,r,s,n,a,l,c,h,u)=>({u_matrix:e,u_normalize_matrix:t,u_globe_matrix:i,u_merc_matrix:o,u_grid_matrix:r,u_tl_parent:s,u_scale_parent:c,u_fade_t:h.mix,u_opacity:h.opacity,u_image0:0,u_image1:1,u_raster_elevation:u,u_zoom_transition:n,u_merc_center:a,u_cutoff_params:l}),Ur=(e,t,i,o,r,s,n,a)=>({u_tile_offset:e,u_velocity:t,u_color_ramp:o,u_velocity_res:i,u_max_speed:r,u_texture_offset:s,u_data_scale:n,u_data_offset:a}),Gr=(e,t,i,o,r,s,n,a)=>({u_velocity:e,u_velocity_res:t,u_max_speed:i,u_speed_factor:o,u_lifetime_delta:r,u_rand_seed:Math.random(),u_texture_offset:s,u_data_scale:n,u_data_offset:a}),jr=e.a6.create(),Vr=(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g,v)=>{const x=s.transform,y={u_is_size_zoom_constant:+("constant"===t||"source"===t),u_is_size_feature_constant:+("constant"===t||"camera"===t),u_size_t:i?i.uSizeT:0,u_size:i?i.uSize:0,u_camera_to_center_distance:x.getCameraToCenterDistance(m),u_rotate_symbol:+o,u_aspect_ratio:x.width/x.height,u_fade_change:s.options.fadeDuration?s.symbolFadeChange:1,u_matrix:n,u_label_plane_matrix:a,u_coord_matrix:l,u_is_text:+c,u_pitch_with_map:+r,u_texsize:h,u_texture:0,u_tile_id:[0,0,0],u_zoom_transition:0,u_inv_rot_matrix:jr,u_merc_center:[0,0],u_camera_forward:[0,0,0],u_ecef_origin:[0,0,0],u_tile_matrix:jr,u_up_vector:[0,-1,0],u_icon_transition:v||0,u_icon_saturation:g};return "globe"===m.name&&(y.u_tile_id=[u.canonical.x,u.canonical.y,1<<u.canonical.z],y.u_zoom_transition=d,y.u_inv_rot_matrix=p,y.u_merc_center=_,y.u_camera_forward=x._camera.forward(),y.u_ecef_origin=e.cr(x.globeMatrix,u.toUnwrapped()),y.u_tile_matrix=Float32Array.from(x.globeMatrix),y.u_up_vector=f),y},Zr=(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g)=>e.e(Vr(t,i,o,r,s,n,a,l,c,h,d,_,p,f,m,g,1),{u_gamma_scale:r?s.transform.getCameraToCenterDistance(g)*Math.cos(s.terrain?0:s.transform._pitch):1,u_device_pixel_ratio:e.f.devicePixelRatio,u_is_halo:+u,undefined:void 0}),Hr=(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m)=>e.e(Zr(t,i,o,r,s,n,a,l,!0,c,!0,u,d,_,p,f,m),{u_texsize_icon:h,u_texture_icon:1}),Wr=(e,t,i,o)=>({u_matrix:e,u_emissive_strength:t,u_opacity:i,u_color:o}),qr=(t,i,o,r,s,n,a)=>e.e(function(t,i,o,r){const s=o.imageManager.getPattern(t.toString(),i),{width:n,height:a}=o.imageManager.getPixelSize(i),l=Math.pow(2,r.tileID.overscaledZ),c=r.tileSize*Math.pow(2,o.transform.tileZoom)/l,h=c*(r.tileID.canonical.x+r.tileID.wrap*l),u=c*r.tileID.canonical.y;return {u_image:0,u_pattern_tl:s.tl,u_pattern_br:s.br,u_texsize:[n,a],u_pattern_size:s.displaySize,u_tile_units_to_pixels:1/e.a3(r,1,o.transform.tileZoom),u_pixel_coord_upper:[h>>16,u>>16],u_pixel_coord_lower:[65535&h,65535&u]}}(s,n,r,a),{u_matrix:t,u_emissive_strength:i,u_opacity:o}),$r=(t,i,o,r,s,n,a,l,c,h,u,d,_=[0,0,0],p)=>{const f=r.style.light,m=f.properties.get("position"),g=[-m.x,-m.y,m.z],v=e.co.create();"viewport"===f.properties.get("anchor")&&(e.co.fromRotation(v,-r.transform.angle),e.N.transformMat3(g,g,v));const x="MASK"===h.alphaMode,y=f.properties.get("color"),b=d.paint.get("model-ambient-occlusion-intensity"),w=d.paint.get("model-color").constantOr(e.ax.white),T=d.paint.get("model-color-mix-intensity").constantOr(0);return {u_matrix:t,u_lighting_matrix:i,u_normal_matrix:o,u_lightpos:g,u_lightintensity:f.properties.get("intensity"),u_lightcolor:[y.r,y.g,y.b],u_camera_pos:_,u_opacity:s,u_baseTextureIsAlpha:0,u_alphaMask:+x,u_alphaCutoff:h.alphaCutoff,u_baseColorFactor:[n.r,n.g,n.b,n.a],u_emissiveFactor:[a[0],a[1],a[2],1],u_metallicFactor:l,u_roughnessFactor:c,u_baseColorTexture:go.BaseColor,u_metallicRoughnessTexture:go.MetallicRoughness,u_normalTexture:go.Normal,u_occlusionTexture:go.Occlusion,u_emissionTexture:go.Emission,u_color_mix:[w.r,w.g,w.b,T],u_aoIntensity:b,u_emissive_strength:u,u_occlusionTextureTransform:p||[0,0,0,0]}},Xr=new Float32Array(16),Kr=(e,t=Xr,i=Xr)=>({u_matrix:e,u_instance:t,u_node_matrix:i}),Yr={fillExtrusion:t=>({u_matrix:new e.bK(t),u_lightpos:new e.bM(t),u_lightintensity:new e.bN(t),u_lightcolor:new e.bM(t),u_vertical_gradient:new e.bN(t),u_opacity:new e.bN(t),u_edge_radius:new e.bN(t),u_ao:new e.bL(t),u_tile_id:new e.bM(t),u_zoom_transition:new e.bN(t),u_inv_rot_matrix:new e.bK(t),u_merc_center:new e.bL(t),u_up_dir:new e.bM(t),u_height_lift:new e.bN(t),u_flood_light_color:new e.bM(t),u_vertical_scale:new e.bN(t),u_flood_light_intensity:new e.bN(t),u_ground_shadow_factor:new e.bM(t),u_emissive_strength:new e.bN(t)}),fillExtrusionDepth:t=>({u_matrix:new e.bK(t),u_edge_radius:new e.bN(t),u_vertical_scale:new e.bN(t)}),fillExtrusionPattern:t=>({u_matrix:new e.bK(t),u_lightpos:new e.bM(t),u_lightintensity:new e.bN(t),u_lightcolor:new e.bM(t),u_vertical_gradient:new e.bN(t),u_height_factor:new e.bN(t),u_edge_radius:new e.bN(t),u_ao:new e.bL(t),u_tile_id:new e.bM(t),u_zoom_transition:new e.bN(t),u_inv_rot_matrix:new e.bK(t),u_merc_center:new e.bL(t),u_up_dir:new e.bM(t),u_height_lift:new e.bN(t),u_image:new e.bO(t),u_texsize:new e.bL(t),u_pixel_coord_upper:new e.bL(t),u_pixel_coord_lower:new e.bL(t),u_tile_units_to_pixels:new e.bN(t),u_opacity:new e.bN(t)}),fillExtrusionGroundEffect:t=>({u_matrix:new e.bK(t),u_opacity:new e.bN(t),u_ao_pass:new e.bN(t),u_meter_to_tile:new e.bN(t),u_ao:new e.bL(t),u_flood_light_intensity:new e.bN(t),u_flood_light_color:new e.bM(t),u_attenuation:new e.bN(t),u_edge_radius:new e.bN(t),u_fb:new e.bO(t),u_fb_size:new e.bN(t)}),fill:t=>({u_matrix:new e.bK(t),u_emissive_strength:new e.bN(t)}),fillPattern:t=>({u_matrix:new e.bK(t),u_emissive_strength:new e.bN(t),u_image:new e.bO(t),u_texsize:new e.bL(t),u_pixel_coord_upper:new e.bL(t),u_pixel_coord_lower:new e.bL(t),u_tile_units_to_pixels:new e.bN(t)}),fillOutline:t=>({u_matrix:new e.bK(t),u_emissive_strength:new e.bN(t),u_world:new e.bL(t)}),fillOutlinePattern:t=>({u_matrix:new e.bK(t),u_emissive_strength:new e.bN(t),u_world:new e.bL(t),u_image:new e.bO(t),u_texsize:new e.bL(t),u_pixel_coord_upper:new e.bL(t),u_pixel_coord_lower:new e.bL(t),u_tile_units_to_pixels:new e.bN(t)}),circle:e.cs,collisionBox:t=>({u_matrix:new e.bK(t),u_camera_to_center_distance:new e.bN(t),u_extrude_scale:new e.bL(t)}),collisionCircle:t=>({u_matrix:new e.bK(t),u_inv_matrix:new e.bK(t),u_camera_to_center_distance:new e.bN(t),u_viewport_size:new e.bL(t)}),debug:t=>({u_color:new e.ca(t),u_matrix:new e.bK(t),u_overlay:new e.bO(t),u_overlay_scale:new e.bN(t)}),clippingMask:t=>({u_matrix:new e.bK(t)}),heatmap:t=>({u_extrude_scale:new e.bN(t),u_intensity:new e.bN(t),u_matrix:new e.bK(t),u_inv_rot_matrix:new e.bK(t),u_merc_center:new e.bL(t),u_tile_id:new e.bM(t),u_zoom_transition:new e.bN(t),u_up_dir:new e.bM(t)}),heatmapTexture:t=>({u_image:new e.bO(t),u_color_ramp:new e.bO(t),u_opacity:new e.bN(t)}),hillshade:t=>({u_matrix:new e.bK(t),u_image:new e.bO(t),u_latrange:new e.bL(t),u_light:new e.bL(t),u_shadow:new e.ca(t),u_highlight:new e.ca(t),u_emissive_strength:new e.bN(t),u_accent:new e.ca(t)}),hillshadePrepare:t=>({u_matrix:new e.bK(t),u_image:new e.bO(t),u_dimension:new e.bL(t),u_zoom:new e.bN(t)}),line:e.ct,linePattern:e.cu,raster:t=>({u_matrix:new e.bK(t),u_normalize_matrix:new e.bK(t),u_globe_matrix:new e.bK(t),u_merc_matrix:new e.bK(t),u_grid_matrix:new e.cb(t),u_tl_parent:new e.bL(t),u_scale_parent:new e.bN(t),u_fade_t:new e.bN(t),u_opacity:new e.bN(t),u_image0:new e.bO(t),u_image1:new e.bO(t),u_brightness_low:new e.bN(t),u_brightness_high:new e.bN(t),u_saturation_factor:new e.bN(t),u_contrast_factor:new e.bN(t),u_spin_weights:new e.bM(t),u_perspective_transform:new e.bL(t),u_raster_elevation:new e.bN(t),u_zoom_transition:new e.bN(t),u_merc_center:new e.bL(t),u_cutoff_params:new e.bP(t),u_colorization_mix:new e.bP(t),u_colorization_offset:new e.bN(t),u_color_ramp:new e.bO(t),u_texture_offset:new e.bL(t),u_texture_res:new e.bL(t),u_emissive_strength:new e.bN(t)}),rasterParticle:t=>({u_matrix:new e.bK(t),u_normalize_matrix:new e.bK(t),u_globe_matrix:new e.bK(t),u_merc_matrix:new e.bK(t),u_grid_matrix:new e.cb(t),u_tl_parent:new e.bL(t),u_scale_parent:new e.bN(t),u_fade_t:new e.bN(t),u_opacity:new e.bN(t),u_image0:new e.bO(t),u_image1:new e.bO(t),u_raster_elevation:new e.bN(t),u_zoom_transition:new e.bN(t),u_merc_center:new e.bL(t),u_cutoff_params:new e.bP(t)}),rasterParticleTexture:t=>({u_texture:new e.bO(t),u_opacity:new e.bN(t)}),rasterParticleDraw:t=>({u_tile_offset:new e.bL(t),u_velocity:new e.bO(t),u_color_ramp:new e.bO(t),u_velocity_res:new e.bL(t),u_max_speed:new e.bN(t),u_texture_offset:new e.bL(t),u_data_scale:new e.bP(t),u_data_offset:new e.bN(t)}),rasterParticleUpdate:t=>({u_velocity:new e.bO(t),u_velocity_res:new e.bL(t),u_max_speed:new e.bN(t),u_speed_factor:new e.bN(t),u_lifetime_delta:new e.bN(t),u_rand_seed:new e.bN(t),u_texture_offset:new e.bL(t),u_data_scale:new e.bP(t),u_data_offset:new e.bN(t)}),symbolIcon:t=>({u_is_size_zoom_constant:new e.bO(t),u_is_size_feature_constant:new e.bO(t),u_size_t:new e.bN(t),u_size:new e.bN(t),u_camera_to_center_distance:new e.bN(t),u_rotate_symbol:new e.bO(t),u_aspect_ratio:new e.bN(t),u_fade_change:new e.bN(t),u_matrix:new e.bK(t),u_label_plane_matrix:new e.bK(t),u_coord_matrix:new e.bK(t),u_is_text:new e.bO(t),u_pitch_with_map:new e.bO(t),u_texsize:new e.bL(t),u_tile_id:new e.bM(t),u_zoom_transition:new e.bN(t),u_inv_rot_matrix:new e.bK(t),u_merc_center:new e.bL(t),u_camera_forward:new e.bM(t),u_tile_matrix:new e.bK(t),u_up_vector:new e.bM(t),u_ecef_origin:new e.bM(t),u_texture:new e.bO(t),u_icon_transition:new e.bN(t),u_icon_saturation:new e.bN(t)}),symbolSDF:t=>({u_is_size_zoom_constant:new e.bO(t),u_is_size_feature_constant:new e.bO(t),u_size_t:new e.bN(t),u_size:new e.bN(t),u_camera_to_center_distance:new e.bN(t),u_rotate_symbol:new e.bO(t),u_aspect_ratio:new e.bN(t),u_fade_change:new e.bN(t),u_matrix:new e.bK(t),u_label_plane_matrix:new e.bK(t),u_coord_matrix:new e.bK(t),u_is_text:new e.bO(t),u_pitch_with_map:new e.bO(t),u_texsize:new e.bL(t),u_texture:new e.bO(t),u_gamma_scale:new e.bN(t),u_device_pixel_ratio:new e.bN(t),u_tile_id:new e.bM(t),u_zoom_transition:new e.bN(t),u_inv_rot_matrix:new e.bK(t),u_merc_center:new e.bL(t),u_camera_forward:new e.bM(t),u_tile_matrix:new e.bK(t),u_up_vector:new e.bM(t),u_ecef_origin:new e.bM(t),u_is_halo:new e.bO(t)}),symbolTextAndIcon:t=>({u_is_size_zoom_constant:new e.bO(t),u_is_size_feature_constant:new e.bO(t),u_size_t:new e.bN(t),u_size:new e.bN(t),u_camera_to_center_distance:new e.bN(t),u_rotate_symbol:new e.bO(t),u_aspect_ratio:new e.bN(t),u_fade_change:new e.bN(t),u_matrix:new e.bK(t),u_label_plane_matrix:new e.bK(t),u_coord_matrix:new e.bK(t),u_is_text:new e.bO(t),u_pitch_with_map:new e.bO(t),u_texsize:new e.bL(t),u_texsize_icon:new e.bL(t),u_texture:new e.bO(t),u_texture_icon:new e.bO(t),u_gamma_scale:new e.bN(t),u_device_pixel_ratio:new e.bN(t),u_is_halo:new e.bO(t)}),background:t=>({u_matrix:new e.bK(t),u_emissive_strength:new e.bN(t),u_opacity:new e.bN(t),u_color:new e.ca(t)}),backgroundPattern:t=>({u_matrix:new e.bK(t),u_emissive_strength:new e.bN(t),u_opacity:new e.bN(t),u_image:new e.bO(t),u_pattern_tl:new e.bL(t),u_pattern_br:new e.bL(t),u_texsize:new e.bL(t),u_pattern_size:new e.bL(t),u_pixel_coord_upper:new e.bL(t),u_pixel_coord_lower:new e.bL(t),u_tile_units_to_pixels:new e.bN(t)}),terrainRaster:rr,terrainDepth:rr,skybox:t=>({u_matrix:new e.bK(t),u_sun_direction:new e.bM(t),u_cubemap:new e.bO(t),u_opacity:new e.bN(t),u_temporal_offset:new e.bN(t)}),skyboxGradient:t=>({u_matrix:new e.bK(t),u_color_ramp:new e.bO(t),u_center_direction:new e.bM(t),u_radius:new e.bN(t),u_opacity:new e.bN(t),u_temporal_offset:new e.bN(t)}),skyboxCapture:t=>({u_matrix_3f:new e.cb(t),u_sun_direction:new e.bM(t),u_sun_intensity:new e.bN(t),u_color_tint_r:new e.bP(t),u_color_tint_m:new e.bP(t),u_luminance:new e.bN(t)}),globeRaster:t=>({u_proj_matrix:new e.bK(t),u_globe_matrix:new e.bK(t),u_normalize_matrix:new e.bK(t),u_merc_matrix:new e.bK(t),u_zoom_transition:new e.bN(t),u_merc_center:new e.bL(t),u_image0:new e.bO(t),u_grid_matrix:new e.cb(t),u_skirt_height:new e.bN(t),u_far_z_cutoff:new e.bN(t),u_frustum_tl:new e.bM(t),u_frustum_tr:new e.bM(t),u_frustum_br:new e.bM(t),u_frustum_bl:new e.bM(t),u_globe_pos:new e.bM(t),u_globe_radius:new e.bN(t),u_viewport:new e.bL(t)}),globeAtmosphere:t=>({u_frustum_tl:new e.bM(t),u_frustum_tr:new e.bM(t),u_frustum_br:new e.bM(t),u_frustum_bl:new e.bM(t),u_horizon:new e.bN(t),u_transition:new e.bN(t),u_fadeout_range:new e.bN(t),u_color:new e.bP(t),u_high_color:new e.bP(t),u_space_color:new e.bP(t),u_temporal_offset:new e.bN(t),u_horizon_angle:new e.bN(t)}),model:t=>({u_matrix:new e.bK(t),u_lighting_matrix:new e.bK(t),u_normal_matrix:new e.bK(t),u_lightpos:new e.bM(t),u_lightintensity:new e.bN(t),u_lightcolor:new e.bM(t),u_camera_pos:new e.bM(t),u_opacity:new e.bN(t),u_baseColorFactor:new e.bP(t),u_emissiveFactor:new e.bP(t),u_metallicFactor:new e.bN(t),u_roughnessFactor:new e.bN(t),u_baseTextureIsAlpha:new e.bO(t),u_alphaMask:new e.bO(t),u_alphaCutoff:new e.bN(t),u_baseColorTexture:new e.bO(t),u_metallicRoughnessTexture:new e.bO(t),u_normalTexture:new e.bO(t),u_occlusionTexture:new e.bO(t),u_emissionTexture:new e.bO(t),u_color_mix:new e.bP(t),u_aoIntensity:new e.bN(t),u_emissive_strength:new e.bN(t),u_occlusionTextureTransform:new e.bP(t)}),modelDepth:t=>({u_matrix:new e.bK(t),u_instance:new e.bK(t),u_node_matrix:new e.bK(t)}),groundShadow:t=>({u_matrix:new e.bK(t),u_ground_shadow_factor:new e.bM(t)}),stars:t=>({u_matrix:new e.bK(t),u_up:new e.bM(t),u_right:new e.bM(t),u_intensity_multiplier:new e.bN(t)})};let Jr;function Qr(t,i,o,r,s,n,a){const l=t.context,c=l.gl,h=t.transform,u=t.getOrCreateProgram("collisionBox"),d=[];let _=0,p=0;for(let l=0;l<r.length;l++){const f=r[l],m=i.getTile(f),g=m.getBucket(o);if(!g)continue;const v=Mi(f,g,h);let x=v;0===s[0]&&0===s[1]||(x=t.translatePosMatrix(v,m,s,n));const y=a?g.textCollisionBox:g.iconCollisionBox,b=g.collisionCircleArray;if(b.length>0){const t=e.a6.create(),i=x;e.a6.mul(t,g.placementInvProjMatrix,h.glCoordMatrix),e.a6.mul(t,t,g.placementViewportMatrix),d.push({circleArray:b,circleOffset:p,transform:i,invTransform:t,projection:g.getProjection()}),_+=b.length/4,p=_;}y&&(t.terrain&&t.terrain.setupElevationDraw(m,u),u.draw(t,c.LINES,Lt.disabled,Rt.disabled,t.colorModeForRenderPass(),Ft.disabled,Rr(x,h,m,g.getProjection()),o.id,y.layoutVertexBuffer,y.indexBuffer,y.segments,null,h.zoom,null,[y.collisionVertexBuffer,y.collisionVertexBufferExt]));}if(!a||!d.length)return;const f=t.getOrCreateProgram("collisionCircle"),m=new e.cv;m.resize(4*_),m._trim();let g=0;for(const e of d)for(let t=0;t<e.circleArray.length/4;t++){const i=4*t,o=e.circleArray[i+0],r=e.circleArray[i+1],s=e.circleArray[i+2],n=e.circleArray[i+3];m.emplace(g++,o,r,s,n,0),m.emplace(g++,o,r,s,n,1),m.emplace(g++,o,r,s,n,2),m.emplace(g++,o,r,s,n,3);}(!Jr||Jr.length<2*_)&&(Jr=function(t){const i=2*t,o=new e.aw;o.resize(i),o._trim();for(let e=0;e<i;e++){const t=6*e;o.uint16[t+0]=4*e+0,o.uint16[t+1]=4*e+1,o.uint16[t+2]=4*e+2,o.uint16[t+3]=4*e+2,o.uint16[t+4]=4*e+3,o.uint16[t+5]=4*e+0;}return o}(_));const v=l.createIndexBuffer(Jr,!0),x=l.createVertexBuffer(m,e.cw.members,!0);for(const i of d){const r={u_matrix:i.transform,u_inv_matrix:i.invTransform,u_camera_to_center_distance:(y=h).getCameraToCenterDistance(i.projection),u_viewport_size:[y.width,y.height]};f.draw(t,c.TRIANGLES,Lt.disabled,Rt.disabled,t.colorModeForRenderPass(),Ft.disabled,r,o.id,x,v,e.aB.simpleSegment(0,2*i.circleOffset,i.circleArray.length,i.circleArray.length/2),null,h.zoom);}var y;x.destroy(),v.destroy();}const es=e.a6.create();function ts(t){const i=t._camera.getWorldToCamera(t.worldSize,1),o=e.a6.multiply([],i,t.globeMatrix);e.a6.invert(o,o);const r=[0,0,0],s=[0,1,0,0];return e.a7.transformMat4(s,s,o),r[0]=s[0],r[1]=s[1],r[2]=s[2],e.N.normalize(r,r),r}function is({width:t,height:i,anchor:o,textOffset:r,textScale:s},n){const{horizontalAlign:a,verticalAlign:l}=e.bf(o),c=-(a-.5)*t,h=-(l-.5)*i,u=e.bd(o,r);return new e.P((c/s+u[0])*n,(h/s+u[1])*n)}function os(t,i,o,r,s,n,a,l,c,h,u){const d=t.text.placedSymbolArray,_=t.text.dynamicLayoutVertexArray,p=t.icon.dynamicLayoutVertexArray,f={},m=t.getProjection(),g=zi(l,m,n),v=n.elevation,x=m.upVectorScale(l.canonical,n.center.lat,n.worldSize).metersToTile;_.clear();for(let p=0;p<d.length;p++){const y=d.get(p),{tileAnchorX:b,tileAnchorY:w,numGlyphs:T}=y,E=y.hidden||!y.crossTileID||t.allowVerticalPlacement&&!y.placedOrientation?null:r[y.crossTileID];if(E){let r=0,d=0,p=0;if(v){const e=v?v.getAtTileOffset(l,b,w):0,[t,i,o]=m.upVector(l.canonical,b,w);r=e*t*x,d=e*i*x,p=e*o*x;}let[S,C,I,D]=vi(y.projectedAnchorX+r,y.projectedAnchorY+d,y.projectedAnchorZ+p,o?g:a);const L=xi(n.getCameraToCenterDistance(m),D);let A=s.evaluateSizeForFeature(t.textSizeData,h,y)*L/e.bc;o&&(A*=t.tilePixelRatio/c);const R=is(E,A);o?(({x:S,y:C,z:I}=m.projectTilePoint(b+R.x,w+R.y,l.canonical)),[S,C,I]=vi(S+r,C+d,I+p,a)):(i&&R._rotate(-n.angle),S+=R.x,C+=R.y,I=0);const P=t.allowVerticalPlacement&&y.placedOrientation===e.b6.vertical?Math.PI/2:0;for(let t=0;t<T;t++)e.b9(_,S,C,I,P);u&&y.associatedIconIndex>=0&&(f[y.associatedIconIndex]={x:S,y:C,z:I,angle:P});}else Di(T,_);}if(u){p.clear();const i=t.icon.placedSymbolArray;for(let t=0;t<i.length;t++){const o=i.get(t),{numGlyphs:r}=o,s=f[t];if(o.hidden||!s)Di(r,p);else {const{x:t,y:i,z:o,angle:n}=s;for(let s=0;s<r;s++)e.b9(p,t,i,o,n);}}t.icon.dynamicLayoutVertexBuffer.updateData(p);}t.text.dynamicLayoutVertexBuffer.updateData(_);}function rs(t,i,o,r,s,n,a={}){const l=o.paint.get("icon-translate"),c=o.paint.get("text-translate"),h=o.paint.get("icon-translate-anchor"),u=o.paint.get("text-translate-anchor"),d=o.layout.get("icon-rotation-alignment"),_=o.layout.get("text-rotation-alignment"),p=o.layout.get("icon-pitch-alignment"),f=o.layout.get("text-pitch-alignment"),m=o.layout.get("icon-keep-upright"),g=o.layout.get("text-keep-upright"),v=o.paint.get("icon-color-saturation"),x=t.context,y=x.gl,b=t.transform,w="map"===d,T="map"===_,E="map"===p,S="map"===f,C=void 0!==o.layout.get("symbol-sort-key").constantOr(1);let I=!1;const D=t.depthModeForSublayer(0,Lt.ReadOnly),L=[e.a5(b.center.lng),e.ae(b.center.lat)],A=o.layout.get("text-variable-anchor"),R="globe"===b.projection.name,P=[],M=[0,-1,0];for(const s of r){const r=i.getTile(s),n=r.getBucket(o);if(!n)continue;if("mercator"===n.projection.name&&R)continue;if(n.fullyClipped)continue;const d="globe"===n.projection.name,_=d?e.S(b.zoom):0,p=zi(s,n.getProjection(),b),f=b.calculatePixelsToTileUnitsMatrix(r),x=A&&n.hasTextData(),D=n.hasIconTextFit()&&x&&n.hasIconData(),z=n.getProjection().createInversionMatrix(b,s.canonical),O=()=>{const i=w&&"point"!==o.layout.get("symbol-placement"),a=[],c=i||D,u=o.paint.get("icon-image-cross-fade").constantOr(0);t.terrainRenderModeElevated()&&E&&a.push("PITCH_WITH_MAP_TERRAIN"),d&&(a.push("PROJECTION_GLOBE_VIEW"),c&&a.push("PROJECTED_POS_ON_VIEWPORT")),u>0&&a.push("ICON_TRANSITION"),n.icon.zOffsetVertexBuffer&&a.push("Z_OFFSET"),v<1&&a.push("SATURATION");const g=n.icon.programConfigurations.get(o.id),x=t.getOrCreateProgram(n.sdfIcons?"symbolSDF":"symbolIcon",{config:g,defines:a});let T;const S=r.imageAtlasTexture?r.imageAtlasTexture.size:[0,0],C=n.iconSizeData,I=e.b5(C,b.zoom),A=E||0!==b.pitch,P=fi(p,r.tileID.canonical,E,w,b,n.getProjection(),f),O=gi(p,r.tileID.canonical,E,w,b,n.getProjection(),f),F=t.translatePosMatrix(O,r,l,h,!0),B=t.translatePosMatrix(p,r,l,h),k=c?es:P,N=w&&!E&&!i;let U=M;!R&&!b.mercatorFromTransition||w||(U=ts(b));const G=d?U:M;T=n.sdfIcons&&!n.iconsInText?Zr(C.kind,I,N,E,t,B,k,F,!1,S,!0,s,_,L,z,G,n.getProjection()):Vr(C.kind,I,N,E,t,B,k,F,!1,S,s,_,L,z,G,n.getProjection(),v,u);const j=r.imageAtlasTexture?r.imageAtlasTexture:null,V=1!==o.layout.get("icon-size").constantOr(0)||n.iconsNeedLinear,Z=n.sdfIcons||t.options.rotating||t.options.zooming||V||A?y.LINEAR:y.NEAREST,H=n.sdfIcons&&0!==o.paint.get("icon-halo-width").constantOr(1),W=t.terrain&&E&&i?e.a6.invert(e.a6.create(),P):es;if(i&&n.icon){const e=b.elevation,i=e?e.getAtTileOffsetFunc(s,b.center.lat,b.worldSize,n.getProjection()):null,o=mi(p,r.tileID.canonical,E,w,b,n.getProjection(),f);bi(n,p,t,!1,o,O,E,m,i,s);}return {program:x,buffers:n.icon,uniformValues:T,atlasTexture:j,atlasTextureIcon:null,atlasInterpolation:Z,atlasInterpolationIcon:null,isSDF:n.sdfIcons,hasHalo:H,tile:r,labelPlaneMatrixInv:W}},F=()=>{const i=T&&"point"!==o.layout.get("symbol-placement"),a=[],l=i||A||D;t.terrainRenderModeElevated()&&S&&a.push("PITCH_WITH_MAP_TERRAIN"),d&&(a.push("PROJECTION_GLOBE_VIEW"),l&&a.push("PROJECTED_POS_ON_VIEWPORT")),n.text.zOffsetVertexBuffer&&a.push("Z_OFFSET");const h=n.text.programConfigurations.get(o.id),m=t.getOrCreateProgram(n.iconsInText?"symbolTextAndIcon":"symbolSDF",{config:h,defines:a});let v,x=[0,0],w=null;const E=n.textSizeData;n.iconsInText&&(x=r.imageAtlasTexture?r.imageAtlasTexture.size:[0,0],w=r.imageAtlasTexture?r.imageAtlasTexture:null,v=S||0!==b.pitch||t.options.rotating||t.options.zooming||"composite"===E.kind||"camera"===E.kind?y.LINEAR:y.NEAREST);const C=r.glyphAtlasTexture?r.glyphAtlasTexture.size:[0,0],I=e.b5(E,b.zoom),P=fi(p,r.tileID.canonical,S,T,b,n.getProjection(),f),O=gi(p,r.tileID.canonical,S,T,b,n.getProjection(),f),F=t.translatePosMatrix(O,r,c,u,!0),B=t.translatePosMatrix(p,r,c,u),k=l?es:P,N=T&&!S&&!i;let U=M;!R&&!b.mercatorFromTransition||T||(U=ts(b));const G=d?U:M;let j;j=n.iconsInText?Hr(E.kind,I,N,S,t,B,k,F,C,x,s,_,L,z,G,n.getProjection()):Zr(E.kind,I,N,S,t,B,k,F,!0,C,!0,s,_,L,z,G,n.getProjection());const V=r.glyphAtlasTexture?r.glyphAtlasTexture:null,Z=y.LINEAR,H=0!==o.paint.get("text-halo-width").constantOr(1),W=t.terrain&&S&&i?e.a6.invert(e.a6.create(),P):es;if(i&&n.text){const e=b.elevation,i=e?e.getAtTileOffsetFunc(s,b.center.lat,b.worldSize,n.getProjection()):null,o=mi(p,r.tileID.canonical,S,T,b,n.getProjection(),f);bi(n,p,t,!0,o,O,S,g,i,s);}return {program:m,buffers:n.text,uniformValues:j,atlasTexture:V,atlasTextureIcon:w,atlasInterpolation:Z,atlasInterpolationIcon:v,isSDF:!0,hasHalo:H,tile:r,labelPlaneMatrixInv:W}},B=n.icon.segments.get().length,k=n.text.segments.get().length,N=B&&!a.onlyText?O():null,U=k&&!a.onlyIcons?F():null,G=o.paint.get("icon-opacity").constantOr(1),j=o.paint.get("text-opacity").constantOr(1);if(C&&n.canOverlap){I=!0;const t=G&&!a.onlyText?n.icon.segments.get():[],i=j&&!a.onlyIcons?n.text.segments.get():[];for(const i of t)P.push({segments:new e.aB([i]),sortKey:i.sortKey,state:N});for(const t of i)P.push({segments:new e.aB([t]),sortKey:t.sortKey,state:U});}else a.onlyText||P.push({segments:G?n.icon.segments:new e.aB([]),sortKey:0,state:N}),a.onlyIcons||P.push({segments:j?n.text.segments:new e.aB([]),sortKey:0,state:U});}I&&P.sort(((e,t)=>e.sortKey-t.sortKey));for(const e of P){const i=e.state;if(i)if(t.terrain&&t.terrain.setupElevationDraw(i.tile,i.program,{useDepthForOcclusion:b.depthOcclusionForSymbolsAndCircles,labelPlaneMatrixInv:i.labelPlaneMatrixInv}),x.activeTexture.set(y.TEXTURE0),i.atlasTexture&&i.atlasTexture.bind(i.atlasInterpolation,y.CLAMP_TO_EDGE,!0),i.atlasTextureIcon&&(x.activeTexture.set(y.TEXTURE1),i.atlasTextureIcon&&i.atlasTextureIcon.bind(i.atlasInterpolationIcon,y.CLAMP_TO_EDGE,!0)),t.uploadCommonLightUniforms(t.context,i.program),i.hasHalo){const r=i.uniformValues;r.u_is_halo=1,ss(i.buffers,e.segments,o,t,i.program,D,s,n,r,2),r.u_is_halo=0;}else {if(i.isSDF){const r=i.uniformValues;i.hasHalo&&(r.u_is_halo=1,ss(i.buffers,e.segments,o,t,i.program,D,s,n,r,1)),r.u_is_halo=0;}ss(i.buffers,e.segments,o,t,i.program,D,s,n,i.uniformValues,1);}}}function ss(e,t,i,o,r,s,n,a,l,c){const h=[e.dynamicLayoutVertexBuffer,e.opacityVertexBuffer,e.iconTransitioningVertexBuffer,e.globeExtVertexBuffer,e.zOffsetVertexBuffer];r.draw(o,o.context.gl.TRIANGLES,s,n,a,Ft.disabled,l,i.id,e.layoutVertexBuffer,e.indexBuffer,t,i.paint,o.transform.zoom,e.programConfigurations.get(i.id),h,c);}function ns(e,t,i,o,r,s,n){const a=e.context.gl,l=i.paint.get("fill-pattern"),c=l&&l.constantOr(1);let h,u,d,_,p;n?(u=c&&!i.getPaintProperty("fill-outline-color")?"fillOutlinePattern":"fillOutline",h=a.LINES):(u=c?"fillPattern":"fill",h=a.TRIANGLES);for(const f of o){const o=t.getTile(f);if(c&&!o.patternsLoaded())continue;const m=o.getBucket(i);if(!m)continue;e.prepareDrawTile();const g=m.programConfigurations.get(i.id),v=e.isTileAffectedByFog(f),x=e.getOrCreateProgram(u,{config:g,overrideFog:v});c&&(e.context.activeTexture.set(a.TEXTURE0),o.imageAtlasTexture&&o.imageAtlasTexture.bind(a.LINEAR,a.CLAMP_TO_EDGE),g.updatePaintBuffers());const y=l.constantOr(null);if(y&&o.imageAtlas){const e=o.imageAtlas.patternPositions[y.toString()];e&&g.setConstantPatternPositions(e);}const b=e.translatePosMatrix(f.projMatrix,o,i.paint.get("fill-translate"),i.paint.get("fill-translate-anchor")),w=i.paint.get("fill-emissive-strength");if(n){_=m.indexBuffer2,p=m.segments2;const t=e.terrain&&e.terrain.renderingToTexture?e.terrain.drapeBufferSize:[a.drawingBufferWidth,a.drawingBufferHeight];d="fillOutlinePattern"===u&&c?Ar(b,w,e,o,t):Lr(b,w,t);}else _=m.indexBuffer,p=m.segments,d=c?Dr(b,w,e,o):Ir(b,w);e.uploadCommonUniforms(e.context,x,f.toUnwrapped()),x.draw(e,h,r,e.stencilModeForClipping(f),s,Ft.disabled,d,i.id,m.layoutVertexBuffer,_,p,i.paint,e.transform.zoom,g,void 0);}}function as(t,i,o,r,s,n,a,l){o.resetLayerRenderingStats(t);const c=t.context,h=c.gl,u=t.transform,d=o.paint.get("fill-extrusion-pattern"),_=d.constantOr(1),p=o.paint.get("fill-extrusion-opacity"),f=t.style.enable3dLights(),m=o.paint.get(f&&!_?"fill-extrusion-ambient-occlusion-wall-radius":"fill-extrusion-ambient-occlusion-radius"),g=[o.paint.get("fill-extrusion-ambient-occlusion-intensity"),m],v=o.layout.get("fill-extrusion-edge-radius"),x=v>0&&!o.paint.get("fill-extrusion-rounded-roof"),y=x?0:v,b="globe"===u.projection.name?e.cF():0,w="globe"===u.projection.name,T=w?e.S(u.zoom):0,E=[e.a5(u.center.lng),e.ae(u.center.lat)],S=o.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0,3),C=o.paint.get("fill-extrusion-flood-light-intensity"),I=o.paint.get("fill-extrusion-vertical-scale"),D=vo(t,o.paint.get("fill-extrusion-cutoff-fade-range")),L=o.paint.get("fill-extrusion-emissive-strength"),A=[];let R;w&&A.push("PROJECTION_GLOBE_VIEW"),g[0]>0&&A.push("FAUX_AO"),x&&A.push("ZERO_ROOF_RADIUS"),l&&A.push("HAS_CENTROID"),C>0&&A.push("FLOOD_LIGHT"),D.shouldRenderCutoff&&A.push("RENDER_CUTOFF");const P="shadow"===t.renderPass,M=t.shadowRenderer,z=P&&!!M;t.shadowRenderer&&(t.shadowRenderer.useNormalOffset=!0);let O=[0,0,0];if(M){const e=t.style.directionalLight,i=t.style.ambientLight;e&&i&&(O=So(e,i)),R=A.concat(["SHADOWS_SINGLE_CASCADE"]);}const F=z?"fillExtrusionDepth":_?"fillExtrusionPattern":"fillExtrusion",B=o.getLayerRenderingStats();for(const e of r){const r=i.getTile(e),f=r.getBucket(o);if(!f||f.projection.name!==u.projection.name)continue;let m=!1;M&&(m=0===M.getMaxCascadeForTile(e.toUnwrapped()));const v=t.isTileAffectedByFog(e),x=f.programConfigurations.get(o.id),z=t.getOrCreateProgram(F,{config:x,defines:m?R:A,overrideFog:v});if(t.terrain&&t.terrain.setupElevationDraw(r,z,{useMeterToDem:!0}),!f.centroidVertexBuffer){const e=z.attributes.a_centroid_pos;void 0!==e&&h.vertexAttrib2f(e,0,0);}!P&&M&&M.setupShadows(r.tileID.toUnwrapped(),z,"vector-tile",r.tileID.overscaledZ),_&&(t.context.activeTexture.set(h.TEXTURE0),r.imageAtlasTexture&&r.imageAtlasTexture.bind(h.LINEAR,h.CLAMP_TO_EDGE),x.updatePaintBuffers());const k=d.constantOr(null);if(k&&r.imageAtlas){const e=r.imageAtlas.patternPositions[k.toString()];e&&x.setConstantPatternPositions(e);}const N=o.paint.get("fill-extrusion-vertical-gradient");let U;if(P&&M){if(_s(r.tileID,f,t))continue;const e=M.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());U=Sr(e,y,I);}else {const i=t.translatePosMatrix(e.expandedProjMatrix,r,o.paint.get("fill-extrusion-translate"),o.paint.get("fill-extrusion-translate-anchor")),s=u.projection.createInversionMatrix(u,e.canonical);U=_?Cr(i,t,N,p,g,y,e,r,b,T,E,s,S,I):Er(i,t,N,p,g,y,e,b,T,E,s,S,I,C,O,L);}t.uploadCommonUniforms(c,z,e.toUnwrapped(),null,D);let G=f.segments;if("mercator"===u.projection.name&&!P&&(G=f.getVisibleSegments(r.tileID,t.terrain,t.transform.getFrustum(0)),!G.get().length))continue;if(B)if(P)for(const e of G.get())B.numRenderedVerticesInShadowPass+=e.primitiveLength;else for(const e of G.get())B.numRenderedVerticesInTransparentPass+=e.primitiveLength;const j=[];(t.terrain||l)&&j.push(f.centroidVertexBuffer),w&&j.push(f.layoutVertexExtBuffer),z.draw(t,c.gl.TRIANGLES,s,n,a,Ft.backCCW,U,o.id,f.layoutVertexBuffer,f.indexBuffer,G,o.paint,t.transform.zoom,x,j);}t.shadowRenderer&&(t.shadowRenderer.useNormalOffset=!1);}function ls(t,i,o,r,s,n,a,l,c,h,u,d,_,p,f,m,g,v,x){const y=t.context,b=y.gl,w=t.transform,T=t.transform.zoom,E=[],S=vo(t,o.paint.get("fill-extrusion-cutoff-fade-range"));"clear"===h?(E.push("CLEAR_SUBPASS"),x&&(E.push("CLEAR_FROM_TEXTURE"),y.activeTexture.set(b.TEXTURE0),x.bind(b.LINEAR,b.CLAMP_TO_EDGE))):"sdf"===h&&E.push("SDF_SUBPASS"),g&&E.push("HAS_CENTROID"),S.shouldRenderCutoff&&E.push("RENDER_CUTOFF");const C=o.layout.get("fill-extrusion-edge-radius"),I=(e,i,r,h,v)=>{const b=i.programConfigurations.get(o.id),w=t.isTileAffectedByFog(e),I=t.getOrCreateProgram("fillExtrusionGroundEffect",{config:b,defines:E,overrideFog:w}),D=((e,t,i,o,r,s,n,a,l,c,h)=>({u_matrix:t,u_opacity:i,u_ao_pass:o?1:0,u_meter_to_tile:r,u_ao:s,u_flood_light_intensity:n,u_flood_light_color:a,u_attenuation:l,u_edge_radius:c,u_fb:0,u_fb_size:h}))(0,h,u,c,v,[d,_*v],p,f,m,T>=17?0:C*v,x?x.size[0]:0),L=[];g&&L.push(i.hiddenByLandmarkVertexBuffer),t.uploadCommonUniforms(y,I,e.toUnwrapped(),null,S),I.draw(t,y.gl.TRIANGLES,s,n,a,l,D,o.id,i.vertexBuffer,i.indexBuffer,r,o.paint,T,b,L);};for(const s of r){const r=i.getTile(s),n=r.getBucket(o);if(!n||n.projection.name!==w.projection.name||!n.groundEffect||n.groundEffect&&!n.groundEffect.hasData())continue;const a=n.groundEffect,l=1/n.tileToMeter;{const e=t.translatePosMatrix(s.projMatrix,r,o.paint.get("fill-extrusion-translate"),o.paint.get("fill-extrusion-translate-anchor")),i=a.getDefaultSegment();I(s,a,i,e,l);}if(v)for(let n=0;n<4;n++){const a=e.cG[n](s),c=i.getTile(a);if(!c)continue;const h=c.getBucket(o);if(!h||h.projection.name!==w.projection.name||!h.groundEffect||h.groundEffect&&!h.groundEffect.hasData())continue;const u=h.groundEffect;let d,_;0===n?(d=[-e.V,0,0],_=1):1===n?(d=[e.V,0,0],_=0):2===n?(d=[0,-e.V,0],_=3):(d=[0,e.V,0],_=2);const p=u.regionSegments[_];if(!p)continue;const f=new Float32Array(16);e.a6.translate(f,s.projMatrix,d),I(s,u,p,t.translatePosMatrix(f,r,o.paint.get("fill-extrusion-translate"),o.paint.get("fill-extrusion-translate-anchor")),l);}}}function cs(t,i,o,r,s,n,a){0===r.centroidVertexArray.length&&r.createCentroidsBuffer();const l=n?n.findDEMTileFor(o):null;if(!(l&&l.dem||a))return;const c=t=>new e.P(Math.ceil((t+e.cJ)*e.cK),0),h=e=>{const t=i.getSource().minzoom,o=e=>{const t=i.getTileByID(e);if(t&&t.hasData())return t.getBucket(s)},r=[0,-1,1];for(const i of r){if(e.overscaledZ+i<t)continue;const r=o(e.calculateScaledKey(e.overscaledZ+i));if(r)return r}},u=[0,0,0],d=(t,i)=>(u[0]=Math.min(t.min.y,i.min.y),u[1]=Math.max(t.max.y,i.max.y),u[2]=e.V-i.min.x>t.max.x?i.min.x-e.V:t.max.x,u),_=(t,i)=>(u[0]=Math.min(t.min.x,i.min.x),u[1]=Math.max(t.max.x,i.max.x),u[2]=e.V-i.min.y>t.max.y?i.min.y-e.V:t.max.y,u),p=[(e,t)=>d(e,t),(e,t)=>d(t,e),(e,t)=>_(e,t),(e,t)=>_(t,e)],f=(t,i,r,s,a,c,h)=>{if(!n)return 0;const u=[[c?r:t,c?t:r,0],[c?r:i,c?i:r,0]],d=h<0?e.V+h:h,_=[c?d:(t+i)/2,c?(t+i)/2:d,0];return 0===r&&h<0||0!==r&&h>0?n.getForTilePoints(a,[_],!0,s):u.push(_),n.getForTilePoints(o,u,!0,l),Math.max(u[0][2],u[1][2],_[2])/n.exaggeration()};for(let t=0;t<4;t++){const i=r.borderFeatureIndices[t];if(0===i.length)continue;const s=e.cG[t](o),l=h(s);if(!(l&&l instanceof e.cH))continue;if(r.borderDoneWithNeighborZ[t]===l.canonical.z)continue;0===l.centroidVertexArray.length&&l.createCentroidsBuffer();const u=n?n.findDEMTileFor(s):null;if(!(u&&u.dem||a))continue;const d=(t<2?1:5)-t,_=l.borderDoneWithNeighborZ[d]!==r.canonical.z,v=l.borderFeatureIndices[d];let x=0;if(r.canonical.z!==l.canonical.z){for(const e of i)r.showCentroid(r.featuresOnBorder[e]);if(_)for(const e of v)l.showCentroid(l.featuresOnBorder[e]);r.borderDoneWithNeighborZ[t]=l.canonical.z,l.borderDoneWithNeighborZ[d]=r.canonical.z;}for(const o of i){const i=r.featuresOnBorder[o],n=r.centroidData[i.centroidDataIndex],h=i.borders[t];let _;for(;x<v.length;){_=l.featuresOnBorder[v[x]];const e=_.borders[d];if(e[1]>h[0]+3||e[0]>h[0]-3)break;l.showCentroid(_),x++;}if(_&&x<v.length){const o=x;let y=0;for(;!(_.borders[d][0]>h[1]-3)&&(y++,++x!==v.length);)_=l.featuresOnBorder[v[x]];if(_=l.featuresOnBorder[v[o]],y>1){const e=_.borders[d];Math.abs(h[0]-e[0])<3&&Math.abs(h[1]-e[1])<3&&(y=1,x=o+1);}else if(0===y){r.showCentroid(i);continue}const b=l.centroidData[_.centroidDataIndex];a&&1===y&&(((m=n).flags|(g=b).flags)&e.cI?(m.flags|=e.cI,g.flags|=e.cI):(m.flags&=~e.cI,g.flags&=~e.cI));const w=i.intersectsCount()>1||_.intersectsCount()>1;if(y>1)x=o,n.centroidXY=b.centroidXY=new e.P(0,0);else if(u&&u.dem&&!w){const i=p[t](n,b),o=t%2?e.V-1:0,r=f(i[0],Math.min(e.V-1,i[1]),o,u,s,t<2,i[2]);n.centroidXY=b.centroidXY=c(r);}else w?n.centroidXY=b.centroidXY=new e.P(0,0):(n.centroidXY=r.encodeBorderCentroid(i),b.centroidXY=l.encodeBorderCentroid(_));r.writeCentroidToBuffer(n),l.writeCentroidToBuffer(b);}else r.showCentroid(i);}r.borderDoneWithNeighborZ[t]=l.canonical.z,l.borderDoneWithNeighborZ[d]=r.canonical.z;}var m,g;(r.needsCentroidUpdate||!r.centroidVertexBuffer&&0!==r.centroidVertexArray.length)&&r.uploadCentroid(t);}const hs=[1,0,0],us=[0,1,0],ds=[0,0,1];function _s(t,i,o){const r=o.transform,s=o.shadowRenderer;if(!s)return !0;const n=t.toUnwrapped(),a=r.tileSize*s._cascades[o.currentShadowCascade].scale;let l=i.maxHeight;if(r.elevation){const e=r.elevation.getMinMaxForTile(t);e&&(l+=e.max);}const c=[...s.shadowDirection];c[2]=-c[2];const h=s.computeSimplifiedTileShadowVolume(n,l,a,c);if(!h)return !1;const u=[hs,us,ds,c,[c[0],0,c[2]],[0,c[1],c[2]]],d="globe"===r.projection.name,_=r.scaleZoom(a),p=e.bq.fromInvProjectionMatrix(r.invProjMatrix,r.worldSize,_,!d),f=s.getCurrentCascadeFrustum();return 0===p.intersectsPrecise(h.vertices,h.planes,u)||0===f.intersectsPrecise(h.vertices,h.planes,u)}function ps(t){return [t[0]*e.cL,t[1]*e.cL,t[2]*e.cL,0]}function fs(t,i,o,r,s,n,a,l,c){const h=r.getSource(),u=o.globeSharedBuffers;if(!u)return;let d,_,p;if(i&&(d=r.getTile(i)),h instanceof e.ap?(_=h.texture,p=e.cj(0,0,o.transform)):d&&i&&(_=d.texture,p=e.cj(i.canonical.z,i.canonical.x,o.transform)),!_||!p)return;t||(p=e.a6.scale(e.a6.create(),p,[1,-1,1]));const f=o.context,m=f.gl,g="nearest"===s.paint.get("raster-resampling")?m.NEAREST:m.LINEAR,v=o.colorModeForDrapableLayerRenderPass(n),x=a.defines;x.push("GLOBE_POLES");const y=new Lt(m.LEQUAL,Lt.ReadWrite,o.depthRangeFor3D),b=Float32Array.from(o.transform.expandedFarZProjMatrix),w=Float32Array.from(e.aT(e.ci(new e.bs(0,0,0))));o.terrain&&o.terrain.prepareDrawTile(),f.activeTexture.set(m.TEXTURE0),_.bind(g,m.CLAMP_TO_EDGE),f.activeTexture.set(m.TEXTURE1),_.bind(g,m.CLAMP_TO_EDGE),_.useMipmap&&f.extTextureFilterAnisotropic&&o.transform.pitch>20&&m.texParameterf(m.TEXTURE_2D,f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,f.extTextureFilterAnisotropicMax);const[T,E,S,C]=i?u.getPoleBuffers(i.canonical.z,!1):u.getPoleBuffers(0,!0),I=s.paint.get("raster-elevation");let D;t?(D=T,o.renderDefaultNorthPole=0!==I):(D=E,o.renderDefaultSouthPole=0!==I);const L=ps(a.mix),A=((e,t,i,o,r,s,n,a,l,c,h,u,d)=>Br(e,t,i,new Float32Array(16),new Float32Array(9),[0,0],o,[0,0],[0,0,0,0],1,{opacity:1,mix:0},s,[0,0]||[0,0],a,2,c,h,u,1,0,d))(b,w,p,e.S(o.transform.zoom),0,s,0,I,0,L,a.offset,a.range,n),R=o.getOrCreateProgram("raster",{defines:x});o.uploadCommonUniforms(f,R,null),R.draw(o,m.TRIANGLES,y,c,v,l,A,s.id,D,S,C);}function ms(e){const t=e._nearZ,i=e.projection.farthestPixelDistance(e),o=i-t,r=.2*e.height,s=t+r;return [t,i,(s-r-t)/o,(s-t)/o]}function gs(e,t,i,o){if(e)return t instanceof ze&&e instanceof $t?t.getTextureDescriptor(e,i,!0):{texture:e.texture,mix:ps(o.mix),offset:o.offset,buffer:0,tileSize:1}}function vs(t,i,o){if(!t)return null;const r=i.getTextureDescriptor(t,o,!0);if(!r)return null;let{texture:s,mix:n,offset:a,tileSize:l,buffer:c,format:h}=r;if(!s||!h)return null;let u=!1;return "uint32"===h&&(u=!0,n[3]=0,n=Or(e.cM,n,[0,o.paint.get("raster-particle-max-speed")]),a=Fr(e.cM,a,[0,o.paint.get("raster-particle-max-speed")])),{texture:s,textureOffset:[c/(l+2*c),l/(l+2*c)],tileSize:l,scalarData:u,scale:n,offset:a,defines:["RASTER_ARRAY",{uint8:"DATA_FORMAT_UINT8",uint16:"DATA_FORMAT_UINT16",uint32:"DATA_FORMAT_UINT32"}[h]]}}function xs(e){const t=e._nearZ,i=e.projection.farthestPixelDistance(e),o=i-t,r=.2*e.height,s=t+r;return [t,i,(s-r-t)/o,(s-t)/o]}const ys=new e.ax(1,0,0,1),bs=new e.ax(0,1,0,1),ws=new e.ax(0,0,1,1),Ts=new e.ax(1,0,1,1),Es=new e.ax(0,1,1,1);function Ss(t,i,o,r,s,n,a){const l=t.context,c=t.transform,h=l.gl,u="globe"===c.projection.name,d=u?["PROJECTION_GLOBE_VIEW"]:[];let _=e.a6.clone(o.projMatrix);if(u&&e.S(c.zoom)>0){const t=e.aS(o.canonical,c),i=e.cN(t);_=e.a6.multiply(new Float32Array(16),c.globeMatrix,i),e.a6.multiply(_,c.projMatrix,_);}const p=e.a6.create();p[12]+=2*s/(e.f.devicePixelRatio*c.width),p[13]+=2*n/(e.f.devicePixelRatio*c.height),e.a6.multiply(_,p,_);const f=t.getOrCreateProgram("debug",{defines:d}),m=i.getTileByID(o.key);t.terrain&&t.terrain.setupElevationDraw(m,f);const g=Lt.disabled,v=Rt.disabled,x=t.colorModeForRenderPass(),y="$debug";l.activeTexture.set(h.TEXTURE0),t.emptyTexture.bind(h.LINEAR,h.CLAMP_TO_EDGE),u?m._makeGlobeTileDebugBuffers(t.context,c):m._makeDebugTileBoundsBuffers(t.context,c.projection);const b=m._tileDebugBuffer||t.debugBuffer,w=m._tileDebugIndexBuffer||t.debugIndexBuffer,T=m._tileDebugSegments||t.debugSegments;if(f.draw(t,h.LINE_STRIP,g,v,x,Ft.disabled,Pr(_,r),y,b,w,T,null,null,null,[m._globeTileDebugBorderBuffer]),a){const e=m.latestRawTileData,i=Math.floor((e&&e.byteLength||0)/1024);let r=o.canonical.toString();o.overscaledZ!==o.canonical.z&&(r+=` => ${o.overscaledZ}`),r+=` ${m.state}`,r+=` ${i}kb`,function(e,t){e.initDebugOverlayCanvas();const i=e.debugOverlayCanvas,o=e.context.gl,r=e.debugOverlayCanvas.getContext("2d");r.clearRect(0,0,i.width,i.height),r.shadowColor="white",r.shadowBlur=2,r.lineWidth=1.5,r.strokeStyle="white",r.textBaseline="top",r.font="bold 36px Open Sans, sans-serif",r.fillText(t,5,5),r.strokeText(t,5,5),e.debugOverlayTexture.update(i),e.debugOverlayTexture.bind(o.LINEAR,o.CLAMP_TO_EDGE);}(t,r);}const E=i.getTile(o).tileSize,S=512/Math.min(E,512)*(o.overscaledZ/c.zoom)*.5,C=m._tileDebugTextBuffer||t.debugBuffer,I=m._tileDebugTextIndexBuffer||t.quadTriangleIndexBuffer,D=m._tileDebugTextSegments||t.debugSegments;f.draw(t,h.TRIANGLES,g,v,Mt.alphaBlended,Ft.disabled,Pr(_,e.ax.transparent,S),y,C,I,D,null,null,null,[m._globeTileDebugTextBuffer]);}function Cs(e,t,i,o){Ds(e,0,t+i/2,e.transform.width,i,o);}function Is(e,t,i,o){Ds(e,t-i/2,0,i,e.transform.height,o);}function Ds(t,i,o,r,s,n){const a=t.context,l=a.gl;l.enable(l.SCISSOR_TEST),l.scissor(i*e.f.devicePixelRatio,o*e.f.devicePixelRatio,r*e.f.devicePixelRatio,s*e.f.devicePixelRatio),a.clear({color:n}),l.disable(l.SCISSOR_TEST);}const Ls=e.ay([{name:"a_pos_3f",components:3,type:"Float32"}]),{members:As}=Ls;function Rs(e,t,i,o){e.emplaceBack(t,i,o);}class Ps{constructor(t){this.vertexArray=new e.az,this.indices=new e.aw,Rs(this.vertexArray,-1,-1,1),Rs(this.vertexArray,1,-1,1),Rs(this.vertexArray,-1,1,1),Rs(this.vertexArray,1,1,1),Rs(this.vertexArray,-1,-1,-1),Rs(this.vertexArray,1,-1,-1),Rs(this.vertexArray,-1,1,-1),Rs(this.vertexArray,1,1,-1),this.indices.emplaceBack(5,1,3),this.indices.emplaceBack(3,7,5),this.indices.emplaceBack(6,2,0),this.indices.emplaceBack(0,4,6),this.indices.emplaceBack(2,6,7),this.indices.emplaceBack(7,3,2),this.indices.emplaceBack(5,4,0),this.indices.emplaceBack(0,1,5),this.indices.emplaceBack(0,2,3),this.indices.emplaceBack(3,1,0),this.indices.emplaceBack(7,6,4),this.indices.emplaceBack(4,5,7),this.vertexBuffer=t.createVertexBuffer(this.vertexArray,As),this.indexBuffer=t.createIndexBuffer(this.indices),this.segment=e.aB.simpleSegment(0,0,36,12);}}function Ms(t,i,o,r,s,n){const a=t.context.gl,l=i.paint.get("sky-atmosphere-color"),c=i.paint.get("sky-atmosphere-halo-color"),h=i.paint.get("sky-atmosphere-sun-intensity"),u=((e,t,i,o,r)=>({u_matrix_3f:e,u_sun_direction:t,u_sun_intensity:i,u_color_tint_r:[o.r,o.g,o.b,o.a],u_color_tint_m:[r.r,r.g,r.b,r.a],u_luminance:5e-5}))(e.co.fromMat4(e.co.create(),r),s,h,l,c);a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+n,i.skyboxTexture,0),o.draw(t,a.TRIANGLES,Lt.disabled,Rt.disabled,Mt.unblended,Ft.frontCW,u,"skyboxCapture",i.skyboxGeometry.vertexBuffer,i.skyboxGeometry.indexBuffer,i.skyboxGeometry.segment);}const zs=e.ay([{type:"Float32",name:"a_pos",components:3},{type:"Float32",name:"a_uv",components:2}]);class Os{constructor(t){const i=new e.cO;i.emplaceBack(-1,1,1,0,0),i.emplaceBack(1,1,1,1,0),i.emplaceBack(1,-1,1,1,1),i.emplaceBack(-1,-1,1,0,1);const o=new e.aw;o.emplaceBack(0,1,2),o.emplaceBack(2,3,0),this.vertexBuffer=t.createVertexBuffer(i,zs.members),this.indexBuffer=t.createIndexBuffer(o),this.segments=e.aB.simpleSegment(0,0,4,2);}destroy(){this.vertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy();}}const Fs=e.ay([{type:"Float32",name:"a_pos_3f",components:3},{type:"Float32",name:"a_uv",components:2},{type:"Float32",name:"a_size_scale",components:1},{type:"Float32",name:"a_fade_opacity",components:1}]);class Bs{constructor(){this.starsCount=16e3,this.sizeMultiplier=.15,this.sizeRange=100,this.intensityRange=200;}}class ks{constructor(t){this.colorModeAlphaBlendedWriteRGB=new Mt([1,Pt,1,Pt],e.ax.transparent,[!0,!0,!0,!1]),this.colorModeWriteAlpha=new Mt([1,0,1,0],e.ax.transparent,[!1,!1,!1,!0]),this.params=new Bs,this.updateNeeded=!0,t.tp.registerParameter(this.params,["Stars"],"starsCount",{min:100,max:16e3,step:1},(()=>{this.updateNeeded=!0;})),t.tp.registerParameter(this.params,["Stars"],"sizeMultiplier",{min:.01,max:2,step:.01}),t.tp.registerParameter(this.params,["Stars"],"sizeRange",{min:0,max:200,step:1},(()=>{this.updateNeeded=!0;})),t.tp.registerParameter(this.params,["Stars"],"intensityRange",{min:0,max:200,step:1},(()=>{this.updateNeeded=!0;}));}update(t){const i=t.context;if(!this.atmosphereBuffer||this.updateNeeded){this.updateNeeded=!1,this.atmosphereBuffer=new Os(i);const t=this.params.sizeRange,o=this.params.intensityRange,r=function(t){const i=e.aA(30),o=[];for(let r=0;r<t;++r){const t=2*Math.PI*i(),r=Math.acos(1-2*i())-.5*Math.PI;o.push(e.N.fromValues(Math.cos(r)*Math.cos(t),Math.cos(r)*Math.sin(t),Math.sin(r)));}return o}(this.params.starsCount),s=e.aA(300),n=new e.cP,a=new e.aw;let l=0;for(let i=0;i<r.length;++i){const c=e.N.scale([],r[i],200),h=Math.max(0,1+.01*t*(1*s()-.5)),u=Math.max(0,1+.01*o*(1*s()-.5));n.emplaceBack(c[0],c[1],c[2],-1,-1,h,u),n.emplaceBack(c[0],c[1],c[2],1,-1,h,u),n.emplaceBack(c[0],c[1],c[2],1,1,h,u),n.emplaceBack(c[0],c[1],c[2],-1,1,h,u),a.emplaceBack(l+0,l+1,l+2),a.emplaceBack(l+0,l+2,l+3),l+=4;}this.starsVx=i.createVertexBuffer(n,Fs.members),this.starsIdx=i.createIndexBuffer(a),this.starsSegments=e.aB.simpleSegment(0,0,n.length,a.length);}}destroy(){this.atmosphereBuffer&&this.atmosphereBuffer.destroy(),this.starsVx&&this.starsVx.destroy(),this.starsIdx&&this.starsIdx.destroy();}drawAtmosphereGlow(t,i){const o=t.context,r=o.gl,s=t.transform,n=new Lt(r.LEQUAL,Lt.ReadOnly,[0,1]),a=e.S(s.zoom),l=i.properties.get("color").toArray01(),c=i.properties.get("high-color").toArray01(),h=i.properties.get("space-color").toArray01PremultipliedAlpha(),u=5e-4,d=e.cQ(i.properties.get("horizon-blend"),0,1,u,.25),_=e.cd(t,o,s)&&d===u?s.worldSize/(2*Math.PI*1.025)-1:s.globeRadius,p=t.frameCounter/1e3%1,f=e.N.length(s.globeCenterInViewSpace),m=Math.sqrt(Math.pow(f,2)-Math.pow(_,2)),g=Math.acos(m/f),v=e=>{const i="globe"===s.projection.name?["PROJECTION_GLOBE_VIEW","FOG"]:["FOG"];e&&i.push("ALPHA_PASS");const u=t.getOrCreateProgram("globeAtmosphere",{defines:i}),_=((e,t,i,o,r,s,n,a,l,c,h,u)=>({u_frustum_tl:e,u_frustum_tr:t,u_frustum_br:i,u_frustum_bl:o,u_horizon:r,u_transition:s,u_fadeout_range:n,u_color:a,u_high_color:l,u_space_color:c,u_temporal_offset:h,u_horizon_angle:u}))(s.frustumCorners.TL,s.frustumCorners.TR,s.frustumCorners.BR,s.frustumCorners.BL,s.frustumCorners.horizon,a,d,l,c,h,p,g);t.uploadCommonUniforms(o,u);const f=this.atmosphereBuffer;f&&u.draw(t,r.TRIANGLES,n,Rt.disabled,e?this.colorModeWriteAlpha:this.colorModeAlphaBlendedWriteRGB,Ft.backCW,_,e?"atmosphere_glow_alpha":"atmosphere_glow",f.vertexBuffer,f.indexBuffer,f.segments);};v(!1),v(!0);}drawStars(t,i){const o=e.aa(i.properties.get("star-intensity"),0,1);if(0===o)return;const r=t.context,s=r.gl,n=t.transform,a=t.getOrCreateProgram("stars"),l=e.bi.identity([]);e.bi.rotateX(l,l,-n._pitch),e.bi.rotateZ(l,l,-n.angle),e.bi.rotateX(l,l,e.bj(n._center.lat)),e.bi.rotateY(l,l,-e.bj(n._center.lng));const c=e.a6.fromQuat(new Float32Array(16),l),h=e.a6.multiply([],n.starsProjMatrix,c),u=e.co.fromMat4([],c),d=e.co.invert([],u),_=[0,1,0];e.N.transformMat3(_,_,d),e.N.scale(_,_,this.params.sizeMultiplier);const p=[1,0,0];e.N.transformMat3(p,p,d),e.N.scale(p,p,this.params.sizeMultiplier);const f=(m=_,g=p,v=o,{u_matrix:Float32Array.from(h),u_up:m,u_right:g,u_intensity_multiplier:v});var m,g,v;t.uploadCommonUniforms(r,a),this.starsVx&&this.starsIdx&&a.draw(t,s.TRIANGLES,Lt.disabled,Rt.disabled,this.colorModeAlphaBlendedWriteRGB,Ft.disabled,f,"atmosphere_stars",this.starsVx,this.starsIdx,this.starsSegments);}}function Ns(t,i){const o=[...t],r=i.cameraWorldSizeForFog/i.worldSize,s=e.a6.identity([]);return e.a6.scale(s,s,[r,r,1]),e.a6.multiply(o,s,o),e.a6.multiply(o,i.worldToFogMatrix,o),o}function Us(e,t,i,o){const r=i.material,s=o.context,{baseColorTexture:n,metallicRoughnessTexture:a}=r.pbrMetallicRoughness,{normalTexture:l,occlusionTexture:c,emissionTexture:h}=r;function u(t,i,o){if(t&&(e.push(i),s.activeTexture.set(s.gl.TEXTURE0+o),t.gfxTexture)){const{minFilter:e,magFilter:i,wrapS:o,wrapT:r}=t.sampler;t.gfxTexture.bindExtraParam(e,i,o,r);}}u(n,"HAS_TEXTURE_u_baseColorTexture",go.BaseColor),u(a,"HAS_TEXTURE_u_metallicRoughnessTexture",go.MetallicRoughness),u(l,"HAS_TEXTURE_u_normalTexture",go.Normal),u(c,"HAS_TEXTURE_u_occlusionTexture",go.Occlusion),u(h,"HAS_TEXTURE_u_emissionTexture",go.Emission),i.texcoordBuffer&&(e.push("HAS_ATTRIBUTE_a_uv_2f"),t.push(i.texcoordBuffer)),i.colorBuffer&&(e.push(12===i.colorBuffer.itemSize?"HAS_ATTRIBUTE_a_color_3f":"HAS_ATTRIBUTE_a_color_4f"),t.push(i.colorBuffer)),i.normalBuffer&&(e.push("HAS_ATTRIBUTE_a_normal_3f"),t.push(i.normalBuffer)),i.pbrBuffer&&(e.push("HAS_ATTRIBUTE_a_pbr"),e.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"),t.push(i.pbrBuffer)),"OPAQUE"!==r.alphaMode&&"MASK"!==r.alphaMode||e.push("UNPREMULT_TEXTURE_IN_SHADER"),r.defined||e.push("DIFFUSE_SHADED"),e.push("USE_STANDARD_DERIVATIVES");}function Gs(t,i,o,r,s,n){const a=o.paint.get("model-opacity"),l=i.context,c=new Lt(i.context.gl.LEQUAL,Lt.ReadWrite,i.depthRangeFor3D),h=i.transform,u=t.mesh,d=u.material,_=d.pbrMetallicRoughness,p=i.style.fog;let f;f="pixels"===i.transform.projection.zAxisUnit?[...t.nodeModelMatrix]:e.a6.multiply([],r.zScaleMatrix,t.nodeModelMatrix),e.a6.multiply(f,r.negCameraPosMatrix,f);const m=e.a6.invert([],f);e.a6.transpose(m,m);const g=o.paint.get("model-emissive-strength").constantOr(0),v=$r(new Float32Array(t.worldViewProjection),new Float32Array(f),new Float32Array(m),i,a,_.baseColorFactor,d.emissiveFactor,_.metallicFactor,_.roughnessFactor,d,g,o),x={defines:[]},y=[];Us(x.defines,y,u,i);const b=i.shadowRenderer;b&&(b.useNormalOffset=!1);let w=null;if(p){const e=Ns(t.nodeModelMatrix,i.transform);if(w=new Float32Array(e),"globe"!==h.projection.name){const t=u.aabb.min,i=u.aabb.max,[o,r]=p.getOpacityForBounds(e,t[0],t[1],i[0],i[1]);x.overrideFog=o>=me||r>=me;}}const T=vo(i,o.paint.get("model-cutoff-fade-range"));T.shouldRenderCutoff&&x.defines.push("RENDER_CUTOFF");const E=i.getOrCreateProgram("model",x);i.uploadCommonUniforms(l,E,null,w,T),"shadow"!==i.renderPass&&b&&b.setupShadowsFromMatrix(t.nodeModelMatrix,E),E.draw(i,l.gl.TRIANGLES,c,s,n,u.material.doubleSided?Ft.disabled:Ft.backCCW,v,o.id,u.vertexBuffer,u.indexBuffer,u.segments,o.paint,i.transform.zoom,void 0,y);}function js(t,i,o,r,s,n,a){let l;l="globe"===t.projection.name?e.cS(o,t):[...o],e.a6.multiply(l,l,i.matrix);const c=e.a6.multiply([],r,l);if(i.meshes)for(const t of i.meshes){if("BLEND"!==t.material.alphaMode){a.push({mesh:t,depth:0,modelIndex:s,worldViewProjection:c,nodeModelMatrix:l});continue}const i=e.N.transformMat4([],t.centroid,c);i[2]>0&&n.push({mesh:t,depth:i[2],modelIndex:s,worldViewProjection:c,nodeModelMatrix:l});}if(i.children)for(const e of i.children)js(t,e,o,r,s,n,a);}function Vs(e,t,i,o){const r=i.shadowRenderer;if(!r)return;const s=r.getShadowPassDepthMode(),n=r.getShadowPassColorMode(),a=r.calculateShadowPassMatrixFromMatrix(t),l=Kr(a);i.getOrCreateProgram("modelDepth",{defines:i._shadowMapDebug?[]:["DEPTH_TEXTURE"]}).draw(i,i.context.gl.TRIANGLES,s,Rt.disabled,n,Ft.backCCW,l,o.id,e.vertexBuffer,e.indexBuffer,e.segments,o.paint,i.transform.zoom,void 0,void 0);}function Zs(t,i,o){const r=i.updateZoomBasedPaintProperties(),s=function(t,i,o){let r,s,n,a=t.terrain?t.terrain.exaggeration():0;if(t.terrain&&a>0){const i=t.terrain,s=i.findDEMTileFor(o);s&&s.dem?r=e.cU.create(i,o,s):a=0;}if(0===a&&(i.terrainElevationMin=0,i.terrainElevationMax=0),a===i.validForExaggeration&&(0===a||r&&r._demTile&&r._demTile.tileID===i.validForDEMTile.id&&r._dem._timestamp===i.validForDEMTile.timestamp))return !1;for(const e in i.instancesPerModel){const t=i.instancesPerModel[e];for(let e=0;e<t.instancedDataArray.length;++e){const o=(r?a*r.getElevationAt(0|t.instancedDataArray.float32[16*e],0|t.instancedDataArray.float32[16*e+1],!0,!0):0)+t.instancesEvaluatedElevation[e];t.instancedDataArray.float32[16*e+6]=o,s=s?Math.min(i.terrainElevationMin,o):o,n=n?Math.max(i.terrainElevationMax,o):o;}}return i.terrainElevationMin=s||0,i.terrainElevationMax=n||0,i.validForExaggeration=a,i.validForDEMTile=r&&r._demTile?{id:r._demTile.tileID,timestamp:r._dem._timestamp}:{id:void 0,timestamp:0},!0}(t,i,o);(r||s)&&(i.uploaded=!1,i.upload(t.context));}const Hs={shadowUniformsInitialized:!1,useSingleShadowCascade:!1,tileMatrix:new Float64Array(16),shadowTileMatrix:new Float32Array(16),aabb:new e.bS([0,0,0],[e.V,e.V,0])};function Ws(t,i){const o=1<<t.canonical.z,r=i.getFreeCameraOptions().position,s=i.elevation,n=t.canonical.x/o,a=(t.canonical.x+1)/o,l=t.canonical.y/o,c=(t.canonical.y+1)/o;let h=i._centerAltitude;if(s){const e=s.getMinMaxForTile(t);e&&e.max>h&&(h=e.max);}const u=e.aa(r.x,n,a)-r.x,d=e.aa(r.y,l,c)-r.y,_=e.bl(h,i.center.lat)-r.z;return i._zoomFromMercatorZ(Math.sqrt(u*u+d*d+_*_))}function qs(e,t,i,o,r,s,n){const a=e.context,l="shadow"===e.renderPass,c=e.shadowRenderer,h=l&&c?c.getShadowPassDepthMode():new Lt(a.gl.LEQUAL,Lt.ReadWrite,e.depthRangeFor3D),u=e.isTileAffectedByFog(s);if(i.meshes)for(const d of i.meshes){const _=["MODEL_POSITION_ON_GPU"],p=[];let f,m,g;o.instancedDataArray.length>20&&_.push("INSTANCED_ARRAYS");const v=vo(e,t.paint.get("model-cutoff-fade-range"));if(v.shouldRenderCutoff&&_.push("RENDER_CUTOFF"),l&&c)f=e.getOrCreateProgram("modelDepth",{defines:_}),m=Kr(n.shadowTileMatrix,n.shadowTileMatrix,Float32Array.from(i.matrix)),g=c.getShadowPassColorMode();else {Us(_,p,d,e),f=e.getOrCreateProgram("model",{defines:_,overrideFog:u});const o=d.material,l=o.pbrMetallicRoughness,h=t.paint.get("model-opacity"),x=t.paint.get("model-emissive-strength").constantOr(0);m=$r(s.expandedProjMatrix,Float32Array.from(i.matrix),new Float32Array(16),e,h,l.baseColorFactor,o.emissiveFactor,l.metallicFactor,l.roughnessFactor,o,x,t,r),c&&(n.shadowUniformsInitialized?f.setShadowUniformValues(a,c.getShadowUniformValues()):(c.setupShadows(s.toUnwrapped(),f,"model-tile",s.overscaledZ),n.shadowUniformsInitialized=!0)),g=v.shouldRenderCutoff||h<1||"OPAQUE"!==o.alphaMode?Mt.alphaBlended:Mt.unblended;}e.uploadCommonUniforms(a,f,s.toUnwrapped(),null,v);const x=d.material.doubleSided?Ft.disabled:Ft.backCCW;if(o.instancedDataArray.length>20)p.push(o.instancedDataBuffer),f.draw(e,a.gl.TRIANGLES,h,Rt.disabled,g,x,m,t.id,d.vertexBuffer,d.indexBuffer,d.segments,t.paint,e.transform.zoom,void 0,p,o.instancedDataArray.length);else {const i=l?"u_instance":"u_normal_matrix";for(let r=0;r<o.instancedDataArray.length;++r)m[i]=new Float32Array(o.instancedDataArray.arrayBuffer,64*r,16),f.draw(e,a.gl.TRIANGLES,h,Rt.disabled,g,x,m,t.id,d.vertexBuffer,d.indexBuffer,d.segments,t.paint,e.transform.zoom,void 0,p);}}if(i.children)for(const a of i.children)qs(e,t,a,o,r,s,n);}const $s=[1,-1,1];function Xs(t,i,o,r){if(!o.modelManager)return !0;const s=o.modelManager;if(!o.shadowRenderer)return !0;const n=o.shadowRenderer,a=i.aabb;let l=!0,c=t.maxHeight;if(0===c){let e=0;for(const i in t.instancesPerModel){const t=s.getModel(i,r);t?e=Math.max(e,Math.max(Math.max(t.aabb.max[0],t.aabb.max[1]),t.aabb.max[2])):l=!1;}c=t.maxScale*e*1.41+t.maxVerticalOffset,l&&(t.maxHeight=c);}a.max[2]=c,a.min[2]+=t.terrainElevationMin,a.max[2]+=t.terrainElevationMax,e.N.transformMat4(a.min,a.min,i.tileMatrix),e.N.transformMat4(a.max,a.max,i.tileMatrix);const h=a.intersects(n.getCurrentCascadeFrustum());return 0===o.currentShadowCascade&&(t.isInsideFirstShadowMapFrustum=2===h),0===h}class Ks{}class Ys{constructor(){this._storage=new Map;}getLinesFromTrianglesBuffer(t,i,o){{const e=this._storage.get(i.id);if(e)return e.lastUsedFrameIdx=t,e.buf}const r=o.gl,s=r.getBufferParameter(r.ELEMENT_ARRAY_BUFFER,r.BUFFER_SIZE),n=new ArrayBuffer(s),a=new Int16Array(n);r.getBufferSubData(r.ELEMENT_ARRAY_BUFFER,0,new Int16Array(n));const l=new e.cW;for(let e=0;e<s/2;e+=3){const t=a[e],i=a[e+1],o=a[e+2];l.emplaceBack(t,i),l.emplaceBack(i,o),l.emplaceBack(o,t);}const c=o.bindVertexArrayOES.current,h=new Ks;return h.buf=new je(o,l),h.lastUsedFrameIdx=t,this._storage.set(i.id,h),o.bindVertexArrayOES.set(c),h.buf}update(e){for(const[t,i]of this._storage)e-i.lastUsedFrameIdx>30&&(i.buf.destroy(),this._storage.delete(t));}destroy(){for(const[e,t]of this._storage)t.buf.destroy(),this._storage.delete(e);}}class Js{registerParameter(e,t,i,o,r){}registerButton(e,t,i){}}const Qs={symbol:function(t,i,o,r,s){if("translucent"!==t.renderPass)return;const n=Rt.disabled,a=t.colorModeForRenderPass();o.layout.get("text-variable-anchor")&&function(t,i,o,r,s,n,a){const l=i.transform,c="map"===s,h="map"===n;for(const i of t){const t=r.getTile(i),s=t.getBucket(o);if(!s||!s.text||!s.text.segments.get().length)continue;const n=e.b5(s.textSizeData,l.zoom),u=zi(i,s.getProjection(),l),d=l.calculatePixelsToTileUnitsMatrix(t),_=fi(u,t.tileID.canonical,h,c,l,s.getProjection(),d),p=s.hasIconTextFit()&&s.hasIconData();if(n){const o=Math.pow(2,l.zoom-t.tileID.overscaledZ);os(s,c,h,a,e.cx,l,_,i,o,n,p);}}}(r,t,o,i,o.layout.get("text-rotation-alignment"),o.layout.get("text-pitch-alignment"),s);const l=0!==o.paint.get("icon-opacity").constantOr(1),c=0!==o.paint.get("text-opacity").constantOr(1);void 0!==o.layout.get("symbol-sort-key").constantOr(1)&&(l||c)?rs(t,i,o,r,n,a):(l&&rs(t,i,o,r,n,a,{onlyIcons:!0}),c&&rs(t,i,o,r,n,a,{onlyText:!0})),i.map.showCollisionBoxes&&(Qr(t,i,o,r,o.paint.get("text-translate"),o.paint.get("text-translate-anchor"),!0),Qr(t,i,o,r,o.paint.get("icon-translate"),o.paint.get("icon-translate-anchor"),!1));},circle:function(t,i,o,r){if("translucent"!==t.renderPass)return;const s=o.paint.get("circle-opacity"),n=o.paint.get("circle-stroke-width"),a=o.paint.get("circle-stroke-opacity"),l=void 0!==o.layout.get("circle-sort-key").constantOr(1),c=o.paint.get("circle-emissive-strength");if(0===s.constantOr(1)&&(0===n.constantOr(1)||0===a.constantOr(1)))return;const h=t.context,u=h.gl,d=t.transform,_=t.depthModeForSublayer(0,Lt.ReadOnly),p=Rt.disabled,f=t.colorModeForDrapableLayerRenderPass(c),m="globe"===d.projection.name,g=[e.a5(d.center.lng),e.ae(d.center.lat)],v=[];for(let s=0;s<r.length;s++){const n=r[s],a=i.getTile(n),c=a.getBucket(o);if(!c||c.projection.name!==d.projection.name)continue;const h=c.programConfigurations.get(o.id),u=e.cy(o),_=t.isTileAffectedByFog(n);m&&u.push("PROJECTION_GLOBE_VIEW");const p=t.getOrCreateProgram("circle",{config:h,defines:u,overrideFog:_}),f=c.layoutVertexBuffer,x=c.globeExtVertexBuffer,y=c.indexBuffer,b=d.projection.createInversionMatrix(d,n.canonical),w={programConfiguration:h,program:p,layoutVertexBuffer:f,globeExtVertexBuffer:x,indexBuffer:y,uniformValues:e.cz(t,n,a,b,g,o),tile:a};if(l){const t=c.segments.get();for(const i of t)v.push({segments:new e.aB([i]),sortKey:i.sortKey,state:w});}else v.push({segments:c.segments,sortKey:0,state:w});}l&&v.sort(((e,t)=>e.sortKey-t.sortKey));const x={useDepthForOcclusion:d.depthOcclusionForSymbolsAndCircles};for(const e of v){const{programConfiguration:i,program:r,layoutVertexBuffer:s,globeExtVertexBuffer:n,indexBuffer:a,uniformValues:l,tile:c}=e.state,m=e.segments;t.terrain&&t.terrain.setupElevationDraw(c,r,x),t.uploadCommonUniforms(h,r,c.tileID.toUnwrapped()),r.draw(t,u.TRIANGLES,_,p,f,Ft.disabled,l,o.id,s,a,m,o.paint,d.zoom,i,[n]);}},heatmap:function(t,i,o,r){if(0!==o.paint.get("heatmap-opacity"))if("offscreen"===t.renderPass){const s=t.context,n=s.gl,a=Rt.disabled,l=new Mt([n.ONE,n.ONE,n.ONE,n.ONE],e.ax.transparent,[!0,!0,!0,!0]);!function(e,t,i,o){const r=e.gl,s=t.width*o,n=t.height*o;e.activeTexture.set(r.TEXTURE1),e.viewport.set([0,0,s,n]);let a=i.heatmapFbo;if(!a||a&&(a.width!==s||a.height!==n)){a&&a.destroy();const t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),a=i.heatmapFbo=e.createFramebuffer(s,n,!0,null),function(e,t,i,o,r,s){const n=e.gl;n.texImage2D(n.TEXTURE_2D,0,e.extRenderToTextureHalfFloat?n.RGBA16F:n.RGBA,r,s,0,n.RGBA,e.extRenderToTextureHalfFloat?n.HALF_FLOAT:n.UNSIGNED_BYTE,null),o.colorAttachment.set(i);}(e,0,t,a,s,n);}else r.bindTexture(r.TEXTURE_2D,a.colorAttachment.get()),e.bindFramebuffer.set(a.framebuffer);}(s,t,o,"globe"===t.transform.projection.name?.5:.25),s.clear({color:e.ax.transparent});const c=t.transform,h="globe"===c.projection.name,u=h?["PROJECTION_GLOBE_VIEW"]:[],d=h?Ft.frontCCW:Ft.disabled,_=[e.a5(c.center.lng),e.ae(c.center.lat)];for(let e=0;e<r.length;e++){const p=r[e];if(i.hasRenderableParent(p))continue;const f=i.getTile(p),m=f.getBucket(o);if(!m||m.projection.name!==c.projection.name)continue;const g=t.isTileAffectedByFog(p),v=m.programConfigurations.get(o.id),x=t.getOrCreateProgram("heatmap",{config:v,defines:u,overrideFog:g}),{zoom:y}=t.transform;t.terrain&&t.terrain.setupElevationDraw(f,x),t.uploadCommonUniforms(s,x,p.toUnwrapped());const b=c.projection.createInversionMatrix(c,p.canonical);x.draw(t,n.TRIANGLES,Lt.disabled,a,l,d,zr(t,p,f,b,_,y,o.paint.get("heatmap-intensity")),o.id,m.layoutVertexBuffer,m.indexBuffer,m.segments,o.paint,t.transform.zoom,v,h?[m.globeExtVertexBuffer]:null);}s.viewport.set([0,0,t.width,t.height]);}else "translucent"===t.renderPass&&(t.context.setColorMode(t.colorModeForRenderPass()),function(t,i){const o=t.context,r=o.gl,s=i.heatmapFbo;if(!s)return;o.activeTexture.set(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,s.colorAttachment.get()),o.activeTexture.set(r.TEXTURE1);let n=i.colorRampTexture;n||(n=i.colorRampTexture=new e.T(o,i.colorRamp,r.RGBA)),n.bind(r.LINEAR,r.CLAMP_TO_EDGE),t.getOrCreateProgram("heatmapTexture").draw(t,r.TRIANGLES,Lt.disabled,Rt.disabled,t.colorModeForRenderPass(),Ft.disabled,((e,t,i,o)=>({u_image:0,u_color_ramp:1,u_opacity:t.paint.get("heatmap-opacity")}))(0,i),i.id,t.viewportBuffer,t.quadTriangleIndexBuffer,t.viewportSegments,i.paint,t.transform.zoom);}(t,o));},line:function(t,i,o,r){if("translucent"!==t.renderPass)return;const s=o.paint.get("line-opacity"),n=o.paint.get("line-width");if(0===s.constantOr(1)||0===n.constantOr(1))return;const a=o.paint.get("line-emissive-strength"),l=t.depthModeForSublayer(0,Lt.ReadOnly),c=t.colorModeForDrapableLayerRenderPass(a),h=t.terrain&&t.terrain.renderingToTexture?1:e.f.devicePixelRatio,u=o.paint.get("line-dasharray"),d=u.constantOr(1),_=o.layout.get("line-cap"),p=o.paint.get("line-pattern"),f=p.constantOr(1),m=o.paint.get("line-pattern").constantOr(1),g=1!==o.paint.get("line-opacity").constantOr(1);let v=!m&&g;const x=o.paint.get("line-gradient"),y=f?"linePattern":"line",b=t.context,w=b.gl,T=e.cA(o);t.terrain&&t.terrain.clipOrMaskOverlapStencilType()&&(v=!1);for(const s of r){const r=i.getTile(s);if(f&&!r.patternsLoaded())continue;const n=r.getBucket(o);if(!n)continue;t.prepareDrawTile();const a=n.programConfigurations.get(o.id),m=t.isTileAffectedByFog(s),g=t.getOrCreateProgram(y,{config:a,defines:T,overrideFog:m}),E=p.constantOr(null);if(E&&r.imageAtlas){const e=r.imageAtlas.patternPositions[E.toString()];e&&a.setConstantPatternPositions(e);}const S=u.constantOr(null),C=_.constantOr(null);if(!f&&S&&C&&r.lineAtlas){const e=r.lineAtlas.getDash(S,C);e&&a.setConstantPatternPositions(e);}let[I,D]=o.paint.get("line-trim-offset");if("round"===C||"square"===C){const e=1;I!==D&&(0===I&&(I-=e),1===D&&(D+=e));}const L=t.terrain?s.projMatrix:null,A=f?e.cB(t,r,o,L,h,[I,D]):e.cC(t,r,o,L,n.lineClipsArray.length,h,[I,D]);if(x){const r=n.gradients[o.id];let a=r.texture;if(o.gradientVersion!==r.version){let l=256;if(o.stepInterpolant){const o=i.getSource().maxzoom,r=s.canonical.z===o?Math.ceil(1<<t.transform.maxZoom-s.canonical.z):1;l=e.aa(e.cD(n.maxLineLength/e.V*1024*r),256,b.maxTextureSize);}r.gradient=e.cE({expression:o.gradientExpression(),evaluationKey:"lineProgress",resolution:l,image:r.gradient||void 0,clips:n.lineClipsArray}),r.texture?r.texture.update(r.gradient):r.texture=new e.T(b,r.gradient,w.RGBA),r.version=o.gradientVersion,a=r.texture;}b.activeTexture.set(w.TEXTURE1),a.bind(o.stepInterpolant?w.NEAREST:w.LINEAR,w.CLAMP_TO_EDGE);}d&&(b.activeTexture.set(w.TEXTURE0),r.lineAtlasTexture&&r.lineAtlasTexture.bind(w.LINEAR,w.REPEAT),a.updatePaintBuffers()),f&&(b.activeTexture.set(w.TEXTURE0),r.imageAtlasTexture&&r.imageAtlasTexture.bind(w.LINEAR,w.CLAMP_TO_EDGE),a.updatePaintBuffers()),t.uploadCommonUniforms(b,g,s.toUnwrapped());const R=e=>{g.draw(t,w.TRIANGLES,l,e,c,Ft.disabled,A,o.id,n.layoutVertexBuffer,n.indexBuffer,n.segments,o.paint,t.transform.zoom,a,[n.layoutVertexBuffer2]);};if(v){const e=t.stencilModeForClipping(s).ref;0===e&&t.terrain&&b.clear({stencil:0});const i={func:w.EQUAL,mask:255};A.u_alpha_discard_threshold=.8,R(new Rt(i,e,255,w.KEEP,w.KEEP,w.INVERT)),A.u_alpha_discard_threshold=0,R(new Rt(i,e,255,w.KEEP,w.KEEP,w.KEEP));}else R(t.stencilModeForClipping(s));}v&&(t.resetStencilClippingMasks(),t.terrain&&b.clear({stencil:0}));},fill:function(t,i,o,r){const s=o.paint.get("fill-color"),n=o.paint.get("fill-opacity");if(0===n.constantOr(1))return;const a=o.paint.get("fill-emissive-strength"),l=t.colorModeForDrapableLayerRenderPass(a),c=o.paint.get("fill-pattern"),h=t.opaquePassEnabledForLayer()&&!c.constantOr(1)&&1===s.constantOr(e.ax.transparent).a&&1===n.constantOr(0)?"opaque":"translucent";if(t.renderPass===h){const e=t.depthModeForSublayer(1,"opaque"===t.renderPass?Lt.ReadWrite:Lt.ReadOnly);ns(t,i,o,r,e,l,!1);}if("translucent"===t.renderPass&&o.paint.get("fill-antialias")){const e=t.depthModeForSublayer(o.getPaintProperty("fill-outline-color")?2:0,Lt.ReadOnly);ns(t,i,o,r,e,l,!0);}},"fill-extrusion":function(t,i,o,r){const s=o.paint.get("fill-extrusion-opacity"),n=t.context,a=n.gl,l=t.terrain,c=l&&l.renderingToTexture;if(0===s)return;const h=t.conflationActive&&t.layerUsedInConflation(o,i.getSource());if(h&&function(e,t,i,o){for(const r of o){const o=t.getTile(r).getBucket(i);o&&(o.updateReplacement(r,e.replacementSource),o.uploadCentroid(e.context));}}(t,i,o,r),l||h)for(const e of r){const r=i.getTile(e).getBucket(o);r&&cs(t.context,i,e,r,o,l,h);}if("shadow"===t.renderPass&&t.shadowRenderer){const n=t.shadowRenderer;if(l&&s<.65&&o._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.Z)return;const a=n.getShadowPassDepthMode(),c=n.getShadowPassColorMode();as(t,i,o,r,a,Rt.disabled,c,h);}else if("translucent"===t.renderPass){const u=!o.paint.get("fill-extrusion-pattern").constantOr(1),d=o.paint.get("fill-extrusion-color").constantOr(e.ax.white);if(!c&&0!==d.a){const e=new Lt(t.context.gl.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D);1===s&&u?as(t,i,o,r,e,Rt.disabled,Mt.unblended,h):(as(t,i,o,r,e,Rt.disabled,Mt.disabled,h),as(t,i,o,r,e,t.stencilModeFor3D(),t.colorModeForRenderPass(),h),t.resetStencilClippingMasks());}if(t.style.enable3dLights()&&u&&(!l&&"globe"!==t.transform.projection.name||c)){const s=o.paint.get("fill-extrusion-opacity"),u=o.paint.get("fill-extrusion-ambient-occlusion-intensity"),d=o.paint.get("fill-extrusion-ambient-occlusion-ground-radius"),_=o.paint.get("fill-extrusion-flood-light-intensity"),p=o.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0,3),f=u>0&&d>0,m=_>0,g=(e,t,i)=>(1-i)*e+i*t,v=n=>{const l=t.depthModeForSublayer(1,Lt.ReadOnly,a.LEQUAL,!0),c=o.paint.get(n?"fill-extrusion-ambient-occlusion-ground-attenuation":"fill-extrusion-flood-light-ground-attenuation"),f=g(.1,3,c),m=t._showOverdrawInspector;if(!m){const c=new Rt({func:a.ALWAYS,mask:255},255,255,a.KEEP,a.KEEP,a.REPLACE),m=new Mt([a.ONE,a.ONE,a.ONE,a.ONE],e.ax.transparent,[!1,!1,!1,!0],a.MIN);ls(t,i,o,r,l,c,m,Ft.disabled,n,"sdf",s,u,d,_,p,f,h,!1);}{const c=m?Rt.disabled:new Rt({func:a.EQUAL,mask:255},255,255,a.KEEP,a.DECR,a.DECR),g=m?t.colorModeForRenderPass():new Mt([a.ONE_MINUS_DST_ALPHA,a.DST_ALPHA,a.ONE,a.ONE],e.ax.transparent,[!0,!0,!0,!0]);ls(t,i,o,r,l,c,g,Ft.disabled,n,"color",s,u,d,_,p,f,h,!1);}};if(c){const c=(n,l,c)=>{const f=t.depthModeForSublayer(1,Lt.ReadOnly,a.LEQUAL,!1),m=o.paint.get(n?"fill-extrusion-ambient-occlusion-ground-attenuation":"fill-extrusion-flood-light-ground-attenuation"),v=g(.1,3,m);{const c=new Mt([a.ONE,a.ONE,a.ONE,a.ONE],e.ax.transparent,[!1,!1,!1,!0]);ls(t,i,o,r,f,Rt.disabled,c,Ft.disabled,n,"clear",s,u,d,_,p,v,h,l);}{const c=new Rt({func:a.ALWAYS,mask:255},255,255,a.KEEP,a.KEEP,a.REPLACE),m=new Mt([a.ONE,a.ONE,a.ONE,a.ONE],e.ax.transparent,[!1,!1,!1,!0],a.MIN);ls(t,i,o,r,f,c,m,Ft.disabled,n,"sdf",s,u,d,_,p,v,h,l);}{const c=n?a.ZERO:a.ONE_MINUS_DST_ALPHA,m=new Rt({func:a.EQUAL,mask:255},255,255,a.KEEP,a.DECR,a.DECR),g=new Mt([c,a.DST_ALPHA,a.ONE_MINUS_DST_ALPHA,a.ZERO],e.ax.transparent,[!0,!0,!0,!0]);ls(t,i,o,r,f,m,g,Ft.disabled,n,"color",s,u,d,_,p,v,h,l);}{const m=new Mt([a.ONE,a.ONE,a.ONE,n?a.ZERO:a.ONE],e.ax.transparent,[!1,!1,!1,!0],n?a.FUNC_ADD:a.MAX);ls(t,i,o,r,f,Rt.disabled,m,Ft.disabled,n,"clear",s,u,d,_,p,v,h,l,c);}};if(f||m){let i;if(t.prepareDrawTile(),l){const t=l.drapeBufferSize[0],o=l.drapeBufferSize[1];i=l.framebufferCopyTexture,i&&(!i||i.size[0]===t&&i.size[1]===o)||(i&&i.destroy(),i=l.framebufferCopyTexture=new e.T(n,new e.h({width:t,height:o}),a.RGBA)),i.bind(a.LINEAR,a.CLAMP_TO_EDGE),a.copyTexImage2D(a.TEXTURE_2D,0,a.RGBA,0,0,t,o,0);}f&&c(!0,!1,i),m&&c(!1,!0,i);}}else f&&v(!0),m&&v(!1);}}},hillshade:function(e,t,i,o){if("offscreen"!==e.renderPass&&"translucent"!==e.renderPass)return;if(e.style.disableElevatedTerrain)return;const r=e.context,s=e.terrain&&e.terrain.renderingToTexture,[n,a]="translucent"!==e.renderPass||s?[{},o]:e.stencilConfigForOverlap(o);for(const o of a){const r=t.getTile(o);if(r.needsHillshadePrepare&&"offscreen"===e.renderPass)or(e,r,i);else if("translucent"===e.renderPass){const t=e.depthModeForSublayer(0,Lt.ReadOnly),a=i.paint.get("hillshade-emissive-strength"),l=e.colorModeForDrapableLayerRenderPass(a),c=s&&e.terrain?e.terrain.stencilModeForRTTOverlap(o):n[o.overscaledZ];tr(e,o,r,i,t,c,l);}}r.viewport.set([0,0,e.width,e.height]),e.resetStencilClippingMasks();},raster:function(t,i,o,r,s,n){if("translucent"!==t.renderPass)return;if(0===o.paint.get("raster-opacity"))return;const a="globe"===t.transform.projection.name,l=0!==o.paint.get("raster-elevation"),c=l&&a;if(t.renderElevatedRasterBackface&&!c)return;const h=t.context,u=h.gl,d=i.getSource(),_=function(t,i,o,r){const s=i.paint.get("raster-color"),n="raster-array"===t.type,a=[],l=i.paint.get("raster-resampling"),c=i.paint.get("raster-color-mix");let h=i.paint.get("raster-color-range");const u=[c[0],c[1],c[2],0],d=c[3];let _="nearest"===l?r.NEAREST:r.LINEAR;if(n&&(a.push("RASTER_ARRAY"),s||a.push("RASTER_COLOR"),"linear"===l&&a.push("RASTER_ARRAY_LINEAR"),_=r.NEAREST,!h&&t.rasterLayers)){const e=t.rasterLayers.find((({id:e})=>e===i.sourceLayer));e&&e.fields&&e.fields.range&&(h=e.fields.range);}if(h=h||[0,1],s){a.push("RASTER_COLOR"),o.activeTexture.set(r.TEXTURE2),i.updateColorRamp(h);let t=i.colorRampTexture;t||(t=i.colorRampTexture=new e.T(o,i.colorRamp,r.RGBA)),t.bind(r.LINEAR,r.CLAMP_TO_EDGE);}return {mix:u,range:h,offset:d,defines:a,resampling:_}}(d,o,h,u);if(d instanceof e.ap&&!r.length&&!a)return;const p=o.paint.get("raster-emissive-strength"),f=t.colorModeForDrapableLayerRenderPass(p),m=t.terrain&&t.terrain.renderingToTexture,g=!t.options.moving,v="nearest"===o.paint.get("raster-resampling")?u.NEAREST:u.LINEAR;if(d instanceof e.ap&&!r.length&&(d.onNorthPole||d.onSouthPole)){const e=l?t.stencilModeFor3D():Rt.disabled;return void fs(!!d.onNorthPole,null,t,i,o,p,_,Ft.disabled,e)}if(!r.length)return;const[x,y]=d instanceof e.ap||m?[{},r]:t.stencilConfigForOverlap(r),b=y[y.length-1].overscaledZ;c&&_.defines.push("PROJECTION_GLOBE_VIEW"),l&&_.defines.push("RENDER_CUTOFF");const w=(r,s,y)=>{for(const w of r){const r=w.toUnwrapped(),T=i.getTile(w);if(m&&(!T||!T.hasData()))continue;h.activeTexture.set(u.TEXTURE0);const E=gs(T,d,o,_);if(!E||!E.texture)continue;const{texture:S,mix:C,offset:I,tileSize:D,buffer:L}=E;let A,R;m?(A=Lt.disabled,R=w.projMatrix):l?(A=new Lt(u.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D),R=a?Float32Array.from(t.transform.expandedFarZProjMatrix):t.transform.calculateProjMatrix(r,g)):(A=t.depthModeForSublayer(w.overscaledZ-b,1===o.paint.get("raster-opacity")?Lt.ReadWrite:Lt.ReadOnly,u.LESS),R=t.transform.calculateProjMatrix(r,g));const P=t.terrain&&m?t.terrain.stencilModeForRTTOverlap(w):x[w.overscaledZ],M=n?0:o.paint.get("raster-fade-duration");T.registerFadeDuration(M);const z=i.findLoadedParent(w,0),O=_r(T,z,i,t.transform,M);let F,B;t.terrain&&t.terrain.prepareDrawTile(),h.activeTexture.set(u.TEXTURE0),S.bind(v,u.CLAMP_TO_EDGE),h.activeTexture.set(u.TEXTURE1),z?(z.texture&&z.texture.bind(v,u.CLAMP_TO_EDGE),F=Math.pow(2,z.tileID.overscaledZ-T.tileID.overscaledZ),B=[T.tileID.canonical.x*F%1,T.tileID.canonical.y*F%1]):S.bind(v,u.CLAMP_TO_EDGE),S.useMipmap&&h.extTextureFilterAnisotropic&&t.transform.pitch>20&&u.texParameterf(u.TEXTURE_2D,h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,h.extTextureFilterAnisotropicMax);const k=t.transform;let N;const U=l?ms(k):[0,0,0,0];let G,j,V,Z,H,W=0;if(c&&d instanceof e.ap&&d.coordinates.length>3)G=Float32Array.from(e.aT(e.ci(new e.bs(0,0,0)))),j=Float32Array.from(k.globeMatrix),V=Float32Array.from(e.ce(k)),Z=[e.a5(k.center.lng),e.ae(k.center.lat)],N=d.elevatedGlobePerspectiveTransform,H=d.elevatedGlobeGridMatrix||new Float32Array(9);else if(c){const t=e.cf(w.canonical);W=e.cg(t.getCenter().lat),G=Float32Array.from(e.aT(e.ci(w.canonical))),j=Float32Array.from(k.globeMatrix),V=Float32Array.from(e.ce(k)),Z=[e.a5(k.center.lng),e.ae(k.center.lat)],N=[0,0],H=Float32Array.from(e.ch(w.canonical,t,W,k.worldSize/k._pixelsPerMercatorPixel));}else N=d instanceof e.ap?d.perspectiveTransform:[0,0],G=new Float32Array(16),j=new Float32Array(9),V=new Float32Array(16),Z=[0,0],H=new Float32Array(9);const q=Br(R,G,j,V,H,B||[0,0],e.S(t.transform.zoom),Z,U,F||1,O,o,N,l?o.paint.get("raster-elevation"):0,2,C,I,_.range,D,L,p),$=t.isTileAffectedByFog(w),X=t.getOrCreateProgram("raster",{defines:_.defines,overrideFog:$});if(t.uploadCommonUniforms(h,X,r),d instanceof e.ap){const i=d.elevatedGlobeVertexBuffer,r=d.elevatedGlobeIndexBuffer;if(m||!a)d.boundsBuffer&&d.boundsSegments&&X.draw(t,u.TRIANGLES,A,Rt.disabled,f,Ft.disabled,q,o.id,d.boundsBuffer,t.quadTriangleIndexBuffer,d.boundsSegments);else if(i&&r){const n=k.zoom<=e.bG?d.elevatedGlobeSegments:d.getSegmentsForLongitude(k.center.lng);n&&X.draw(t,u.TRIANGLES,A,Rt.disabled,f,s,q,o.id,i,r,n);}}else if(c){A=new Lt(u.LEQUAL,Lt.ReadOnly,t.depthRangeFor3D);const e=t.globeSharedBuffers;if(e){const[i,r,n]=e.getGridBuffers(W,!1);X.draw(t,u.TRIANGLES,A,y||P,t.colorModeForRenderPass(),s,q,o.id,i,r,n);}}else {const{tileBoundsBuffer:e,tileBoundsIndexBuffer:i,tileBoundsSegments:r}=t.getTileBoundsBuffers(T);X.draw(t,u.TRIANGLES,A,P,f,Ft.disabled,q,o.id,e,i,r);}}if(!(d instanceof e.ap)&&c)for(const e of r){const r=e.canonical.y===(1<<e.canonical.z)-1;0===e.canonical.y&&fs(!0,e,t,i,o,p,_,s,y||Rt.disabled),r&&fs(!1,e,t,i,o,p,_,s===Ft.frontCW?Ft.backCW:Ft.frontCW,y||Rt.disabled);}};c?w(y,t.renderElevatedRasterBackface?Ft.backCW:Ft.frontCW,t.stencilModeFor3D()):w(y,Ft.disabled,void 0),t.resetStencilClippingMasks();},"raster-particle":function(t,i,o,r,s,n){"offscreen"===t.renderPass&&function(t,i,o,r){if(!r.length)return;const s=t.context,n=s.gl,a=i.getSource();if(!(a instanceof ze))return;const l=[];for(const e of r){const t=i.getTile(e);if(!(t instanceof $t))continue;const r=vs(t,a,o);if(!r)continue;const n=[r.tileSize,r.tileSize];let c=o.tileFramebuffer;c||(c=o.tileFramebuffer=s.createFramebuffer(n[0],n[1],!0,null));let h=t.rasterParticleState;const u=o.paint.get("raster-particle-count");h||(h=t.rasterParticleState=new Nt(s,e,n,u));const d=h.update(o.lastInvalidatedAt);h.numParticles!==u&&h.setNumParticles(e,u);const _=h.targetColorTexture;h.targetColorTexture=h.backgroundColorTexture,h.backgroundColorTexture=_;const p=h.particleVertices0;h.particleVertices0=h.particleVertices1,h.particleVertices1=p,l.push([e,r,h,d]);}if(0===l.length)return;const c=e.f.now(),h=o.previousDrawTimestamp?.001*(c-o.previousDrawTimestamp):.0167;if(o.previousDrawTimestamp=c,o.hasColorMap()){s.activeTexture.set(n.TEXTURE0+2);let t=o.colorRampTexture;t||(t=o.colorRampTexture=new e.T(s,o.colorRamp,n.RGBA)),t.bind(n.LINEAR,n.CLAMP_TO_EDGE);}s.bindFramebuffer.set(o.tileFramebuffer.framebuffer),s.activeTexture.set(n.TEXTURE0),function(t,i,o){const r=t.context,s=r.gl,n=i.tileFramebuffer;r.activeTexture.set(s.TEXTURE0);const a={u_texture:0,u_opacity:1.05*(c=i.paint.get("raster-particle-fade-opacity-factor"))/(c+.05)},l=t.getOrCreateProgram("rasterParticleTexture",{defines:[],overrideFog:!1});var c;for(const c of o){const[,,o,h]=c;n.colorAttachment.set(o.targetColorTexture.texture),r.viewport.set([0,0,n.width,n.height]),r.clear({color:e.ax.transparent}),h&&(o.backgroundColorTexture.bind(s.NEAREST,s.CLAMP_TO_EDGE),l.draw(t,s.TRIANGLES,Lt.disabled,Rt.disabled,Mt.alphaBlended,Ft.disabled,a,i.id,t.viewportBuffer,t.quadTriangleIndexBuffer,t.viewportSegments));}}(t,o,l),function(t,i,o,r){const s=t.context.gl,n=o.tileFramebuffer,a="globe"===t.transform.projection.name,l=o.paint.get("raster-particle-max-speed");for(const c of r){const[r,h,u]=c;h.texture.bind(s.LINEAR,s.CLAMP_TO_EDGE),n.colorAttachment.set(u.targetColorTexture.texture);const d=t.getOrCreateProgram("rasterParticleDraw",{defines:h.defines,overrideFog:!1}),_=h.scalarData?[]:[0,1,2,3].map((t=>e.cG[t](r)));_.push(r);const p=r.canonical.x,f=r.canonical.y;for(const e of _){const n=i.getTile(a?e.wrapped():e);if(!n)continue;const c=n.rasterParticleState;if(!c)continue;const u=Ur([e.canonical.x+(1<<e.canonical.z)*(e.wrap-r.wrap)-p,e.canonical.y-f],0,h.texture.size,2,l,h.textureOffset,h.scale,h.offset);d.draw(t,s.POINTS,Lt.disabled,Rt.disabled,Mt.alphaBlended,Ft.disabled,u,o.id,c.particleVertices0,void 0,c.particleSegment);}}}(t,i,o,l),function(e,t,i,o){const r=e.context.gl;let s=t.transformFeedbackObject;s||(s=t.transformFeedbackObject=r.createTransformFeedback()),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,t.transformFeedbackObject);const n=t.paint.get("raster-particle-max-speed"),a=o*t.paint.get("raster-particle-speed-factor")*.3,l=(c=t.paint.get("raster-particle-reset-rate-factor"),Math.pow(c,6));var c;for(const o of i){const[,i,s]=o;i.texture.bind(r.LINEAR,r.CLAMP_TO_EDGE);const c=Gr(0,i.texture.size,n,a,l,i.textureOffset,i.scale,i.offset);e.getOrCreateProgram("rasterParticleUpdate",{defines:i.defines,transformFeedback:{bufferMode:r.SEPARATE_ATTRIBS,shaderVaryings:["v_new_particle"]}}).draw(e,r.POINTS,Lt.disabled,Rt.disabled,Mt.disabled,Ft.disabled,c,t.id,s.particleVertices0,void 0,s.particleSegment,{},void 0,void 0,void 0,void 0,[{buffer:s.particleVertices1,targetIndex:0}]);}r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,null);}(t,o,l,h);}(t,i,o,r),"translucent"===t.renderPass&&(function(t,i,o,r,s){const n=t.context,a=n.gl,l=!t.options.moving,c="globe"===t.transform.projection.name;if(!r.length)return;const[h,u]=t.stencilConfigForOverlap(r),d=[];c&&d.push("PROJECTION_GLOBE_VIEW");for(const r of u){const s=r.toUnwrapped(),u=i.getTile(r);if(!u.rasterParticleState)continue;const _=u.rasterParticleState,p=100;u.registerFadeDuration(p);const f=i.findLoadedParent(r,0),m=_r(u,f,i,t.transform,p);let g,v;t.terrain&&t.terrain.prepareDrawTile(),n.activeTexture.set(a.TEXTURE0),_.targetColorTexture.bind(a.LINEAR,a.CLAMP_TO_EDGE),n.activeTexture.set(a.TEXTURE1),f&&f.rasterParticleState?(f.rasterParticleState.targetColorTexture.bind(a.LINEAR,a.CLAMP_TO_EDGE),g=Math.pow(2,f.tileID.overscaledZ-u.tileID.overscaledZ),v=[u.tileID.canonical.x*g%1,u.tileID.canonical.y*g%1]):_.targetColorTexture.bind(a.LINEAR,a.CLAMP_TO_EDGE);const x=c?Float32Array.from(t.transform.expandedFarZProjMatrix):t.transform.calculateProjMatrix(s,l),y=t.transform,b=xs(y),w=e.cf(r.canonical),T=e.cg(w.getCenter().lat);let E,S,C,I,D;c?(E=Float32Array.from(e.aT(e.ci(r.canonical))),S=Float32Array.from(y.globeMatrix),C=Float32Array.from(e.ce(y)),I=[e.a5(y.center.lng),e.ae(y.center.lat)],D=Float32Array.from(e.ch(r.canonical,w,T,y.worldSize/y._pixelsPerMercatorPixel))):(E=new Float32Array(16),S=new Float32Array(9),C=new Float32Array(16),I=[0,0],D=new Float32Array(9));const L=Nr(x,E,S,C,D,v||[0,0],e.S(t.transform.zoom),I,b,g||1,m,250),A=t.isTileAffectedByFog(r),R=t.getOrCreateProgram("rasterParticle",{defines:d,overrideFog:A});if(t.uploadCommonUniforms(n,R,s),c){const e=new Lt(a.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D),i=0,r=t.globeSharedBuffers;if(r){const[s,n,l]=r.getGridBuffers(T,0!==i);R.draw(t,a.TRIANGLES,e,Rt.disabled,Mt.alphaBlended,Ft.backCCW,L,o.id,s,n,l);}}else {const e=t.depthModeForSublayer(0,Lt.ReadOnly),i=h[r.overscaledZ],{tileBoundsBuffer:s,tileBoundsIndexBuffer:n,tileBoundsSegments:l}=t.getTileBoundsBuffers(u);R.draw(t,a.TRIANGLES,e,i,Mt.alphaBlended,Ft.disabled,L,o.id,s,n,l);}}t.resetStencilClippingMasks();}(t,i,o,r),t.style.map.triggerRepaint());},background:function(e,t,i,o){const r=i.paint.get("background-color"),s=i.paint.get("background-opacity"),n=i.paint.get("background-emissive-strength");if(0===s)return;const a=e.context,l=a.gl,c=e.transform,h=c.tileSize,u=i.paint.get("background-pattern");if(e.isPatternMissing(u,i.scope))return;const d=!u&&1===r.a&&1===s&&e.opaquePassEnabledForLayer()?"opaque":"translucent";if(e.renderPass!==d)return;const _=Rt.disabled,p=e.depthModeForSublayer(0,"opaque"===d?Lt.ReadWrite:Lt.ReadOnly),f=e.colorModeForDrapableLayerRenderPass(n),m=u?"backgroundPattern":"background";let g,v=o;v||(g=e.getBackgroundTiles(),v=Object.values(g).map((e=>e.tileID))),u&&(a.activeTexture.set(l.TEXTURE0),e.imageManager.bind(e.context,i.scope));for(const d of v){const v=e.isTileAffectedByFog(d),x=e.getOrCreateProgram(m,{overrideFog:v}),y=d.toUnwrapped(),b=o?d.projMatrix:e.transform.calculateProjMatrix(y);e.prepareDrawTile();const w=t?t.getTile(d):g?g[d.key]:new Gt(d,h,c.zoom,e),T=u?qr(b,n,s,e,u,i.scope,{tileID:d,tileSize:h}):Wr(b,n,s,r);e.uploadCommonUniforms(a,x,y);const{tileBoundsBuffer:E,tileBoundsIndexBuffer:S,tileBoundsSegments:C}=e.getTileBoundsBuffers(w);x.draw(e,l.TRIANGLES,p,_,f,Ft.disabled,T,i.id,E,S,C);}},sky:function(t,i,o){const r=t._atmosphere?e.S(t.transform.zoom):1,s=o.paint.get("sky-opacity")*r;if(0===s)return;const n=t.context,a=o.paint.get("sky-type"),l=new Lt(n.gl.LEQUAL,Lt.ReadOnly,[0,1]),c=t.frameCounter/1e3%1;"atmosphere"===a?"offscreen"===t.renderPass?o.needsSkyboxCapture(t)&&(function(t,i,o,r){const s=t.context,n=s.gl;let a=i.skyboxFbo;if(!a){a=i.skyboxFbo=s.createFramebuffer(32,32,!0,null),i.skyboxGeometry=new Ps(s),i.skyboxTexture=s.gl.createTexture(),n.bindTexture(n.TEXTURE_CUBE_MAP,i.skyboxTexture),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR);for(let e=0;e<6;++e)n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,n.RGBA,32,32,0,n.RGBA,n.UNSIGNED_BYTE,null);}s.bindFramebuffer.set(a.framebuffer),s.viewport.set([0,0,32,32]);const l=i.getCenter(t,!0),c=t.getOrCreateProgram("skyboxCapture"),h=new Float64Array(16);e.a6.identity(h),e.a6.rotateY(h,h,.5*-Math.PI),Ms(t,i,c,h,l,0),e.a6.identity(h),e.a6.rotateY(h,h,.5*Math.PI),Ms(t,i,c,h,l,1),e.a6.identity(h),e.a6.rotateX(h,h,.5*-Math.PI),Ms(t,i,c,h,l,2),e.a6.identity(h),e.a6.rotateX(h,h,.5*Math.PI),Ms(t,i,c,h,l,3),e.a6.identity(h),Ms(t,i,c,h,l,4),e.a6.identity(h),e.a6.rotateY(h,h,Math.PI),Ms(t,i,c,h,l,5),s.viewport.set([0,0,t.width,t.height]);}(t,o),o.markSkyboxValid(t)):"sky"===t.renderPass&&function(e,t,i,o,r){const s=e.context,n=s.gl,a=e.transform,l=e.getOrCreateProgram("skybox");s.activeTexture.set(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,t.skyboxTexture);const c=((e,t,i,o,r)=>({u_matrix:e,u_sun_direction:t,u_cubemap:0,u_opacity:o,u_temporal_offset:r}))(a.skyboxMatrix,t.getCenter(e,!1),0,o,r);e.uploadCommonUniforms(s,l),l.draw(e,n.TRIANGLES,i,Rt.disabled,e.colorModeForRenderPass(),Ft.backCW,c,"skybox",t.skyboxGeometry.vertexBuffer,t.skyboxGeometry.indexBuffer,t.skyboxGeometry.segment);}(t,o,l,s,c):"gradient"===a&&"sky"===t.renderPass&&function(t,i,o,r,s){const n=t.context,a=n.gl,l=t.transform,c=t.getOrCreateProgram("skyboxGradient");i.skyboxGeometry||(i.skyboxGeometry=new Ps(n)),n.activeTexture.set(a.TEXTURE0);let h=i.colorRampTexture;h||(h=i.colorRampTexture=new e.T(n,i.colorRamp,a.RGBA)),h.bind(a.LINEAR,a.CLAMP_TO_EDGE);const u=((t,i,o,r,s)=>({u_matrix:t,u_color_ramp:0,u_center_direction:i,u_radius:e.bj(o),u_opacity:r,u_temporal_offset:s}))(l.skyboxMatrix,i.getCenter(t,!1),i.paint.get("sky-gradient-radius"),r,s);t.uploadCommonUniforms(n,c),c.draw(t,a.TRIANGLES,o,Rt.disabled,t.colorModeForRenderPass(),Ft.backCW,u,"skyboxGradient",i.skyboxGeometry.vertexBuffer,i.skyboxGeometry.indexBuffer,i.skyboxGeometry.segment);}(t,o,l,s,c);},debug:function(t,i,o,r,s,n){for(let a=0;a<o.length;a++)if(s){const s=1,l=.8,c=new e.ax(r.r*l,r.g*l,r.b*l,1);Ss(t,i,o[a],r,-s,-s,n),Ss(t,i,o[a],r,-s,s,n),Ss(t,i,o[a],r,s,s,n),Ss(t,i,o[a],r,s,-s,n),Ss(t,i,o[a],c,0,0,n);}else Ss(t,i,o[a],r,0,0,n);},custom:function(t,i,o,r){const s=t.context,n=o.implementation;if(!t.transform.projection.unsupportedLayers||!t.transform.projection.unsupportedLayers.includes("custom")||t.terrain&&(t.terrain.renderingToTexture||"offscreen"===t.renderPass)&&o.isLayerDraped(i)){if("offscreen"===t.renderPass){const i=n.prerender;if(i){if(t.setCustomLayerDefaults(),s.setColorMode(t.colorModeForRenderPass()),"globe"===t.transform.projection.name){const o=t.transform.pointMerc;i.call(n,s.gl,t.transform.customLayerMatrix(),t.transform.getProjection(),t.transform.globeToMercatorMatrix(),e.S(t.transform.zoom),[o.x,o.y],t.transform.pixelsPerMeterRatio);}else i.call(n,s.gl,t.transform.customLayerMatrix());s.setDirty(),t.setBaseState();}}else if("translucent"===t.renderPass){if(t.terrain&&t.terrain.renderingToTexture){const i=n.renderToTile;if(i){const o=r[0].canonical,a=new e.L(o.x+r[0].wrap*(1<<o.z),o.y,o.z);s.setDepthMode(Lt.disabled),s.setStencilMode(Rt.disabled),s.setColorMode(t.colorModeForRenderPass()),t.setCustomLayerDefaults(),i.call(n,s.gl,a),s.setDirty(),t.setBaseState();}return}t.setCustomLayerDefaults(),s.setColorMode(t.colorModeForRenderPass()),s.setStencilMode(Rt.disabled);const i="3d"===n.renderingMode?new Lt(t.context.gl.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D):t.depthModeForSublayer(0,Lt.ReadOnly);if(s.setDepthMode(i),"globe"===t.transform.projection.name){const i=t.transform.pointMerc;n.render(s.gl,t.transform.customLayerMatrix(),t.transform.getProjection(),t.transform.globeToMercatorMatrix(),e.S(t.transform.zoom),[i.x,i.y],t.transform.pixelsPerMeterRatio);}else n.render(s.gl,t.transform.customLayerMatrix());s.setDirty(),t.setBaseState(),s.bindFramebuffer.set(null);}}else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");},model:function(t,i,o,r){if("opaque"===t.renderPass)return;const s=o.paint.get("model-opacity");if(0===s)return;const n=o.paint.get("model-cast-shadows");if("shadow"===t.renderPass){if(!n)return;if(t.terrain&&s<.65&&o._transitionablePaint._values["model-opacity"].value.expression instanceof e.Z)return}const a=t.shadowRenderer,l=o.paint.get("model-receive-shadows");a&&(a.useNormalOffset=!0,l||(a.enabled=!1));const c=()=>{a&&(a.useNormalOffset=!0,l||(a.enabled=!0));},h=i.getSource();if("light-beam"===t.renderPass&&"batched-model"!==h.type)return;if("vector"===h.type||"geojson"===h.type)return function(t,i,o,r){const s=t.transform;if("mercator"!==s.projection.name)return void e.w(`Drawing 3D models for ${s.projection.name} projection is not yet implemented`);const n=s.getFreeCameraOptions().position;if(!t.modelManager)return;const a=t.modelManager;o.modelManager=a;const l=t.shadowRenderer;if(!o._unevaluatedLayout._values.hasOwnProperty("model-id"))return;const c=o._unevaluatedLayout._values["model-id"],h={...o.layout.get("model-id").parameters};for(const u of r){const r=i.getTile(u).getBucket(o);if(!r||r.projection.name!==s.projection.name)continue;const d=Ws(u,s);h.zoom=d;const _=c.possiblyEvaluate(h);if(Zs(t,r,u),Hs.shadowUniformsInitialized=!1,Hs.useSingleShadowCascade=!!l&&0===l.getMaxCascadeForTile(u.toUnwrapped()),"shadow"===t.renderPass&&l){if(1===t.currentShadowCascade&&r.isInsideFirstShadowMapFrustum)continue;const i=s.calculatePosMatrix(u.toUnwrapped(),s.worldSize);if(Hs.tileMatrix.set(i),Hs.shadowTileMatrix=Float32Array.from(l.calculateShadowPassMatrixFromMatrix(i)),Hs.aabb.min.fill(0),Hs.aabb.max[0]=Hs.aabb.max[1]=e.V,Hs.aabb.max[2]=0,Xs(r,Hs,t,o.scope))continue}const p=1<<u.canonical.z,f=[((n.x-u.wrap)*p-u.canonical.x)*e.V,(n.y*p-u.canonical.y)*e.V,n.z*p*e.V];for(let e in r.instancesPerModel){const i=r.instancesPerModel[e];i.features.length>0&&(e=_.evaluate(i.features[0].feature,{}));const s=a.getModel(e,o.scope);if(s&&s.uploaded)for(const e of s.nodes)qs(t,o,e,i,f,u,Hs);}}}(t,i,o,r),void c();if(!h.loaded())return;if("batched-model"===h.type)return function(t,i,o,r){o.resetLayerRenderingStats(t);const s=t.context,n=t.transform,a=t.style.fog,l=t.shadowRenderer;if("mercator"!==n.projection.name)return void e.w(`Drawing 3D landmark models for ${n.projection.name} projection is not yet implemented`);const c=t.transform.getFreeCameraOptions().position,h=e.N.scale([],[c.x,c.y,c.z],t.transform.worldSize);e.N.negate(h,h);const u=e.a6.identity([]),d=e.cR(n.center.lat,n.zoom),_=e.a6.fromScaling([],[1,1,1/d]);e.a6.translate(u,u,h);const p=o.paint.get("model-opacity"),f=new Lt(s.gl.LEQUAL,Lt.ReadWrite,t.depthRangeFor3D),m=new Lt(s.gl.LEQUAL,Lt.ReadOnly,t.depthRangeFor3D),g=new e.bS([1/0,1/0,1/0],[-1/0,-1/0,-1/0]),v="shadow"===t.renderPass,x=v&&l?l.getCurrentCascadeFrustum():n.getFrustum(n.scaleZoom(n.worldSize)),y=o.getLayerRenderingStats(),b=function(c,h){for(const d of r){const r=i.getTile(d).getBucket(o);if(!r||!r.uploaded)continue;let b=!1;l&&(b=0===l.getMaxCascadeForTile(d.toUnwrapped()));const w=n.calculatePosMatrix(d.toUnwrapped(),n.worldSize),T=r.modelTraits;for(const i of r.getNodesInfo()){if(i.hiddenByReplacement)continue;if(!i.node.meshes)continue;const r=i.evaluatedScale,E=i.node;let S=0;if(t.terrain&&E.elevation&&(S=E.elevation*t.terrain.exaggeration()),r[0]<=1&&r[1]<=1&&r[2]<=1&&0===(()=>{const t=i.getLocalBounds();return g.min=[...t.min],g.max=[...t.max],g.min[2]+=S,g.max[2]+=S,e.N.transformMat4(g.min,g.min,w),e.N.transformMat4(g.max,g.max,w),g})().intersects(x))continue;const C="light-beam"===t.renderPass,I=[...w];e.a6.translate(I,I,[(E.anchor?E.anchor[0]:0)*(r[0]-1),(E.anchor?E.anchor[1]:0)*(r[1]-1),S]),e.N.exactEquals(r,e.cT)||e.a6.scale(I,I,r),e.a6.multiply(I,I,E.matrix);const D=e.a6.multiply([],_,I);e.a6.multiply(D,u,D);const L=e.a6.invert([],D);e.a6.transpose(L,L),e.a6.scale(L,L,$s);const A=e.a6.multiply([],n.expandedFarZProjMatrix,I),R=T&e.cV.HasMapboxMeshFeatures,P=R?0:i.evaluatedRMEA[0][2];for(let e=0;e<E.meshes.length;++e){const r=E.meshes[e],u=e===E.lightMeshIndex;if(u){if(!C&&!t.terrain&&t.shadowRenderer){t.currentLayer<t.firstLightBeamLayer&&(t.firstLightBeamLayer=t.currentLayer);continue}}else if(C)continue;const _={defines:[]},g=[];if(Us(_.defines,g,r,t),R||_.defines.push("DIFFUSE_SHADED"),b&&_.defines.push("SHADOWS_SINGLE_CASCADE"),y&&(v?y.numRenderedVerticesInShadowPass+=r.vertexArray.length:y.numRenderedVerticesInTransparentPass+=r.vertexArray.length),v){Vs(r,I,t,o);continue}let x=null;if(a){const e=Ns(I,t.transform);if(x=new Float32Array(e),"globe"!==n.projection.name){const t=r.aabb.min,i=r.aabb.max,[o,s]=a.getOpacityForBounds(e,t[0],t[1],i[0],i[1]);_.overrideFog=o>=me||s>=me;}}const w=r.material;let T;w.occlusionTexture&&w.occlusionTexture.offsetScale&&(T=w.occlusionTexture.offsetScale,_.defines.push("OCCLUSION_TEXTURE_TRANSFORM")),!v&&l&&(l.useNormalOffset=!!r.normalBuffer);const S=t.getOrCreateProgram("model",_);!v&&l&&l.setupShadowsFromMatrix(I,S,l.useNormalOffset),t.uploadCommonUniforms(s,S,d.toUnwrapped(),x);const M=w.pbrMetallicRoughness;M.metallicFactor=.9,M.roughnessFactor=.5;const z=$r(new Float32Array(A),new Float32Array(D),new Float32Array(L),t,p,M.baseColorFactor,w.emissiveFactor,M.metallicFactor,M.roughnessFactor,w,P,o,[0,0,0],T);S.draw(t,s.gl.TRIANGLES,h&&!u?f:m,Rt.disabled,c?u||p<1||i.hasTranslucentParts?Mt.alphaBlended:Mt.unblended:Mt.disabled,Ft.backCCW,z,o.id,r.vertexBuffer,r.indexBuffer,r.segments,o.paint,t.transform.zoom,void 0,g);}}}};(((function(e,t,i,o){const r=e.terrain?e.terrain.exaggeration():0,s=e.transform.zoom;for(const n of o){const o=t.getTile(n).getBucket(i);o&&(e.conflationActive&&o.updateReplacement(n,e.replacementSource),o.evaluateScale(e,i),e.terrain&&r>0&&o.elevationUpdate(e.terrain,r,n,i.source),o.needsReEvaluation(e,s,i)&&o.evaluate(i));}})))(t,i,o,r),1===p?b(!0,!0):(b(!1,!0),b(!0,!1));}(t,i,o,r),void c();const u=h.getModels(),d=[],_=t.transform.getFreeCameraOptions().position,p=e.N.scale([],[_.x,_.y,_.z],t.transform.worldSize);e.N.negate(p,p);const f=[],m=[];let g=0;for(const i of u){const r=o.paint.get("model-rotation").constantOr(null),s=o.paint.get("model-scale").constantOr(null),n=o.paint.get("model-translation").constantOr(null);i.computeModelMatrix(t,r,s,n,!0,!0,!1);const a=e.a6.identity([]),l=e.cR(i.position.lat,t.transform.zoom),c=e.a6.fromScaling([],[1,1,1/l]);e.a6.translate(a,a,p),d.push({zScaleMatrix:c,negCameraPosMatrix:a});for(const e of i.nodes)js(t.transform,e,i.matrix,t.transform.expandedFarZProjMatrix,g,f,m);g++;}if(f.sort(((e,t)=>t.depth-e.depth)),"shadow"!==t.renderPass){if(1===s)for(const e of m)Gs(e,t,o,d[e.modelIndex],Rt.disabled,t.colorModeForRenderPass());else {for(const e of m)Gs(e,t,o,d[e.modelIndex],Rt.disabled,Mt.disabled);for(const e of m)Gs(e,t,o,d[e.modelIndex],t.stencilModeFor3D(),t.colorModeForRenderPass());t.resetStencilClippingMasks();}for(const e of f)Gs(e,t,o,d[e.modelIndex],Rt.disabled,t.colorModeForRenderPass());c();}else {for(const e of m)Vs(e.mesh,e.nodeModelMatrix,t,o);for(const e of f)Vs(e.mesh,e.nodeModelMatrix,t,o);c();}}},en={model:function(e,t,i){const o=e.scope,r=t.getSource();if(!r.loaded())return;if("vector"===r.type||"geojson"===r.type)return void(i.modelManager&&i.modelManager.upload(i,o));if("batched-model"===r.type)return;const s=r.getModels();for(const e of s)e.upload(i.context);},raster:function(e,t,i){const o=t.getSource();if(!(o instanceof ze&&o.loaded()))return;const r=e.sourceLayer||o.rasterLayerIds&&o.rasterLayerIds[0];if(!r)return;const s=e.paint.get("raster-array-band")||o.getInitialBand(r);if(null==s)return;const n=t.getIds().map((e=>t.getTileByID(e)));for(const e of n)e.updateNeeded(r,s)&&o.prepareTile(e,r,s);},"raster-particle":function(e,t,i){const o=t.getSource();if(!(o instanceof ze&&o.loaded()))return;const r=e.sourceLayer||o.rasterLayerIds&&o.rasterLayerIds[0];if(!r)return;const s=e.paint.get("raster-particle-array-band")||o.getInitialBand(r);if(null==s)return;const n=t.getIds().map((e=>t.getTileByID(e)));for(const e of n)e.updateNeeded(r,s)&&o.prepareTile(e,r,s);}};class tn{constructor(t,i,o,r){this.context=new Bt(t,i),this.transform=o,this._tileTextures={},this.frameCopies=[],this.loadTimeStamps=[],this.tp=r,this._debugParams={showTerrainProxyTiles:!1},r.registerParameter(this._debugParams,["Terrain"],"showTerrainProxyTiles",{},(()=>{this.style.map.triggerRepaint();})),this.setup(),this.numSublayers=Kt.maxUnderzooming+Kt.maxOverzooming+1,this.depthEpsilon=1/Math.pow(2,16),this.deferredRenderGpuTimeQueries=[],this.gpuTimers={},this.frameCounter=0,this._backgroundTiles={},this.conflationActive=!1,this.replacementSource=new e.cX,this.longestCutoffRange=0,this.minCutoffZoom=0,this._fogVisible=!1,this._cachedTileFogOpacities={},this._shadowRenderer=new wo(this),this._wireframeDebugCache=new Ys,this.renderDefaultNorthPole=!0,this.renderDefaultSouthPole=!0;}updateTerrain(e,t){const i=!!e&&!!e.terrain&&this.transform.projection.supportsTerrain;if(!(i||this._terrain&&this._terrain.enabled))return;this._terrain||(this._terrain=new gr(this,e));const o=this._terrain;this.transform.elevation=i?o:null,o.update(e,this.transform,t),this.transform.elevation&&!o.enabled&&(this.transform.elevation=null);}_updateFog(e){const t=e.fog;if(!t||"globe"===this.transform.projection.name||t.getOpacity(this.transform.pitch)<1||t.properties.get("horizon-blend")<.03)return void(this.transform.fogCullDistSq=null);const[i,o]=t.getFovAdjustedRange(this.transform._fov);if(i>o)return void(this.transform.fogCullDistSq=null);const r=i+.78*(o-i);this.transform.fogCullDistSq=r*r;}get terrain(){return this.transform._terrainEnabled()&&this._terrain&&this._terrain.enabled?this._terrain:null}get shadowRenderer(){return this._shadowRenderer&&this._shadowRenderer.enabled?this._shadowRenderer:null}get wireframeDebugCache(){return this._wireframeDebugCache}resize(t,i){if(this.width=t*e.f.devicePixelRatio,this.height=i*e.f.devicePixelRatio,this.context.viewport.set([0,0,this.width,this.height]),this.style)for(const e of this.style.order)this.style._mergedLayers[e].resize();}setup(){const t=this.context,i=new e.aN;i.emplaceBack(0,0),i.emplaceBack(e.V,0),i.emplaceBack(0,e.V),i.emplaceBack(e.V,e.V),this.tileExtentBuffer=t.createVertexBuffer(i,e.aP.members),this.tileExtentSegments=e.aB.simpleSegment(0,0,4,2);const o=new e.aN;o.emplaceBack(0,0),o.emplaceBack(e.V,0),o.emplaceBack(0,e.V),o.emplaceBack(e.V,e.V),this.debugBuffer=t.createVertexBuffer(o,e.aP.members),this.debugSegments=e.aB.simpleSegment(0,0,4,5);const r=new e.aN;r.emplaceBack(-1,-1),r.emplaceBack(1,-1),r.emplaceBack(-1,1),r.emplaceBack(1,1),this.viewportBuffer=t.createVertexBuffer(r,e.aP.members),this.viewportSegments=e.aB.simpleSegment(0,0,4,2);const s=new e.av;s.emplaceBack(0,0,0,0),s.emplaceBack(e.V,0,e.V,0),s.emplaceBack(0,e.V,0,e.V),s.emplaceBack(e.V,e.V,e.V,e.V),this.mercatorBoundsBuffer=t.createVertexBuffer(s,e.aR.members),this.mercatorBoundsSegments=e.aB.simpleSegment(0,0,4,2);const n=new e.aw;n.emplaceBack(0,1,2),n.emplaceBack(2,1,3),this.quadTriangleIndexBuffer=t.createIndexBuffer(n);const a=new e.aO;for(const e of [0,1,3,2,0])a.emplaceBack(e);this.debugIndexBuffer=t.createIndexBuffer(a),this.emptyTexture=new e.T(t,new e.h({width:1,height:1},Uint8Array.of(0,0,0,0)),t.gl.RGBA),this.identityMat=e.a6.create();const l=this.context.gl;this.stencilClearMode=new Rt({func:l.ALWAYS,mask:0},0,255,l.ZERO,l.ZERO,l.ZERO),this.loadTimeStamps.push(performance.now());}getMercatorTileBoundsBuffers(){return {tileBoundsBuffer:this.mercatorBoundsBuffer,tileBoundsIndexBuffer:this.quadTriangleIndexBuffer,tileBoundsSegments:this.mercatorBoundsSegments}}getTileBoundsBuffers(e){return e._makeTileBoundsBuffers(this.context,this.transform.projection),e._tileBoundsBuffer?{tileBoundsBuffer:e._tileBoundsBuffer,tileBoundsIndexBuffer:e._tileBoundsIndexBuffer,tileBoundsSegments:e._tileBoundsSegments}:this.getMercatorTileBoundsBuffers()}clearStencil(){const e=this.context.gl;this.nextStencilID=1,this.currentStencilSource=void 0,this._tileClippingMaskIDs={},this.getOrCreateProgram("clippingMask").draw(this,e.TRIANGLES,Lt.disabled,this.stencilClearMode,Mt.disabled,Ft.disabled,dr(this.identityMat),"$clipping",this.viewportBuffer,this.quadTriangleIndexBuffer,this.viewportSegments);}resetStencilClippingMasks(){this.terrain||(this.currentStencilSource=void 0,this._tileClippingMaskIDs={});}_renderTileClippingMasks(e,t,i){if(!t||this.currentStencilSource===t.id||!e.isTileClipped()||!i||0===i.length)return;if(this._tileClippingMaskIDs&&!this.terrain){let e=!1;for(const t of i)if(void 0===this._tileClippingMaskIDs[t.key]){e=!0;break}if(!e)return}this.currentStencilSource=t.id;const o=this.context,r=o.gl;this.nextStencilID+i.length>256&&this.clearStencil(),o.setColorMode(Mt.disabled),o.setDepthMode(Lt.disabled);const s=this.getOrCreateProgram("clippingMask");this._tileClippingMaskIDs={};for(const e of i){const i=t.getTile(e),o=this._tileClippingMaskIDs[e.key]=this.nextStencilID++,{tileBoundsBuffer:n,tileBoundsIndexBuffer:a,tileBoundsSegments:l}=this.getTileBoundsBuffers(i);s.draw(this,r.TRIANGLES,Lt.disabled,new Rt({func:r.ALWAYS,mask:0},o,255,r.KEEP,r.KEEP,r.REPLACE),Mt.disabled,Ft.disabled,dr(e.projMatrix),"$clipping",n,a,l);}}stencilModeFor3D(){this.currentStencilSource=void 0,this.nextStencilID+1>256&&this.clearStencil();const e=this.nextStencilID++,t=this.context.gl;return new Rt({func:t.NOTEQUAL,mask:255},e,255,t.KEEP,t.KEEP,t.REPLACE)}stencilModeForClipping(e){if(this.terrain)return this.terrain.stencilModeForRTTOverlap(e);const t=this.context.gl;return new Rt({func:t.EQUAL,mask:255},this._tileClippingMaskIDs[e.key],0,t.KEEP,t.KEEP,t.REPLACE)}stencilConfigForOverlap(e){const t=this.context.gl,i=e.sort(((e,t)=>t.overscaledZ-e.overscaledZ)),o=i[i.length-1].overscaledZ,r=i[0].overscaledZ-o+1;if(r>1){this.currentStencilSource=void 0,this.nextStencilID+r>256&&this.clearStencil();const e={};for(let i=0;i<r;i++)e[i+o]=new Rt({func:t.GEQUAL,mask:255},i+this.nextStencilID,255,t.KEEP,t.KEEP,t.REPLACE);return this.nextStencilID+=r,[e,i]}return [{[o]:Rt.disabled},i]}colorModeForRenderPass(){const t=this.context.gl;if(this._showOverdrawInspector){const i=1/8;return new Mt([t.CONSTANT_COLOR,t.ONE,t.CONSTANT_COLOR,t.ONE],new e.ax(i,i,i,0),[!0,!0,!0,!0])}return "opaque"===this.renderPass?Mt.unblended:Mt.alphaBlended}colorModeForDrapableLayerRenderPass(t){const i=this.context.gl;return (()=>this.style&&this.style.enable3dLights()&&this.terrain&&this.terrain.renderingToTexture)()&&"translucent"===this.renderPass?new Mt([i.ONE,i.ONE_MINUS_SRC_ALPHA,i.CONSTANT_ALPHA,i.ONE_MINUS_SRC_ALPHA],new e.ax(0,0,0,void 0===t?0:t),[!0,!0,!0,!0]):this.colorModeForRenderPass()}depthModeForSublayer(e,t,i,o=!1){if(!this.opaquePassEnabledForLayer()&&!o)return Lt.disabled;const r=1-((1+this.currentLayer)*this.numSublayers+e)*this.depthEpsilon;return new Lt(i||this.context.gl.LEQUAL,t,[r,r])}opaquePassEnabledForLayer(){return this.currentLayer<this.opaquePassCutoff}render(t,i){this._wireframeDebugCache.update(this.frameCounter),this.style=t,this.options=i;const o=this.style._mergedLayers,r=this.style.order,s=r.map((e=>o[e])),n=this.style._mergedSourceCaches;this.imageManager=t.imageManager,this.modelManager=t.modelManager,this.symbolFadeChange=t.placement.symbolFadeChange(e.f.now()),this.imageManager.beginFrame();let a=0,l=!1;for(const e in n){const t=n[e];t.used&&(t.prepare(this.context),t.getSource().usedInConflation&&++a);}for(const e of s)e.isHidden(this.transform.zoom)||this.prepareLayer(e);const c={},h={},u={},d={},_={};for(const e in n){const t=n[e];c[e]=t.getVisibleCoordinates(),h[e]=c[e].slice().reverse(),u[e]=t.getVisibleCoordinates(!0).reverse(),d[e]=t.getShadowCasterCoordinates(),_[e]=t.sortCoordinatesByDistance(c[e]);}const p=e=>{const t=this.style.getLayerSourceCache(e);return t&&t.used?t.getSource():null};if(a){const e=[];for(const t of s)this.layerUsedInConflation(t,p(t))&&e.push(t);if(e&&e.length>1){const t=[];for(const i of e){const e=this.style.getLayerSourceCache(i);e&&e.used&&e.getSource().usedInConflation&&t.push({layer:i.fqid,cache:e});}this.replacementSource.setSources(t),l=!0;}}l||this.replacementSource.clear(),this.conflationActive=l,this.minCutoffZoom=0,this.longestCutoffRange=0;for(const e of s){const t=e.cutoffRange();if(this.longestCutoffRange=Math.max(t,this.longestCutoffRange),t>0){const t=p(e);t&&(this.minCutoffZoom=Math.max(t.minzoom,this.minCutoffZoom)),e.minzoom&&(this.minCutoffZoom=Math.max(e.minzoom,this.minCutoffZoom));}}this.opaquePassCutoff=1/0;for(let e=0;e<s.length;e++)if(s[e].is3D()){this.opaquePassCutoff=e;break}const f=this.style&&this.style.fog;f?(this._fogVisible=0!==f.getOpacity(this.transform.pitch),this._fogVisible&&"globe"!==this.transform.projection.name&&(this._fogVisible=f.isVisibleOnFrustum(this.transform.cameraFrustum))):this._fogVisible=!1,this._cachedTileFogOpacities={},this.terrain&&(this.terrain.updateTileBinding(u),this.opaquePassCutoff=0);const m=this._shadowRenderer;if(m){m.updateShadowParameters(this.transform,this.style.directionalLight);for(const e in n)for(const t of c[e]){let e={min:0,max:0};this.terrain&&(e=this.terrain.getMinMaxForTile(t)||e),m.addShadowReceiver(t.toUnwrapped(),e.min,e.max);}}if("globe"!==this.transform.projection.name||this.globeSharedBuffers||(this.globeSharedBuffers=new e.cY(this.context)),this.style.fog&&this.transform.projection.supportsFog?(this._atmosphere||(this._atmosphere=new ks(this)),this._atmosphere.update(this)):this._atmosphere&&(this._atmosphere.destroy(),this._atmosphere=void 0),!e.cZ(this.context.gl))return;this.renderPass="offscreen";for(const e of s){const i=t.getLayerSourceCache(e);if(!e.hasOffscreenPass()||e.isHidden(this.transform.zoom))continue;const o=i?h[i.id]:void 0;("custom"===e.type||"raster"===e.type||"raster-particle"===e.type||e.isSky()||o&&o.length)&&this.renderLayer(this,i,e,o);}this.depthRangeFor3D=[0,1-(s.length+2)*this.numSublayers*this.depthEpsilon];const g=this.terrain;g&&(this.style.hasSymbolLayers()||this.style.hasCircleLayers())&&!this.transform.isOrthographic&&g.drawDepth(),this._shadowRenderer&&(this.renderPass="shadow",this._shadowRenderer.drawShadowPass(this.style,d)),this.context.bindFramebuffer.set(null),this.context.viewport.set([0,0,this.width,this.height]);const v="globe"===this.transform.projection.name||this.transform.isHorizonVisible(),x=(()=>{if(i.showOverdrawInspector)return e.ax.black;if(this.style.fog&&this.transform.projection.supportsFog&&!v){const t=this.style.fog.properties.get("color").toArray01();return new e.ax(...t)}if(this.style.fog&&this.transform.projection.supportsFog&&v){const t=this.style.fog.properties.get("space-color").toArray01();return new e.ax(...t)}return e.ax.transparent})();if(this.context.clear({color:x,depth:1}),this.clearStencil(),this._showOverdrawInspector=i.showOverdrawInspector,this.renderPass="opaque",this.style.fog&&this.transform.projection.supportsFog&&this._atmosphere&&!this._showOverdrawInspector&&v&&this._atmosphere.drawStars(this,this.style.fog),!this.terrain)for(this.currentLayer=r.length-1;this.currentLayer>=0;this.currentLayer--){const e=s[this.currentLayer],i=t.getLayerSourceCache(e);if(e.isSky())continue;const o=i?(e.is3D()?_:h)[i.id]:void 0;this._renderTileClippingMasks(e,i,o),this.renderLayer(this,i,e,o);}if(this.style.fog&&this.transform.projection.supportsFog&&this._atmosphere&&!this._showOverdrawInspector&&v&&this._atmosphere.drawAtmosphereGlow(this,this.style.fog),this.renderPass="sky",(!this._atmosphere||e.S(this.transform.zoom)>0)&&("globe"===this.transform.projection.name||this.transform.isHorizonVisible()))for(this.currentLayer=0;this.currentLayer<r.length;this.currentLayer++){const e=s[this.currentLayer],i=t.getLayerSourceCache(e);e.isSky()&&this.renderLayer(this,i,e,i?h[i.id]:void 0);}function y(e,t){let i;return t&&(i=("symbol"===e.type?u:e.is3D()?_:h)[t.id]),i}if(this.renderPass="translucent","globe"===this.transform.projection.name){for(this.renderElevatedRasterBackface=!0,this.currentLayer=0;this.currentLayer<r.length;){const e=s[this.currentLayer];if("raster"===e.type){const i=t.getLayerSourceCache(e);this.renderLayer(this,i,e,y(e,i));}++this.currentLayer;}this.renderElevatedRasterBackface=!1;}this.currentLayer=0,this.firstLightBeamLayer=Number.MAX_SAFE_INTEGER;let b=0;for(m&&(b=m.getShadowCastingLayerCount());this.currentLayer<r.length;){const e=s[this.currentLayer],i=t.getLayerSourceCache(e);if(e.isSky())++this.currentLayer;else if(g&&this.style.isLayerDraped(e)){if(e.isHidden(this.transform.zoom)){++this.currentLayer;continue}this.currentLayer=g.renderBatch(this.currentLayer);}else {if(this._renderTileClippingMasks(e,i,i?c[i.id]:void 0),this.renderLayer(this,i,e,y(e,i)),!g&&m&&b>0&&e.hasShadowPass()&&0==--b&&(m.drawGroundShadows(),this.firstLightBeamLayer<=this.currentLayer)){const e=this.currentLayer;for(this.renderPass="light-beam",this.currentLayer=this.firstLightBeamLayer;this.currentLayer<=e;this.currentLayer++){const e=s[this.currentLayer];if(!e.hasLightBeamPass())continue;const i=t.getLayerSourceCache(e);this.renderLayer(this,i,e,i?h[i.id]:void 0);}this.currentLayer=e,this.renderPass="translucent";}++this.currentLayer;}}if(this.terrain&&this.terrain.postRender(),this.options.showTileBoundaries||this.options.showQueryGeometry||this.options.showTileAABBs){let i=null;s.forEach((e=>{const o=t.getLayerSourceCache(e);o&&!e.isHidden(this.transform.zoom)&&o.getVisibleCoordinates().length&&(!i||i.getSource().maxzoom<o.getSource().maxzoom)&&(i=o);})),i&&this.options.showTileBoundaries&&Qs.debug(this,i,i.getVisibleCoordinates(),e.ax.red,!1,this.options.showParseStatus);}this.terrain&&this._debugParams.showTerrainProxyTiles&&Qs.debug(this,this.terrain.proxySourceCache,this.terrain.proxyCoords,new e.ax(1,.8,.1,1),!0,this.options.showParseStatus),this.options.showPadding&&function(e){const t=e.transform.padding;Cs(e,e.transform.height-(t.top||0),3,ys),Cs(e,t.bottom||0,3,bs),Is(e,t.left||0,3,ws),Is(e,e.transform.width-(t.right||0),3,Ts);const i=e.transform.centerPoint;!function(e,t,i,o){Ds(e,t-1,i-10,2,20,o),Ds(e,t-10,i-1,20,2,o);}(e,i.x,e.transform.height-i.y,Es);}(this),this.context.setDefault(),this.frameCounter=(this.frameCounter+1)%Number.MAX_SAFE_INTEGER,this.tileLoaded&&this.options.speedIndexTiming&&(this.loadTimeStamps.push(performance.now()),this.saveCanvasCopy()),l||(this.conflationActive=!1);}prepareLayer(e){this.gpuTimingStart(e);const{unsupportedLayers:t}=this.transform.projection,i=!t||!t.includes(e.type);if(en[e.type]&&(i||this.terrain&&"custom"===e.type)){const t=this.style.getLayerSourceCache(e);en[e.type](e,t,this);}this.gpuTimingEnd();}renderLayer(e,t,i,o){i.isHidden(this.transform.zoom)||("background"===i.type||"sky"===i.type||"custom"===i.type||"model"===i.type||"raster"===i.type||"raster-particle"===i.type||o&&o.length)&&(this.id=i.id,this.gpuTimingStart(i),(!e.transform.projection.unsupportedLayers||!e.transform.projection.unsupportedLayers.includes(i.type)||e.terrain&&"custom"===i.type)&&Qs[i.type](e,t,i,o,this.style.placement.variableOffsets,this.options.isInitialLoad),this.gpuTimingEnd());}gpuTimingStart(e){if(!this.options.gpuTiming)return;const t=this.context.extTimerQuery,i=this.context.gl;let o=this.gpuTimers[e.id];o||(o=this.gpuTimers[e.id]={calls:0,cpuTime:0,query:i.createQuery()}),o.calls++,i.beginQuery(t.TIME_ELAPSED_EXT,o.query);}gpuTimingDeferredRenderStart(){if(this.options.gpuTimingDeferredRender){const e=this.context.extTimerQuery,t=this.context.gl,i=t.createQuery();this.deferredRenderGpuTimeQueries.push(i),t.beginQuery(e.TIME_ELAPSED_EXT,i);}}gpuTimingDeferredRenderEnd(){this.options.gpuTimingDeferredRender&&this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);}gpuTimingEnd(){this.options.gpuTiming&&this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);}collectGpuTimers(){const e=this.gpuTimers;return this.gpuTimers={},e}collectDeferredRenderGpuQueries(){const e=this.deferredRenderGpuTimeQueries;return this.deferredRenderGpuTimeQueries=[],e}queryGpuTimers(e){const t={};for(const i in e){const o=e[i],r=this.context.extTimerQuery,s=r.getQueryParameter(o.query,this.context.gl.QUERY_RESULT)/1e6;r.deleteQueryEXT(o.query),t[i]=s;}return t}queryGpuTimeDeferredRender(e){if(!this.options.gpuTimingDeferredRender)return 0;const t=this.context.extTimerQuery,i=this.context.gl;let o=0;for(const r of e)o+=t.getQueryParameter(r,i.QUERY_RESULT)/1e6,t.deleteQueryEXT(r);return o}translatePosMatrix(t,i,o,r,s){if(!o[0]&&!o[1])return t;const n=s?"map"===r?this.transform.angle:0:"viewport"===r?-this.transform.angle:0;if(n){const e=Math.sin(n),t=Math.cos(n);o=[o[0]*t-o[1]*e,o[0]*e+o[1]*t];}const a=[s?o[0]:e.a3(i,o[0],this.transform.zoom),s?o[1]:e.a3(i,o[1],this.transform.zoom),0],l=new Float32Array(16);return e.a6.translate(l,t,a),l}saveTileTexture(e){const t=e.size[0],i=this._tileTextures[t];i?i.push(e):this._tileTextures[t]=[e];}getTileTexture(e){const t=this._tileTextures[e];return t&&t.length>0?t.pop():null}isPatternMissing(e,t){return null===e||void 0!==e&&!this.imageManager.getPattern(e.toString(),t)}terrainRenderModeElevated(){return this.style&&!!this.style.getTerrain()&&!!this.terrain&&!this.terrain.renderingToTexture}linearFloatFilteringSupported(){return null!=this.context.extTextureFloatLinear}currentGlobalDefines(e,t,i){const o=void 0===i?this.terrain&&this.terrain.renderingToTexture:i,r=this.terrain&&0===this.terrain.exaggeration(),s=[];return this.style&&this.style.enable3dLights()&&("globeRaster"===e||"terrainRaster"===e?(s.push("LIGHTING_3D_MODE"),s.push("LIGHTING_3D_ALPHA_EMISSIVENESS")):o||s.push("LIGHTING_3D_MODE")),"shadow"===this.renderPass?this._shadowMapDebug||s.push("DEPTH_TEXTURE"):this.shadowRenderer&&(this.shadowRenderer.useNormalOffset?s.push("RENDER_SHADOWS","DEPTH_TEXTURE","NORMAL_OFFSET"):s.push("RENDER_SHADOWS","DEPTH_TEXTURE")),this.terrainRenderModeElevated()&&(s.push("TERRAIN"),this.linearFloatFilteringSupported()&&s.push("TERRAIN_DEM_FLOAT_FORMAT"),r&&s.push("ZERO_EXAGGERATION")),"globe"===this.transform.projection.name&&s.push("GLOBE"),!this._fogVisible||o||void 0!==t&&!t||s.push("FOG","FOG_DITHERING"),o&&s.push("RENDER_TO_TEXTURE"),this._showOverdrawInspector&&s.push("OVERDRAW_INSPECTOR"),s}getOrCreateProgram(e,t){this.cache=this.cache||{};const i=t&&t.defines||[],o=t&&t.config,r=t&&t.transformFeedback,s=this.currentGlobalDefines(e,t&&t.overrideFog,t&&t.overrideRtt).concat(i),n=br.cacheKey(Ko[e],e,s,o);return this.cache[n]||(this.cache[n]=new br(this.context,e,Ko[e],o,Yr[e],s,r)),this.cache[n]}setCustomLayerDefaults(){this.context.unbindVAO(),this.context.cullFace.setDefault(),this.context.frontFace.setDefault(),this.context.cullFaceSide.setDefault(),this.context.activeTexture.setDefault(),this.context.pixelStoreUnpack.setDefault(),this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),this.context.pixelStoreUnpackFlipY.setDefault();}setBaseState(){const e=this.context.gl;this.context.cullFace.set(!1),this.context.viewport.set([0,0,this.width,this.height]),this.context.blendEquation.set(e.FUNC_ADD);}initDebugOverlayCanvas(){null==this.debugOverlayCanvas&&(this.debugOverlayCanvas=document.createElement("canvas"),this.debugOverlayCanvas.width=512,this.debugOverlayCanvas.height=512,this.debugOverlayTexture=new e.T(this.context,this.debugOverlayCanvas,this.context.gl.RGBA));}destroy(){this._terrain&&this._terrain.destroy(),this._atmosphere&&(this._atmosphere.destroy(),this._atmosphere=void 0),this.globeSharedBuffers&&this.globeSharedBuffers.destroy(),this.emptyTexture.destroy(),this.debugOverlayTexture&&this.debugOverlayTexture.destroy(),this._wireframeDebugCache.destroy();}prepareDrawTile(){this.terrain&&this.terrain.prepareDrawTile();}uploadCommonLightUniforms(t,i){if(this.style.enable3dLights()){const o=this.style.directionalLight,r=this.style.ambientLight;if(o&&r){const s=((t,i)=>{const o=t.properties.get("direction"),r=t.properties.get("color").toArray01(),s=t.properties.get("intensity"),n=i.properties.get("color").toArray01(),a=i.properties.get("intensity"),l=[o.x,o.y,o.z],c=e.cn(n,a),h=e.cn(r,s);return {u_lighting_ambient_color:c,u_lighting_directional_dir:l,u_lighting_directional_color:h,u_ground_radiance:vr(l,h,c)}})(o,r);i.setLightsUniformValues(t,s);}}}uploadCommonUniforms(t,i,o,r,s){if(this.uploadCommonLightUniforms(t,i),this.terrain&&this.terrain.renderingToTexture)return;const n=this.style.fog;if(n){const s=n.getOpacity(this.transform.pitch),a=((t,i,o,r,s,n,a,l,c,h,u,d)=>{const _=t.transform,p=i.properties.get("color").toArray01();p[3]=r;const f=t.frameCounter/1e3%1,[m,g]=i.properties.get("vertical-range");return {u_fog_matrix:o?_.calculateFogTileMatrix(o):d||t.identityMat,u_fog_range:i.getFovAdjustedRange(_._fov),u_fog_color:p,u_fog_horizon_blend:i.properties.get("horizon-blend"),u_fog_vertical_limit:[Math.min(m,g),g],u_fog_temporal_offset:f,u_frustum_tl:s,u_frustum_tr:n,u_frustum_br:a,u_frustum_bl:l,u_globe_pos:c,u_globe_radius:h,u_viewport:u,u_globe_transition:e.S(_.zoom),u_is_globe:+("globe"===_.projection.name)}})(this,n,o,s,this.transform.frustumCorners.TL,this.transform.frustumCorners.TR,this.transform.frustumCorners.BR,this.transform.frustumCorners.BL,this.transform.globeCenterInViewSpace,this.transform.globeRadius,[this.transform.width*e.f.devicePixelRatio,this.transform.height*e.f.devicePixelRatio],r);i.setFogUniformValues(t,a);}s&&i.setCutoffUniformValues(t,s.uniformValues);}setTileLoadedFlag(e){this.tileLoaded=e;}saveCanvasCopy(){const e=this.canvasCopy();e&&(this.frameCopies.push(e),this.tileLoaded=!1);}canvasCopy(){const e=this.context.gl,t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.copyTexImage2D(e.TEXTURE_2D,0,e.RGBA,0,0,e.drawingBufferWidth,e.drawingBufferHeight,0),t}getCanvasCopiesAndTimestamps(){return {canvasCopies:this.frameCopies,timeStamps:this.loadTimeStamps}}averageElevationNeedsEasing(){if(!this.transform._elevation)return !1;const e=this.style&&this.style.fog;return !!e&&0!==e.getOpacity(this.transform.pitch)}getBackgroundTiles(){const e=this._backgroundTiles,t=this._backgroundTiles={},i=this.transform.coveringTiles({tileSize:512});for(const o of i)t[o.key]=e[o.key]||new Gt(o,512,this.transform.tileZoom,this);return t}clearBackgroundTiles(){this._backgroundTiles={};}layerUsedInConflation(e,t){return !(!e.is3D()||e.minzoom&&e.minzoom>this.transform.zoom||"building"!==e.sourceLayer&&(!t||"batched-model"!==t.type))}isTileAffectedByFog(e){if(!this.style||!this.style.fog)return !1;if("globe"===this.transform.projection.name)return !0;let t=this._cachedTileFogOpacities[e.key];return t||(this._cachedTileFogOpacities[e.key]=t=this.style.fog.getOpacityForTile(e)),t[0]>=me||t[1]>=me}}function on(e,t){let i=!1,o=null;const r=()=>{o=null,i&&(e(),o=setTimeout(r,t),i=!1);};return ()=>(i=!0,o||r(),o)}class rn{constructor(t){this._hashName=t&&encodeURIComponent(t),e.aY(["_getCurrentHash","_onHashChange","_updateHash"],this),this._updateHash=on(this._updateHashUnthrottled.bind(this),300);}addTo(e){return this._map=e,window.addEventListener("hashchange",this._onHashChange,!1),e.on("moveend",this._updateHash),this}remove(){return this._map?(this._map.off("moveend",this._updateHash),window.removeEventListener("hashchange",this._onHashChange,!1),clearTimeout(this._updateHash()),this._map=void 0,this):this}getHashString(){const e=this._map;if(!e)return "";const t=sn(e);if(this._hashName){const e=this._hashName;let i=!1;const o=location.hash.slice(1).split("&").map((o=>{const r=o.split("=")[0];return r===e?(i=!0,`${r}=${t}`):o})).filter((e=>e));return i||o.push(`${e}=${t}`),`#${o.join("&")}`}return `#${t}`}_getCurrentHash(){const e=location.hash.replace("#","");if(this._hashName){let t;return e.split("&").map((e=>e.split("="))).forEach((e=>{e[0]===this._hashName&&(t=e);})),(t&&t[1]||"").split("/")}return e.split("/")}_onHashChange(){const e=this._map;if(!e)return !1;const t=this._getCurrentHash();if(t.length>=3&&!t.some((e=>isNaN(e)))){const i=e.dragRotate.isEnabled()&&e.touchZoomRotate.isEnabled()?+(t[3]||0):e.getBearing();return e.jumpTo({center:[+t[2],+t[1]],zoom:+t[0],bearing:i,pitch:+(t[4]||0)}),!0}return !1}_updateHashUnthrottled(){history.replaceState(history.state,"",location.href.replace(/(#.+)?$/,this.getHashString()));}}function sn(e,t){const i=e.getCenter(),o=Math.round(100*e.getZoom())/100,r=Math.ceil((o*Math.LN2+Math.log(512/360/.5))/Math.LN10),s=Math.pow(10,r),n=Math.round(i.lng*s)/s,a=Math.round(i.lat*s)/s,l=e.getBearing(),c=e.getPitch();let h=t?`/${n}/${a}/${o}`:`${o}/${a}/${n}`;return (l||c)&&(h+="/"+Math.round(10*l)/10),c&&(h+=`/${Math.round(c)}`),h}const nn={linearity:.3,easing:e.c_(0,0,.3,1)},an=e.e({deceleration:2500,maxSpeed:1400},nn),ln=e.e({deceleration:20,maxSpeed:1400},nn),cn=e.e({deceleration:1e3,maxSpeed:360},nn),hn=e.e({deceleration:1e3,maxSpeed:90},nn);class un{constructor(e){this._map=e,this.clear();}clear(){this._inertiaBuffer=[];}record(t){this._drainInertiaBuffer(),this._inertiaBuffer.push({time:e.f.now(),settings:t});}_drainInertiaBuffer(){const t=this._inertiaBuffer,i=e.f.now();for(;t.length>0&&i-t[0].time>160;)t.shift();}_onMoveEnd(t){if(this._map._prefersReducedMotion())return;if(this._drainInertiaBuffer(),this._inertiaBuffer.length<2)return;const i={zoom:0,bearing:0,pitch:0,pan:new e.P(0,0),pinchAround:void 0,around:void 0};for(const{settings:e}of this._inertiaBuffer)i.zoom+=e.zoomDelta||0,i.bearing+=e.bearingDelta||0,i.pitch+=e.pitchDelta||0,e.panDelta&&i.pan._add(e.panDelta),e.around&&(i.around=e.around),e.pinchAround&&(i.pinchAround=e.pinchAround);const o=this._inertiaBuffer[this._inertiaBuffer.length-1].time-this._inertiaBuffer[0].time,r={};if(i.pan.mag()){const s=_n(i.pan.mag(),o,e.e({},an,t||{}));r.offset=i.pan.mult(s.amount/i.pan.mag()),r.center=this._map.transform.center,dn(r,s);}if(i.zoom){const e=_n(i.zoom,o,ln);r.zoom=this._map.transform.zoom+e.amount,dn(r,e);}if(i.bearing){const t=_n(i.bearing,o,cn);r.bearing=this._map.transform.bearing+e.aa(t.amount,-179,179),dn(r,t);}if(i.pitch){const e=_n(i.pitch,o,hn);r.pitch=this._map.transform.pitch+e.amount,dn(r,e);}if(r.zoom||r.bearing){const e=void 0===i.pinchAround?i.around:i.pinchAround;r.around=e?this._map.unproject(e):this._map.getCenter();}return this.clear(),r.noMoveStart=!0,r}}function dn(e,t){(!e.duration||e.duration<t.duration)&&(e.duration=t.duration,e.easing=t.easing);}function _n(t,i,o){const{maxSpeed:r,linearity:s,deceleration:n}=o,a=e.aa(t*s/(i/1e3),-r,r),l=Math.abs(a)/(n*s);return {easing:o.easing,duration:1e3*l,amount:a*(l/2)}}class pn extends e.b{preventDefault(){this._defaultPrevented=!0;}get defaultPrevented(){return this._defaultPrevented}constructor(t,i,o,r={}){const s=p(i.getCanvasContainer(),o),n=i.unproject(s);super(t,e.e({point:s,lngLat:n,originalEvent:o},r)),this._defaultPrevented=!1,this.target=i;}}class fn extends e.b{preventDefault(){this._defaultPrevented=!0;}get defaultPrevented(){return this._defaultPrevented}constructor(t,i,o){const r="touchend"===t?o.changedTouches:o.touches,s=f(i.getCanvasContainer(),r),n=s.map((e=>i.unproject(e))),a=s.reduce(((e,t,i,o)=>e.add(t.div(o.length))),new e.P(0,0));super(t,{points:s,point:a,lngLats:n,lngLat:i.unproject(a),originalEvent:o}),this._defaultPrevented=!1;}}class mn extends e.b{preventDefault(){this._defaultPrevented=!0;}get defaultPrevented(){return this._defaultPrevented}constructor(e,t,i){super(e,{originalEvent:i}),this._defaultPrevented=!1;}}class gn{constructor(e,t){this._map=e,this._clickTolerance=t.clickTolerance;}reset(){this._mousedownPos=void 0;}wheel(e){return this._firePreventable(new mn(e.type,this._map,e))}mousedown(e,t){return this._mousedownPos=t,this._firePreventable(new pn(e.type,this._map,e))}mouseup(e){this._map.fire(new pn(e.type,this._map,e));}preclick(t){const i=e.e({},t);i.type="preclick",this._map.fire(new pn(i.type,this._map,i));}click(e,t){this._mousedownPos&&this._mousedownPos.dist(t)>=this._clickTolerance||(this.preclick(e),this._map.fire(new pn(e.type,this._map,e)));}dblclick(e){return this._firePreventable(new pn(e.type,this._map,e))}mouseover(e){this._map.fire(new pn(e.type,this._map,e));}mouseout(e){this._map.fire(new pn(e.type,this._map,e));}touchstart(e){return this._firePreventable(new fn(e.type,this._map,e))}touchmove(e){this._map.fire(new fn(e.type,this._map,e));}touchend(e){this._map.fire(new fn(e.type,this._map,e));}touchcancel(e){this._map.fire(new fn(e.type,this._map,e));}_firePreventable(e){if(this._map.fire(e),e.defaultPrevented)return {}}isEnabled(){return !0}isActive(){return !1}enable(){}disable(){}}class vn{constructor(e){this._map=e;}reset(){this._delayContextMenu=!1,this._contextMenuEvent=void 0;}mousemove(e){this._map.fire(new pn(e.type,this._map,e));}mousedown(){this._delayContextMenu=!0;}mouseup(){this._delayContextMenu=!1,this._contextMenuEvent&&(this._map.fire(new pn("contextmenu",this._map,this._contextMenuEvent)),delete this._contextMenuEvent);}contextmenu(e){this._delayContextMenu?this._contextMenuEvent=e:this._map.fire(new pn(e.type,this._map,e)),this._map.listens("contextmenu")&&e.preventDefault();}isEnabled(){return !0}isActive(){return !1}enable(){}disable(){}}class xn{constructor(e,t){this._map=e,this._el=e.getCanvasContainer(),this._container=e.getContainer(),this._clickTolerance=t.clickTolerance||1;}isEnabled(){return !!this._enabled}isActive(){return !!this._active}enable(){this.isEnabled()||(this._enabled=!0);}disable(){this.isEnabled()&&(this._enabled=!1);}mousedown(e,t){this.isEnabled()&&e.shiftKey&&0===e.button&&(h(),this._startPos=this._lastPos=t,this._active=!0);}mousemoveWindow(e,t){if(!this._active)return;const i=t,o=this._startPos,r=this._lastPos;if(!o||!r||r.equals(i)||!this._box&&i.dist(o)<this._clickTolerance)return;this._lastPos=i,this._box||(this._box=s("div","mapboxgl-boxzoom",this._container),this._container.classList.add("mapboxgl-crosshair"),this._fireEvent("boxzoomstart",e));const n=Math.min(o.x,i.x),a=Math.max(o.x,i.x),l=Math.min(o.y,i.y),c=Math.max(o.y,i.y);this._map._requestDomTask((()=>{this._box&&(this._box.style.transform=`translate(${n}px,${l}px)`,this._box.style.width=a-n+"px",this._box.style.height=c-l+"px");}));}mouseupWindow(t,i){if(!this._active)return;const o=this._startPos,r=i;if(o&&0===t.button){if(this.reset(),_(),o.x!==r.x||o.y!==r.y)return this._map.fire(new e.b("boxzoomend",{originalEvent:t})),{cameraAnimation:e=>e.fitScreenCoordinates(o,r,this._map.getBearing(),{linear:!1})};this._fireEvent("boxzoomcancel",t);}}keydown(e){this._active&&27===e.keyCode&&(this.reset(),this._fireEvent("boxzoomcancel",e));}blur(){this.reset();}reset(){this._active=!1,this._container.classList.remove("mapboxgl-crosshair"),this._box&&(this._box.remove(),this._box=null),u(),delete this._startPos,delete this._lastPos;}_fireEvent(t,i){return this._map.fire(new e.b(t,{originalEvent:i}))}}function yn(e,t){const i={};for(let o=0;o<e.length;o++)i[e[o].identifier]=t[o];return i}class bn{constructor(e){this.reset(),this.numTouches=e.numTouches;}reset(){this.centroid=void 0,this.startTime=0,this.touches={},this.aborted=!1;}touchstart(t,i,o){(this.centroid||o.length>this.numTouches)&&(this.aborted=!0),this.aborted||(0===this.startTime&&(this.startTime=t.timeStamp),o.length===this.numTouches&&(this.centroid=function(t){const i=new e.P(0,0);for(const e of t)i._add(e);return i.div(t.length)}(i),this.touches=yn(o,i)));}touchmove(e,t,i){if(this.aborted||!this.centroid)return;const o=yn(i,t);for(const e in this.touches){const t=o[e];(!t||t.dist(this.touches[e])>30)&&(this.aborted=!0);}}touchend(e,t,i){if((!this.centroid||e.timeStamp-this.startTime>500)&&(this.aborted=!0),0===i.length){const e=!this.aborted&&this.centroid;if(this.reset(),e)return e}}}class wn{constructor(e){this.singleTap=new bn(e),this.numTaps=e.numTaps,this.reset();}reset(){this.lastTime=1/0,this.lastTap=void 0,this.count=0,this.singleTap.reset();}touchstart(e,t,i){this.singleTap.touchstart(e,t,i);}touchmove(e,t,i){this.singleTap.touchmove(e,t,i);}touchend(e,t,i){const o=this.singleTap.touchend(e,t,i);if(o){const t=e.timeStamp-this.lastTime<500,i=!this.lastTap||this.lastTap.dist(o)<30;if(t&&i||this.reset(),this.count++,this.lastTime=e.timeStamp,this.lastTap=o,this.count===this.numTaps)return this.reset(),o}}}class Tn{constructor(){this._zoomIn=new wn({numTouches:1,numTaps:2}),this._zoomOut=new wn({numTouches:2,numTaps:1}),this.reset();}reset(){this._active=!1,this._zoomIn.reset(),this._zoomOut.reset();}touchstart(e,t,i){this._zoomIn.touchstart(e,t,i),this._zoomOut.touchstart(e,t,i);}touchmove(e,t,i){this._zoomIn.touchmove(e,t,i),this._zoomOut.touchmove(e,t,i);}touchend(e,t,i){const o=this._zoomIn.touchend(e,t,i),r=this._zoomOut.touchend(e,t,i);return o?(this._active=!0,e.preventDefault(),setTimeout((()=>this.reset()),0),{cameraAnimation:t=>t.easeTo({duration:300,zoom:t.getZoom()+1,around:t.unproject(o)},{originalEvent:e})}):r?(this._active=!0,e.preventDefault(),setTimeout((()=>this.reset()),0),{cameraAnimation:t=>t.easeTo({duration:300,zoom:t.getZoom()-1,around:t.unproject(r)},{originalEvent:e})}):void 0}touchcancel(){this.reset();}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}const En={0:1,2:2};class Sn{constructor(e){this.reset(),this._clickTolerance=e.clickTolerance||1;}blur(){this.reset();}reset(){this._active=!1,this._moved=!1,this._lastPoint=void 0,this._eventButton=void 0;}_correctButton(e,t){return !1}_move(e,t){return {}}mousedown(e,t){if(this._lastPoint)return;const i=m(e);this._correctButton(e,i)&&(this._lastPoint=t,this._eventButton=i);}mousemoveWindow(e,t){const i=this._lastPoint;if(i)if(e.preventDefault(),null!=this._eventButton&&function(e,t){const i=En[t];return void 0===e.buttons||(e.buttons&i)!==i}(e,this._eventButton))this.reset();else if(this._moved||!(t.dist(i)<this._clickTolerance))return this._moved=!0,this._lastPoint=t,this._move(i,t)}mouseupWindow(e){this._lastPoint&&m(e)===this._eventButton&&(this._moved&&_(),this.reset());}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}class Cn extends Sn{mousedown(e,t){super.mousedown(e,t),this._lastPoint&&(this._active=!0);}_correctButton(e,t){return 0===t&&!e.ctrlKey}_move(e,t){return {around:t,panDelta:t.sub(e)}}}class In extends Sn{_correctButton(e,t){return 0===t&&e.ctrlKey||2===t}_move(e,t){const i=.8*(t.x-e.x);if(i)return this._active=!0,{bearingDelta:i}}contextmenu(e){e.preventDefault();}}class Dn extends Sn{_correctButton(e,t){return 0===t&&e.ctrlKey||2===t}_move(e,t){const i=-.5*(t.y-e.y);if(i)return this._active=!0,{pitchDelta:i}}contextmenu(e){e.preventDefault();}}class Ln{constructor(t,i){this._map=t,this._el=t.getCanvasContainer(),this._minTouches=1,this._clickTolerance=i.clickTolerance||1,this.reset(),e.aY(["_addTouchPanBlocker","_showTouchPanBlockerAlert"],this);}reset(){this._active=!1,this._touches={},this._sum=new e.P(0,0);}touchstart(e,t,i){return this._calculateTransform(e,t,i)}touchmove(t,i,o){if(this._active&&!(o.length<this._minTouches)){if(this._map._cooperativeGestures&&!this._map.isMoving()){if(1===o.length&&!e.c$())return void this._showTouchPanBlockerAlert();"hidden"!==this._alertContainer.style.visibility&&(this._alertContainer.style.visibility="hidden",clearTimeout(this._alertTimer));}return t.cancelable&&t.preventDefault(),this._calculateTransform(t,i,o)}}touchend(e,t,i){this._calculateTransform(e,t,i),this._active&&i.length<this._minTouches&&this.reset();}touchcancel(){this.reset();}_calculateTransform(t,i,o){o.length>0&&(this._active=!0);const r=yn(o,i),s=new e.P(0,0),n=new e.P(0,0);let a=0;for(const e in r){const t=r[e],i=this._touches[e];i&&(s._add(t),n._add(t.sub(i)),a++,r[e]=t);}if(this._touches=r,a<this._minTouches||!n.mag())return;const l=n.div(a);return this._sum._add(l),this._sum.mag()<this._clickTolerance?void 0:{around:s.div(a),panDelta:l}}enable(){this._enabled=!0,this._map._cooperativeGestures&&(this._addTouchPanBlocker(),this._el.classList.add("mapboxgl-touch-pan-blocker-override","mapboxgl-scrollable-page"));}disable(){this._enabled=!1,this._map._cooperativeGestures&&(clearTimeout(this._alertTimer),this._alertContainer.remove(),this._el.classList.remove("mapboxgl-touch-pan-blocker-override","mapboxgl-scrollable-page")),this.reset();}isEnabled(){return !!this._enabled}isActive(){return !!this._active}_addTouchPanBlocker(){this._map&&!this._alertContainer&&(this._alertContainer=s("div","mapboxgl-touch-pan-blocker",this._map._container),this._alertContainer.textContent=this._map._getUIString("TouchPanBlocker.Message"),this._alertContainer.style.fontSize=`${Math.max(10,Math.min(24,Math.floor(.05*this._el.clientWidth)))}px`);}_showTouchPanBlockerAlert(){this._alertContainer.style.visibility="visible",this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"),this._alertContainer.setAttribute("role","alert"),clearTimeout(this._alertTimer),this._alertTimer=setTimeout((()=>{this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"),this._alertContainer.removeAttribute("role");}),500);}}class An{constructor(){this.reset();}reset(){this._active=!1,this._firstTwoTouches=void 0;}_start(e){}_move(e,t,i){return {}}touchstart(e,t,i){this._firstTwoTouches||i.length<2||(this._firstTwoTouches=[i[0].identifier,i[1].identifier],this._start([t[0],t[1]]));}touchmove(e,t,i){const o=this._firstTwoTouches;if(!o)return;e.preventDefault();const[r,s]=o,n=Rn(i,t,r),a=Rn(i,t,s);if(!n||!a)return;const l=this._aroundCenter?null:n.add(a).div(2);return this._move([n,a],l,e)}touchend(e,t,i){if(!this._firstTwoTouches)return;const[o,r]=this._firstTwoTouches,s=Rn(i,t,o),n=Rn(i,t,r);s&&n||(this._active&&_(),this.reset());}touchcancel(){this.reset();}enable(e){this._enabled=!0,this._aroundCenter=!!e&&"center"===e.around;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}function Rn(e,t,i){for(let o=0;o<e.length;o++)if(e[o].identifier===i)return t[o]}function Pn(e,t){return Math.log(e/t)/Math.LN2}class Mn extends An{reset(){super.reset(),this._distance=0,this._startDistance=0;}_start(e){this._startDistance=this._distance=e[0].dist(e[1]);}_move(e,t){const i=this._distance;if(this._distance=e[0].dist(e[1]),this._active||!(Math.abs(Pn(this._distance,this._startDistance))<.1))return this._active=!0,{zoomDelta:Pn(this._distance,i),pinchAround:t}}}function zn(e,t){return 180*e.angleWith(t)/Math.PI}class On extends An{reset(){super.reset(),this._minDiameter=0,this._startVector=void 0,this._vector=void 0;}_start(e){this._startVector=this._vector=e[0].sub(e[1]),this._minDiameter=e[0].dist(e[1]);}_move(e,t){const i=this._vector;if(this._vector=e[0].sub(e[1]),i&&(this._active||!this._isBelowThreshold(this._vector)))return this._active=!0,{bearingDelta:zn(this._vector,i),pinchAround:t}}_isBelowThreshold(e){this._minDiameter=Math.min(this._minDiameter,e.mag());const t=25/(Math.PI*this._minDiameter)*360,i=this._startVector;if(!i)return !1;const o=zn(e,i);return Math.abs(o)<t}}function Fn(e){return Math.abs(e.y)>Math.abs(e.x)}class Bn extends An{constructor(e){super(),this._map=e;}reset(){super.reset(),this._valid=void 0,this._firstMove=void 0,this._lastPoints=void 0;}_start(e){this._lastPoints=e,Fn(e[0].sub(e[1]))&&(this._valid=!1);}_move(t,i,o){const r=this._lastPoints;if(!r)return;const s=t[0].sub(r[0]),n=t[1].sub(r[1]);return this._map._cooperativeGestures&&!e.c$()&&o.touches.length<3||(this._valid=this.gestureBeginsVertically(s,n,o.timeStamp),!this._valid)?void 0:(this._lastPoints=t,this._active=!0,{pitchDelta:(s.y+n.y)/2*-.5})}gestureBeginsVertically(e,t,i){if(void 0!==this._valid)return this._valid;const o=e.mag()>=2,r=t.mag()>=2;if(!o&&!r)return;if(!o||!r)return null==this._firstMove&&(this._firstMove=i),i-this._firstMove<100&&void 0;const s=e.y>0==t.y>0;return Fn(e)&&Fn(t)&&s}}const kn={panStep:100,bearingStep:15,pitchStep:10};class Nn{constructor(){const e=kn;this._panStep=e.panStep,this._bearingStep=e.bearingStep,this._pitchStep=e.pitchStep,this._rotationDisabled=!1;}blur(){this.reset();}reset(){this._active=!1;}keydown(e){if(e.altKey||e.ctrlKey||e.metaKey)return;let t=0,i=0,o=0,r=0,s=0;switch(e.keyCode){case 61:case 107:case 171:case 187:t=1;break;case 189:case 109:case 173:t=-1;break;case 37:e.shiftKey?i=-1:(e.preventDefault(),r=-1);break;case 39:e.shiftKey?i=1:(e.preventDefault(),r=1);break;case 38:e.shiftKey?o=1:(e.preventDefault(),s=-1);break;case 40:e.shiftKey?o=-1:(e.preventDefault(),s=1);break;default:return}return this._rotationDisabled&&(i=0,o=0),{cameraAnimation:n=>{const a=n.getZoom();n.easeTo({duration:300,easeId:"keyboardHandler",easing:Un,zoom:t?Math.round(a)+t*(e.shiftKey?2:1):a,bearing:n.getBearing()+i*this._bearingStep,pitch:n.getPitch()+o*this._pitchStep,offset:[-r*this._panStep,-s*this._panStep],center:n.getCenter()},{originalEvent:e});}}}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}disableRotation(){this._rotationDisabled=!0;}enableRotation(){this._rotationDisabled=!1;}}function Un(e){return e*(2-e)}const Gn=4.000244140625,jn=1/450;class Vn{constructor(t,i){this._map=t,this._el=t.getCanvasContainer(),this._handler=i,this._delta=0,this._lastDelta=0,this._defaultZoomRate=.01,this._wheelZoomRate=jn,e.aY(["_onTimeout","_addScrollZoomBlocker","_showBlockerAlert"],this);}setZoomRate(e){this._defaultZoomRate=e;}setWheelZoomRate(e){this._wheelZoomRate=e;}isEnabled(){return !!this._enabled}isActive(){return this._active||void 0!==this._finishTimeout}isZooming(){return !!this._zooming}enable(e){this.isEnabled()||(this._enabled=!0,this._aroundCenter=!!e&&"center"===e.around,this._map._cooperativeGestures&&this._addScrollZoomBlocker());}disable(){this.isEnabled()&&(this._enabled=!1,this._map._cooperativeGestures&&(clearTimeout(this._alertTimer),this._alertContainer.remove()));}wheel(t){if(!this.isEnabled())return;if(this._map._cooperativeGestures){if(!(t.ctrlKey||t.metaKey||this.isZooming()||e.c$()))return void this._showBlockerAlert();"hidden"!==this._alertContainer.style.visibility&&(this._alertContainer.style.visibility="hidden",clearTimeout(this._alertTimer));}let i=t.deltaMode===WheelEvent.DOM_DELTA_LINE?40*t.deltaY:t.deltaY;const o=e.f.now(),r=o-(this._lastWheelEventTime||0);this._lastWheelEventTime=o,0!==i&&i%Gn==0?this._type="wheel":0!==i&&Math.abs(i)<4?this._type="trackpad":r>400?(this._type=null,this._lastValue=i,this._timeout=setTimeout(this._onTimeout,40,t)):this._type||(this._type=Math.abs(r*i)<200?"trackpad":"wheel",this._timeout&&(clearTimeout(this._timeout),this._timeout=null,i+=this._lastValue)),t.shiftKey&&i&&(i/=4),this._type&&(this._lastWheelEvent=t,this._delta-=i,this._active||this._start(t)),t.preventDefault();}_onTimeout(e){this._type="wheel",this._delta-=this._lastValue,this._active||this._start(e);}_start(e){if(!this._delta)return;this._frameId&&(this._frameId=null),this._active=!0,this.isZooming()||(this._zooming=!0),this._finishTimeout&&(clearTimeout(this._finishTimeout),delete this._finishTimeout);const t=p(this._el,e);this._aroundPoint=this._aroundCenter?this._map.transform.centerPoint:t,this._aroundCoord=this._map.transform.pointCoordinate3D(this._aroundPoint),this._targetZoom=void 0,this._frameId||(this._frameId=!0,this._handler._triggerRenderFrame());}renderFrame(){if(!this._frameId)return;if(this._frameId=null,!this.isActive())return;const t=this._map.transform;"wheel"===this._type&&t.projection.wrap&&(t._center.lng>=180||t._center.lng<=-180)&&(this._prevEase=null,this._easing=null,this._lastWheelEvent=null,this._lastWheelEventTime=0);const i=()=>t._terrainEnabled()&&this._aroundCoord?t.computeZoomRelativeTo(this._aroundCoord):t.zoom;if(0!==this._delta){const e="wheel"===this._type&&Math.abs(this._delta)>Gn?this._wheelZoomRate:this._defaultZoomRate;let o=2/(1+Math.exp(-Math.abs(this._delta*e)));this._delta<0&&0!==o&&(o=1/o);const r=i(),s=Math.pow(2,r),n="number"==typeof this._targetZoom?t.zoomScale(this._targetZoom):s;this._targetZoom=Math.min(t.maxZoom,Math.max(t.minZoom,t.scaleZoom(n*o))),"wheel"===this._type&&(this._startZoom=r,this._easing=this._smoothOutEasing(200)),this._lastDelta=this._delta,this._delta=0;}const o="number"==typeof this._targetZoom?this._targetZoom:i(),r=this._startZoom,s=this._easing;let n,a=!1;if("wheel"===this._type&&r&&s){const t=Math.min((e.f.now()-this._lastWheelEventTime)/200,1),i=s(t);n=e.U(r,o,i),t<1?this._frameId||(this._frameId=!0):a=!0;}else n=o,a=!0;this._active=!0,a&&(this._active=!1,this._finishTimeout=setTimeout((()=>{this._zooming=!1,this._handler._triggerRenderFrame(),delete this._targetZoom,delete this._finishTimeout;}),200));let l=n-i();return l*this._lastDelta<0&&(l=0),{noInertia:!0,needsRenderFrame:!a,zoomDelta:l,around:this._aroundPoint,aroundCoord:this._aroundCoord,originalEvent:this._lastWheelEvent}}_smoothOutEasing(t){let i=e.d0;if(this._prevEase){const t=this._prevEase,o=(e.f.now()-t.start)/t.duration,r=t.easing(o+.01)-t.easing(o),s=.27/Math.sqrt(r*r+1e-4)*.01,n=Math.sqrt(.0729-s*s);i=e.c_(s,n,.25,1);}return this._prevEase={start:e.f.now(),duration:t,easing:i},i}blur(){this.reset();}reset(){this._active=!1;}_addScrollZoomBlocker(){this._map&&!this._alertContainer&&(this._alertContainer=s("div","mapboxgl-scroll-zoom-blocker",this._map._container),this._alertContainer.textContent=/(Mac|iPad)/i.test(navigator.userAgent)?this._map._getUIString("ScrollZoomBlocker.CmdMessage"):this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),this._alertContainer.style.fontSize=`${Math.max(10,Math.min(24,Math.floor(.05*this._el.clientWidth)))}px`);}_showBlockerAlert(){this._alertContainer.style.visibility="visible",this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"),this._alertContainer.setAttribute("role","alert"),clearTimeout(this._alertTimer),this._alertTimer=setTimeout((()=>{this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"),this._alertContainer.removeAttribute("role");}),200);}}class Zn{constructor(e,t){this._clickZoom=e,this._tapZoom=t;}enable(){this._clickZoom.enable(),this._tapZoom.enable();}disable(){this._clickZoom.disable(),this._tapZoom.disable();}isEnabled(){return this._clickZoom.isEnabled()&&this._tapZoom.isEnabled()}isActive(){return this._clickZoom.isActive()||this._tapZoom.isActive()}}class Hn{constructor(){this.reset();}reset(){this._active=!1;}blur(){this.reset();}dblclick(e,t){return e.preventDefault(),{cameraAnimation:i=>{i.easeTo({duration:300,zoom:i.getZoom()+(e.shiftKey?-1:1),around:i.unproject(t)},{originalEvent:e});}}}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}class Wn{constructor(){this._tap=new wn({numTouches:1,numTaps:1}),this.reset();}reset(){this._active=!1,this._swipePoint=void 0,this._swipeTouch=0,this._tapTime=0,this._tap.reset();}touchstart(e,t,i){this._swipePoint||(this._tapTime&&e.timeStamp-this._tapTime>500&&this.reset(),this._tapTime?i.length>0&&(this._swipePoint=t[0],this._swipeTouch=i[0].identifier):this._tap.touchstart(e,t,i));}touchmove(e,t,i){if(this._tapTime){if(this._swipePoint){if(i[0].identifier!==this._swipeTouch)return;const o=t[0],r=o.y-this._swipePoint.y;return this._swipePoint=o,e.preventDefault(),this._active=!0,{zoomDelta:r/128}}}else this._tap.touchmove(e,t,i);}touchend(e,t,i){this._tapTime?this._swipePoint&&0===i.length&&this.reset():this._tap.touchend(e,t,i)&&(this._tapTime=e.timeStamp);}touchcancel(){this.reset();}enable(){this._enabled=!0;}disable(){this._enabled=!1,this.reset();}isEnabled(){return this._enabled}isActive(){return this._active}}class qn{constructor(e,t,i){this._el=e,this._mousePan=t,this._touchPan=i;}enable(e){this._inertiaOptions=e||{},this._mousePan.enable(),this._touchPan.enable(),this._el.classList.add("mapboxgl-touch-drag-pan");}disable(){this._mousePan.disable(),this._touchPan.disable(),this._el.classList.remove("mapboxgl-touch-drag-pan");}isEnabled(){return this._mousePan.isEnabled()&&this._touchPan.isEnabled()}isActive(){return this._mousePan.isActive()||this._touchPan.isActive()}}class $n{constructor(e,t,i){this._pitchWithRotate=e.pitchWithRotate,this._mouseRotate=t,this._mousePitch=i;}enable(){this._mouseRotate.enable(),this._pitchWithRotate&&this._mousePitch.enable();}disable(){this._mouseRotate.disable(),this._mousePitch.disable();}isEnabled(){return this._mouseRotate.isEnabled()&&(!this._pitchWithRotate||this._mousePitch.isEnabled())}isActive(){return this._mouseRotate.isActive()||this._mousePitch.isActive()}}class Xn{constructor(e,t,i,o){this._el=e,this._touchZoom=t,this._touchRotate=i,this._tapDragZoom=o,this._rotationDisabled=!1,this._enabled=!0;}enable(e){this._touchZoom.enable(e),this._rotationDisabled||this._touchRotate.enable(e),this._tapDragZoom.enable(),this._el.classList.add("mapboxgl-touch-zoom-rotate");}disable(){this._touchZoom.disable(),this._touchRotate.disable(),this._tapDragZoom.disable(),this._el.classList.remove("mapboxgl-touch-zoom-rotate");}isEnabled(){return this._touchZoom.isEnabled()&&(this._rotationDisabled||this._touchRotate.isEnabled())&&this._tapDragZoom.isEnabled()}isActive(){return this._touchZoom.isActive()||this._touchRotate.isActive()||this._tapDragZoom.isActive()}disableRotation(){this._rotationDisabled=!0,this._touchRotate.disable();}enableRotation(){this._rotationDisabled=!1,this._touchZoom.isEnabled()&&this._touchRotate.enable();}}const Kn=e=>e.zoom||e.drag||e.pitch||e.rotate;class Yn extends e.b{}class Jn{constructor(){this.constants=[1,1,.01],this.radius=0;}setup(t,i){const o=e.N.sub([],i,t);this.radius=e.N.length(o[2]<0?e.N.div([],o,this.constants):[o[0],o[1],0]);}projectRay(t){e.N.div(t,t,this.constants),e.N.normalize(t,t),e.N.mul(t,t,this.constants);const i=e.N.scale([],t,this.radius);if(i[2]>0){const t=e.N.scale([],[0,0,1],e.N.dot(i,[0,0,1])),o=e.N.scale([],e.N.normalize([],[i[0],i[1],0]),this.radius),r=e.N.add([],i,e.N.scale([],e.N.sub([],e.N.add([],o,t),i),2));i[0]=r[0],i[1]=r[1];}return i}}function Qn(e){return e.panDelta&&e.panDelta.mag()||e.zoomDelta||e.bearingDelta||e.pitchDelta}class ea{constructor(t,i){this._map=t,this._el=this._map.getCanvasContainer(),this._handlers=[],this._handlersById={},this._changes=[],this._inertia=new un(t),this._bearingSnap=i.bearingSnap,this._previousActiveHandlers={},this._trackingEllipsoid=new Jn,this._dragOrigin=null,this._eventsInProgress={},this._addDefaultHandlers(i),e.aY(["handleEvent","handleWindowEvent"],this);const o=this._el;this._listeners=[[o,"touchstart",{passive:!0}],[o,"touchmove",{passive:!1}],[o,"touchend",void 0],[o,"touchcancel",void 0],[o,"mousedown",void 0],[o,"mousemove",void 0],[o,"mouseup",void 0],[document,"mousemove",{capture:!0}],[document,"mouseup",void 0],[o,"mouseover",void 0],[o,"mouseout",void 0],[o,"dblclick",void 0],[o,"click",void 0],[o,"keydown",{capture:!1}],[o,"keyup",void 0],[o,"wheel",{passive:!1}],[o,"contextmenu",void 0],[window,"blur",void 0]];for(const[e,t,i]of this._listeners){const o=e===document?this.handleWindowEvent:this.handleEvent;e.addEventListener(t,o,i);}}destroy(){for(const[e,t,i]of this._listeners){const o=e===document?this.handleWindowEvent:this.handleEvent;e.removeEventListener(t,o,i);}}_addDefaultHandlers(e){const t=this._map,i=t.getCanvasContainer();this._add("mapEvent",new gn(t,e));const o=t.boxZoom=new xn(t,e);this._add("boxZoom",o);const r=new Tn,s=new Hn;t.doubleClickZoom=new Zn(s,r),this._add("tapZoom",r),this._add("clickZoom",s);const n=new Wn;this._add("tapDragZoom",n);const a=t.touchPitch=new Bn(t);this._add("touchPitch",a);const l=new In(e),c=new Dn(e);t.dragRotate=new $n(e,l,c),this._add("mouseRotate",l,["mousePitch"]),this._add("mousePitch",c,["mouseRotate"]);const h=new Cn(e),u=new Ln(t,e);t.dragPan=new qn(i,h,u),this._add("mousePan",h),this._add("touchPan",u,["touchZoom","touchRotate"]);const d=new On,_=new Mn;t.touchZoomRotate=new Xn(i,_,d,n),this._add("touchRotate",d,["touchPan","touchZoom"]),this._add("touchZoom",_,["touchPan","touchRotate"]),this._add("blockableMapEvent",new vn(t));const p=t.scrollZoom=new Vn(t,this);this._add("scrollZoom",p,["mousePan"]);const f=t.keyboard=new Nn;this._add("keyboard",f);for(const i of ["boxZoom","doubleClickZoom","tapDragZoom","touchPitch","dragRotate","dragPan","touchZoomRotate","scrollZoom","keyboard"])e.interactive&&e[i]&&t[i].enable(e[i]);}_add(e,t,i){this._handlers.push({handlerName:e,handler:t,allowed:i}),this._handlersById[e]=t;}stop(e){if(!this._updatingCamera){for(const{handler:e}of this._handlers)e.reset();this._inertia.clear(),this._fireEvents({},{},e),this._changes=[],this._originalZoom=void 0;}}isActive(){for(const{handler:e}of this._handlers)if(e.isActive())return !0;return !1}isZooming(){return !!this._eventsInProgress.zoom||this._map.scrollZoom.isZooming()}isRotating(){return !!this._eventsInProgress.rotate}isMoving(){return !!Kn(this._eventsInProgress)||this.isZooming()}_isDragging(){return !!this._eventsInProgress.drag}_blockedByActive(e,t,i){for(const o in e)if(o!==i&&(!t||t.indexOf(o)<0))return !0;return !1}handleWindowEvent(e){this.handleEvent(e,`${e.type}Window`);}_getMapTouches(e){const t=[];for(const i of e)this._el.contains(i.target)&&t.push(i);return t}handleEvent(e,t){this._updatingCamera=!0;const i="renderFrame"===e.type,o=i?void 0:e,r={needsRenderFrame:!1},s={},n={},a=e.touches?this._getMapTouches(e.touches):void 0,l=a?f(this._el,a):i?void 0:p(this._el,e);for(const{handlerName:i,handler:c,allowed:h}of this._handlers){if(!c.isEnabled())continue;let u;this._blockedByActive(n,h,i)?c.reset():c[t||e.type]&&(u=c[t||e.type](e,l,a),this.mergeHandlerResult(r,s,u,i,o),u&&u.needsRenderFrame&&this._triggerRenderFrame()),(u||c.isActive())&&(n[i]=c);}const c={};for(const e in this._previousActiveHandlers)n[e]||(c[e]=o);this._previousActiveHandlers=n,(Object.keys(c).length||Qn(r))&&(this._changes.push([r,s,c]),this._triggerRenderFrame()),(Object.keys(n).length||Qn(r))&&this._map._stop(!0),this._updatingCamera=!1;const{cameraAnimation:h}=r;h&&(this._inertia.clear(),this._fireEvents({},{},!0),this._changes=[],h(this._map));}mergeHandlerResult(t,i,o,r,s){if(!o)return;e.e(t,o);const n={handlerName:r,originalEvent:o.originalEvent||s};void 0!==o.zoomDelta&&(i.zoom=n),void 0!==o.panDelta&&(i.drag=n),void 0!==o.pitchDelta&&(i.pitch=n),void 0!==o.bearingDelta&&(i.rotate=n);}_applyChanges(){const t={},i={},o={};for(const[r,s,n]of this._changes)r.panDelta&&(t.panDelta=(t.panDelta||new e.P(0,0))._add(r.panDelta)),r.zoomDelta&&(t.zoomDelta=(t.zoomDelta||0)+r.zoomDelta),r.bearingDelta&&(t.bearingDelta=(t.bearingDelta||0)+r.bearingDelta),r.pitchDelta&&(t.pitchDelta=(t.pitchDelta||0)+r.pitchDelta),void 0!==r.around&&(t.around=r.around),void 0!==r.aroundCoord&&(t.aroundCoord=r.aroundCoord),void 0!==r.pinchAround&&(t.pinchAround=r.pinchAround),r.noInertia&&(t.noInertia=r.noInertia),e.e(i,s),e.e(o,n);this._updateMapTransform(t,i,o),this._changes=[];}_updateMapTransform(t,i,o){const r=this._map,s=r.transform,n=e=>[e.x,e.y,e.z];if((e=>{const t=this._eventsInProgress.drag;return t&&!this._handlersById[t.handlerName].isActive()})()&&!Qn(t)){const e=s.zoom;s.cameraElevationReference="sea",null!=this._originalZoom&&s._orthographicProjectionAtLowPitch&&"globe"!==s.projection.name&&0===s.pitch?(s.cameraElevationReference="ground",s.zoom=this._originalZoom):(s.recenterOnTerrain(),s.cameraElevationReference="ground"),e!==s.zoom&&this._map._update(!0);}if(s._isCameraConstrained&&r._stop(!0),!Qn(t))return void this._fireEvents(i,o,!0);let{panDelta:a,zoomDelta:l,bearingDelta:c,pitchDelta:h,around:u,aroundCoord:d,pinchAround:_}=t;s._isCameraConstrained&&(l>0&&(l=0),s._isCameraConstrained=!1),void 0!==_&&(u=_),(l||(e=>i[e]&&!this._eventsInProgress[e])("drag"))&&u&&(this._dragOrigin=n(s.pointCoordinate3D(u)),this._originalZoom=s.zoom,this._trackingEllipsoid.setup(s._camera.position,this._dragOrigin)),s.cameraElevationReference="sea",r._stop(!0),u=u||r.transform.centerPoint,c&&(s.bearing+=c),h&&(s.pitch+=h),s._updateCameraState();const p=[0,0,0];if(a)if("mercator"===s.projection.name){const e=this._trackingEllipsoid.projectRay(s.screenPointToMercatorRay(u).dir),t=this._trackingEllipsoid.projectRay(s.screenPointToMercatorRay(u.sub(a)).dir);p[0]=t[0]-e[0],p[1]=t[1]-e[1];}else {const t=s.pointCoordinate(u);if("globe"===s.projection.name){a=a.rotate(-s.angle);const i=s._pixelsPerMercatorPixel/s.worldSize;p[0]=-a.x*e.d1(e.au(t.y))*i,p[1]=-a.y*e.d1(s.center.lat)*i;}else {const e=s.pointCoordinate(u.sub(a));t&&e&&(p[0]=e.x-t.x,p[1]=e.y-t.y);}}const f=s.zoom,m=[0,0,0];if(l){const t=n(d||s.pointCoordinate3D(u)),i={dir:e.N.normalize([],e.N.sub([],t,s._camera.position))};if(i.dir[2]<0){const o=s.zoomDeltaToMovement(t,l);e.N.scale(m,i.dir,o);}}const g=e.N.add(p,p,m);s._translateCameraConstrained(g),l&&Math.abs(s.zoom-f)>1e-4&&s.recenterOnTerrain(),s.cameraElevationReference="ground",this._map._update(),t.noInertia||this._inertia.record(t),this._fireEvents(i,o,!0);}_fireEvents(t,i,o){const r=Kn(this._eventsInProgress),s=Kn(t),n={};for(const e in t){const{originalEvent:i}=t[e];this._eventsInProgress[e]||(n[`${e}start`]=i),this._eventsInProgress[e]=t[e];}!r&&s&&this._fireEvent("movestart",s.originalEvent);for(const e in n)this._fireEvent(e,n[e]);s&&this._fireEvent("move",s.originalEvent);for(const e in t){const{originalEvent:i}=t[e];this._fireEvent(e,i);}const a={};let l;for(const e in this._eventsInProgress){const{handlerName:t,originalEvent:o}=this._eventsInProgress[e];this._handlersById[t].isActive()||(delete this._eventsInProgress[e],l=i[t]||o,a[`${e}end`]=l);}for(const e in a)this._fireEvent(e,a[e]);const c=Kn(this._eventsInProgress);if(o&&(r||s)&&!c){this._updatingCamera=!0;const t=this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),i=e=>0!==e&&-this._bearingSnap<e&&e<this._bearingSnap;t?(i(t.bearing||this._map.getBearing())&&(t.bearing=0),this._map.easeTo(t,{originalEvent:l})):(this._map.fire(new e.b("moveend",{originalEvent:l})),i(this._map.getBearing())&&this._map.resetNorth()),this._updatingCamera=!1;}}_fireEvent(t,i){this._map.fire(new e.b(t,i?{originalEvent:i}:{}));}_requestFrame(){return this._map.triggerRepaint(),this._map._renderTaskQueue.add((e=>{this._frameId=void 0,this.handleEvent(new Yn("renderFrame",{timeStamp:e})),this._applyChanges();}))}_triggerRenderFrame(){void 0===this._frameId&&(this._frameId=this._requestFrame());}}const ta="map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";class ia extends e.E{constructor(t,i){super(),this._moving=!1,this._zooming=!1,this.transform=t,this._bearingSnap=i.bearingSnap,this._respectPrefersReducedMotion=!1!==i.respectPrefersReducedMotion,e.aY(["_renderFrameCallback"],this);}getCenter(){return new e.bn(this.transform.center.lng,this.transform.center.lat)}setCenter(e,t){return this.jumpTo({center:e},t)}panBy(t,i,o){return t=e.P.convert(t).mult(-1),this.panTo(this.transform.center,e.e({offset:t},i),o)}panTo(t,i,o){return this.easeTo(e.e({center:t},i),o)}getZoom(){return this.transform.zoom}setZoom(e,t){return this.jumpTo({zoom:e},t),this}zoomTo(t,i,o){return this.easeTo(e.e({zoom:t},i),o)}zoomIn(e,t){return this.zoomTo(this.getZoom()+1,e,t),this}zoomOut(e,t){return this.zoomTo(this.getZoom()-1,e,t),this}getBearing(){return this.transform.bearing}setBearing(e,t){return this.jumpTo({bearing:e},t),this}getPadding(){return this.transform.padding}setPadding(e,t){return this.jumpTo({padding:e},t),this}rotateTo(t,i,o){return this.easeTo(e.e({bearing:t},i),o)}resetNorth(t,i){return this.rotateTo(0,e.e({duration:1e3},t),i),this}resetNorthPitch(t,i){return this.easeTo(e.e({bearing:0,pitch:0,duration:1e3},t),i),this}snapToNorth(e,t){return Math.abs(this.getBearing())<this._bearingSnap?this.resetNorth(e,t):this}getPitch(){return this.transform.pitch}setPitch(e,t){return this.jumpTo({pitch:e},t),this}cameraForBounds(t,i){t=e.ad.convert(t);const o=i&&i.bearing||0,r=i&&i.pitch||0,s=t.getNorthWest(),n=t.getSouthEast();return this._cameraForBounds(this.transform,s,n,o,r,i)}_extendCameraOptions(t){const i={top:0,bottom:0,right:0,left:0};if("number"==typeof(t=e.e({padding:i,offset:[0,0],maxZoom:this.transform.maxZoom},t)).padding){const e=t.padding;t.padding={top:e,bottom:e,right:e,left:e};}return t.padding=e.e(i,t.padding),t}_minimumAABBFrustumDistance(e,t){const i=t.max[0]-t.min[0],o=t.max[1]-t.min[1];return i/o>e.aspect?i/(2*Math.tan(.5*e.fovX)*e.aspect):o/(2*Math.tan(.5*e.fovY)*e.aspect)}_cameraForBoundsOnGlobe(t,i,o,r,s,n){const a=t.clone(),l=this._extendCameraOptions(n);a.bearing=r,a.pitch=s;const c=e.bn.convert(i),h=e.bn.convert(o),u=.5*(c.lat+h.lat),d=.5*(c.lng+h.lng),_=e.d2(u,d),p=e.N.normalize([],_),f=e.N.normalize([],e.N.cross([],p,[0,1,0])),m=e.N.cross([],f,p),g=[f[0],f[1],f[2],0,m[0],m[1],m[2],0,p[0],p[1],p[2],0,0,0,0,1],v=[_,e.d2(c.lat,c.lng),e.d2(h.lat,c.lng),e.d2(h.lat,h.lng),e.d2(c.lat,h.lng),e.d2(u,c.lng),e.d2(u,h.lng),e.d2(c.lat,d),e.d2(h.lat,d)];let x=e.bS.fromPoints(v.map((t=>[e.N.dot(f,t),e.N.dot(m,t),e.N.dot(p,t)])));const y=e.N.transformMat4([],x.center,g);0===e.N.squaredLength(y)&&e.N.set(y,0,0,1),e.N.normalize(y,y),e.N.scale(y,y,e.ab),a.center=e.d3(y);const b=a.getWorldToCameraMatrix(),w=e.a6.invert(new Float64Array(16),b);x=e.bS.applyTransform(x,e.a6.multiply([],b,g)),e.N.transformMat4(y,y,b);const T=.5*(x.max[2]-x.min[2]),E=this._minimumAABBFrustumDistance(a,x),S=e.N.scale([],[0,0,1],T),C=e.N.add(S,y,S),I=E+(0===a.pitch?0:e.N.distance(y,C)),D=a.globeCenterInViewSpace,L=e.N.sub([],y,[D[0],D[1],D[2]]);e.N.normalize(L,L),e.N.scale(L,L,I);const A=e.N.add([],y,L);e.N.transformMat4(A,A,w);const R=e.d4/e.ab,P=e.N.length(A),M=e.bl(Math.max(P*R-e.d4,Number.EPSILON),0),z=Math.min(a.zoomFromMercatorZAdjusted(M),l.maxZoom);return z>.5*(e.bG+e.bx)?(a.setProjection({name:"mercator"}),a.zoom=z,this._cameraForBounds(a,i,o,r,s,n)):{center:a.center,zoom:z,bearing:r,pitch:s}}queryTerrainElevation(t,i){const o=this.transform.elevation;return o?(i=e.e({},{exaggerated:!0},i),o.getAtPoint(e.L.fromLngLat(t),null,i.exaggerated)):null}_cameraForBounds(t,i,o,r,s,n){if("globe"===t.projection.name)return this._cameraForBoundsOnGlobe(t,i,o,r,s,n);const a=t.clone(),l=this._extendCameraOptions(n),c=a.padding;a.bearing=r,a.pitch=s;const h=e.bn.convert(i),u=e.bn.convert(o),d=new e.bn(h.lng,u.lat),_=new e.bn(u.lng,h.lat),p=a.project(h),f=a.project(u),m=this.queryTerrainElevation(h),g=this.queryTerrainElevation(u),v=this.queryTerrainElevation(d),x=this.queryTerrainElevation(_),y=[[p.x,p.y,Math.min(m||0,g||0,v||0,x||0)],[f.x,f.y,Math.max(m||0,g||0,v||0,x||0)]];let b=e.bS.fromPoints(y);const w=a.getWorldToCameraMatrix(),T=e.a6.invert(new Float64Array(16),w);b=e.bS.applyTransform(b,w);const E=e.N.sub([],b.max,b.min),S=c.left||0,C=c.right||0,I=c.bottom||0,D=c.top||0,{left:L,right:A,top:R,bottom:P}=l.padding,M=.5*(S+C),z=.5*(D+I),O=Math.min(a.scaleZoom(a.scale*Math.min((a.width-(S+C+L+A))/E[0],(a.height-(I+D+P+R))/E[1])),l.maxZoom),F=a.scale/a.zoomScale(O);b=new e.bS([b.min[0]-(L+M)*F,b.min[1]-(P+z)*F,b.min[2]],[b.max[0]+(A+M)*F,b.max[1]+(R+z)*F,b.max[2]]);const B=.5*E[2],k=this._minimumAABBFrustumDistance(a,b),N=[0,0,1,0];e.a7.transformMat4(N,N,w),e.a7.normalize(N,N);const U=e.N.scale([],N,k+B),G=e.N.add([],b.center,U),j=("number"==typeof l.offset.x&&"number"==typeof l.offset.y?new e.P(l.offset.x,l.offset.y):e.P.convert(l.offset)).rotate(-e.bj(r));b.center[0]-=j.x*F,b.center[1]+=j.y*F,e.N.transformMat4(b.center,b.center,T),e.N.transformMat4(G,G,T);const V=[b.center[0],b.center[1],G[2]*a.pixelsPerMeter];e.N.scale(V,V,1/a.worldSize);const Z=e.at(V[0]),H=e.au(V[1]),W=Math.min(a._zoomFromMercatorZ(V[2]),l.maxZoom),q=new e.bn(Z,H);return a.mercatorFromTransition&&W<.5*(e.bG+e.bx)?(a.setProjection({name:"globe"}),a.zoom=W,this._cameraForBounds(a,i,o,r,s,n)):{center:q,zoom:W,bearing:r,pitch:s}}fitBounds(e,t,i){const o=this.cameraForBounds(e,t);return this._fitInternal(o,t,i)}fitScreenCoordinates(t,i,o,r,s){const n=e.P.convert(t),a=e.P.convert(i),l=new e.P(Math.min(n.x,a.x),Math.min(n.y,a.y)),c=new e.P(Math.max(n.x,a.x),Math.max(n.y,a.y));if("mercator"===this.transform.projection.name&&this.transform.anyCornerOffEdge(n,a))return this;const h=this.transform.pointLocation3D(l),u=this.transform.pointLocation3D(c),d=this.transform.pointLocation3D(new e.P(l.x,c.y)),_=this.transform.pointLocation3D(new e.P(c.x,l.y)),p=[Math.min(h.lng,u.lng,d.lng,_.lng),Math.min(h.lat,u.lat,d.lat,_.lat)],f=[Math.max(h.lng,u.lng,d.lng,_.lng),Math.max(h.lat,u.lat,d.lat,_.lat)],m=r&&r.pitch?r.pitch:this.getPitch(),g=this._cameraForBounds(this.transform,p,f,o,m,r);return this._fitInternal(g,r,s)}_fitInternal(t,i,o){return t?(delete(i=e.e(t,i)).padding,i.linear?this.easeTo(i,o):this.flyTo(i,o)):this}jumpTo(t,i){this.stop();const o=t.preloadOnly?this.transform.clone():this.transform;let r=!1,s=!1,n=!1;return "zoom"in t&&o.zoom!==+t.zoom&&(r=!0,o.zoom=+t.zoom),void 0!==t.center&&(o.center=e.bn.convert(t.center)),"bearing"in t&&o.bearing!==+t.bearing&&(s=!0,o.bearing=+t.bearing),"pitch"in t&&o.pitch!==+t.pitch&&(n=!0,o.pitch=+t.pitch),null==t.padding||o.isPaddingEqual(t.padding)||(o.padding=t.padding),t.preloadOnly?(this._preloadTiles(o),this):(this.fire(new e.b("movestart",i)).fire(new e.b("move",i)),r&&this.fire(new e.b("zoomstart",i)).fire(new e.b("zoom",i)).fire(new e.b("zoomend",i)),s&&this.fire(new e.b("rotatestart",i)).fire(new e.b("rotate",i)).fire(new e.b("rotateend",i)),n&&this.fire(new e.b("pitchstart",i)).fire(new e.b("pitch",i)).fire(new e.b("pitchend",i)),this.fire(new e.b("moveend",i)))}getFreeCameraOptions(){return this.transform.projection.supportsFreeCamera||e.w(ta),this.transform.getFreeCameraOptions()}setFreeCameraOptions(t,i){const o=this.transform;if(!o.projection.supportsFreeCamera)return e.w(ta),this;this.stop();const r=o.zoom,s=o.pitch,n=o.bearing;o.setFreeCameraOptions(t);const a=r!==o.zoom,l=s!==o.pitch,c=n!==o.bearing;return this.fire(new e.b("movestart",i)).fire(new e.b("move",i)),a&&this.fire(new e.b("zoomstart",i)).fire(new e.b("zoom",i)).fire(new e.b("zoomend",i)),c&&this.fire(new e.b("rotatestart",i)).fire(new e.b("rotate",i)).fire(new e.b("rotateend",i)),l&&this.fire(new e.b("pitchstart",i)).fire(new e.b("pitch",i)).fire(new e.b("pitchend",i)),this.fire(new e.b("moveend",i)),this}easeTo(t,i){this._stop(!1,t.easeId),(!1===(t=e.e({offset:[0,0],duration:500,easing:e.d0},t)).animate||this._prefersReducedMotion(t))&&(t.duration=0);const o=this.transform,r=this.getZoom(),s=this.getBearing(),n=this.getPitch(),a=this.getPadding(),l="zoom"in t?+t.zoom:r,c="bearing"in t?this._normalizeBearing(t.bearing,s):s,h="pitch"in t?+t.pitch:n,u="padding"in t?t.padding:o.padding,d=e.P.convert(t.offset);let _,p,f;if("globe"===o.projection.name){const i=e.L.fromLngLat(o.center),r=d.rotate(-o.angle);i.x+=r.x/o.worldSize,i.y+=r.y/o.worldSize;const s=i.toLngLat(),n=e.bn.convert(t.center||s);this._normalizeCenter(n),_=o.centerPoint.add(r),p=new e.P(i.x,i.y).mult(o.worldSize),f=new e.P(e.a5(n.lng),e.ae(n.lat)).mult(o.worldSize).sub(p);}else {_=o.centerPoint.add(d);const i=o.pointLocation(_),r=e.bn.convert(t.center||i);this._normalizeCenter(r),p=o.project(i),f=o.project(r).sub(p);}const m=o.zoomScale(l-r);let g,v;t.around&&(g=e.bn.convert(t.around),v=o.locationPoint(g));const x=this._zooming||l!==r,y=this._rotating||s!==c,b=this._pitching||h!==n,w=!o.isPaddingEqual(u),T=o=>T=>{if(x&&(o.zoom=e.U(r,l,T)),y&&(o.bearing=e.U(s,c,T)),b&&(o.pitch=e.U(n,h,T)),w&&(o.interpolatePadding(a,u,T),_=o.centerPoint.add(d)),g)o.setLocationAtPoint(g,v);else {const e=o.zoomScale(o.zoom-r),t=l>r?Math.min(2,m):Math.max(.5,m),i=Math.pow(t,1-T),s=o.unproject(p.add(f.mult(T*i)).mult(e));o.setLocationAtPoint(o.renderWorldCopies?s.wrap():s,_);}return t.preloadOnly||this._fireMoveEvents(i),o};if(t.preloadOnly){const e=this._emulate(T,t.duration,o);return this._preloadTiles(e),this}const E={moving:this._moving,zooming:this._zooming,rotating:this._rotating,pitching:this._pitching};return this._zooming=x,this._rotating=y,this._pitching=b,this._easeId=t.easeId,this._prepareEase(i,t.noMoveStart,E),this._ease(T(o),(e=>{"sea"===o.cameraElevationReference&&o.recenterOnTerrain(),this._afterEase(i,e);}),t),this}_prepareEase(t,i,o={}){this._moving=!0,this.transform.cameraElevationReference="sea",this.transform._orthographicProjectionAtLowPitch&&0===this.transform.pitch&&"globe"!==this.transform.projection.name&&(this.transform.cameraElevationReference="ground"),i||o.moving||this.fire(new e.b("movestart",t)),this._zooming&&!o.zooming&&this.fire(new e.b("zoomstart",t)),this._rotating&&!o.rotating&&this.fire(new e.b("rotatestart",t)),this._pitching&&!o.pitching&&this.fire(new e.b("pitchstart",t));}_fireMoveEvents(t){this.fire(new e.b("move",t)),this._zooming&&this.fire(new e.b("zoom",t)),this._rotating&&this.fire(new e.b("rotate",t)),this._pitching&&this.fire(new e.b("pitch",t));}_afterEase(t,i){if(this._easeId&&i&&this._easeId===i)return;this._easeId=void 0,this.transform.cameraElevationReference="ground";const o=this._zooming,r=this._rotating,s=this._pitching;this._moving=!1,this._zooming=!1,this._rotating=!1,this._pitching=!1,o&&this.fire(new e.b("zoomend",t)),r&&this.fire(new e.b("rotateend",t)),s&&this.fire(new e.b("pitchend",t)),this.fire(new e.b("moveend",t));}flyTo(t,i){if(this._prefersReducedMotion(t)){const o=e.ac(t,["center","zoom","bearing","pitch","around"]);return this.jumpTo(o,i)}this.stop(),t=e.e({offset:[0,0],speed:1.2,curve:1.42,easing:e.d0},t);const o=this.transform,r=this.getZoom(),s=this.getBearing(),n=this.getPitch(),a="zoom"in t?e.aa(+t.zoom,o.minZoom,o.maxZoom):r,l="bearing"in t?this._normalizeBearing(t.bearing,s):s,c="pitch"in t?+t.pitch:n,h=o.zoomScale(a-r),u=e.P.convert(t.offset),d=o.centerPoint.add(u),_=o.pointLocation(d);let p=t.center;if(p&&t.padding){const e=this._cameraForBounds(this.transform,p,p,l,c,t);e&&(p=e.center);}p=e.bn.convert(p||_),this._normalizeCenter(p);const f=o.project(_),m=o.project(p).sub(f);let g=t.curve;const v=Math.max(o.width,o.height),x=v/h,y=m.mag();if("minZoom"in t){const i=e.aa(Math.min(t.minZoom,r,a),o.minZoom,o.maxZoom),s=v/o.zoomScale(i-r);g=Math.sqrt(s/y*2);}const b=g*g;function w(e){const t=(x*x-v*v+(e?-1:1)*b*b*y*y)/(2*(e?x:v)*b*y);return Math.log(Math.sqrt(t*t+1)-t)}function T(e){return (Math.exp(e)-Math.exp(-e))/2}function E(e){return (Math.exp(e)+Math.exp(-e))/2}const S=w(0);let C=function(e){return E(S)/E(S+g*e)},I=function(e){return v*((E(S)*(T(t=S+g*e)/E(t))-T(S))/b)/y;var t;},D=(w(1)-S)/g;if(Math.abs(y)<1e-6||!isFinite(D)){if(Math.abs(v-x)<1e-6)return this.easeTo(t,i);const e=x<v?-1:1;D=Math.abs(Math.log(x/v))/g,I=function(){return 0},C=function(t){return Math.exp(e*g*t)};}t.duration="duration"in t?+t.duration:1e3*D/("screenSpeed"in t?+t.screenSpeed/g:+t.speed),t.maxDuration&&t.duration>t.maxDuration&&(t.duration=0);const L=s!==l,A=c!==n,R=o=>h=>{const u=h*D,_=1/C(u);o.zoom=1===h?a:r+o.scaleZoom(_),L&&(o.bearing=e.U(s,l,h)),A&&(o.pitch=e.U(n,c,h));const g=1===h?p:o.unproject(f.add(m.mult(I(u))).mult(_));return o.setLocationAtPoint(o.renderWorldCopies?g.wrap():g,d),o._updateCameraOnTerrain(),t.preloadOnly||this._fireMoveEvents(i),o};if(t.preloadOnly){const e=this._emulate(R,t.duration,o);return this._preloadTiles(e),this}return this._zooming=!0,this._rotating=L,this._pitching=A,this._prepareEase(i,!1),this._ease(R(o),(()=>this._afterEase(i)),t),this}isEasing(){return !!this._easeFrameId}stop(){return this._stop()}_stop(e,t){if(this._easeFrameId&&(this._cancelRenderFrame(this._easeFrameId),this._easeFrameId=void 0,this._onEaseFrame=void 0),this._onEaseEnd){const e=this._onEaseEnd;this._onEaseEnd=void 0,e.call(this,t);}if(!e){const e=this.handlers;e&&e.stop(!1);}return this}_ease(t,i,o){!1===o.animate||0===o.duration?(t(1),i()):(this._easeStart=e.f.now(),this._easeOptions=o,this._onEaseFrame=t,this._onEaseEnd=i,this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback));}_renderFrameCallback(){const t=Math.min((e.f.now()-this._easeStart)/this._easeOptions.duration,1),i=this._onEaseFrame;i&&i(this._easeOptions.easing(t)),t<1?this._easeFrameId=this._requestRenderFrame(this._renderFrameCallback):this.stop();}_normalizeBearing(t,i){t=e.bh(t,-180,180);const o=Math.abs(t-i);return Math.abs(t-360-i)<o&&(t-=360),Math.abs(t+360-i)<o&&(t+=360),t}_normalizeCenter(e){const t=this.transform;if(t.maxBounds)return;if("globe"!==t.projection.name&&!t.renderWorldCopies)return;const i=e.lng-t.center.lng;e.lng+=i>180?-360:i<-180?360:0;}_prefersReducedMotion(t){return this._respectPrefersReducedMotion&&e.f.prefersReducedMotion&&!(t&&t.essential)}_emulate(e,t,i){const o=Math.ceil(15*t/1e3),r=[],s=e(i.clone());for(let e=0;e<=o;e++){const t=s(e/o);r.push(t.clone());}return r}}class oa{constructor(t={}){this.options=t,e.aY(["_toggleAttribution","_updateEditLink","_updateData","_updateCompact"],this);}getDefaultPosition(){return "bottom-right"}onAdd(e){const t=this.options&&this.options.compact;return this._map=e,this._container=s("div","mapboxgl-ctrl mapboxgl-ctrl-attrib"),this._compactButton=s("button","mapboxgl-ctrl-attrib-button",this._container),s("span","mapboxgl-ctrl-icon",this._compactButton).setAttribute("aria-hidden","true"),this._compactButton.type="button",this._compactButton.addEventListener("click",this._toggleAttribution),this._setElementTitle(this._compactButton,"ToggleAttribution"),this._innerContainer=s("div","mapboxgl-ctrl-attrib-inner",this._container),t&&this._container.classList.add("mapboxgl-compact"),this._updateAttributions(),this._updateEditLink(),this._map.on("styledata",this._updateData),this._map.on("sourcedata",this._updateData),this._map.on("moveend",this._updateEditLink),void 0===t&&(this._map.on("resize",this._updateCompact),this._updateCompact()),this._container}onRemove(){this._container.remove(),this._map.off("styledata",this._updateData),this._map.off("sourcedata",this._updateData),this._map.off("moveend",this._updateEditLink),this._map.off("resize",this._updateCompact),this._map=void 0,this._attribHTML=void 0;}_setElementTitle(e,t){const i=this._map._getUIString(`AttributionControl.${t}`);e.removeAttribute("title"),e.firstElementChild&&e.firstElementChild.setAttribute("title",i);}_toggleAttribution(){this._container.classList.contains("mapboxgl-compact-show")?(this._container.classList.remove("mapboxgl-compact-show"),this._compactButton.setAttribute("aria-expanded","false")):(this._container.classList.add("mapboxgl-compact-show"),this._compactButton.setAttribute("aria-expanded","true"));}_updateEditLink(){let t=this._editLink;t||(t=this._editLink=this._container.querySelector(".mapbox-improve-map"));const i=[{key:"owner",value:this.styleOwner},{key:"id",value:this.styleId},{key:"access_token",value:this._map._requestManager._customAccessToken||e.d5.ACCESS_TOKEN}];if(t){const o=i.reduce(((e,t,o)=>(t.value&&(e+=`${t.key}=${t.value}${o<i.length-1?"&":""}`),e)),"?");t.href=`${e.d5.FEEDBACK_URL}/${o}#${sn(this._map,!0)}`,t.rel="noopener nofollow",this._setElementTitle(t,"MapFeedback");}}_updateData(e){!e||"metadata"!==e.sourceDataType&&"visibility"!==e.sourceDataType&&"style"!==e.dataType||(this._updateAttributions(),this._updateEditLink());}_updateAttributions(){if(!this._map.style)return;let e=[];if(this._map.style.stylesheet){const e=this._map.style.stylesheet;this.styleOwner=e.owner,this.styleId=e.id;}const t=this._map.style._mergedSourceCaches;for(const i in t){const o=t[i];if(o.used){const t=o.getSource();t.attribution&&e.indexOf(t.attribution)<0&&e.push(t.attribution);}}e.sort(((e,t)=>e.length-t.length)),e=e.filter(((t,i)=>{for(let o=i+1;o<e.length;o++)if(e[o].indexOf(t)>=0)return !1;return !0})),this.options.customAttribution&&(Array.isArray(this.options.customAttribution)?e=[...this.options.customAttribution,...e]:e.unshift(this.options.customAttribution));const i=e.join(" | ");i!==this._attribHTML&&(this._attribHTML=i,e.length?(this._innerContainer.innerHTML=i,this._container.classList.remove("mapboxgl-attrib-empty")):this._container.classList.add("mapboxgl-attrib-empty"),this._editLink=null);}_updateCompact(){this._map.getCanvasContainer().offsetWidth<=640?this._container.classList.add("mapboxgl-compact"):this._container.classList.remove("mapboxgl-compact","mapboxgl-compact-show");}}class ra{constructor(){e.aY(["_updateLogo","_updateCompact"],this);}onAdd(e){this._map=e,this._container=s("div","mapboxgl-ctrl");const t=s("a","mapboxgl-ctrl-logo");return t.target="_blank",t.rel="noopener nofollow",t.href="https://www.mapbox.com/",t.setAttribute("aria-label",this._map._getUIString("LogoControl.Title")),t.setAttribute("rel","noopener nofollow"),this._container.appendChild(t),this._container.style.display="none",this._map.on("sourcedata",this._updateLogo),this._updateLogo(),this._map.on("resize",this._updateCompact),this._updateCompact(),this._container}onRemove(){this._container.remove(),this._map.off("sourcedata",this._updateLogo),this._map.off("resize",this._updateCompact);}getDefaultPosition(){return "bottom-left"}_updateLogo(e){e&&"metadata"!==e.sourceDataType||(this._container.style.display=this._logoRequired()?"block":"none");}_logoRequired(){if(!this._map.style)return !0;const e=this._map.style._sourceCaches;if(0===Object.entries(e).length)return !0;for(const t in e){const i=e[t].getSource();if(i.hasOwnProperty("mapbox_logo")&&!i.mapbox_logo)return !1}return !0}_updateCompact(){const e=this._container.children;if(e.length){const t=e[0];this._map.getCanvasContainer().offsetWidth<250?t.classList.add("mapboxgl-compact"):t.classList.remove("mapboxgl-compact");}}}class sa{constructor(){this._queue=[],this._id=0,this._cleared=!1,this._currentlyRunning=!1;}add(e){const t=++this._id;return this._queue.push({callback:e,id:t,cancelled:!1}),t}remove(e){const t=this._currentlyRunning,i=t?this._queue.concat(t):this._queue;for(const t of i)if(t.id===e)return void(t.cancelled=!0)}run(e=0){const t=this._currentlyRunning=this._queue;this._queue=[];for(const i of t)if(!i.cancelled&&(i.callback(e),this._cleared))break;this._cleared=!1,this._currentlyRunning=!1;}clear(){this._currentlyRunning&&(this._cleared=!0),this._queue=[];}}function na(t,i,o){if(t=new e.bn(t.lng,t.lat),i){const r=new e.bn(t.lng-360,t.lat),s=new e.bn(t.lng+360,t.lat),n=360*Math.ceil(Math.abs(t.lng-o.center.lng)/360),a=o.locationPoint(t).distSqr(i),l=i.x<0||i.y<0||i.x>o.width||i.y>o.height;o.locationPoint(r).distSqr(i)<a&&(l||Math.abs(r.lng-o.center.lng)<n)?t=r:o.locationPoint(s).distSqr(i)<a&&(l||Math.abs(s.lng-o.center.lng)<n)&&(t=s);}for(;Math.abs(t.lng-o.center.lng)>180;){const e=o.locationPoint(t);if(e.x>=0&&e.y>=0&&e.x<=o.width&&e.y<=o.height)break;t.lng>o.center.lng?t.lng-=360:t.lng+=360;}return t}const aa={center:"translate(-50%,-50%)",top:"translate(-50%,0)","top-left":"translate(0,0)","top-right":"translate(-100%,0)",bottom:"translate(-50%,-100%)","bottom-left":"translate(0,-100%)","bottom-right":"translate(-100%,-100%)",left:"translate(0,-50%)",right:"translate(-100%,-50%)"};class la extends e.E{constructor(t,i){if(super(),(t instanceof HTMLElement||i)&&(t=e.e({element:t},i)),e.aY(["_update","_onMove","_onUp","_addDragHandler","_onMapClick","_onKeyPress","_clearFadeTimer"],this),this._anchor=t&&t.anchor||"center",this._color=t&&t.color||"#3FB1CE",this._scale=t&&t.scale||1,this._draggable=t&&t.draggable||!1,this._clickTolerance=t&&t.clickTolerance||0,this._isDragging=!1,this._state="inactive",this._rotation=t&&t.rotation||0,this._rotationAlignment=t&&t.rotationAlignment||"auto",this._pitchAlignment=t&&t.pitchAlignment&&t.pitchAlignment||"auto",this._updateMoving=()=>this._update(!0),this._occludedOpacity=t&&t.occludedOpacity||.2,t&&t.element)this._element=t.element,this._offset=e.P.convert(t&&t.offset||[0,0]);else {this._defaultMarker=!0,this._element=s("div");const i=41,o=27,r=n("svg",{display:"block",height:i*this._scale+"px",width:o*this._scale+"px",viewBox:`0 0 ${o} ${i}`},this._element),a=n("radialGradient",{id:"shadowGradient"},n("defs",{},r));n("stop",{offset:"10%","stop-opacity":.4},a),n("stop",{offset:"100%","stop-opacity":.05},a),n("ellipse",{cx:13.5,cy:34.8,rx:10.5,ry:5.25,fill:"url(#shadowGradient)"},r),n("path",{fill:this._color,d:"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"},r),n("path",{opacity:.25,d:"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"},r),n("circle",{fill:"white",cx:13.5,cy:13.5,r:5.5},r),this._offset=e.P.convert(t&&t.offset||[0,-14]);}this._element.hasAttribute("aria-label")||this._element.setAttribute("aria-label","Map marker"),this._element.hasAttribute("role")||this._element.setAttribute("role","img"),this._element.classList.add("mapboxgl-marker"),this._element.addEventListener("dragstart",(e=>{e.preventDefault();})),this._element.addEventListener("mousedown",(e=>{e.preventDefault();}));const o=this._element.classList;for(const e in aa)o.remove(`mapboxgl-marker-anchor-${e}`);o.add(`mapboxgl-marker-anchor-${this._anchor}`);const r=t&&t.className?t.className.trim().split(/\s+/):[];o.add(...r),this._popup=null;}addTo(e){return e===this._map||(this.remove(),this._map=e,e.getCanvasContainer().appendChild(this._element),e.on("move",this._updateMoving),e.on("moveend",this._update),e.on("remove",this._clearFadeTimer),e._addMarker(this),this.setDraggable(this._draggable),this._update(),e.on("click",this._onMapClick)),this}remove(){const e=this._map;return e&&(e.off("click",this._onMapClick),e.off("move",this._updateMoving),e.off("moveend",this._update),e.off("mousedown",this._addDragHandler),e.off("touchstart",this._addDragHandler),e.off("mouseup",this._onUp),e.off("touchend",this._onUp),e.off("mousemove",this._onMove),e.off("touchmove",this._onMove),e.off("remove",this._clearFadeTimer),e._removeMarker(this),this._map=void 0),this._clearFadeTimer(),this._element.remove(),this._popup&&this._popup.remove(),this}getLngLat(){return this._lngLat}setLngLat(t){return this._lngLat=e.bn.convert(t),this._pos=null,this._popup&&this._popup.setLngLat(this._lngLat),this._update(!0),this}getElement(){return this._element}setPopup(e){if(this._popup&&(this._popup.remove(),this._popup=null,this._element.removeAttribute("role"),this._element.removeEventListener("keypress",this._onKeyPress),this._originalTabIndex||this._element.removeAttribute("tabindex")),e){if(!("offset"in e.options)){const t=38.1,i=13.5,o=Math.sqrt(Math.pow(i,2)/2);e.options.offset=this._defaultMarker?{top:[0,0],"top-left":[0,0],"top-right":[0,0],bottom:[0,-t],"bottom-left":[o,-1*(t-i+o)],"bottom-right":[-o,-1*(t-i+o)],left:[i,-1*(t-i)],right:[-i,-1*(t-i)]}:this._offset;}this._popup=e,e._marker=this,this._lngLat&&this._popup.setLngLat(this._lngLat),this._element.setAttribute("role","button"),this._originalTabIndex=this._element.getAttribute("tabindex"),this._originalTabIndex||this._element.setAttribute("tabindex","0"),this._element.addEventListener("keypress",this._onKeyPress),this._element.setAttribute("aria-expanded","false");}return this}_onKeyPress(e){const t=e.code,i=e.charCode||e.keyCode;"Space"!==t&&"Enter"!==t&&32!==i&&13!==i||this.togglePopup();}_onMapClick(e){const t=e.originalEvent.target,i=this._element;this._popup&&(t===i||i.contains(t))&&this.togglePopup();}getPopup(){return this._popup}togglePopup(){const e=this._popup;return e?(e.isOpen()?(e.remove(),this._element.setAttribute("aria-expanded","false")):this._map&&(e.addTo(this._map),this._element.setAttribute("aria-expanded","true")),this):this}_behindTerrain(){const e=this._map,t=this._pos;if(!e||!t)return !1;const i=e.unproject(t),o=e.getFreeCameraOptions();if(!o.position)return !1;const r=o.position.toLngLat();return r.distanceTo(i)<.9*r.distanceTo(this._lngLat)}_evaluateOpacity(){const t=this._map;if(!t)return;const i=this._pos;if(!i||i.x<0||i.x>t.transform.width||i.y<0||i.y>t.transform.height)return void this._clearFadeTimer();const o=t.unproject(i);let r;t._showingGlobe()&&e.d6(t.transform,this._lngLat)?r=0:(r=1-t._queryFogOpacity(o),t.transform._terrainEnabled()&&t.getTerrain()&&this._behindTerrain()&&(r*=this._occludedOpacity)),this._element.style.opacity=`${r}`,this._element.style.pointerEvents=r>0?"auto":"none",this._popup&&this._popup._setOpacity(r),this._fadeTimer=null;}_clearFadeTimer(){this._fadeTimer&&(clearTimeout(this._fadeTimer),this._fadeTimer=null);}_updateDOM(){const e=this._pos;if(!e||!this._map)return;const t=this._offset.mult(this._scale);this._element.style.transform=`\n            translate(${e.x}px,${e.y}px)\n            ${aa[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t.x}px,${t.y}px)\n        `;}_calculateXYTransform(){const t=this._pos,i=this._map,o=this.getPitchAlignment();if(!i||!t||"map"!==o)return "";if(!i._showingGlobe()){const e=i.getPitch();return e?`rotateX(${e}deg)`:""}const r=e.bF(e.d7(i.transform,this._lngLat)),s=t.sub(e.d8(i.transform)),n=Math.abs(s.x)+Math.abs(s.y);if(0===n)return "";const a=r/n;return `rotateX(${-s.y*a}deg) rotateY(${s.x*a}deg)`}_calculateZTransform(){const t=this._pos,i=this._map;if(!i||!t)return "";let o=0;const r=this.getRotationAlignment();if("map"===r)if(i._showingGlobe()){const t=i.project(new e.bn(this._lngLat.lng,this._lngLat.lat+.001)),r=i.project(new e.bn(this._lngLat.lng,this._lngLat.lat-.001)).sub(t);o=e.bF(Math.atan2(r.y,r.x))-90;}else o=-i.getBearing();else if("horizon"===r){const r=e.O(4,6,i.getZoom()),s=e.d8(i.transform);s.y+=r*i.transform.height;const n=t.sub(s),a=e.bF(Math.atan2(n.y,n.x));o=(a>90?a-270:a+90)*(1-r);}return o+=this._rotation,o?`rotateZ(${o}deg)`:""}_update(e){cancelAnimationFrame(this._updateFrameId);const t=this._map;t&&(t.transform.renderWorldCopies&&(this._lngLat=na(this._lngLat,this._pos,t.transform)),this._pos=t.project(this._lngLat),!0===e?this._updateFrameId=requestAnimationFrame((()=>{this._element&&this._pos&&this._anchor&&(this._pos=this._pos.round(),this._updateDOM());})):this._pos=this._pos.round(),t._requestDomTask((()=>{this._map&&(this._element&&this._pos&&this._anchor&&this._updateDOM(),(t._showingGlobe()||t.getTerrain()||t.getFog())&&!this._fadeTimer&&(this._fadeTimer=setTimeout(this._evaluateOpacity.bind(this),60)));})));}getOffset(){return this._offset}setOffset(t){return this._offset=e.P.convert(t),this._update(),this}addClassName(e){return this._element.classList.add(e),this}removeClassName(e){return this._element.classList.remove(e),this}toggleClassName(e){return this._element.classList.toggle(e)}_onMove(t){const i=this._map;if(!i)return;const o=this._pointerdownPos,r=this._positionDelta;if(o&&r){if(!this._isDragging){const e=this._clickTolerance||i._clickTolerance;if(t.point.dist(o)<e)return;this._isDragging=!0;}this._pos=t.point.sub(r),this._lngLat=i.unproject(this._pos),this.setLngLat(this._lngLat),this._element.style.pointerEvents="none","pending"===this._state&&(this._state="active",this.fire(new e.b("dragstart"))),this.fire(new e.b("drag"));}}_onUp(){this._element.style.pointerEvents="auto",this._positionDelta=null,this._pointerdownPos=null,this._isDragging=!1;const t=this._map;t&&(t.off("mousemove",this._onMove),t.off("touchmove",this._onMove)),"active"===this._state&&this.fire(new e.b("dragend")),this._state="inactive";}_addDragHandler(e){const t=this._map,i=this._pos;t&&i&&this._element.contains(e.originalEvent.target)&&(e.preventDefault(),this._positionDelta=e.point.sub(i),this._pointerdownPos=e.point,this._state="pending",t.on("mousemove",this._onMove),t.on("touchmove",this._onMove),t.once("mouseup",this._onUp),t.once("touchend",this._onUp));}setDraggable(e){this._draggable=!!e;const t=this._map;return t&&(e?(t.on("mousedown",this._addDragHandler),t.on("touchstart",this._addDragHandler)):(t.off("mousedown",this._addDragHandler),t.off("touchstart",this._addDragHandler))),this}isDraggable(){return this._draggable}setRotation(e){return this._rotation=e||0,this._update(),this}getRotation(){return this._rotation}setRotationAlignment(e){return this._rotationAlignment=e||"auto",this._update(),this}getRotationAlignment(){return "auto"===this._rotationAlignment||"horizon"===this._rotationAlignment&&this._map&&!this._map._showingGlobe()?"viewport":this._rotationAlignment}setPitchAlignment(e){return this._pitchAlignment=e||"auto",this._update(),this}getPitchAlignment(){return "auto"===this._pitchAlignment?this.getRotationAlignment():this._pitchAlignment}setOccludedOpacity(e){return this._occludedOpacity=e||.2,this._update(),this}getOccludedOpacity(){return this._occludedOpacity}}const ca={closeButton:!0,closeOnClick:!0,focusAfterOpen:!0,className:"",maxWidth:"240px"},ha=["a[href]","[tabindex]:not([tabindex='-1'])","[contenteditable]:not([contenteditable='false'])","button:not([disabled])","input:not([disabled])","select:not([disabled])","textarea:not([disabled])"].join(", ");function ua(t=new e.P(0,0),i="bottom"){if("number"==typeof t){const o=Math.round(Math.sqrt(.5*Math.pow(t,2)));switch(i){case"top":return new e.P(0,t);case"top-left":return new e.P(o,o);case"top-right":return new e.P(-o,o);case"bottom":return new e.P(0,-t);case"bottom-left":return new e.P(o,-o);case"bottom-right":return new e.P(-o,-o);case"left":return new e.P(t,0);case"right":return new e.P(-t,0)}return new e.P(0,0)}return t instanceof e.P||Array.isArray(t)?e.P.convert(t):e.P.convert(t[i]||[0,0])}class da{constructor(e){this.jumpTo(e);}getValue(t){if(t<=this._startTime)return this._start;if(t>=this._endTime)return this._end;const i=e.cc((t-this._startTime)/(this._endTime-this._startTime));return this._start*(1-i)+this._end*i}isEasing(e){return e>=this._startTime&&e<=this._endTime}jumpTo(e){this._startTime=-1/0,this._endTime=-1/0,this._start=e,this._end=e;}easeTo(e,t,i){this._start=this.getValue(t),this._end=e,this._startTime=t,this._endTime=t+i;}}const _a={"AttributionControl.ToggleAttribution":"Toggle attribution","AttributionControl.MapFeedback":"Map feedback","FullscreenControl.Enter":"Enter fullscreen","FullscreenControl.Exit":"Exit fullscreen","GeolocateControl.FindMyLocation":"Find my location","GeolocateControl.LocationNotAvailable":"Location not available","LogoControl.Title":"Mapbox logo","Map.Title":"Map","NavigationControl.ResetBearing":"Reset bearing to north","NavigationControl.ZoomIn":"Zoom in","NavigationControl.ZoomOut":"Zoom out","ScrollZoomBlocker.CtrlMessage":"Use ctrl + scroll to zoom the map","ScrollZoomBlocker.CmdMessage":"Use ⌘ + scroll to zoom the map","TouchPanBlocker.Message":"Use two fingers to move the map"},pa={center:[0,0],zoom:0,bearing:0,pitch:0,minZoom:-2,maxZoom:22,minPitch:0,maxPitch:85,interactive:!0,scrollZoom:!0,boxZoom:!0,dragRotate:!0,dragPan:!0,keyboard:!0,doubleClickZoom:!0,touchZoomRotate:!0,touchPitch:!0,cooperativeGestures:!1,performanceMetricsCollection:!0,bearingSnap:7,clickTolerance:3,pitchWithRotate:!0,hash:!1,attributionControl:!0,antialias:!1,failIfMajorPerformanceCaveat:!1,preserveDrawingBuffer:!1,trackResize:!0,renderWorldCopies:!0,refreshExpiredTiles:!0,minTileCacheSize:null,maxTileCacheSize:null,localIdeographFontFamily:"sans-serif",localFontFamily:null,transformRequest:null,accessToken:null,fadeDuration:300,respectPrefersReducedMotion:!0,crossSourceCollisions:!0,collectResourceTiming:!1,testMode:!1};class fa{constructor(){this.showOverdrawInspector=!1,this.showTileBoundaries=!1,this.showParseStatus=!1,this.continuousRedraw=!1,this.showTileAABBs=!1,this.showPadding=!1,this.showTerrainWireframe=!1,this.showLayers2DWireframe=!1,this.showLayers3DWireframe=!1;}}const ma={showCompass:!0,showZoom:!0,visualizePitch:!1};class ga{constructor(t,i,o=!1){this._clickTolerance=10,this.element=i,this.mouseRotate=new In({clickTolerance:t.dragRotate._mouseRotate._clickTolerance}),this.map=t,o&&(this.mousePitch=new Dn({clickTolerance:t.dragRotate._mousePitch._clickTolerance})),e.aY(["mousedown","mousemove","mouseup","touchstart","touchmove","touchend","reset"],this),i.addEventListener("mousedown",this.mousedown),i.addEventListener("touchstart",this.touchstart,{passive:!1}),i.addEventListener("touchmove",this.touchmove),i.addEventListener("touchend",this.touchend),i.addEventListener("touchcancel",this.reset);}down(e,t){this.mouseRotate.mousedown(e,t),this.mousePitch&&this.mousePitch.mousedown(e,t),h();}move(e,t){const i=this.map,o=this.mouseRotate.mousemoveWindow(e,t),r=o&&o.bearingDelta;if(r&&i.setBearing(i.getBearing()+r),this.mousePitch){const o=this.mousePitch.mousemoveWindow(e,t),r=o&&o.pitchDelta;r&&i.setPitch(i.getPitch()+r);}}off(){const e=this.element;e.removeEventListener("mousedown",this.mousedown),e.removeEventListener("touchstart",this.touchstart,{passive:!1}),e.removeEventListener("touchmove",this.touchmove),e.removeEventListener("touchend",this.touchend),e.removeEventListener("touchcancel",this.reset),this.offTemp();}offTemp(){u(),window.removeEventListener("mousemove",this.mousemove),window.removeEventListener("mouseup",this.mouseup);}mousedown(t){this.down(e.e({},t,{ctrlKey:!0,preventDefault:()=>t.preventDefault()}),p(this.element,t)),window.addEventListener("mousemove",this.mousemove),window.addEventListener("mouseup",this.mouseup);}mousemove(e){this.move(e,p(this.element,e));}mouseup(e){this.mouseRotate.mouseupWindow(e),this.mousePitch&&this.mousePitch.mouseupWindow(e),this.offTemp();}touchstart(e){1!==e.targetTouches.length?this.reset():(this._startPos=this._lastPos=f(this.element,e.targetTouches)[0],this.down({type:"mousedown",button:0,ctrlKey:!0,preventDefault:()=>e.preventDefault()},this._startPos));}touchmove(e){1!==e.targetTouches.length?this.reset():(this._lastPos=f(this.element,e.targetTouches)[0],this.move({preventDefault:()=>e.preventDefault()},this._lastPos));}touchend(e){0===e.targetTouches.length&&this._startPos&&this._lastPos&&this._startPos.dist(this._lastPos)<this._clickTolerance&&this.element.click(),this.reset();}reset(){this.mouseRotate.reset(),this.mousePitch&&this.mousePitch.reset(),delete this._startPos,delete this._lastPos,this.offTemp();}}const va={positionOptions:{enableHighAccuracy:!1,maximumAge:0,timeout:6e3},fitBoundsOptions:{maxZoom:15},trackUserLocation:!1,showAccuracyCircle:!0,showUserLocation:!0,showUserHeading:!1},xa={maxWidth:100,unit:"metric"},ya={kilometer:"km",meter:"m",mile:"mi",foot:"ft","nautical-mile":"nm"},ba={version:e.dk,supported:i,setRTLTextPlugin:e.dm,getRTLTextPluginStatus:e.dn,Map:class extends ia{constructor(t){const i=t;if(null!=(t=e.e({},pa,t)).minZoom&&null!=t.maxZoom&&t.minZoom>t.maxZoom)throw new Error("maxZoom must be greater than or equal to minZoom");if(null!=t.minPitch&&null!=t.maxPitch&&t.minPitch>t.maxPitch)throw new Error("maxPitch must be greater than or equal to minPitch");if(null!=t.minPitch&&t.minPitch<0)throw new Error("minPitch must be greater than or equal to 0");if(null!=t.maxPitch&&t.maxPitch>85)throw new Error("maxPitch must be less than or equal to 85");if(t.antialias&&e.d9(window)&&(t.antialias=!1,e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")),super(new mo(t.minZoom,t.maxZoom,t.minPitch,t.maxPitch,t.renderWorldCopies),t),this._repaint=!1,this._interactive=t.interactive,this._minTileCacheSize=t.minTileCacheSize,this._maxTileCacheSize=t.maxTileCacheSize,this._failIfMajorPerformanceCaveat=t.failIfMajorPerformanceCaveat,this._preserveDrawingBuffer=t.preserveDrawingBuffer,this._antialias=t.antialias,this._trackResize=t.trackResize,this._bearingSnap=t.bearingSnap,this._refreshExpiredTiles=t.refreshExpiredTiles,this._fadeDuration=t.fadeDuration,this._isInitialLoad=!0,this._crossSourceCollisions=t.crossSourceCollisions,this._collectResourceTiming=t.collectResourceTiming,this._language=this._parseLanguage(t.language),this._worldview=t.worldview,this._renderTaskQueue=new sa,this._domRenderTaskQueue=new sa,this._controls=[],this._markers=[],this._popups=[],this._mapId=e.aC(),this._locale=e.e({},_a,t.locale),this._clickTolerance=t.clickTolerance,this._cooperativeGestures=t.cooperativeGestures,this._performanceMetricsCollection=t.performanceMetricsCollection,this._containerWidth=0,this._containerHeight=0,this._showParseStatus=!0,this._averageElevationLastSampledAt=-1/0,this._averageElevationExaggeration=0,this._averageElevation=new da(0),this._interactionRange=[1/0,-1/0],this._visibilityHidden=0,this._useExplicitProjection=!1,this._requestManager=new e.da(t.transformRequest,t.accessToken,t.testMode),this._silenceAuthErrors=!!t.testMode,this._contextCreateOptions=t.contextCreateOptions?{...t.contextCreateOptions}:{},"string"==typeof t.container){const e=document.getElementById(t.container);if(!e)throw new Error(`Container '${t.container.toString()}' not found.`);this._container=e;}else {if(!(t.container instanceof HTMLElement))throw new Error("Invalid type: 'container' must be a String or HTMLElement.");this._container=t.container;}if(this._container.childNodes.length>0&&e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."),t.maxBounds&&this.setMaxBounds(t.maxBounds),e.aY(["_onWindowOnline","_onWindowResize","_onVisibilityChange","_onMapScroll","_contextLost","_contextRestored"],this),this._setupContainer(),this._debugParams=new fa,this._tp=t.devtools?new Js(this):new Js,this._tp.registerParameter(this._debugParams,["Debug"],"showOverdrawInspector",void 0,(()=>{this._update();})),this._tp.registerParameter(this._debugParams,["Debug"],"showTileBoundaries",void 0,(()=>{this._update();})),this._tp.registerParameter(this._debugParams,["Debug"],"showParseStatus",void 0,(()=>{this._update();})),this._tp.registerParameter(this._debugParams,["Debug"],"continuousRedraw",void 0,(e=>{this.repaint=e;})),this._tp.registerParameter(this._debugParams,["Debug"],"showTileAABBs",void 0,(e=>{this.showTileAABBs=e;})),this._tp.registerParameter(this._debugParams,["Debug"],"showPadding",void 0,(e=>{this.showPadding=e;})),this._tp.registerParameter(this._debugParams,["Debug","Wireframe"],"showTerrainWireframe",void 0,(()=>{this._update();})),this._tp.registerParameter(this._debugParams,["Debug","Wireframe"],"showLayers2DWireframe",void 0,(()=>{this._update();})),this._tp.registerParameter(this._debugParams,["Debug","Wireframe"],"showLayers3DWireframe",void 0,(()=>{this._update();})),this._setupPainter(),void 0===this.painter)throw new Error("Failed to initialize WebGL.");if(this.on("move",(()=>this._update(!1))),this.on("moveend",(()=>this._update(!1))),this.on("zoom",(()=>this._update(!0))),this._fullscreenchangeEvent="onfullscreenchange"in document?"fullscreenchange":"webkitfullscreenchange",window.addEventListener("online",this._onWindowOnline,!1),window.addEventListener("resize",this._onWindowResize,!1),window.addEventListener("orientationchange",this._onWindowResize,!1),window.addEventListener(this._fullscreenchangeEvent,this._onWindowResize,!1),window.addEventListener("visibilitychange",this._onVisibilityChange,!1),this.handlers=new ea(this,t),this._localFontFamily=t.localFontFamily,this._localIdeographFontFamily=t.localIdeographFontFamily,(t.style||!t.testMode)&&this.setStyle(t.style||e.d5.DEFAULT_STYLE,{localFontFamily:this._localFontFamily,localIdeographFontFamily:this._localIdeographFontFamily}),t.projection&&this.setProjection(t.projection),t.hash&&(this._hash=new rn("string"==typeof t.hash&&t.hash||void 0).addTo(this)),!this._hash||!this._hash._onHashChange()){null==i.center&&null==i.zoom||(this.transform._unmodified=!1),this.jumpTo({center:t.center,zoom:t.zoom,bearing:t.bearing,pitch:t.pitch});const o=t.bounds;o&&(this.resize(),this.fitBounds(o,e.e({},t.fitBoundsOptions,{duration:0})));}this.resize(),t.attributionControl&&this.addControl(new oa({customAttribution:t.customAttribution})),this._logoControl=new ra,this.addControl(this._logoControl,t.logoPosition),this.on("style.load",(()=>{this.transform.unmodified&&this.jumpTo(this.style.stylesheet);})),this.on("data",(t=>{this._update("style"===t.dataType),this.fire(new e.b(`${t.dataType}data`,t));})),this.on("dataloading",(t=>{this.fire(new e.b(`${t.dataType}dataloading`,t));}));}_getMapId(){return this._mapId}addControl(t,i){if(void 0===i&&(i=t.getDefaultPosition?t.getDefaultPosition():"top-right"),!t||!t.onAdd)return this.fire(new e.a(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));const o=t.onAdd(this);this._controls.push(t);const r=this._controlPositions[i];return -1!==i.indexOf("bottom")?r.insertBefore(o,r.firstChild):r.appendChild(o),this}removeControl(t){if(!t||!t.onRemove)return this.fire(new e.a(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));const i=this._controls.indexOf(t);return i>-1&&this._controls.splice(i,1),t.onRemove(this),this}hasControl(e){return this._controls.indexOf(e)>-1}getContainer(){return this._container}getCanvasContainer(){return this._canvasContainer}getCanvas(){return this._canvas}resize(t){if(this._updateContainerDimensions(),this._containerWidth===this.transform.width&&this._containerHeight===this.transform.height)return this;this._resizeCanvas(this._containerWidth,this._containerHeight),this.transform.resize(this._containerWidth,this._containerHeight),this.painter.resize(Math.ceil(this._containerWidth),Math.ceil(this._containerHeight));const i=!this._moving;return i&&this.fire(new e.b("movestart",t)).fire(new e.b("move",t)),this.fire(new e.b("resize",t)),i&&this.fire(new e.b("moveend",t)),this}getBounds(){return this.transform.getBounds()}getMaxBounds(){return this.transform.getMaxBounds()||null}setMaxBounds(t){return this.transform.setMaxBounds(e.ad.convert(t)),this._update()}setMinZoom(t){if((t=null==t?-2:t)>=-2&&t<=this.transform.maxZoom)return this.transform.minZoom=t,this._update(),this.getZoom()<t?this.setZoom(t):this.fire(new e.b("zoomstart")).fire(new e.b("zoom")).fire(new e.b("zoomend")),this;throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")}getMinZoom(){return this.transform.minZoom}setMaxZoom(t){if((t=null==t?22:t)>=this.transform.minZoom)return this.transform.maxZoom=t,this._update(),this.getZoom()>t?this.setZoom(t):this.fire(new e.b("zoomstart")).fire(new e.b("zoom")).fire(new e.b("zoomend")),this;throw new Error("maxZoom must be greater than the current minZoom")}getMaxZoom(){return this.transform.maxZoom}setMinPitch(t){if((t=null==t?0:t)<0)throw new Error("minPitch must be greater than or equal to 0");if(t>=0&&t<=this.transform.maxPitch)return this.transform.minPitch=t,this._update(),this.getPitch()<t?this.setPitch(t):this.fire(new e.b("pitchstart")).fire(new e.b("pitch")).fire(new e.b("pitchend")),this;throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")}getMinPitch(){return this.transform.minPitch}setMaxPitch(t){if((t=null==t?85:t)>85)throw new Error("maxPitch must be less than or equal to 85");if(t>=this.transform.minPitch)return this.transform.maxPitch=t,this._update(),this.getPitch()>t?this.setPitch(t):this.fire(new e.b("pitchstart")).fire(new e.b("pitch")).fire(new e.b("pitchend")),this;throw new Error("maxPitch must be greater than or equal to minPitch")}getMaxPitch(){return this.transform.maxPitch}getRenderWorldCopies(){return this.transform.renderWorldCopies}setRenderWorldCopies(e){return this.transform.renderWorldCopies=e,this.transform.renderWorldCopies||this._forceMarkerAndPopupUpdate(!0),this._update()}getLanguage(){return this._language}_parseLanguage(e){return "auto"===e?navigator.language:Array.isArray(e)?0===e.length?void 0:e.map((e=>"auto"===e?navigator.language:e)):e}setLanguage(e){const t=this._parseLanguage(e);if(!this.style||t===this._language)return this;this._language=t,this.style.reloadSources();for(const e of this._controls)e._setLanguage&&e._setLanguage(this._language);return this}getWorldview(){return this._worldview}setWorldview(e){return this.style&&e!==this._worldview?(this._worldview=e,this.style.reloadSources(),this):this}getProjection(){return this.transform.mercatorFromTransition?{name:"globe",center:[0,0]}:this.transform.getProjection()}_showingGlobe(){return "globe"===this.transform.projection.name}setProjection(e){return this._lazyInitEmptyStyle(),e?"string"==typeof e&&(e={name:e}):e=null,this._useExplicitProjection=!!e,this._prioritizeAndUpdateProjection(e,this.style.projection)}_updateProjectionTransition(){if("globe"!==this.getProjection().name)return;const t=this.transform,i=t.projection.name;let o;"globe"===i&&t.zoom>=e.bx?(t.setMercatorFromTransition(),o=!0):"mercator"===i&&t.zoom<e.bx&&(t.setProjection({name:"globe"}),o=!0),o&&(this.style.applyProjectionUpdate(),this.style._forceSymbolLayerUpdate());}_prioritizeAndUpdateProjection(e,t){return this._updateProjection(e||t||{name:"mercator"})}_updateProjection(t){let i;return i="globe"===t.name&&this.transform.zoom>=e.bx?this.transform.setMercatorFromTransition():this.transform.setProjection(t),this.style.applyProjectionUpdate(),i&&(this.painter.clearBackgroundTiles(),this.style.clearSources(),this._update(!0),this._forceMarkerAndPopupUpdate(!0)),this}project(t){return this.transform.locationPoint3D(e.bn.convert(t))}unproject(t){return this.transform.pointLocation3D(e.P.convert(t))}isMoving(){return this._moving||this.handlers&&this.handlers.isMoving()||!1}isZooming(){return this._zooming||this.handlers&&this.handlers.isZooming()||!1}isRotating(){return this._rotating||this.handlers&&this.handlers.isRotating()||!1}_isDragging(){return this.handlers&&this.handlers._isDragging()||!1}_createDelegatedListener(e,t,i){if("mouseenter"===e||"mouseover"===e){let o=!1;const r=r=>{const s=t.filter((e=>this.getLayer(e))),n=s.length?this.queryRenderedFeatures(r.point,{layers:s}):[];n.length?o||(o=!0,i.call(this,new pn(e,this,r.originalEvent,{features:n}))):o=!1;},s=()=>{o=!1;};return {layers:new Set(t),listener:i,delegates:{mousemove:r,mouseout:s}}}if("mouseleave"===e||"mouseout"===e){let o=!1;const r=r=>{const s=t.filter((e=>this.getLayer(e)));(s.length?this.queryRenderedFeatures(r.point,{layers:s}):[]).length?o=!0:o&&(o=!1,i.call(this,new pn(e,this,r.originalEvent)));},s=t=>{o&&(o=!1,i.call(this,new pn(e,this,t.originalEvent)));};return {layers:new Set(t),listener:i,delegates:{mousemove:r,mouseout:s}}}{const o=e=>{const o=t.filter((e=>this.getLayer(e))),r=o.length?this.queryRenderedFeatures(e.point,{layers:o}):[];r.length&&(e.features=r,i.call(this,e),delete e.features);};return {layers:new Set(t),listener:i,delegates:{[e]:o}}}}on(e,t,i){if(void 0===i)return super.on(e,t);if(Array.isArray(t)||(t=[t]),t)for(const e of t)if(!this._isValidId(e))return this;const o=this._createDelegatedListener(e,t,i);this._delegatedListeners=this._delegatedListeners||{},this._delegatedListeners[e]=this._delegatedListeners[e]||[],this._delegatedListeners[e].push(o);for(const e in o.delegates)this.on(e,o.delegates[e]);return this}once(e,t,i){if(void 0===i)return super.once(e,t);if(Array.isArray(t)||(t=[t]),t)for(const e of t)if(!this._isValidId(e))return this;const o=this._createDelegatedListener(e,t,i);for(const e in o.delegates)this.once(e,o.delegates[e]);return this}off(e,t,i){if(void 0===i)return super.off(e,t);t=new Set(Array.isArray(t)?t:[t]);for(const e of t)if(!this._isValidId(e))return this;const o=(e,t)=>{if(e.size!==t.size)return !1;for(const i of e)if(!t.has(i))return !1;return !0},r=this._delegatedListeners?this._delegatedListeners[e]:void 0;return r&&(e=>{for(let r=0;r<e.length;r++){const s=e[r];if(s.listener===i&&o(s.layers,t)){for(const e in s.delegates)this.off(e,s.delegates[e]);return e.splice(r,1),this}}})(r),this}queryRenderedFeatures(t,i){if(!this.style)return [];if(void 0!==i||void 0===t||t instanceof e.P||Array.isArray(t)||(i=t,t=void 0),t=t||[[0,0],[this.transform.width,this.transform.height]],(i=i||{}).layers&&Array.isArray(i.layers))for(const e of i.layers)if(!this._isValidId(e))return [];return this.style.queryRenderedFeatures(t,i,this.transform)}querySourceFeatures(e,t){return this._isValidId(e)?this.style.querySourceFeatures(e,t):[]}isPointOnSurface(t){const{name:i}=this.transform.projection;return "globe"!==i&&"mercator"!==i&&e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`),this.transform.isPointOnSurface(e.P.convert(t))}setStyle(t,i){return !1!==(i=e.e({},{localIdeographFontFamily:this._localIdeographFontFamily,localFontFamily:this._localFontFamily},i)).diff&&i.localIdeographFontFamily===this._localIdeographFontFamily&&i.localFontFamily===this._localFontFamily&&this.style&&t?(this._diffStyle(t,i),this):(this._localIdeographFontFamily=i.localIdeographFontFamily,this._localFontFamily=i.localFontFamily,this._updateStyle(t,i))}_getUIString(e){const t=this._locale[e];if(null==t)throw new Error(`Missing UI string '${e}'`);return t}_updateStyle(e,t){return this.style&&(this.style.setEventedParent(null),this.style._remove(),this.style=void 0),e&&(this.style=new Mo(this,t||{}),this.style.setEventedParent(this,{style:this.style}),"string"==typeof e?this.style.loadURL(e):this.style.loadJSON(e)),this._updateTerrain(),this}_lazyInitEmptyStyle(){this.style||(this.style=new Mo(this,{}),this.style.setEventedParent(this,{style:this.style}),this.style.loadEmpty());}_diffStyle(t,i){if("string"==typeof t){const o=this._requestManager.normalizeStyleURL(t),r=this._requestManager.transformRequest(o,e.R.Style);e.g(r,((t,o)=>{t?this.fire(new e.a(t)):o&&this._updateDiff(o,i);}));}else "object"==typeof t&&this._updateDiff(t,i);}_updateDiff(t,i){try{this.style.setState(t)&&this._update(!0);}catch(o){e.w(`Unable to perform style diff: ${o.message||o.error||o}.  Rebuilding the style from scratch.`),this._updateStyle(t,i);}}getStyle(){if(this.style)return this.style.serialize()}isStyleLoaded(){return this.style?this.style.loaded():(e.w("There is no style added to the map."),!1)}_isValidId(t){return null==t?(this.fire(new e.a(new Error("IDs can't be empty."))),!1):!e.c4(t)||(this.fire(new e.a(new Error(`IDs can't contain special symbols: "${t}".`))),!1)}addSource(e,t){return this._isValidId(e)?(this._lazyInitEmptyStyle(),this.style.addSource(e,t),this._update(!0)):this}isSourceLoaded(e){return !!this._isValidId(e)&&!!this.style&&this.style._isSourceCacheLoaded(e)}areTilesLoaded(){return this.style.areTilesLoaded()}addSourceType(e,t,i){this._lazyInitEmptyStyle(),this.style.addSourceType(e,t,i);}removeSource(e){return this._isValidId(e)?(this.style.removeSource(e),this._updateTerrain(),this._update(!0)):this}getSource(e){return this._isValidId(e)?this.style.getOwnSource(e):null}addImage(t,i,{pixelRatio:o=1,sdf:r=!1,stretchX:s,stretchY:n,content:a}={}){if(this._lazyInitEmptyStyle(),i instanceof HTMLImageElement||ImageBitmap&&i instanceof ImageBitmap){const{width:l,height:c,data:h}=e.f.getImageData(i);this.style.addImage(t,{data:new e.h({width:l,height:c},h),pixelRatio:o,stretchX:s,stretchY:n,content:a,sdf:r,version:0});}else if(void 0===i.width||void 0===i.height)this.fire(new e.a(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));else {const{width:l,height:c}=i,h=i;this.style.addImage(t,{data:new e.h({width:l,height:c},new Uint8Array(h.data)),pixelRatio:o,stretchX:s,stretchY:n,content:a,sdf:r,version:0,userImage:h}),h.onAdd&&h.onAdd(this,t);}}updateImage(t,i){this._lazyInitEmptyStyle();const o=this.style.getImage(t);if(!o)return void this.fire(new e.a(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));const r=i instanceof HTMLImageElement||ImageBitmap&&i instanceof ImageBitmap?e.f.getImageData(i):i,{width:s,height:n}=r,a=r.data;if(void 0===s||void 0===n)return void this.fire(new e.a(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));if(s!==o.data.width||n!==o.data.height)return void this.fire(new e.a(new Error(`The width and height of the updated image (${s}, ${n})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`)));const l=!(i instanceof HTMLImageElement||ImageBitmap&&i instanceof ImageBitmap);o.data.replace(a,l),this.style.updateImage(t,o);}hasImage(t){return t?!!this.style&&!!this.style.getImage(t):(this.fire(new e.a(new Error("Missing required image id"))),!1)}removeImage(e){this.style.removeImage(e);}loadImage(t,i){e.d(this._requestManager.transformRequest(t,e.R.Image),((t,o)=>{i(t,o instanceof HTMLImageElement?e.f.getImageData(o):o);}));}listImages(){return this.style.listImages()}addModel(e,t){this._lazyInitEmptyStyle(),this.style.addModel(e,t);}hasModel(t){return t?this.style.hasModel(t):(this.fire(new e.a(new Error("Missing required model id"))),!1)}removeModel(e){this.style.removeModel(e);}listModels(){return this.style.listModels()}addLayer(e,t){return this._isValidId(e.id)?(this._lazyInitEmptyStyle(),this.style.addLayer(e,t),this._update(!0)):this}getSlot(e){const t=this.getLayer(e);return t&&t.slot||null}setSlot(e,t){return this.style.setSlot(e,t),this.style.mergeLayers(),this._update(!0)}addImport(e,t){return this.style.addImport(e,t),this}updateImport(e,t){return "string"!=typeof t&&t.id!==e?(this.removeImport(e),this.addImport(t)):(this.style.updateImport(e,t),this._update(!0))}removeImport(e){return this.style.removeImport(e),this}moveImport(e,t){return this.style.moveImport(e,t),this._update(!0)}moveLayer(e,t){return this._isValidId(e)?(this.style.moveLayer(e,t),this._update(!0)):this}removeLayer(e){return this._isValidId(e)?(this.style.removeLayer(e),this._update(!0)):this}getLayer(e){return this._isValidId(e)?this.style.getOwnLayer(e):null}setLayerZoomRange(e,t,i){return this._isValidId(e)?(this.style.setLayerZoomRange(e,t,i),this._update(!0)):this}setFilter(e,t,i={}){return this._isValidId(e)?(this.style.setFilter(e,t,i),this._update(!0)):this}getFilter(e){return this._isValidId(e)?this.style.getFilter(e):null}setPaintProperty(e,t,i,o={}){return this._isValidId(e)?(this.style.setPaintProperty(e,t,i,o),this._update(!0)):this}getPaintProperty(e,t){return this._isValidId(e)?this.style.getPaintProperty(e,t):null}setLayoutProperty(e,t,i,o={}){return this._isValidId(e)?(this.style.setLayoutProperty(e,t,i,o),this._update(!0)):this}getLayoutProperty(e,t){return this._isValidId(e)?this.style.getLayoutProperty(e,t):null}getConfigProperty(e,t){return this.style.getConfigProperty(e,t)}setConfigProperty(e,t,i){return this.style.setConfigProperty(e,t,i),this._update(!0)}setLights(e){if(this._lazyInitEmptyStyle(),e&&1===e.length&&"flat"===e[0].type){const t=e[0];t.properties?this.style.setFlatLight(t.properties,t.id,{}):this.style.setFlatLight({},"flat");}else this.style.setLights(e),this.painter.terrain&&(this.painter.terrain.invalidateRenderCache=!0);return this._update(!0)}getLights(){const e=this.style.getLights()||[];return 0===e.length&&e.push({id:this.style.light.id,type:"flat",properties:this.style.getFlatLight()}),e}setLight(e,t={}){return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."),this.setLights([{id:"flat",type:"flat",properties:e}])}getLight(){return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."),this.style.getFlatLight()}setTerrain(e){return this._lazyInitEmptyStyle(),!e&&this.transform.projection.requiresDraping?this.style.setTerrainForDraping():this.style.setTerrain(e),this._averageElevationLastSampledAt=-1/0,this._update(!0)}getTerrain(){return this.style?this.style.getTerrain():null}setFog(e){return this._lazyInitEmptyStyle(),this.style.setFog(e),this._update(!0)}getFog(){return this.style?this.style.getFog():null}setCamera(e){return this.style.setCamera(e),this._triggerCameraUpdate(e)}_triggerCameraUpdate(e){return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic"===e["camera-projection"]))}getCamera(){return this.style.camera}_queryFogOpacity(t){return this.style&&this.style.fog?this.style.fog.getOpacityAtLatLng(e.bn.convert(t),this.transform):0}setFeatureState(e,t){return this._isValidId(e.source)?(this.style.setFeatureState(e,t),this._update()):this}removeFeatureState(e,t){return this._isValidId(e.source)?(this.style.removeFeatureState(e,t),this._update()):this}getFeatureState(e){return this._isValidId(e.source)?this.style.getFeatureState(e):null}_updateContainerDimensions(){if(!this._container)return;const e=this._container.getBoundingClientRect().width||400,t=this._container.getBoundingClientRect().height||300;let i,o,r,s=this._container;for(;s&&(!o||!r);){const e=window.getComputedStyle(s).transform;e&&"none"!==e&&(i=e.match(/matrix.*\((.+)\)/)[1].split(", "),i[0]&&"0"!==i[0]&&"1"!==i[0]&&(o=i[0]),i[3]&&"0"!==i[3]&&"1"!==i[3]&&(r=i[3])),s=s.parentElement;}this._containerWidth=o?Math.abs(e/o):e,this._containerHeight=r?Math.abs(t/r):t;}_detectMissingCSS(){"rgb(250, 128, 114)"!==window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color")&&e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");}_setupContainer(){const e=this._container;e.classList.add("mapboxgl-map"),(this._missingCSSCanary=s("div","mapboxgl-canary",e)).style.visibility="hidden",this._detectMissingCSS();const t=this._canvasContainer=s("div","mapboxgl-canvas-container",e);this._canvas=s("canvas","mapboxgl-canvas",t),this._interactive&&(t.classList.add("mapboxgl-interactive"),this._canvas.setAttribute("tabindex","0")),this._canvas.addEventListener("webglcontextlost",this._contextLost,!1),this._canvas.addEventListener("webglcontextrestored",this._contextRestored,!1),this._canvas.setAttribute("aria-label",this._getUIString("Map.Title")),this._canvas.setAttribute("role","region"),this._updateContainerDimensions(),this._resizeCanvas(this._containerWidth,this._containerHeight);const i=this._controlContainer=s("div","mapboxgl-control-container",e),o=this._controlPositions={};["top-left","top-right","bottom-left","bottom-right"].forEach((e=>{o[e]=s("div",`mapboxgl-ctrl-${e}`,i);})),this._container.addEventListener("scroll",this._onMapScroll,!1);}_resizeCanvas(t,i){const o=e.f.devicePixelRatio||1;this._canvas.width=o*Math.ceil(t),this._canvas.height=o*Math.ceil(i),this._canvas.style.width=`${t}px`,this._canvas.style.height=`${i}px`;}_addMarker(e){this._markers.push(e);}_removeMarker(e){const t=this._markers.indexOf(e);-1!==t&&this._markers.splice(t,1);}_addPopup(e){this._popups.push(e);}_removePopup(e){const t=this._popups.indexOf(e);-1!==t&&this._popups.splice(t,1);}_setupPainter(){const t=e.e({},i.webGLContextAttributes,{failIfMajorPerformanceCaveat:this._failIfMajorPerformanceCaveat,preserveDrawingBuffer:this._preserveDrawingBuffer,antialias:this._antialias||!1}),o=this._canvas.getContext("webgl2",t);o?(e.db(o,!0),this.painter=new tn(o,this._contextCreateOptions,this.transform,this._tp),this.on("data",(e=>{"source"===e.dataType&&this.painter.setTileLoadedFlag(!0);})),e.dc.testSupport(o)):this.fire(new e.a(new Error("Failed to initialize WebGL")));}_contextLost(t){t.preventDefault(),this._frame&&(this._frame.cancel(),this._frame=null),this.fire(new e.b("webglcontextlost",{originalEvent:t}));}_contextRestored(t){this._setupPainter(),this.resize(),this._update(),this.fire(new e.b("webglcontextrestored",{originalEvent:t}));}_onMapScroll(e){if(e.target===this._container)return this._container.scrollTop=0,this._container.scrollLeft=0,!1}loaded(){return !this._styleDirty&&!this._sourcesDirty&&!!this.style&&this.style.loaded()}_update(e){return this.style?(this._styleDirty=this._styleDirty||e,this._sourcesDirty=!0,this.triggerRepaint(),this):this}_requestRenderFrame(e){return this._update(),this._renderTaskQueue.add(e)}_cancelRenderFrame(e){this._renderTaskQueue.remove(e);}_requestDomTask(e){!this.loaded()||this.loaded()&&!this.isMoving()?e():this._domRenderTaskQueue.add(e);}_render(t){let i;this.fire(new e.b("renderstart"));const o=this.painter.context.extTimerQuery,r=e.f.now(),s=this.painter.context.gl;if(this.listens("gpu-timing-frame")&&(i=s.createQuery(),s.beginQuery(o.TIME_ELAPSED_EXT,i)),this.painter.context.setDirty(),this.painter.setBaseState(),(this.isMoving()||this.isRotating()||this.isZooming())&&(this._interactionRange[0]=Math.min(this._interactionRange[0],performance.now()),this._interactionRange[1]=Math.max(this._interactionRange[1],performance.now())),this._renderTaskQueue.run(t),this._domRenderTaskQueue.run(t),this._removed)return;this._updateProjectionTransition();const n=this._isInitialLoad?0:this._fadeDuration;if(this.style&&this._styleDirty){this._styleDirty=!1;const t=this.transform.zoom,i=this.transform.pitch,o=e.f.now(),r=new e.K(t,{now:o,fadeDuration:n,pitch:i,transition:this.style.transition});this.style.update(r);}this.style&&this.style.hasFogTransition()&&(this.style._markersNeedUpdate=!0,this._sourcesDirty=!0);let a=!1;if(this.style&&this._sourcesDirty?(this._sourcesDirty=!1,this.painter._updateFog(this.style),this._updateTerrain(),a=this._updateAverageElevation(r),this.style.updateSources(this.transform),this._forceMarkerAndPopupUpdate()):a=this._updateAverageElevation(r),this._placementDirty=this.style&&this.style._updatePlacement(this.painter.transform,this.showCollisionBoxes,n,this._crossSourceCollisions),this.style&&this.painter.render(this.style,{showTileBoundaries:this.showTileBoundaries||this._debugParams.showTileBoundaries,showParseStatus:this.showParseStatus||this._debugParams.showParseStatus,wireframe:{terrain:this.showTerrainWireframe||this._debugParams.showTerrainWireframe,layers2D:this.showLayers2DWireframe||this._debugParams.showLayers2DWireframe,layers3D:this.showLayers3DWireframe||this._debugParams.showLayers3DWireframe},showOverdrawInspector:this._showOverdrawInspector||this._debugParams.showOverdrawInspector,showQueryGeometry:!!this._showQueryGeometry,showTileAABBs:this.showTileAABBs||this._debugParams.showTileAABBs,rotating:this.isRotating(),zooming:this.isZooming(),moving:this.isMoving(),fadeDuration:n,isInitialLoad:this._isInitialLoad,showPadding:this.showPadding||this._debugParams.showPadding,gpuTiming:!!this.listens("gpu-timing-layer"),gpuTimingDeferredRender:!!this.listens("gpu-timing-deferred-render"),speedIndexTiming:this.speedIndexTiming}),this.fire(new e.b("render")),this.loaded()&&!this._loaded&&(this._loaded=!0,this.fire(new e.b("load"))),this.style&&this.style.hasTransitions()&&(this._styleDirty=!0),this.style&&!this._placementDirty&&this.style._releaseSymbolFadeTiles(),i){const t=e.f.now()-r;s.endQuery(o.TIME_ELAPSED_EXT),setTimeout((()=>{const o=s.getQueryParameter(i,s.QUERY_RESULT)/1e6;s.deleteQuery(i),this.fire(new e.b("gpu-timing-frame",{cpuTime:t,gpuTime:o}));}),50);}if(this.listens("gpu-timing-layer")){const t=this.painter.collectGpuTimers();setTimeout((()=>{const i=this.painter.queryGpuTimers(t);this.fire(new e.b("gpu-timing-layer",{layerTimes:i}));}),50);}if(this.listens("gpu-timing-deferred-render")){const t=this.painter.collectDeferredRenderGpuQueries();setTimeout((()=>{const i=this.painter.queryGpuTimeDeferredRender(t);this.fire(new e.b("gpu-timing-deferred-render",{gpuTime:i}));}),50);}const l=this._sourcesDirty||this._styleDirty||this._placementDirty||a;if(l||this._repaint)this.triggerRepaint();else {const t=!this.isMoving()&&this.loaded();if(t&&(a=this._updateAverageElevation(r,!0)),a)this.triggerRepaint();else if(this._triggerFrame(!1),t&&(this.fire(new e.b("idle")),this._isInitialLoad=!1,this.speedIndexTiming)){const t=this._calculateSpeedIndex();this.fire(new e.b("speedindexcompleted",{speedIndex:t})),this.speedIndexTiming=!1;}}!this._loaded||this._fullyLoaded||l||(this._fullyLoaded=!0,this._performanceMetricsCollection&&e.dd(this._requestManager._customAccessToken,{width:this.painter.width,height:this.painter.height,interactionRange:this._interactionRange,visibilityHidden:this._visibilityHidden,terrainEnabled:!!this.painter.style.getTerrain(),fogEnabled:!!this.painter.style.getFog(),projection:this.getProjection().name,zoom:this.transform.zoom,renderer:this.painter.context.renderer,vendor:this.painter.context.vendor}),this._authenticate());}_forceMarkerAndPopupUpdate(e){for(const t of this._markers)e&&!this.getRenderWorldCopies()&&(t._lngLat=t._lngLat.wrap()),t._update();for(const t of this._popups)!e||this.getRenderWorldCopies()||t._trackPointer||(t._lngLat=t._lngLat.wrap()),t._update();}_updateAverageElevation(e,t=!1){const i=e=>(this.transform.averageElevation=e,this._update(!1),!0);if(!this.painter.averageElevationNeedsEasing())return 0!==this.transform.averageElevation&&i(0);const o=this.transform.elevation&&this.transform.elevation.exaggeration()!==this._averageElevationExaggeration;if(o||(t||e-this._averageElevationLastSampledAt>500)&&!this._averageElevation.isEasing(e)){const t=this.transform.averageElevation;let r=this.transform.sampleAverageElevation();this.transform.elevation&&(this._averageElevationExaggeration=this.transform.elevation.exaggeration()),isNaN(r)?r=0:this._averageElevationLastSampledAt=e;const s=Math.abs(t-r);if(s>1){if(this._isInitialLoad||o)return this._averageElevation.jumpTo(r),i(r);this._averageElevation.easeTo(r,e,300);}else if(s>1e-4)return this._averageElevation.jumpTo(r),i(r)}return !!this._averageElevation.isEasing(e)&&i(this._averageElevation.getValue(e))}_authenticate(){e.de(this._getMapId(),this._requestManager._skuToken,this._requestManager._customAccessToken,(t=>{if(t&&(t.message===e.df||401===t.status)){const t=this.painter.context.gl;e.db(t,!1),this._logoControl instanceof ra&&this._logoControl._updateLogo(),t&&t.clear(t.DEPTH_BUFFER_BIT|t.COLOR_BUFFER_BIT|t.STENCIL_BUFFER_BIT),this._silenceAuthErrors||this.fire(new e.a(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));}})),e.dg(this._getMapId(),this._requestManager._skuToken,this._requestManager._customAccessToken,(()=>{}));}_updateTerrain(){const e=this._isDragging();this.painter.updateTerrain(this.style,e);}_calculateSpeedIndex(){const e=this.painter.canvasCopy(),t=this.painter.getCanvasCopiesAndTimestamps();t.timeStamps.push(performance.now());const i=this.painter.context.gl,o=i.createFramebuffer();function r(e){i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0);const t=new Uint8Array(i.drawingBufferWidth*i.drawingBufferHeight*4);return i.readPixels(0,0,i.drawingBufferWidth,i.drawingBufferHeight,i.RGBA,i.UNSIGNED_BYTE,t),t}return i.bindFramebuffer(i.FRAMEBUFFER,o),this._canvasPixelComparison(r(e),t.canvasCopies.map(r),t.timeStamps)}_canvasPixelComparison(e,t,i){let o=i[1]-i[0];const r=e.length/4;for(let s=0;s<t.length;s++){const n=t[s];let a=0;for(let t=0;t<n.length;t+=4)n[t]===e[t]&&n[t+1]===e[t+1]&&n[t+2]===e[t+2]&&n[t+3]===e[t+3]&&(a+=1);o+=(i[s+2]-i[s+1])*(1-a/r);}return o}remove(){this._hash&&this._hash.remove();for(const e of this._controls)e.onRemove(this);this._controls=[],this._frame&&(this._frame.cancel(),this._frame=null),this._renderTaskQueue.clear(),this._domRenderTaskQueue.clear(),this.style&&this.style.destroy(),this.painter.destroy(),this.handlers&&this.handlers.destroy(),this.handlers=void 0,this.setStyle(null),window.removeEventListener("resize",this._onWindowResize,!1),window.removeEventListener("orientationchange",this._onWindowResize,!1),window.removeEventListener(this._fullscreenchangeEvent,this._onWindowResize,!1),window.removeEventListener("online",this._onWindowOnline,!1),window.removeEventListener("visibilitychange",this._onVisibilityChange,!1);const t=this.painter.context.gl.getExtension("WEBGL_lose_context");t&&t.loseContext(),this._canvas.removeEventListener("webglcontextlost",this._contextLost,!1),this._canvas.removeEventListener("webglcontextrestored",this._contextRestored,!1),this._canvasContainer.remove(),this._controlContainer.remove(),this._missingCSSCanary.remove(),this._canvas=void 0,this._canvasContainer=void 0,this._controlContainer=void 0,this._missingCSSCanary=void 0,this._container.classList.remove("mapboxgl-map"),this._container.removeEventListener("scroll",this._onMapScroll,!1),e.dh(this.painter.context.gl),e.di.remove(),e.dj.remove(),this._removed=!0,this.fire(new e.b("remove"));}triggerRepaint(){this._triggerFrame(!0);}_triggerFrame(t){this._renderNextFrame=this._renderNextFrame||t,this.style&&!this._frame&&(this._frame=e.f.frame((e=>{const t=!!this._renderNextFrame;this._frame=null,this._renderNextFrame=null,t&&this._render(e);})));}_preloadTiles(t){const i=this.style?Object.values(this.style._sourceCaches):[];return e.b1(i,((e,i)=>e._preloadTiles(t,i)),(()=>{this.triggerRepaint();})),this}_onWindowOnline(){this._update();}_onWindowResize(e){this._trackResize&&this.resize({originalEvent:e})._update();}_onVisibilityChange(){"hidden"===document.visibilityState&&this._visibilityHidden++;}get showTileBoundaries(){return !!this._showTileBoundaries}set showTileBoundaries(e){this._showTileBoundaries!==e&&(this._showTileBoundaries=e,this._update());}get showParseStatus(){return !!this._showParseStatus}set showParseStatus(e){this._showParseStatus!==e&&(this._showParseStatus=e,this._update());}get showTerrainWireframe(){return !!this._showTerrainWireframe}set showTerrainWireframe(e){this._showTerrainWireframe!==e&&(this._showTerrainWireframe=e,this._update());}get showLayers2DWireframe(){return !!this._showLayers2DWireframe}set showLayers2DWireframe(e){this._showLayers2DWireframe!==e&&(this._showLayers2DWireframe=e,this._update());}get showLayers3DWireframe(){return !!this._showLayers3DWireframe}set showLayers3DWireframe(e){this._showLayers3DWireframe!==e&&(this._showLayers3DWireframe=e,this._update());}get speedIndexTiming(){return !!this._speedIndexTiming}set speedIndexTiming(e){this._speedIndexTiming!==e&&(this._speedIndexTiming=e,this._update());}get showPadding(){return !!this._showPadding}set showPadding(e){this._showPadding!==e&&(this._showPadding=e,this._update());}get showCollisionBoxes(){return !!this._showCollisionBoxes}set showCollisionBoxes(e){this._showCollisionBoxes!==e&&(this._showCollisionBoxes=e,e?this.style._generateCollisionBoxes():this._update());}get showOverdrawInspector(){return !!this._showOverdrawInspector}set showOverdrawInspector(e){this._showOverdrawInspector!==e&&(this._showOverdrawInspector=e,this._update());}get repaint(){return !!this._repaint}set repaint(e){this._repaint!==e&&(this._repaint=e,this.triggerRepaint());}get vertices(){return !!this._vertices}set vertices(e){this._vertices=e,this._update();}get showTileAABBs(){return !!this._showTileAABBs}set showTileAABBs(e){this._showTileAABBs!==e&&(this._showTileAABBs=e,e&&this._update());}_setCacheLimits(t,i){e.dl(t,i);}get version(){return e.dk}},NavigationControl:class{constructor(t){this.options=e.e({},ma,t),this._container=s("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._container.addEventListener("contextmenu",(e=>e.preventDefault())),this.options.showZoom&&(e.aY(["_setButtonTitle","_updateZoomButtons"],this),this._zoomInButton=this._createButton("mapboxgl-ctrl-zoom-in",(e=>{this._map&&this._map.zoomIn({},{originalEvent:e});})),s("span","mapboxgl-ctrl-icon",this._zoomInButton).setAttribute("aria-hidden","true"),this._zoomOutButton=this._createButton("mapboxgl-ctrl-zoom-out",(e=>{this._map&&this._map.zoomOut({},{originalEvent:e});})),s("span","mapboxgl-ctrl-icon",this._zoomOutButton).setAttribute("aria-hidden","true")),this.options.showCompass&&(e.aY(["_rotateCompassArrow"],this),this._compass=this._createButton("mapboxgl-ctrl-compass",(e=>{const t=this._map;t&&(this.options.visualizePitch?t.resetNorthPitch({},{originalEvent:e}):t.resetNorth({},{originalEvent:e}));})),this._compassIcon=s("span","mapboxgl-ctrl-icon",this._compass),this._compassIcon.setAttribute("aria-hidden","true"));}_updateZoomButtons(){const e=this._map;if(!e)return;const t=e.getZoom(),i=t===e.getMaxZoom(),o=t===e.getMinZoom();this._zoomInButton.disabled=i,this._zoomOutButton.disabled=o,this._zoomInButton.setAttribute("aria-disabled",i.toString()),this._zoomOutButton.setAttribute("aria-disabled",o.toString());}_rotateCompassArrow(){const e=this._map;if(!e)return;const t=this.options.visualizePitch?`scale(${1/Math.pow(Math.cos(e.transform.pitch*(Math.PI/180)),.5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle*(180/Math.PI)}deg)`:`rotate(${e.transform.angle*(180/Math.PI)}deg)`;e._requestDomTask((()=>{this._compassIcon&&(this._compassIcon.style.transform=t);}));}onAdd(e){return this._map=e,this.options.showZoom&&(this._setButtonTitle(this._zoomInButton,"ZoomIn"),this._setButtonTitle(this._zoomOutButton,"ZoomOut"),e.on("zoom",this._updateZoomButtons),this._updateZoomButtons()),this.options.showCompass&&(this._setButtonTitle(this._compass,"ResetBearing"),this.options.visualizePitch&&e.on("pitch",this._rotateCompassArrow),e.on("rotate",this._rotateCompassArrow),this._rotateCompassArrow(),this._handler=new ga(e,this._compass,this.options.visualizePitch)),this._container}onRemove(){const e=this._map;e&&(this._container.remove(),this.options.showZoom&&e.off("zoom",this._updateZoomButtons),this.options.showCompass&&(this.options.visualizePitch&&e.off("pitch",this._rotateCompassArrow),e.off("rotate",this._rotateCompassArrow),this._handler&&this._handler.off(),this._handler=void 0),this._map=void 0);}_createButton(e,t){const i=s("button",e,this._container);return i.type="button",i.addEventListener("click",t),i}_setButtonTitle(e,t){if(!this._map)return;const i=this._map._getUIString(`NavigationControl.${t}`);e.setAttribute("aria-label",i),e.firstElementChild&&e.firstElementChild.setAttribute("title",i);}},GeolocateControl:class extends e.E{constructor(t){super();const i=navigator.geolocation;this.options=e.e({geolocation:i},va,t),e.aY(["_onSuccess","_onError","_onZoom","_finish","_setupUI","_updateCamera","_updateMarker","_updateMarkerRotation","_onDeviceOrientation"],this),this._updateMarkerRotationThrottled=on(this._updateMarkerRotation,20),this._numberOfWatches=0;}onAdd(e){return this._map=e,this._container=s("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._checkGeolocationSupport(this._setupUI),this._container}onRemove(){void 0!==this._geolocationWatchID&&(this.options.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0),this.options.showUserLocation&&this._userLocationDotMarker&&this._userLocationDotMarker.remove(),this.options.showAccuracyCircle&&this._accuracyCircleMarker&&this._accuracyCircleMarker.remove(),this._container.remove(),this._map.off("zoom",this._onZoom),this._map=void 0,this._numberOfWatches=0,this._noTimeout=!1;}_checkGeolocationSupport(e){const t=(t=!!this.options.geolocation)=>{this._supportsGeolocation=t,e(t);};void 0!==this._supportsGeolocation?e(this._supportsGeolocation):void 0!==navigator.permissions?navigator.permissions.query({name:"geolocation"}).then((e=>t("denied"!==e.state))).catch((()=>t())):t();}_isOutOfMapMaxBounds(e){const t=this._map.getMaxBounds(),i=e.coords;return !!t&&(i.longitude<t.getWest()||i.longitude>t.getEast()||i.latitude<t.getSouth()||i.latitude>t.getNorth())}_setErrorState(){switch(this._watchState){case"WAITING_ACTIVE":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"ACTIVE_LOCK":this._watchState="ACTIVE_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");break;case"BACKGROUND":this._watchState="BACKGROUND_ERROR",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");}}_onSuccess(t){if(this._map){if(this._isOutOfMapMaxBounds(t))return this._setErrorState(),this.fire(new e.b("outofmaxbounds",t)),this._updateMarker(),void this._finish();if(this.options.trackUserLocation)switch(this._lastKnownPosition=t,this._watchState){case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"BACKGROUND":case"BACKGROUND_ERROR":this._watchState="BACKGROUND",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");}this.options.showUserLocation&&"OFF"!==this._watchState&&this._updateMarker(t),this.options.trackUserLocation&&"ACTIVE_LOCK"!==this._watchState||this._updateCamera(t),this.options.showUserLocation&&this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"),this.fire(new e.b("geolocate",t)),this._finish();}}_updateCamera(t){const i=new e.bn(t.coords.longitude,t.coords.latitude),o=t.coords.accuracy,r=this._map.getBearing(),s=e.e({bearing:r},this.options.fitBoundsOptions);this._map.fitBounds(i.toBounds(o),s,{geolocateSource:!0});}_updateMarker(t){if(t){const i=new e.bn(t.coords.longitude,t.coords.latitude);this._accuracyCircleMarker.setLngLat(i).addTo(this._map),this._userLocationDotMarker.setLngLat(i).addTo(this._map),this._accuracy=t.coords.accuracy,this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();}else this._userLocationDotMarker.remove(),this._accuracyCircleMarker.remove();}_updateCircleRadius(){const t=this._map.transform,i=e.bl(1,t._center.lat)*t.worldSize,o=Math.ceil(2*this._accuracy*i);this._circleElement.style.width=`${o}px`,this._circleElement.style.height=`${o}px`;}_onZoom(){this.options.showUserLocation&&this.options.showAccuracyCircle&&this._updateCircleRadius();}_updateMarkerRotation(){this._userLocationDotMarker&&"number"==typeof this._heading?(this._userLocationDotMarker.setRotation(this._heading),this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")):(this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"),this._userLocationDotMarker.setRotation(0));}_onError(t){if(this._map){if(this.options.trackUserLocation)if(1===t.code){this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this._geolocateButton.disabled=!0;const e=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.setAttribute("aria-label",e),this._geolocateButton.firstElementChild&&this._geolocateButton.firstElementChild.setAttribute("title",e),void 0!==this._geolocationWatchID&&this._clearWatch();}else {if(3===t.code&&this._noTimeout)return;this._setErrorState();}"OFF"!==this._watchState&&this.options.showUserLocation&&this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"),this.fire(new e.b("error",t)),this._finish();}}_finish(){this._timeoutId&&clearTimeout(this._timeoutId),this._timeoutId=void 0;}_setupUI(t){if(void 0!==this._map){if(this._container.addEventListener("contextmenu",(e=>e.preventDefault())),this._geolocateButton=s("button","mapboxgl-ctrl-geolocate",this._container),s("span","mapboxgl-ctrl-icon",this._geolocateButton).setAttribute("aria-hidden","true"),this._geolocateButton.type="button",!1===t){e.w("Geolocation support is not available so the GeolocateControl will be disabled.");const t=this._map._getUIString("GeolocateControl.LocationNotAvailable");this._geolocateButton.disabled=!0,this._geolocateButton.setAttribute("aria-label",t),this._geolocateButton.firstElementChild&&this._geolocateButton.firstElementChild.setAttribute("title",t);}else {const e=this._map._getUIString("GeolocateControl.FindMyLocation");this._geolocateButton.setAttribute("aria-label",e),this._geolocateButton.firstElementChild&&this._geolocateButton.firstElementChild.setAttribute("title",e);}this.options.trackUserLocation&&(this._geolocateButton.setAttribute("aria-pressed","false"),this._watchState="OFF"),this.options.showUserLocation&&(this._dotElement=s("div","mapboxgl-user-location"),this._dotElement.appendChild(s("div","mapboxgl-user-location-dot")),this._dotElement.appendChild(s("div","mapboxgl-user-location-heading")),this._userLocationDotMarker=new la({element:this._dotElement,rotationAlignment:"map",pitchAlignment:"map"}),this._circleElement=s("div","mapboxgl-user-location-accuracy-circle"),this._accuracyCircleMarker=new la({element:this._circleElement,pitchAlignment:"map"}),this.options.trackUserLocation&&(this._watchState="OFF"),this._map.on("zoom",this._onZoom)),this._geolocateButton.addEventListener("click",this.trigger.bind(this)),this._setup=!0,this.options.trackUserLocation&&this._map.on("movestart",(t=>{t.geolocateSource||"ACTIVE_LOCK"!==this._watchState||t.originalEvent&&"resize"===t.originalEvent.type||(this._watchState="BACKGROUND",this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this.fire(new e.b("trackuserlocationend")));}));}}_onDeviceOrientation(e){this._userLocationDotMarker&&(e.webkitCompassHeading?this._heading=e.webkitCompassHeading:!0===e.absolute&&(this._heading=-1*e.alpha),this._updateMarkerRotationThrottled());}trigger(){if(!this._setup)return e.w("Geolocate control triggered before added to a map"),!1;if(this.options.trackUserLocation){switch(this._watchState){case"OFF":this._watchState="WAITING_ACTIVE",this.fire(new e.b("trackuserlocationstart"));break;case"WAITING_ACTIVE":case"ACTIVE_LOCK":case"ACTIVE_ERROR":case"BACKGROUND_ERROR":this._numberOfWatches--,this._noTimeout=!1,this._watchState="OFF",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),this.fire(new e.b("trackuserlocationend"));break;case"BACKGROUND":this._watchState="ACTIVE_LOCK",this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),this._lastKnownPosition&&this._updateCamera(this._lastKnownPosition),this.fire(new e.b("trackuserlocationstart"));}switch(this._watchState){case"WAITING_ACTIVE":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_LOCK":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");break;case"ACTIVE_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");break;case"BACKGROUND":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");break;case"BACKGROUND_ERROR":this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");}if("OFF"===this._watchState&&void 0!==this._geolocationWatchID)this._clearWatch();else if(void 0===this._geolocationWatchID){let e;this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","true"),this._numberOfWatches++,this._numberOfWatches>1?(e={maximumAge:6e5,timeout:0},this._noTimeout=!0):(e=this.options.positionOptions,this._noTimeout=!1),this._geolocationWatchID=this.options.geolocation.watchPosition(this._onSuccess,this._onError,e),this.options.showUserHeading&&this._addDeviceOrientationListener();}}else this.options.geolocation.getCurrentPosition(this._onSuccess,this._onError,this.options.positionOptions),this._timeoutId=setTimeout(this._finish,1e4);return !0}_addDeviceOrientationListener(){const e=()=>{"ondeviceorientationabsolute"in window?window.addEventListener("deviceorientationabsolute",this._onDeviceOrientation):window.addEventListener("deviceorientation",this._onDeviceOrientation);};"undefined"!=typeof DeviceMotionEvent&&"function"==typeof DeviceMotionEvent.requestPermission?DeviceOrientationEvent.requestPermission().then((t=>{"granted"===t&&e();})).catch(console.error):e();}_clearWatch(){this.options.geolocation.clearWatch(this._geolocationWatchID),window.removeEventListener("deviceorientation",this._onDeviceOrientation),window.removeEventListener("deviceorientationabsolute",this._onDeviceOrientation),this._geolocationWatchID=void 0,this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),this._geolocateButton.setAttribute("aria-pressed","false"),this.options.showUserLocation&&this._updateMarker(null);}},AttributionControl:oa,ScaleControl:class{constructor(t){this.options=e.e({},xa,t),this._isNumberFormatSupported=function(){try{return new Intl.NumberFormat("en",{style:"unit",unitDisplay:"short",unit:"meter"}),!0}catch(e){return !1}}(),e.aY(["_update","_setScale","setUnit"],this);}getDefaultPosition(){return "bottom-left"}_update(){const e=this.options.maxWidth||100,t=this._map,i=t._containerHeight/2,o=t._containerWidth/2-e/2,r=t.unproject([o,i]),s=t.unproject([o+e,i]),n=r.distanceTo(s);if("imperial"===this.options.unit){const t=3.2808*n;t>5280?this._setScale(e,t/5280,"mile"):this._setScale(e,t,"foot");}else "nautical"===this.options.unit?this._setScale(e,n/1852,"nautical-mile"):n>=1e3?this._setScale(e,n/1e3,"kilometer"):this._setScale(e,n,"meter");}_setScale(e,t,i){this._map._requestDomTask((()=>{const o=function(e){const t=Math.pow(10,`${Math.floor(e)}`.length-1);let i=e/t;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:i>=1?1:function(e){const t=Math.pow(10,Math.ceil(-Math.log(e)/Math.LN10));return Math.round(e*t)/t}(i),t*i}(t),r=o/t;this._container.innerHTML=this._isNumberFormatSupported&&"nautical-mile"!==i?new Intl.NumberFormat(this._language,{style:"unit",unitDisplay:"short",unit:i}).format(o):`${o}&nbsp;${ya[i]}`,this._container.style.width=e*r+"px";}));}onAdd(e){return this._map=e,this._language=e.getLanguage(),this._container=s("div","mapboxgl-ctrl mapboxgl-ctrl-scale",e.getContainer()),this._container.dir="auto",this._map.on("move",this._update),this._update(),this._container}onRemove(){this._container.remove(),this._map.off("move",this._update),this._map=void 0;}_setLanguage(e){this._language=e,this._update();}setUnit(e){this.options.unit=e,this._update();}},FullscreenControl:class{constructor(t){this._fullscreen=!1,t&&t.container&&(t.container instanceof HTMLElement?this._container=t.container:e.w("Full screen control 'container' must be a DOM element.")),e.aY(["_onClickFullscreen","_changeIcon"],this),"onfullscreenchange"in document?this._fullscreenchange="fullscreenchange":"onwebkitfullscreenchange"in document&&(this._fullscreenchange="webkitfullscreenchange");}onAdd(t){return this._map=t,this._container||(this._container=this._map.getContainer()),this._controlContainer=s("div","mapboxgl-ctrl mapboxgl-ctrl-group"),this._checkFullscreenSupport()?this._setupUI():(this._controlContainer.style.display="none",e.w("This device does not support fullscreen mode.")),this._controlContainer}onRemove(){this._controlContainer.remove(),this._map=null,document.removeEventListener(this._fullscreenchange,this._changeIcon);}_checkFullscreenSupport(){return !(!document.fullscreenEnabled&&!document.webkitFullscreenEnabled)}_setupUI(){const e=this._fullscreenButton=s("button","mapboxgl-ctrl-fullscreen",this._controlContainer);s("span","mapboxgl-ctrl-icon",e).setAttribute("aria-hidden","true"),e.type="button",this._updateTitle(),this._fullscreenButton.addEventListener("click",this._onClickFullscreen),document.addEventListener(this._fullscreenchange,this._changeIcon);}_updateTitle(){const e=this._getTitle();this._fullscreenButton.setAttribute("aria-label",e),this._fullscreenButton.firstElementChild&&this._fullscreenButton.firstElementChild.setAttribute("title",e);}_getTitle(){return this._map._getUIString(this._isFullscreen()?"FullscreenControl.Exit":"FullscreenControl.Enter")}_isFullscreen(){return this._fullscreen}_changeIcon(){(document.fullscreenElement||document.webkitFullscreenElement)===this._container!==this._fullscreen&&(this._fullscreen=!this._fullscreen,this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),this._updateTitle());}_onClickFullscreen(){this._isFullscreen()?document.exitFullscreen?document.exitFullscreen():document.webkitCancelFullScreen&&document.webkitCancelFullScreen():this._container.requestFullscreen?this._container.requestFullscreen():this._container.webkitRequestFullscreen&&this._container.webkitRequestFullscreen();}},Popup:class extends e.E{constructor(t){super(),this.options=e.e(Object.create(ca),t),e.aY(["_update","_onClose","remove","_onMouseEvent"],this),this._classList=new Set(t&&t.className?t.className.trim().split(/\s+/):[]);}addTo(t){return this._map&&this.remove(),this._map=t,this.options.closeOnClick&&t.on("preclick",this._onClose),this.options.closeOnMove&&t.on("move",this._onClose),t.on("remove",this.remove),this._update(),t._addPopup(this),this._focusFirstElement(),this._trackPointer?(t.on("mousemove",this._onMouseEvent),t.on("mouseup",this._onMouseEvent),t._canvasContainer.classList.add("mapboxgl-track-pointer")):t.on("move",this._update),this.fire(new e.b("open")),this}isOpen(){return !!this._map}remove(){this._content&&this._content.remove(),this._container&&(this._container.remove(),this._container=void 0);const t=this._map;return t&&(t.off("move",this._update),t.off("move",this._onClose),t.off("preclick",this._onClose),t.off("click",this._onClose),t.off("remove",this.remove),t.off("mousemove",this._onMouseEvent),t.off("mouseup",this._onMouseEvent),t.off("drag",this._onMouseEvent),t._canvasContainer&&t._canvasContainer.classList.remove("mapboxgl-track-pointer"),t._removePopup(this),this._map=void 0),this.fire(new e.b("close")),this}getLngLat(){return this._lngLat}setLngLat(t){this._lngLat=e.bn.convert(t),this._pos=null,this._trackPointer=!1,this._update();const i=this._map;return i&&(i.on("move",this._update),i.off("mousemove",this._onMouseEvent),i._canvasContainer.classList.remove("mapboxgl-track-pointer")),this}trackPointer(){this._trackPointer=!0,this._pos=null,this._update();const e=this._map;return e&&(e.off("move",this._update),e.on("mousemove",this._onMouseEvent),e.on("drag",this._onMouseEvent),e._canvasContainer.classList.add("mapboxgl-track-pointer")),this}getElement(){return this._container}setText(e){return this.setDOMContent(document.createTextNode(e))}setHTML(e){const t=document.createDocumentFragment(),i=document.createElement("body");let o;for(i.innerHTML=e;o=i.firstChild,o;)t.appendChild(o);return this.setDOMContent(t)}getMaxWidth(){return this._container&&this._container.style.maxWidth}setMaxWidth(e){return this.options.maxWidth=e,this._update(),this}setDOMContent(e){let t=this._content;if(t)for(;t.hasChildNodes();)t.firstChild&&t.removeChild(t.firstChild);else t=this._content=s("div","mapboxgl-popup-content",this._container||void 0);if(t.appendChild(e),this.options.closeButton){const e=this._closeButton=s("button","mapboxgl-popup-close-button",t);e.type="button",e.setAttribute("aria-label","Close popup"),e.setAttribute("aria-hidden","true"),e.innerHTML="&#215;",e.addEventListener("click",this._onClose);}return this._update(),this._focusFirstElement(),this}addClassName(e){return this._classList.add(e),this._updateClassList(),this}removeClassName(e){return this._classList.delete(e),this._updateClassList(),this}setOffset(e){return this.options.offset=e,this._update(),this}toggleClassName(e){let t;return this._classList.delete(e)?t=!1:(this._classList.add(e),t=!0),this._updateClassList(),t}_onMouseEvent(e){this._update(e.point);}_getAnchor(e){if(this.options.anchor)return this.options.anchor;const t=this._map,i=this._container,o=this._pos;if(!t||!i||!o)return "bottom";const r=i.offsetWidth,s=i.offsetHeight,n=o.x<r/2,a=o.x>t.transform.width-r/2;if(o.y+e<s)return n?"top-left":a?"top-right":"top";if(o.y>t.transform.height-s){if(n)return "bottom-left";if(a)return "bottom-right"}return n?"left":a?"right":"bottom"}_updateClassList(){const e=this._container;if(!e)return;const t=[...this._classList];t.push("mapboxgl-popup"),this._anchor&&t.push(`mapboxgl-popup-anchor-${this._anchor}`),this._trackPointer&&t.push("mapboxgl-popup-track-pointer"),e.className=t.join(" ");}_update(t){const i=this._map,o=this._content;if(!i||!this._lngLat&&!this._trackPointer||!o)return;let r=this._container;if(r||(r=this._container=s("div","mapboxgl-popup",i.getContainer()),this._tip=s("div","mapboxgl-popup-tip",r),r.appendChild(o)),this.options.maxWidth&&r.style.maxWidth!==this.options.maxWidth&&(r.style.maxWidth=this.options.maxWidth),i.transform.renderWorldCopies&&!this._trackPointer&&(this._lngLat=na(this._lngLat,this._pos,i.transform)),!this._trackPointer||t){const e=this._pos=this._trackPointer&&t?t:i.project(this._lngLat),o=ua(this.options.offset),r=this._anchor=this._getAnchor(o.y),s=ua(this.options.offset,r),n=e.add(s).round();i._requestDomTask((()=>{this._container&&r&&(this._container.style.transform=`${aa[r]} translate(${n.x}px,${n.y}px)`);}));}if(!this._marker&&i._showingGlobe()){const t=e.d6(i.transform,this._lngLat)?0:1;this._setOpacity(t);}this._updateClassList();}_focusFirstElement(){if(!this.options.focusAfterOpen||!this._container)return;const e=this._container.querySelector(ha);e&&e.focus();}_onClose(){this.remove();}_setOpacity(e){this._container&&(this._container.style.opacity=`${e}`),this._content&&(this._content.style.pointerEvents=e?"auto":"none");}},Marker:la,Style:Mo,LngLat:e.bn,LngLatBounds:e.ad,Point:e.P,MercatorCoordinate:e.L,FreeCameraOptions:uo,Evented:e.E,config:e.d5,prewarm:e.dp,clearPrewarmedResources:e.dq,get accessToken(){return e.d5.ACCESS_TOKEN},set accessToken(t){e.d5.ACCESS_TOKEN=t;},get baseApiUrl(){return e.d5.API_URL},set baseApiUrl(t){e.d5.API_URL=t;},get workerCount(){return e.dr.workerCount},set workerCount(t){e.dr.workerCount=t;},get maxParallelImageRequests(){return e.d5.MAX_PARALLEL_IMAGE_REQUESTS},set maxParallelImageRequests(t){e.d5.MAX_PARALLEL_IMAGE_REQUESTS=t;},clearStorage(t){e.ds(t);},get workerUrl(){return e.dt.workerUrl},set workerUrl(t){e.dt.workerUrl=t;},get workerClass(){return e.dt.workerClass},set workerClass(t){e.dt.workerClass=t;},get workerParams(){return e.dt.workerParams},set workerParams(t){e.dt.workerParams=t;},get dracoUrl(){return e.du()},set dracoUrl(t){e.dv(t);},get meshoptUrl(){return e.dw()},set meshoptUrl(t){e.dx(t);},setNow:e.f.setNow,restoreNow:e.f.restoreNow};return ba}));

    //
    // Our custom intro provides a specialized "define()" function, called by the
    // AMD modules below, that sets up the worker blob URL and then executes the
    // main module, storing its exported value as 'mapboxgl'


    var mapboxgl$1 = mapboxgl;

    return mapboxgl$1;

    }));

    });

    /* node_modules/fa-svelte/src/Icon.svelte generated by Svelte v3.42.4 */

    const file$1 = "node_modules/fa-svelte/src/Icon.svelte";

    function create_fragment$1(ctx) {
    	let svg;
    	let path_1;
    	let svg_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path_1 = svg_element("path");
    			attr_dev(path_1, "fill", "currentColor");
    			attr_dev(path_1, "d", /*path*/ ctx[0]);
    			add_location(path_1, file$1, 7, 2, 129);
    			attr_dev(svg, "aria-hidden", "true");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classes*/ ctx[1]) + " svelte-1d15yci"));
    			attr_dev(svg, "role", "img");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[2]);
    			add_location(svg, file$1, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*path*/ 1) {
    				attr_dev(path_1, "d", /*path*/ ctx[0]);
    			}

    			if (dirty & /*classes*/ 2 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classes*/ ctx[1]) + " svelte-1d15yci"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*viewBox*/ 4) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[2]);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { icon } = $$props;
    	let path = [];
    	let classes = "";
    	let viewBox = "";

    	$$self.$$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('icon' in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    	};

    	$$self.$capture_state = () => ({ icon, path, classes, viewBox });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    		if ('icon' in $$props) $$invalidate(3, icon = $$new_props.icon);
    		if ('path' in $$props) $$invalidate(0, path = $$new_props.path);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    		if ('viewBox' in $$props) $$invalidate(2, viewBox = $$new_props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*icon*/ 8) {
    			$$invalidate(2, viewBox = "0 0 " + icon.icon[0] + " " + icon.icon[1]);
    		}

    		$$invalidate(1, classes = "fa-svelte " + ($$props.class ? $$props.class : ""));

    		if ($$self.$$.dirty & /*icon*/ 8) {
    			$$invalidate(0, path = icon.icon[4]);
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [path, classes, viewBox, icon];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$z(this, options, instance$1, create_fragment$1, safe_not_equal, { icon: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*icon*/ ctx[3] === undefined && !('icon' in props)) {
    			console.warn("<Icon> was created without expected prop 'icon'");
    		}
    	}

    	get icon() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var faSquareXmark = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'square-xmark';
    var width = 448;
    var height = 512;
    var aliases = [10062,"times-square","xmark-square"];
    var unicode = 'f2d3';
    var svgPathData = 'M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zm79 143c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        aliases,
        unicode,
        svgPathData
      ]};

    exports.faSquareXmark = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = aliases;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    exports.aliases = aliases;
    });

    var source = faSquareXmark;

    var faXmarkSquare = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });

    exports.definition = {
      prefix: source.prefix,
      iconName: source.iconName,
      icon: [
        source.width,
        source.height,
        source.aliases,
        source.unicode,
        source.svgPathData
      ]};

    exports.faXmarkSquare = exports.definition;
    exports.prefix = source.prefix;
    exports.iconName = source.iconName;
    exports.width = source.width;
    exports.height = source.height;
    exports.ligatures = source.aliases;
    exports.unicode = source.unicode;
    exports.svgPathData = source.svgPathData;
    exports.aliases = source.aliases;
    });

    var faXmark = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'xmark';
    var width = 384;
    var height = 512;
    var aliases = [128473,10005,10006,10060,215,"close","multiply","remove","times"];
    var unicode = 'f00d';
    var svgPathData = 'M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        aliases,
        unicode,
        svgPathData
      ]};

    exports.faXmark = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = aliases;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    exports.aliases = aliases;
    });

    function ascending$4(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function bisector$1(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We can’t do this
      // for a comparator (except for specific, known comparators) because we can’t
      // tell if the comparator is symmetric, and an asymmetric comparator can’t be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$4;
        compare2 = (d, x) => ascending$4(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$4 || f === descending$2 ? f : zero$1;
        compare2 = f;
        delta = f;
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function zero$1() {
      return 0;
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector$1(ascending$4);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector$1(number$3).center;
    var bisect = bisectRight;

    function blur(values, r) {
      if (!((r = +r) >= 0)) throw new RangeError("invalid r");
      let length = values.length;
      if (!((length = Math.floor(length)) >= 0)) throw new RangeError("invalid length");
      if (!length || !r) return values;
      const blur = blurf(r);
      const temp = values.slice();
      blur(values, temp, 0, length, 1);
      blur(temp, values, 0, length, 1);
      blur(values, temp, 0, length, 1);
      return values;
    }

    const blur2 = Blur2(blurf);

    const blurImage = Blur2(blurfImage);

    function Blur2(blur) {
      return function(data, rx, ry = rx) {
        if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
        if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
        let {data: values, width, height} = data;
        if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
        if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
        if (!width || !height || (!rx && !ry)) return data;
        const blurx = rx && blur(rx);
        const blury = ry && blur(ry);
        const temp = values.slice();
        if (blurx && blury) {
          blurh(blurx, temp, values, width, height);
          blurh(blurx, values, temp, width, height);
          blurh(blurx, temp, values, width, height);
          blurv(blury, values, temp, width, height);
          blurv(blury, temp, values, width, height);
          blurv(blury, values, temp, width, height);
        } else if (blurx) {
          blurh(blurx, values, temp, width, height);
          blurh(blurx, temp, values, width, height);
          blurh(blurx, values, temp, width, height);
        } else if (blury) {
          blurv(blury, values, temp, width, height);
          blurv(blury, temp, values, width, height);
          blurv(blury, values, temp, width, height);
        }
        return data;
      };
    }

    function blurh(blur, T, S, w, h) {
      for (let y = 0, n = w * h; y < n;) {
        blur(T, S, y, y += w, 1);
      }
    }

    function blurv(blur, T, S, w, h) {
      for (let x = 0, n = w * h; x < w; ++x) {
        blur(T, S, x, x + n, w);
      }
    }

    function blurfImage(radius) {
      const blur = blurf(radius);
      return (T, S, start, stop, step) => {
        start <<= 2, stop <<= 2, step <<= 2;
        blur(T, S, start + 0, stop + 0, step);
        blur(T, S, start + 1, stop + 1, step);
        blur(T, S, start + 2, stop + 2, step);
        blur(T, S, start + 3, stop + 3, step);
      };
    }

    // Given a target array T, a source array S, sets each value T[i] to the average
    // of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,
    // for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between
    // S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an
    // integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted
    // according to r - ⌊radius⌋.
    function blurf(radius) {
      const radius0 = Math.floor(radius);
      if (radius0 === radius) return bluri(radius);
      const t = radius - radius0;
      const w = 2 * radius + 1;
      return (T, S, start, stop, step) => { // stop must be aligned!
        if (!((stop -= step) >= start)) return; // inclusive stop
        let sum = radius0 * S[start];
        const s0 = step * radius0;
        const s1 = s0 + step;
        for (let i = start, j = start + s0; i < j; i += step) {
          sum += S[Math.min(stop, i)];
        }
        for (let i = start, j = stop; i <= j; i += step) {
          sum += S[Math.min(stop, i + s0)];
          T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
          sum -= S[Math.max(start, i - s0)];
        }
      };
    }

    // Like blurf, but optimized for integer radius.
    function bluri(radius) {
      const w = 2 * radius + 1;
      return (T, S, start, stop, step) => { // stop must be aligned!
        if (!((stop -= step) >= start)) return; // inclusive stop
        let sum = radius * S[start];
        const s = step * radius;
        for (let i = start, j = start + s; i < j; i += step) {
          sum += S[Math.min(stop, i)];
        }
        for (let i = start, j = stop; i <= j; i += step) {
          sum += S[Math.min(stop, i + s)];
          T[i] = sum / w;
          sum -= S[Math.max(start, i - s)];
        }
      };
    }

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$4(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$3(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$4);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function variance$1(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance$1(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder$1 {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder$1();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder$1();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$c(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$c, identity$c, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$c, keys);
    }

    function flatten$2(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$2(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$2(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$c, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$b(values, ...keys) {
      return nest(values, identity$c, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f] = F;
      if ((f && f.length !== 2) || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascendingDefined(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascendingDefined(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(compareDefined(f));
    }

    function compareDefined(compare = ascending$4) {
      if (compare === ascending$4) return ascendingDefined;
      if (typeof compare !== "function") throw new TypeError("compare is not a function");
      return (a, b) => {
        const x = compare(a, b);
        if (x || x === 0) return x;
        return (compare(b, b) === 0) - (compare(a, a) === 0);
      };
    }

    function ascendingDefined(a, b) {
      return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length !== 2
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$4(av, bv) || ascending$4(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$4(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$4 = array$5.slice;

    function constant$c(x) {
      return () => x;
    }

    const e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function tickSpec(start, stop, count) {
      const step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log10(step)),
          error = step / Math.pow(10, power),
          factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
      }
      if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
      return [i1, i2, inc];
    }

    function ticks(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      if (!(count > 0)) return [];
      if (start === stop) return [start];
      const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
      if (!(i2 >= i1)) return [];
      const n = i2 - i1 + 1, ticks = new Array(n);
      if (reverse) {
        if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
        else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
      } else {
        if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
        else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
      }
      return ticks;
    }

    function tickIncrement(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      return tickSpec(start, stop, count)[2];
    }

    function tickStep(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
      return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.max(1, Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1);
    }

    function bin() {
      var value = identity$c,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            step,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the domain is aligned with the first tick (which it will by
          // default), then we can use quantization rather than bisection to bin
          // values, which is substantially faster.
          if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

          // If the last threshold is coincident with the domain’s upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we don’t
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        // Be careful not to mutate an array owned by the user!
        var m = tz.length, a = 0, b = m;
        while (tz[a] <= x0) ++a;
        while (tz[b - 1] > x1) --b;
        if (a || b < m) tz = tz.slice(a, b), m = b - a;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        if (isFinite(step)) {
          if (step > 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
              }
            }
          } else if (step < 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                const j = Math.floor((x0 - x) * step);
                bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
              }
            }
          }
        } else {
          for (i = 0; i < n; ++i) {
            if ((x = values[i]) != null && x0 <= x && x <= x1) {
              bins[bisect(tz, x, 0, m)].push(data[i]);
            }
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$c(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$c([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : constant$c(Array.isArray(_) ? slice$4.call(_) : _), histogram) : threshold;
      };

      return histogram;
    }

    function max$5(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function min$3(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect$1(array, k, left = 0, right = Infinity, compare) {
      k = Math.floor(k);
      left = Math.floor(Math.max(0, left));
      right = Math.floor(Math.min(array.length - 1, right));

      if (!(left <= k && k <= right)) return array;

      compare = compare === undefined ? ascendingDefined : compareDefined(compare);

      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect$1(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }

      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function greatest(values, compare = ascending$4) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$4(value, maxValue) > 0
              : ascending$4(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length) || isNaN(p = +p)) return;
      if (p <= 0 || n < 2) return min$3(values);
      if (p >= 1) return max$5(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$5(quickselect$1(values, i0).subarray(0, i0 + 1)),
          value1 = min$3(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length) || isNaN(p = +p)) return;
      if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileIndex(values, p, valueof = number$3) {
      if (isNaN(p = +p)) return;
      numbers = Float64Array.from(values, (_, i) => number$3(valueof(values[i], i, values)));
      if (p <= 0) return minIndex(numbers);
      if (p >= 1) return maxIndex(numbers);
      var numbers,
          index = Uint32Array.from(values, (_, i) => i),
          j = numbers.length - 1,
          i = Math.floor(j * p);
      quickselect$1(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));
      i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);
      return i >= 0 ? i : -1;
    }

    function thresholdFreedmanDiaconis(values, min, max) {
      const c = count$1(values), d = quantile$1(values, 0.75) - quantile$1(values, 0.25);
      return c && d ? Math.ceil((max - min) / (2 * d * Math.pow(c, -1 / 3))) : 1;
    }

    function thresholdScott(values, min, max) {
      const c = count$1(values), d = deviation(values);
      return c && d ? Math.ceil((max - min) * Math.cbrt(c) / (3.49 * d)) : 1;
    }

    function mean$1(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function medianIndex(values, valueof) {
      return quantileIndex(values, 0.5, valueof);
    }

    function* flatten$1(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge$3(arrays) {
      return Array.from(flatten$1(arrays));
    }

    function mode$1(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$3(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function rank(values, valueof = ascending$4) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      let V = Array.from(values);
      const R = new Float64Array(V.length);
      if (valueof.length !== 2) V = V.map(valueof), valueof = ascending$4;
      const compareIndex = (i, j) => valueof(V[i], V[j]);
      let k, r;
      values = Uint32Array.from(V, (_, i) => i);
      // Risky chaining due to Safari 14 https://github.com/d3/d3-array/issues/123
      values.sort(valueof === ascending$4 ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
      values.forEach((j, i) => {
          const c = compareIndex(j, k === undefined ? j : k);
          if (c >= 0) {
            if (k === undefined || c > 0) k = j, r = i;
            R[j] = r;
          } else {
            R[j] = NaN;
          }
        });
      return R;
    }

    function least(values, compare = ascending$4) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$4(value, minValue) < 0
              : ascending$4(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$4) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatestIndex(values, compare = ascending$4) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$3(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$3(matrix, length$3), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$3(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$3(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference$1(values, ...others) {
      values = new InternSet(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint$1(values, other) {
      const iterator = other[Symbol.iterator](), set = new InternSet();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function intersection$1(values, ...others) {
      values = new InternSet(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function set$2(values) {
      return values instanceof InternSet ? values : new InternSet(values);
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        const io = intern(o);
        if (set.has(io)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          const ivalue = intern(value);
          set.add(ivalue);
          if (Object.is(io, ivalue)) break;
        }
      }
      return true;
    }

    function intern(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union$1(...others) {
      const set = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$b(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$8 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$2(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$b) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$2 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$8)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$8)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$4 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$2(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$4, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we don’t ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$b(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum$1(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum$1);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$b(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isn’t worried about “live” collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // don’t; we’d rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$3;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$3(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove$1() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove$1);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$a = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$a(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$a(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$a(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$a(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define$1(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend$2(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define$1(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHex8() {
      return this.rgb().formatHex8();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define$1(Rgb, rgb, extend$2(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }

    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }

    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }

    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }

    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }

    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define$1(Hsl, hsl$2, extend$2(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));

    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }

    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$2 = Math.PI / 180;
    const degrees$3 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define$1(Lab, lab$1, extend$2(Color, {
      brighter(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$3;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$2;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define$1(Hcl, hcl$2, extend$2(Color, {
      brighter(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));

    var A$1 = -0.14861,
        B$2 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$2,
        BC_DA = B$2 * C - D$1 * A$1;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$3 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define$1(Cubehelix, cubehelix$3, extend$2(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$2,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A$1 * cosh + B$2 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$9 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$9(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$9(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$9(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$3(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$2(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$3(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$3(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$9(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$2
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$2 = 180 / Math.PI;

    var identity$a = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$2,
        skewX: Math.atan(skewX) * degrees$2,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$a : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$a;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$a;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$2 = 1e-12;

    function cosh$1(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh$1(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0 ≅ u1.
        if (d2 < epsilon2$2) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh$1(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh$1(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh$1(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$3;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED$1 = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init$y(node, id) {
      var schedule = get$1(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get$1(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get$1(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED$1;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED$1;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED$1;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED$1;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get$1(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get$1(node, id).value[name];
      };
    }

    function interpolate$2(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$2;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init$y(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init$y(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get$1(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get$1(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get$1(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start$1(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start$1(name) ? init$y : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get$1(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$2;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get$1(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$5 = Math.PI,
        halfPi$4 = pi$5 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$4);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$4);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$5 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$6 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$6);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$6); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$6);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$6); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$6);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$6); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$8 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$4, max: max$4, min: min$2} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type$1),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type$1),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type$1),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type$1(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name “__brush” rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type$1("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type$1("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$3(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$2(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$2(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$4(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$4(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$4(point.cur[0] - point[0]) > abs$4(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$4(W - w0, min$2(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$4(N - n0, min$2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$4(W, min$2(E, points[0][0])), e1 = max$4(W, min$2(E, points[1][0])), signX = 1;
                if (signY) n1 = max$4(N, min$2(S, points[0][1])), s1 = max$4(N, min$2(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$4(W - w0, min$2(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$4(W - e0, min$2(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$4(N - n0, min$2(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$4(N - s0, min$2(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$4(W, min$2(E, w0 - dx * signX)), e1 = max$4(W, min$2(E, e0 + dx * signX));
              if (signY) n1 = max$4(N, min$2(S, n0 - dy * signY)), s1 = max$4(N, min$2(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$8(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$8(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$8(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$3 = Math.abs;
    var cos$3 = Math.cos;
    var sin$3 = Math.sin;
    var pi$4 = Math.PI;
    var halfPi$3 = pi$4 / 2;
    var tau$5 = pi$4 * 2;
    var max$3 = Math.max;
    var epsilon$7 = 1e-12;

    function range$2(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$2(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$3(0, tau$5 - padAngle * n) / k;
        dx = k ? padAngle : tau$5 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$2(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$2(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$3(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$3 = Math.PI,
        tau$4 = 2 * pi$3,
        epsilon$6 = 1e-6,
        tauEpsilon = tau$4 - epsilon$6;

    function append$1(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }

    function appendRound$1(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
      if (d > 15) return append$1;
      const k = 10 ** d;
      return function(strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }

    class Path$1 {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
        this._append = digits == null ? append$1 : appendRound$1(digits);
      }
      moveTo(x, y) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x, y) {
        this._append`L${this._x1 = +x},${this._y1 = +y}`;
      }
      quadraticCurveTo(x1, y1, x, y) {
        this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x, y) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
      }
      arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

        // Is the radius negative? Error.
        if (r < 0) throw new Error(`negative radius: ${r}`);

        let x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$6));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$6) || !r) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        }

        // Otherwise, draw an arc!
        else {
          let x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$6) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }

          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;

        // Is the radius negative? Error.
        if (r < 0) throw new Error(`negative radius: ${r}`);

        let dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$6 || Math.abs(this._y1 - y0) > epsilon$6) {
          this._append`L${x0},${y0}`;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$4 + tau$4;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$6) {
          this._append`A${r},${r},0,${+(da >= pi$3)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
        }
      }
      rect(x, y, w, h) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    }

    function path() {
      return new Path$1;
    }

    // Allow instanceof d3.path
    path.prototype = Path$1.prototype;

    function pathRound(digits = 3) {
      return new Path$1(+digits);
    }

    var slice$3 = Array.prototype.slice;

    function constant$7(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$3.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$3,
            sa1 = endAngle.apply(this, argv) - halfPi$3,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$3,
            ta1 = endAngle.apply(this, argv) - halfPi$3;

        if (!context) context = buffer = path();

        if (ap > epsilon$7) {
          if (abs$3(sa1 - sa0) > ap * 2 + epsilon$7) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$3(ta1 - ta0) > ap * 2 + epsilon$7) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$3(sa0), sr * sin$3(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$3(ta0), tr2 * sin$3(ta0));
            context.lineTo(tr * cos$3(ta2), tr * sin$3(ta2));
            context.lineTo(tr2 * cos$3(ta1), tr2 * sin$3(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$3(ta0), tr * sin$3(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$3(sa0), sr * sin$3(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$7(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$7(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$7(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$7(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$7(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$7(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$7(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$2 = array$2.slice;

    function ascending$2(a, b) {
      return a - b;
    }

    function area$5(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$6 = x => () => x;

    function contains$3(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$3() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function Contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values, finite);
          tz = ticks(...nice$1(e[0], e[1], tz), tz);
          while (tz[tz.length - 1] >= e[1]) tz.pop();
          while (tz[1] < e[0]) tz.shift();
        } else {
          tz = tz.slice().sort(ascending$2);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        const v = value == null ? NaN : +value;
        if (isNaN(v)) throw new Error(`invalid value: ${value}`);

        var polygons = [],
            holes = [];

        isorings(values, v, function(ring) {
          smooth(ring, values, v);
          if (area$5(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$3((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = above(values[0], value);
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = above(values[x + 1], value);
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = above(values[y * dx + dx], value);
          t2 = above(values[y * dx], value);
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);
            t3 = t2, t2 = above(values[y * dx + x + 1], value);
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = above(values[y * dx + x + 1], value);
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v1 = valid(values[yt * dx + xt]);
          if (x > 0 && x < dx && xt === x) {
            point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);
          }
          if (y > 0 && y < dy && yt === y) {
            point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$2.call(_)) : constant$6(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$3, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // When computing the extent, ignore infinite values (as well as invalid ones).
    function finite(x) {
      return isFinite(x) ? x : NaN;
    }

    // Is the (possibly invalid) x greater than or equal to the (known valid) value?
    // Treat any invalid value as below negative infinity.
    function above(x, value) {
      return x == null ? false : +x >= value;
    }

    // During smoothing, treat any invalid value as negative infinity.
    function valid(v) {
      return v == null || isNaN(v = +v) ? -Infinity : v;
    }

    function smooth1(x, v0, v1, value) {
      const a = value - v0;
      const b = v1 - v0;
      const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);
      return isNaN(d) ? x : x + d - 0.5;
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$6(20);

      function grid(data) {
        var values = new Float32Array(n * m),
            pow2k = Math.pow(2, -k),
            i = -1;

        for (const d of data) {
          var xi = (x(d, ++i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        }

        blur2({data: values, width: n, height: m}, r * pow2k);
        return values;
      }

      function density(data) {
        var values = grid(data),
            tz = threshold(values),
            pow4k = Math.pow(2, 2 * k);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          tz = ticks(Number.MIN_VALUE, max$5(values) / pow4k, tz);
        }

        return Contours()
            .size([n, m])
            .thresholds(tz.map(d => d * pow4k))
          (values)
            .map((c, i) => (c.value = +tz[i], transform(c)));
      }

      density.contours = function(data) {
        var values = grid(data),
            contours = Contours().size([n, m]),
            pow4k = Math.pow(2, 2 * k),
            contour = value => {
              value = +value;
              var c = transform(contours.contour(values, value * pow4k));
              c.value = value; // preserve exact threshold value
              return c;
            };
        Object.defineProperty(contour, "max", {get: () => max$5(values) / pow4k});
        return contour;
      };

      function transform(geometry) {
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$6(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$2.call(_)) : constant$6(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();
      };

      return density;
    }

    const epsilon$5 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$5) * epsilon$5;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$2(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$5) * epsilon$5;
    const ccwerrboundB = (2 + 12 * epsilon$5) * epsilon$5;
    const ccwerrboundC = (9 + 64 * epsilon$5) * epsilon$5 * epsilon$5;

    const B$1 = vec(4);
    const C1$1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B$1[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B$1[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B$1[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B$1[3] = u3;

        let det = estimate(4, B$1);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$2(4, B$1, 4, u, C1$1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$2(C1len, C1$1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$2(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0, minDist = Infinity; i < n; i++) {
                const d = dist$1(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            // find the point closest to the seed
            for (let i = 0, minDist = Infinity; i < n; i++) {
                if (i === i0) continue;
                const d = dist$1(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    const d = this._dists[id];
                    if (d > d0) {
                        hull[j++] = id;
                        d0 = d;
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist$1(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist$1(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$4 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;
        let bx, by; // lazily computed barycenter of the hull

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // For a degenerate triangle, the circumcenter is at the infinity, in a
            // direction orthogonal to the halfedge and away from the “center” of
            // the diagram <bx, by>, defined as the hull’s barycenter.
            if (bx === undefined) {
              bx = by = 0;
              for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];
              bx /= hull.length, by /= hull.length;
            }
            const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] === cj[aj]
                  && ci[ai + 1] === cj[aj + 1]
                  && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]
                  && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return this._simplify(V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points));
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        // for more robustness, always consider the segment in the same order
        const flip = c0 < c1;
        if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];
        while (true) {
          if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
      _simplify(P) {
        if (P && P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {
              P.splice(j, 2), i -= 2;
            }
          }
          if (!P.length) P = null;
        }
        return P;
      }
    }

    const tau$3 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$3);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer$2(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center$1(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add$3(this.cover(x, y), x, y, d);
    }

    function add$3(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add$3(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$5(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$4(d) {
      return d.x + d.vx;
    }

    function y$4(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$5(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$4, y$4).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$a(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$3(links) {
      var id = index$a,
          strength = defaultStrength,
          strengths,
          distance = constant$5(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$5(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$2 = 1664525;
    const c$4 = 1013904223;
    const m$1 = 4294967296; // 2^32

    function lcg$2() {
      let s = 1;
      return () => (s = (a$2 * s + c$4) % m$1) / m$1;
    }

    function x$3(d) {
      return d.x;
    }

    function y$3(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$2();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$5(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$3, y$3).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$5(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$5(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$2(x) {
      var strength = constant$5(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$5(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$2(y) {
      var strength = constant$5(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$5(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$9(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$9 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$9 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$3 = 1e-6;
    var epsilon2$1 = 1e-12;
    var pi$2 = Math.PI;
    var halfPi$2 = pi$2 / 2;
    var quarterPi$1 = pi$2 / 4;
    var tau$2 = pi$2 * 2;

    var degrees$1 = 180 / pi$2;
    var radians$1 = pi$2 / 180;

    var abs$2 = Math.abs;
    var atan$1 = Math.atan;
    var atan2$2 = Math.atan2;
    var cos$2 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot$1 = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$2 = Math.sin;
    var sign$4 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$3 = Math.sqrt;
    var tan = Math.tan;

    function acos$2(x) {
      return x > 1 ? 0 : x < -1 ? pi$2 : Math.acos(x);
    }

    function asin$2(x) {
      return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$2(x / 2)) * x;
    }

    function noop$2() {}

    function streamGeometry$1(geometry, stream) {
      if (geometry && streamGeometryType$1.hasOwnProperty(geometry.type)) {
        streamGeometryType$1[geometry.type](geometry, stream);
      }
    }

    var streamObjectType$1 = {
      Feature: function(object, stream) {
        streamGeometry$1(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry$1(features[i].geometry, stream);
      }
    };

    var streamGeometryType$1 = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine$1(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine$1(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon$1(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon$1(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry$1(geometries[i], stream);
      }
    };

    function streamLine$1(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon$1(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine$1(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream$1(object, stream) {
      if (object && streamObjectType$1.hasOwnProperty(object.type)) {
        streamObjectType$1[object.type](object, stream);
      } else {
        streamGeometry$1(object, stream);
      }
    }

    var areaRingSum$1 = new Adder$1();

    // hello?

    var areaSum$1 = new Adder$1(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaRingSum$1 = new Adder$1();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$2 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$2;
      },
      sphere: function() {
        areaSum$1.add(tau$2);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians$1, phi *= radians$1;
      lambda0$2 = lambda, cosPhi0$1 = cos$2(phi = phi / 2 + quarterPi$1), sinPhi0$1 = sin$2(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      phi = phi / 2 + quarterPi$1; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoli’s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$2(phi),
          sinPhi = sin$2(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$2(adLambda),
          v = k * sdLambda * sin$2(adLambda);
      areaRingSum$1.add(atan2$2(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$4(object) {
      areaSum$1 = new Adder$1();
      geoStream$1(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical$1(cartesian) {
      return [atan2$2(cartesian[1], cartesian[0]), asin$2(cartesian[2])];
    }

    function cartesian$1(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$2(phi);
      return [cosPhi * cos$2(lambda), cosPhi * sin$2(lambda), sin$2(phi)];
    }

    function cartesianDot$1(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross$1(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace$1(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale$1(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace$1(d) {
      var l = sqrt$3(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range$1;

    var boundsStream$3 = {
      point: boundsPoint$2,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$3.point = boundsRingPoint;
        boundsStream$3.lineStart = boundsRingStart;
        boundsStream$3.lineEnd = boundsRingEnd;
        deltaSum = new Adder$1();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$3.point = boundsPoint$2;
        boundsStream$3.lineStart = boundsLineStart;
        boundsStream$3.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$3) phi1 = 90;
        else if (deltaSum < -epsilon$3) phi0 = -90;
        range$1[0] = lambda0$1, range$1[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$2(lambda, phi) {
      ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian$1([lambda * radians$1, phi * radians$1]);
      if (p0) {
        var normal = cartesianCross$1(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross$1(equatorial, normal);
        cartesianNormalizeInPlace$1(inflection);
        inflection = spherical$1(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees$1 * sign,
            phii,
            antimeridian = abs$2(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees$1;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees$1;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle$1(lambda0$1, lambda) > angle$1(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle$1(lambda, lambda1) > angle$1(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle$1(lambda0$1, lambda) > angle$1(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle$1(lambda, lambda1) > angle$1(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$3.point = linePoint;
    }

    function boundsLineEnd() {
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      boundsStream$3.point = boundsPoint$2;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$2(deltaSum) > epsilon$3) lambda0$1 = -(lambda1 = 180);
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle$1(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds$1(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream$1(feature, boundsStream$3);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle$1(a[0], b[1]) > angle$1(a[0], a[1])) a[1] = b[1];
            if (angle$1(b[0], a[1]) > angle$1(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle$1(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range$1 = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$5, y0$5, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$2,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$2(phi);
      centroidPointCartesian(cosPhi * cos$2(lambda), cosPhi * sin$2(lambda), sin$2(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$2(phi);
      x0$5 = cosPhi * cos$2(lambda);
      y0$5 = cosPhi * sin$2(lambda);
      z0 = sin$2(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$5, y0$5, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$2(phi),
          x = cosPhi * cos$2(lambda),
          y = cosPhi * sin$2(lambda),
          z = sin$2(phi),
          w = atan2$2(sqrt$3((w = y0$5 * z - z0 * y) * w + (w = z0 * x - x0$5 * z) * w + (w = x0$5 * y - y0$5 * x) * w), x0$5 * x + y0$5 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$5 + (x0$5 = x));
      Y1$1 += w * (y0$5 + (y0$5 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$5, y0$5, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians$1, phi *= radians$1;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$2(phi);
      x0$5 = cosPhi * cos$2(lambda);
      y0$5 = cosPhi * sin$2(lambda);
      z0 = sin$2(phi);
      centroidPointCartesian(x0$5, y0$5, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var cosPhi = cos$2(phi),
          x = cosPhi * cos$2(lambda),
          y = cosPhi * sin$2(lambda),
          z = sin$2(phi),
          cx = y0$5 * z - z0 * y,
          cy = z0 * x - x0$5 * z,
          cz = x0$5 * y - y0$5 * x,
          m = hypot$1(cx, cy, cz),
          w = asin$2(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$5 + (x0$5 = x));
      Y1$1 += w * (y0$5 + (y0$5 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$5, y0$5, z0);
    }

    function centroid$2(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder$1();
      Y2$1 = new Adder$1();
      Z2$1 = new Adder$1();
      geoStream$1(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot$1(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2$1) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$3) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot$1(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2$1) return [NaN, NaN];
      }

      return [atan2$2(y, x) * degrees$1, asin$2(z / m) * degrees$1];
    }

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function compose$1(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity$1(lambda, phi) {
      if (abs$2(lambda) > pi$2) lambda -= Math.round(lambda / tau$2) * tau$2;
      return [lambda, phi];
    }

    rotationIdentity$1.invert = rotationIdentity$1;

    function rotateRadians$1(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$2) ? (deltaPhi || deltaGamma ? compose$1(rotationLambda$1(deltaLambda), rotationPhiGamma$1(deltaPhi, deltaGamma))
        : rotationLambda$1(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma$1(deltaPhi, deltaGamma)
        : rotationIdentity$1);
    }

    function forwardRotationLambda$1(deltaLambda) {
      return function(lambda, phi) {
        lambda += deltaLambda;
        if (abs$2(lambda) > pi$2) lambda -= Math.round(lambda / tau$2) * tau$2;
        return [lambda, phi];
      };
    }

    function rotationLambda$1(deltaLambda) {
      var rotation = forwardRotationLambda$1(deltaLambda);
      rotation.invert = forwardRotationLambda$1(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma$1(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$2(deltaPhi),
          sinDeltaPhi = sin$2(deltaPhi),
          cosDeltaGamma = cos$2(deltaGamma),
          sinDeltaGamma = sin$2(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$2(phi),
            x = cos$2(lambda) * cosPhi,
            y = sin$2(lambda) * cosPhi,
            z = sin$2(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$2(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$2(phi),
            x = cos$2(lambda) * cosPhi,
            y = sin$2(lambda) * cosPhi,
            z = sin$2(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$2(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians$1(rotate[0] * radians$1, rotate[1] * radians$1, rotate.length > 2 ? rotate[2] * radians$1 : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians$1, coordinates[1] * radians$1);
        return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians$1, coordinates[1] * radians$1);
        return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream$1(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$2(radius),
          sinRadius = sin$2(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$2;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius$1(cosRadius, t0);
        t1 = circleRadius$1(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$2;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical$1([cosRadius, -sinRadius * cos$2(t), -sinRadius * sin$2(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius$1(cosRadius, point) {
      point = cartesian$1(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace$1(point);
      var radius = acos$2(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$2 - epsilon$3) % tau$2;
    }

    function circle$2() {
      var center = constant$4([0, 0]),
          radius = constant$4(90),
          precision = constant$4(2),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees$1, x[1] *= degrees$1;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians$1,
            p = precision.apply(this, arguments) * radians$1;
        ring = [];
        rotate = rotateRadians$1(-c[0] * radians$1, -c[1] * radians$1, 0).invert;
        circleStream$1(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$4([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$4(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer$1() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$2,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual$1(a, b) {
      return abs$2(a[0] - b[0]) < epsilon$3 && abs$2(a[1] - b[1]) < epsilon$3;
    }

    function Intersection$1(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual$1(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$3;
        }

        subject.push(x = new Intersection$1(p0, segment, null, true));
        clip.push(x.o = new Intersection$1(p0, null, x, false));
        subject.push(x = new Intersection$1(p1, segment, null, false));
        clip.push(x.o = new Intersection$1(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$2(subject);
      link$2(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$2(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$2(point[0]) <= pi$2 ? point[0] : sign$4(point[0]) * ((abs$2(point[0]) + pi$2) % tau$2 - pi$2);
    }

    function polygonContains$1(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$2(phi),
          normal = [sin$2(lambda), -cos$2(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder$1();

      if (sinPhi === 1) phi = halfPi$2 + epsilon$3;
      else if (sinPhi === -1) phi = -halfPi$2 - epsilon$3;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi$1,
            sinPhi0 = sin$2(phi0),
            cosPhi0 = cos$2(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi$1,
              sinPhi1 = sin$2(phi1),
              cosPhi1 = cos$2(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$2,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$2(k * sign * sin$2(absDelta), cosPhi0 * cosPhi1 + k * cos$2(absDelta)));
          angle += antimeridian ? delta + sign * tau$2 : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross$1(cartesian$1(point0), cartesian$1(point1));
            cartesianNormalizeInPlace$1(arc);
            var intersection = cartesianCross$1(normal, arc);
            cartesianNormalizeInPlace$1(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$2(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$3 || angle < epsilon$3 && sum < -epsilon2$1) ^ (winding & 1);
    }

    function clip$1(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer$1(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge$3(segments);
            var startInside = polygonContains$1(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection$1, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment$1));
        }

        return clip;
      };
    }

    function validSegment$1(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection$1(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$3 : halfPi$2 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$3 : halfPi$2 - b[1]);
    }

    var clipAntimeridian$1 = clip$1(
      function() { return true; },
      clipAntimeridianLine$1,
      clipAntimeridianInterpolate$1,
      [-pi$2, -halfPi$2]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine$1(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$2 : -pi$2,
              delta = abs$2(lambda1 - lambda0);
          if (abs$2(delta - pi$2) < epsilon$3) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$2) { // line crosses antimeridian
            if (abs$2(lambda0 - sign0) < epsilon$3) lambda0 -= sign0 * epsilon$3; // handle degeneracies
            if (abs$2(lambda1 - sign1) < epsilon$3) lambda1 -= sign1 * epsilon$3;
            phi0 = clipAntimeridianIntersect$1(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect$1(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$2(lambda0 - lambda1);
      return abs$2(sinLambda0Lambda1) > epsilon$3
          ? atan$1((sin$2(phi0) * (cosPhi1 = cos$2(phi1)) * sin$2(lambda1)
              - sin$2(phi1) * (cosPhi0 = cos$2(phi0)) * sin$2(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate$1(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$2;
        stream.point(-pi$2, phi);
        stream.point(0, phi);
        stream.point(pi$2, phi);
        stream.point(pi$2, 0);
        stream.point(pi$2, -phi);
        stream.point(0, -phi);
        stream.point(-pi$2, -phi);
        stream.point(-pi$2, 0);
        stream.point(-pi$2, phi);
      } else if (abs$2(from[0] - to[0]) > epsilon$3) {
        var lambda = from[0] < to[0] ? pi$2 : -pi$2;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle$1(radius) {
      var cr = cos$2(radius),
          delta = 2 * radians$1,
          smallRadius = cr > 0,
          notHemisphere = abs$2(cr) > epsilon$3; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream$1(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$2(lambda) * cos$2(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$2 : -pi$2), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual$1(point0, point2) || pointEqual$1(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual$1(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian$1(a),
            pb = cartesian$1(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross$1(pa, pb),
            n2n2 = cartesianDot$1(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross$1(n1, n2),
            A = cartesianScale$1(n1, c1),
            B = cartesianScale$1(n2, c2);
        cartesianAddInPlace$1(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot$1(A, u),
            uu = cartesianDot$1(u, u),
            t2 = w * w - uu * (cartesianDot$1(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$3(t2),
            q = cartesianScale$1(u, (-w - t) / uu);
        cartesianAddInPlace$1(q, A);
        q = spherical$1(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$2(delta - pi$2) < epsilon$3,
            meridian = polar || delta < epsilon$3;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$2(q[0] - lambda0) < epsilon$3 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$2 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale$1(u, (-w + t) / uu);
          cartesianAddInPlace$1(q1, A);
          return [q, spherical$1(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$2 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip$1(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$2, radius - pi$2]);
    }

    function clipLine$1(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax$1 = 1e9, clipMin$1 = -clipMax$1;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$2(p[0] - x0) < epsilon$3 ? direction > 0 ? 0 : 3
            : abs$2(p[0] - x1) < epsilon$3 ? direction > 0 ? 2 : 1
            : abs$2(p[1] - y0) < epsilon$3 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer$1(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge$3(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin$1, Math.min(clipMax$1, x_)), y_ = Math.max(clipMin$1, Math.min(clipMax$1, y_))],
                  b = [x = Math.max(clipMin$1, Math.min(clipMax$1, x)), y = Math.max(clipMin$1, Math.min(clipMax$1, y))];
              if (clipLine$1(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$2,
      point: noop$2,
      lineStart: lengthLineStart,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$2;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      lambda0 = lambda, sinPhi0 = sin$2(phi), cosPhi0 = cos$2(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians$1, phi *= radians$1;
      var sinPhi = sin$2(phi),
          cosPhi = cos$2(phi),
          delta = abs$2(lambda - lambda0),
          cosDelta = cos$2(delta),
          sinDelta = sin$2(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$2(sqrt$3(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$2(object) {
      lengthSum$1 = new Adder$1();
      geoStream$1(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object$1 = {type: "LineString", coordinates: coordinates};

    function distance$2(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$2(object$1);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance$2(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance$2(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance$2(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2$1 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains$1(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians$1, point[1] * radians$1];
    }

    function contains$2(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$3(y0, y1 - epsilon$3, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$3(x0, x1 - epsilon$3, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$3(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$3(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$3(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$2(x % DX) > epsilon$3; }).map(x))
            .concat(range$3(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$2(y % DY) > epsilon$3; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$3], [180, 90 - epsilon$3]])
          .extentMinor([[-180, -80 - epsilon$3], [180, 80 + epsilon$3]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate$1(a, b) {
      var x0 = a[0] * radians$1,
          y0 = a[1] * radians$1,
          x1 = b[0] * radians$1,
          y1 = b[1] * radians$1,
          cy0 = cos$2(y0),
          sy0 = sin$2(y0),
          cy1 = cos$2(y1),
          sy1 = sin$2(y1),
          kx0 = cy0 * cos$2(x0),
          ky0 = cy0 * sin$2(x0),
          kx1 = cy1 * cos$2(x1),
          ky1 = cy1 * sin$2(x1),
          d = 2 * asin$2(sqrt$3(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$2(d);

      var interpolate = d ? function(t) {
        var B = sin$2(t *= d) / k,
            A = sin$2(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$2(y, x) * degrees$1,
          atan2$2(z, sqrt$3(x * x + y * y)) * degrees$1
        ];
      } : function() {
        return [x0 * degrees$1, y0 * degrees$1];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$8 = x => x;

    var areaSum = new Adder$1(),
        areaRingSum = new Adder$1(),
        x00$2,
        y00$2,
        x0$4,
        y0$4;

    var areaStream = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$2;
        areaSum.add(abs$2(areaRingSum));
        areaRingSum = new Adder$1();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder$1();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$4 = x, y00$2 = y0$4 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$4 * x - x0$4 * y);
      x0$4 = x, y0$4 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var pathArea = areaStream;

    var x0$3 = Infinity,
        y0$3 = x0$3,
        x1$1 = -x0$3,
        y1$1 = x1$1;

    var boundsStream$1 = {
      point: boundsPoint$1,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2,
      result: function() {
        var bounds = [[x0$3, y0$3], [x1$1, y1$1]];
        x1$1 = y1$1 = -(y0$3 = x0$3 = Infinity);
        return bounds;
      }
    };

    function boundsPoint$1(x, y) {
      if (x < x0$3) x0$3 = x;
      if (x > x1$1) x1$1 = x;
      if (y < y0$3) y0$3 = y;
      if (y > y1$1) y1$1 = y;
    }

    var boundsStream$2 = boundsStream$1;

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$2,
        y0$2;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$2 = x, y0$2 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$2, dy = y - y0$2, z = sqrt$3(dx * dx + dy * dy);
      X1 += z * (x0$2 + x) / 2;
      Y1 += z * (y0$2 + y) / 2;
      Z1 += z;
      centroidPoint(x0$2 = x, y0$2 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$2 = x, y00$1 = y0$2 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$2,
          dy = y - y0$2,
          z = sqrt$3(dx * dx + dy * dy);

      X1 += z * (x0$2 + x) / 2;
      Y1 += z * (y0$2 + y) / 2;
      Z1 += z;

      z = y0$2 * x - x0$2 * y;
      X2 += z * (x0$2 + x);
      Y2 += z * (y0$2 + y);
      Z2 += z * 3;
      centroidPoint(x0$2 = x, y0$2 = y);
    }

    var pathCentroid = centroidStream;

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$2);
            break;
          }
        }
      },
      result: noop$2
    };

    var lengthSum = new Adder$1(),
        lengthRing,
        x00,
        y00,
        x0$1,
        y0$1;

    var lengthStream = {
      point: noop$2,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$2;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder$1();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0$1 = x, y00 = y0$1 = y;
    }

    function lengthPoint(x, y) {
      x0$1 -= x, y0$1 -= y;
      lengthSum.add(sqrt$3(x0$1 * x0$1 + y0$1 * y0$1));
      x0$1 = x, y0$1 = y;
    }

    var pathMeasure = lengthStream;

    // Simple caching for constant-radius points.
    let cacheDigits, cacheAppend, cacheRadius, cacheCircle;

    class PathString {
      constructor(digits) {
        this._append = digits == null ? append : appendRound(digits);
        this._radius = 4.5;
        this._ = "";
      }
      pointRadius(_) {
        this._radius = +_;
        return this;
      }
      polygonStart() {
        this._line = 0;
      }
      polygonEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line === 0) this._ += "Z";
        this._point = NaN;
      }
      point(x, y) {
        switch (this._point) {
          case 0: {
            this._append`M${x},${y}`;
            this._point = 1;
            break;
          }
          case 1: {
            this._append`L${x},${y}`;
            break;
          }
          default: {
            this._append`M${x},${y}`;
            if (this._radius !== cacheRadius || this._append !== cacheAppend) {
              const r = this._radius;
              const s = this._;
              this._ = ""; // stash the old string so we can cache the circle path fragment
              this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
              cacheRadius = r;
              cacheAppend = this._append;
              cacheCircle = this._;
              this._ = s;
            }
            this._ += cacheCircle;
            break;
          }
        }
      }
      result() {
        const result = this._;
        this._ = "";
        return result.length ? result : null;
      }
    }

    function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }

    function appendRound(digits) {
      const d = Math.floor(digits);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
      if (d > 15) return append;
      if (d !== cacheDigits) {
        const k = 10 ** d;
        cacheDigits = d;
        cacheAppend = function append(strings) {
          let i = 1;
          this._ += strings[0];
          for (const j = strings.length; i < j; ++i) {
            this._ += Math.round(arguments[i] * k) / k + strings[i];
          }
        };
      }
      return cacheAppend;
    }

    function index$9(projection, context) {
      let digits = 3,
          pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream$1(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream$1(object, projectionStream(pathArea));
        return pathArea.result();
      };

      path.measure = function(object) {
        geoStream$1(object, projectionStream(pathMeasure));
        return pathMeasure.result();
      };

      path.bounds = function(object) {
        geoStream$1(object, projectionStream(boundsStream$2));
        return boundsStream$2.result();
      };

      path.centroid = function(object) {
        geoStream$1(object, projectionStream(pathCentroid));
        return pathCentroid.result();
      };

      path.projection = function(_) {
        if (!arguments.length) return projection;
        projectionStream = _ == null ? (projection = null, identity$8) : (projection = _).stream;
        return path;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      path.digits = function(_) {
        if (!arguments.length) return digits;
        if (_ == null) digits = null;
        else {
          const d = Math.floor(_);
          if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        if (context === null) contextStream = new PathString(digits);
        return path;
      };

      return path.projection(projection).digits(digits).context(context);
    }

    function transform$3(methods) {
      return {
        stream: transformer$5(methods)
      };
    }

    function transformer$5(methods) {
      return function(stream) {
        var s = new TransformStream$1;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream$1() {}

    TransformStream$1.prototype = {
      constructor: TransformStream$1,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream$1(object, projection.stream(boundsStream$2));
      fitBounds(boundsStream$2.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent$1(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize$1(projection, size, object) {
      return fitExtent$1(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth$1 = 16, // maximum depth of subdivision
        cosMinDistance$1 = cos$2(30 * radians$1); // cos(minimum angular distance)

    function resample$2(project, delta2) {
      return +delta2 ? resample$3(project, delta2) : resampleNone$1(project);
    }

    function resampleNone$1(project) {
      return transformer$5({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$3(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$3(a * a + b * b + c * c),
              phi2 = asin$2(c /= m),
              lambda2 = abs$2(abs$2(c) - 1) < epsilon$3 || abs$2(lambda0 - lambda1) < epsilon$3 ? (lambda0 + lambda1) / 2 : atan2$2(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance$1) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian$1([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth$1, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth$1, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians$1 = transformer$5({
      point: function(x, y) {
        this.stream.point(x * radians$1, y * radians$1);
      }
    });

    function transformRotate$1(rotate) {
      return transformer$5({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$2(alpha),
          sinAlpha = sin$2(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection$1(project) {
      return projectionMutator$1(function() { return project; })();
    }

    function projectionMutator$1(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian$1, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$8, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians$1, point[1] * radians$1);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees$1, point[1] * degrees$1];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians$1(transformRotate$1(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle$1(theta = _ * radians$1) : (theta = null, clipAntimeridian$1), reset()) : theta * degrees$1;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$8) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians$1, phi = _[1] % 360 * radians$1, recenter()) : [lambda * degrees$1, phi * degrees$1];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians$1, deltaPhi = _[1] % 360 * radians$1, deltaGamma = _.length > 2 ? _[2] % 360 * radians$1 : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians$1, recenter()) : alpha * degrees$1;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample$2(projectTransform, delta2 = _ * _), reset()) : sqrt$3(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent$1(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize$1(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians$1(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose$1(project, transform);
        projectRotateTransform = compose$1(rotate, projectTransform);
        projectResample = resample$2(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$2 / 3,
          m = projectionMutator$1(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians$1, phi1 = _[1] * radians$1) : [phi0 * degrees$1, phi1 * degrees$1];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$2(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$2(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$2(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$2(y0), n = (sy0 + sin$2(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$2(n) < epsilon$3) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$3(c) / n;

      function project(x, y) {
        var r = sqrt$3(c - 2 * n * sin$2(y)) / n;
        return [r * sin$2(x *= n), r0 - r * cos$2(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$2(x, abs$2(r0y)) * sign$4(r0y);
        if (r0y * n < 0)
          l -= pi$2 * sign$4(x) * sign$4(r0y);
        return [l / n, asin$2((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$3, y + 0.120 * k + epsilon$3], [x - 0.214 * k - epsilon$3, y + 0.234 * k - epsilon$3]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$3, y + 0.166 * k + epsilon$3], [x - 0.115 * k - epsilon$3, y + 0.234 * k - epsilon$3]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent$1(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize$1(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw$1(scale) {
      return function(x, y) {
        var cx = cos$2(x),
            cy = cos$2(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$2(x),
          k * sin$2(y)
        ];
      }
    }

    function azimuthalInvert$1(angle) {
      return function(x, y) {
        var z = sqrt$3(x * x + y * y),
            c = angle(z),
            sc = sin$2(c),
            cc = cos$2(c);
        return [
          atan2$2(x * sc, z * cc),
          asin$2(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw$1(function(cxcy) {
      return sqrt$3(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert$1(function(z) {
      return 2 * asin$2(z / 2);
    });

    function azimuthalEqualArea() {
      return projection$1(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw$1 = azimuthalRaw$1(function(c) {
      return (c = acos$2(c)) && c / sin$2(c);
    });

    azimuthalEquidistantRaw$1.invert = azimuthalInvert$1(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection$1(azimuthalEquidistantRaw$1)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$2 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan$1(exp(y)) - halfPi$2];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$2);
    }

    function mercatorProjection(project) {
      var m = projection$1(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$2 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$2 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$2(y0),
          n = y0 === y1 ? sin$2(y0) : log$1(cy0 / cos$2(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$2 + epsilon$3) y = -halfPi$2 + epsilon$3; }
        else { if (y > halfPi$2 - epsilon$3) y = halfPi$2 - epsilon$3; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$2(n * x), f - r * cos$2(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$4(n) * sqrt$3(x * x + fy * fy),
          l = atan2$2(x, abs$2(fy)) * sign$4(fy);
        if (fy * n < 0)
          l -= pi$2 * sign$4(x) * sign$4(fy);
        return [l / n, 2 * atan$1(pow$1(f / r, 1 / n)) - halfPi$2];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection$1(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$2(y0),
          n = y0 === y1 ? sin$2(y0) : (cy0 - cos$2(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$2(n) < epsilon$3) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$2(nx), g - gy * cos$2(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$2(x, abs$2(gy)) * sign$4(gy);
        if (gy * n < 0)
          l -= pi$2 * sign$4(x) * sign$4(gy);
        return [l / n, g - sign$4(n) * sqrt$3(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1$1 = 1.340264,
        A2$1 = -0.081106,
        A3$1 = 0.000893,
        A4$1 = 0.003796,
        M$1 = sqrt$3(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$2(M$1 * sin$2(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$2(l) / (M$1 * (A1$1 + 3 * A2$1 * l2 + l6 * (7 * A3$1 + 9 * A4$1 * l2))),
        l * (A1$1 + A2$1 * l2 + l6 * (A3$1 + A4$1 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1$1 + A2$1 * l2 + l6 * (A3$1 + A4$1 * l2)) - y;
        fpy = A1$1 + 3 * A2$1 * l2 + l6 * (7 * A3$1 + 9 * A4$1 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$2(delta) < epsilon2$1) break;
      }
      return [
        M$1 * x * (A1$1 + 3 * A2$1 * l2 + l6 * (7 * A3$1 + 9 * A4$1 * l2)) / cos$2(l),
        asin$2(sin$2(l) / M$1)
      ];
    };

    function equalEarth() {
      return projection$1(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$2(y), k = cos$2(x) * cy;
      return [cy * sin$2(x) / k, sin$2(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert$1(atan$1);

    function gnomonic() {
      return projection$1(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$7() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$5({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$8,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$8) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians$1, sa = sin$2(alpha), ca = cos$2(alpha), reset()) : alpha * degrees$1;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent$1(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize$1(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$2(delta) > epsilon$3 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection$1(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$2(y) * sin$2(x), sin$2(y)];
    }

    orthographicRaw.invert = azimuthalInvert$1(asin$2);

    function orthographic() {
      return projection$1(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$3);
    }

    function stereographicRaw(x, y) {
      var cy = cos$2(y), k = 1 + cos$2(x) * cy;
      return [cy * sin$2(x) / k, sin$2(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert$1(function(z) {
      return 2 * atan$1(z);
    });

    function stereographic() {
      return projection$1(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$2 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan$1(exp(x)) - halfPi$2];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Don’t include the root’s parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$4(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$4(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$4(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$4.prototype = hierarchy.prototype = {
      constructor: Node$4,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array, random) {
      let m = array.length,
          t,
          i;

      while (m) {
        i = random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      return packEncloseRandom(circles, lcg$1());
    }

    function packEncloseRandom(circles, random) {
      var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects$4(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node$3(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packSiblingsRandom(circles, random) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node$3(a), b = new Node$3(b), c = new Node$3(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle…
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node$3(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects$4(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects$4(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = packEncloseRandom(a, random);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packSiblingsRandom(circles, lcg$1());
      return circles;
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$8() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        const random = lcg$1();
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildrenRandom(padding, 0.5, random))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildrenRandom(constantZero, 1, random))
              .eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$3(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildrenRandom(padding, k, random) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packSiblingsRandom(children, random);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {},
        imputed = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId,
          path;

      function stratify(data) {
        var nodes = Array.from(data),
            currentId = id,
            currentParentId = parentId,
            n,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        if (path != null) {
          const I = nodes.map((d, i) => normalize$3(path(d, i, data)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i of P) {
            if (!S.has(i)) {
              S.add(i);
              I.push(i);
              P.push(parentof(i));
              nodes.push(imputed);
            }
          }
          currentId = (_, i) => I[i];
          currentParentId = (_, i) => P[i];
        }

        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$4(d);
          if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");

        // When imputing internal nodes, only introduce roots if needed.
        // Then replace the imputed marker data with null.
        if (path != null) {
          while (root.data === imputed && root.children.length === 1) {
            root = root.children[0], --n;
          }
          for (let i = nodes.length - 1; i >= 0; --i) {
            node = nodes[i];
            if (node.data !== imputed) break;
            node.data = null;
          }
        }

        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = optional(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = optional(x), stratify) : parentId;
      };

      stratify.path = function(x) {
        return arguments.length ? (path = optional(x), stratify) : path;
      };

      return stratify;
    }

    // To normalize a path, we coerce to a string, strip the trailing slash if any
    // (as long as the trailing slash is not immediately preceded by another slash),
    // and add leading slash if missing.
    function normalize$3(path) {
      path = `${path}`;
      let i = path.length;
      if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
      return path[0] === "/" ? path : `/${path}`;
    }

    // Walk backwards to find the first slash that is not the leading slash, e.g.:
    // "/foo/bar" ⇥ "/foo", "/foo" ⇥ "/", "/" ↦ "". (The root is special-cased
    // because the id of the root must be a truthy value.)
    function parentof(path) {
      let i = path.length;
      if (i < 2) return "";
      while (--i > 1) if (slash(path, i)) break;
      return path.slice(0, i);
    }

    // Slashes can be escaped; to determine whether a slash is a path delimiter, we
    // count the number of preceding backslashes escaping the forward slash: an odd
    // number indicates an escaped forward slash.
    function slash(path, i) {
      if (path[i] === "/") {
        let k = 0;
        while (i > 0 && path[--i] === "\\") ++k;
        if ((k & 1) === 0) return true;
      }
      return false;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$4.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.’s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function index$7() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$3(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$3(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$3(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$3(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$3(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi);

    function area$3(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid$1(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$2(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$2(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains$1(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length$1(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$3(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$5() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$6(x) {
      return x;
    }

    function normalize$2(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize$2(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize$2(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize$2(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$4() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$3,
          transform,
          untransform,
          unknown,
          clamp = identity$6,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$6) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$6, rescale()) : clamp !== identity$6;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$4()(identity$6, identity$6);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$5(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$5(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : x => Math.pow(base, x);
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), x => Math.log(x) / base);
    }

    function reflect(f) {
      return (x, k) => -f(-x, k);
    }

    function loggish(transform) {
      const scale = transform(transformLog, transformExp);
      const domain = scale.domain;
      let base = 10;
      let logs;
      let pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = count => {
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;

        if (r) ([u, v] = [v, u]);

        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1; k < base; ++k) {
              t = i < 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1; k >= 1; --k) {
              t = i > 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };

      scale.tickFormat = (count, specifier) => {
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
          specifier = format(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return d => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = () => {
        return domain(nice(domain(), {
          floor: x => pows(Math.floor(logs(x))),
          ceil: x => pows(Math.ceil(logs(x)))
        }));
      };

      return scale;
    }

    function log() {
      const scale = loggish(transformer$4()).domain([1, 10]);
      scale.copy = () => copy$1(scale, log()).base(scale.base());
      initRange.apply(scale, arguments);
      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$4());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$6, identity$6),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$6, identity$6)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$4());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$2() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$2(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$2(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$2)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$4);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    const t0 = new Date, t1 = new Date;

    function timeInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = (date) => {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = (date) => {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = (date) => {
        const d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = (date, step) => {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = (start, stop, step) => {
        const range = [];
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        let previous;
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = (test) => {
        return timeInterval((date) => {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, (date, step) => {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = (start, end) => {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = (step) => {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? (d) => field(d) % step === 0
                  : (d) => interval.count(0, d) % step === 0);
        };
      }

      return interval;
    }

    const millisecond = timeInterval(() => {
      // noop
    }, (date, step) => {
      date.setTime(+date + step);
    }, (start, end) => {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = (k) => {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return timeInterval((date) => {
        date.setTime(Math.floor(date / k) * k);
      }, (date, step) => {
        date.setTime(+date + step * k);
      }, (start, end) => {
        return (end - start) / k;
      });
    };

    const milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    const second = timeInterval((date) => {
      date.setTime(date - date.getMilliseconds());
    }, (date, step) => {
      date.setTime(+date + step * durationSecond);
    }, (start, end) => {
      return (end - start) / durationSecond;
    }, (date) => {
      return date.getUTCSeconds();
    });

    const seconds = second.range;

    const timeMinute = timeInterval((date) => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, (date, step) => {
      date.setTime(+date + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date) => {
      return date.getMinutes();
    });

    const timeMinutes = timeMinute.range;

    const utcMinute = timeInterval((date) => {
      date.setUTCSeconds(0, 0);
    }, (date, step) => {
      date.setTime(+date + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date) => {
      return date.getUTCMinutes();
    });

    const utcMinutes = utcMinute.range;

    const timeHour = timeInterval((date) => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, (date, step) => {
      date.setTime(+date + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date) => {
      return date.getHours();
    });

    const timeHours = timeHour.range;

    const utcHour = timeInterval((date) => {
      date.setUTCMinutes(0, 0, 0);
    }, (date, step) => {
      date.setTime(+date + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date) => {
      return date.getUTCHours();
    });

    const utcHours = utcHour.range;

    const timeDay = timeInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );

    const timeDays = timeDay.range;

    const utcDay = timeInterval((date) => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date) => {
      return date.getUTCDate() - 1;
    });

    const utcDays = utcDay.range;

    const unixDay = timeInterval((date) => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date) => {
      return Math.floor(date / durationDay);
    });

    const unixDays = unixDay.range;

    function timeWeekday(i) {
      return timeInterval((date) => {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setDate(date.getDate() + step * 7);
      }, (start, end) => {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    const timeSunday = timeWeekday(0);
    const timeMonday = timeWeekday(1);
    const timeTuesday = timeWeekday(2);
    const timeWednesday = timeWeekday(3);
    const timeThursday = timeWeekday(4);
    const timeFriday = timeWeekday(5);
    const timeSaturday = timeWeekday(6);

    const timeSundays = timeSunday.range;
    const timeMondays = timeMonday.range;
    const timeTuesdays = timeTuesday.range;
    const timeWednesdays = timeWednesday.range;
    const timeThursdays = timeThursday.range;
    const timeFridays = timeFriday.range;
    const timeSaturdays = timeSaturday.range;

    function utcWeekday(i) {
      return timeInterval((date) => {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, (start, end) => {
        return (end - start) / durationWeek;
      });
    }

    const utcSunday = utcWeekday(0);
    const utcMonday = utcWeekday(1);
    const utcTuesday = utcWeekday(2);
    const utcWednesday = utcWeekday(3);
    const utcThursday = utcWeekday(4);
    const utcFriday = utcWeekday(5);
    const utcSaturday = utcWeekday(6);

    const utcSundays = utcSunday.range;
    const utcMondays = utcMonday.range;
    const utcTuesdays = utcTuesday.range;
    const utcWednesdays = utcWednesday.range;
    const utcThursdays = utcThursday.range;
    const utcFridays = utcFriday.range;
    const utcSaturdays = utcSaturday.range;

    const timeMonth = timeInterval((date) => {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setMonth(date.getMonth() + step);
    }, (start, end) => {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, (date) => {
      return date.getMonth();
    });

    const timeMonths = timeMonth.range;

    const utcMonth = timeInterval((date) => {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, (start, end) => {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, (date) => {
      return date.getUTCMonth();
    });

    const utcMonths = utcMonth.range;

    const timeYear = timeInterval((date) => {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setFullYear(date.getFullYear() + step);
    }, (start, end) => {
      return end.getFullYear() - start.getFullYear();
    }, (date) => {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    timeYear.every = (k) => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    const timeYears = timeYear.range;

    const utcYear = timeInterval((date) => {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, (start, end) => {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, (date) => {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = (k) => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    const utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [second,  1,      durationSecond],
        [second,  5,  5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector$1(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    var formatIso$1 = formatIso;

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var parseIso$1 = parseIso;

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$3() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$6,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$3);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$3()(identity$6));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$3()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$3());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$3());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$6;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$4);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer$2() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$6,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$3);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer$2()(identity$6));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var observable10 = colors("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$2(x) {
      return function constant() {
        return x;
      };
    }

    const abs$1 = Math.abs;
    const atan2$1 = Math.atan2;
    const cos$1 = Math.cos;
    const max$2 = Math.max;
    const min$1 = Math.min;
    const sin$1 = Math.sin;
    const sqrt$1 = Math.sqrt;

    const epsilon$2 = 1e-12;
    const pi$1 = Math.PI;
    const halfPi$1 = pi$1 / 2;
    const tau$1 = 2 * pi$1;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
    }

    function withPath(shape) {
      let digits = 3;

      shape.digits = function(_) {
        if (!arguments.length) return digits;
        if (_ == null) {
          digits = null;
        } else {
          const d = Math.floor(_);
          if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        return shape;
      };

      return () => new Path$1(digits);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect$3(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon$2) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt$1(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt$1(max$2(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$2(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null,
          path = withPath(arc);

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi$1,
            a1 = endAngle.apply(this, arguments) - halfPi$1,
            da = abs$1(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon$2)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau$1 - epsilon$2) {
          context.moveTo(r1 * cos$1(a0), r1 * sin$1(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon$2) {
            context.moveTo(r0 * cos$1(a1), r0 * sin$1(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon$2) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$1(r0 * r0 + r1 * r1)),
              rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon$2) {
            var p0 = asin$1(rp / r0 * sin$1(ap)),
                p1 = asin$1(rp / r1 * sin$1(ap));
            if ((da0 -= p0 * 2) > epsilon$2) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$2) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos$1(a01),
              y01 = r1 * sin$1(a01),
              x10 = r0 * cos$1(a10),
              y10 = r0 * sin$1(a10);

          // Apply rounded corners?
          if (rc > epsilon$2) {
            var x11 = r1 * cos$1(a11),
                y11 = r1 * sin$1(a11),
                x00 = r0 * cos$1(a00),
                y00 = r0 * sin$1(a00),
                oc;

            // Restrict the corner radius according to the sector angle. If this
            // intersection fails, it’s probably because the arc is too small, so
            // disable the corner radius entirely.
            if (da < pi$1) {
              if (oc = intersect$3(x01, y01, x00, y00, x11, y11, x10, y10)) {
                var ax = x01 - oc[0],
                    ay = y01 - oc[1],
                    bx = x11 - oc[0],
                    by = y11 - oc[1],
                    kc = 1 / sin$1(acos$1((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2),
                    lc = sqrt$1(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = min$1(rc, (r0 - lc) / (kc - 1));
                rc1 = min$1(rc, (r1 - lc) / (kc + 1));
              } else {
                rc0 = rc1 = 0;
              }
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon$2)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon$2) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon$2) || !(da0 > epsilon$2)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$2) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
        return [cos$1(a) * r, sin$1(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$2(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice$1 = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x$1(p) {
      return p[0];
    }

    function y$1(p) {
      return p[1];
    }

    function line(x, y) {
      var defined = constant$2(true),
          context = null,
          curve = curveLinear,
          output = null,
          path = withPath(line);

      x = typeof x === "function" ? x : (x === undefined) ? x$1 : constant$2(x);
      y = typeof y === "function" ? y : (y === undefined) ? y$1 : constant$2(y);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x(d, i, data), +y(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$2(+_), line) : x;
      };

      line.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$2(+_), line) : y;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area$2(x0, y0, y1) {
      var x1 = null,
          defined = constant$2(true),
          context = null,
          curve = curveLinear,
          output = null,
          path = withPath(area);

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x$1 : constant$2(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$2(0) : constant$2(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y$1 : constant$2(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$4(d) {
      return d;
    }

    function pie() {
      var value = identity$4,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$2(0),
          endAngle = constant$2(tau$1),
          padAngle = constant$2(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area$2().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    class BumpRadial {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {}
      point(x, y) {
        x = +x, y = +y;
        if (this._point === 0) {
          this._point = 1;
        } else {
          const p0 = pointRadial(this._x0, this._y0);
          const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y) / 2);
          const p2 = pointRadial(x, this._y0);
          const p3 = pointRadial(x, y);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
        this._x0 = x, this._y0 = y;
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function bumpRadial(context) {
      return new BumpRadial(context);
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link$1(curve) {
      let source = linkSource,
          target = linkTarget,
          x = x$1,
          y = y$1,
          context = null,
          output = null,
          path = withPath(link);

      function link() {
        let buffer;
        const argv = slice$1.call(arguments);
        const s = source.apply(this, argv);
        const t = target.apply(this, argv);
        if (context == null) output = curve(buffer = path());
        output.lineStart();
        argv[0] = s, output.point(+x.apply(this, argv), +y.apply(this, argv));
        argv[0] = t, output.point(+x.apply(this, argv), +y.apply(this, argv));
        output.lineEnd();
        if (buffer) return output = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$2(+_), link) : x;
      };

      link.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$2(+_), link) : y;
      };

      link.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
      };

      return link;
    }

    function linkHorizontal() {
      return link$1(bumpX);
    }

    function linkVertical() {
      return link$1(bumpY);
    }

    function linkRadial() {
      const l = link$1(bumpRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    const sqrt3$2 = sqrt$1(3);

    var asterisk = {
      draw(context, size) {
        const r = sqrt$1(size + min$1(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3$2;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };

    var circle$1 = {
      draw(context, size) {
        const r = sqrt$1(size / pi$1);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau$1);
      }
    };

    var cross$1 = {
      draw(context, size) {
        const r = sqrt$1(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    const tan30 = sqrt$1(1 / 3);
    const tan30_2 = tan30 * 2;

    var diamond = {
      draw(context, size) {
        const y = sqrt$1(size / tan30_2);
        const x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var diamond2 = {
      draw(context, size) {
        const r = sqrt$1(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };

    var plus = {
      draw(context, size) {
        const r = sqrt$1(size - min$1(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };

    var square$1 = {
      draw(context, size) {
        const w = sqrt$1(size);
        const x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var square2 = {
      draw(context, size) {
        const r = sqrt$1(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };

    const ka = 0.89081309152928522810;
    const kr = sin$1(pi$1 / 10) / sin$1(7 * pi$1 / 10);
    const kx = sin$1(tau$1 / 10) * kr;
    const ky = -cos$1(tau$1 / 10) * kr;

    var star = {
      draw(context, size) {
        const r = sqrt$1(size * ka);
        const x = kx * r;
        const y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (let i = 1; i < 5; ++i) {
          const a = tau$1 * i / 5;
          const c = cos$1(a);
          const s = sin$1(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    const sqrt3$1 = sqrt$1(3);

    var triangle = {
      draw(context, size) {
        const y = -sqrt$1(size / (sqrt3$1 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3$1 * y, -y);
        context.lineTo(sqrt3$1 * y, -y);
        context.closePath();
      }
    };

    const sqrt3 = sqrt$1(3);

    var triangle2 = {
      draw(context, size) {
        const s = sqrt$1(size) * 0.6824;
        const t = s  / 2;
        const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
        context.moveTo(0, -s);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };

    const c = -0.5;
    const s = sqrt$1(3) / 2;
    const k = 1 / sqrt$1(12);
    const a = (k / 2 + 1) * 3;

    var wye = {
      draw(context, size) {
        const r = sqrt$1(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var times = {
      draw(context, size) {
        const r = sqrt$1(size - min$1(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };

    // These symbols are designed to be filled.
    const symbolsFill = [
      circle$1,
      cross$1,
      diamond,
      square$1,
      star,
      triangle,
      wye
    ];

    // These symbols are designed to be stroked (with a width of 1.5px and round caps).
    const symbolsStroke = [
      circle$1,
      plus,
      times,
      triangle2,
      asterisk,
      square2,
      diamond2
    ];

    function Symbol$1(type, size) {
      let context = null,
          path = withPath(symbol);

      type = typeof type === "function" ? type : constant$2(type || circle$1);
      size = typeof size === "function" ? size : constant$2(size === undefined ? 64 : +size);

      function symbol() {
        let buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$2(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$2(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop$1() {}

    function point$4(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$4(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$4(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$4(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$4(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$3(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$2(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon$2) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon$2) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign$3(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign$3(s0) + sign$3(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$1(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point$1(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point$1(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point$1(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$2([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$2(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$2(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending$1(series) {
      var sums = series.map(sum$1);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum$1(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending$1(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum$1),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse$2(series) {
      return none(series).reverse();
    }

    var constant$1 = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity$3 = new Transform(1, 0, 0);

    transform$2.prototype = Transform.prototype;

    function transform$2(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity$3;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity$3;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity$3.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$1(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$1(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisect,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$4,
        bisector: bisector$1,
        blur: blur,
        blur2: blur2,
        blurImage: blurImage,
        count: count$1,
        cross: cross$3,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder$1,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$b,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: thresholdFreedmanDiaconis,
        thresholdScott: thresholdScott,
        thresholdSturges: thresholdSturges,
        max: max$5,
        maxIndex: maxIndex,
        mean: mean$1,
        median: median,
        medianIndex: medianIndex,
        merge: merge$3,
        min: min$3,
        minIndex: minIndex,
        mode: mode$1,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileIndex: quantileIndex,
        quantileSorted: quantileSorted,
        quickselect: quickselect$1,
        range: range$3,
        rank: rank,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$3,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance$1,
        zip: zip,
        every: every,
        some: some,
        filter: filter$1,
        map: map$1,
        reduce: reduce,
        reverse: reverse$3,
        sort: sort,
        difference: difference$1,
        disjoint: disjoint$1,
        intersection: intersection$1,
        subset: subset,
        superset: superset,
        union: union$1,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: Contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer$2,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center$1,
        forceCollide: collide,
        forceLink: link$3,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$2,
        forceY: y$2,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$4,
        geoBounds: bounds$1,
        geoCentroid: centroid$2,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian$1,
        geoClipCircle: clipCircle$1,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$2,
        geoDistance: distance$2,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate$1,
        geoLength: length$2,
        geoPath: index$9,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw$1,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$7,
        geoProjection: projection$1,
        geoProjectionMutator: projectionMutator$1,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream$1,
        geoTransform: transform$3,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$4,
        pack: index$8,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index$7,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$3,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$2,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        Path: Path$1,
        path: path,
        pathRound: pathRound,
        polygonArea: area$3,
        polygonCentroid: centroid$1,
        polygonHull: hull,
        polygonContains: contains$1,
        polygonLength: length$1,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$5,
        scaleIdentity: identity$5,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$2,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemeObservable10: observable10,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area$2,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        link: link$1,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: Symbol$1,
        symbolsStroke: symbolsStroke,
        symbolsFill: symbolsFill,
        symbols: symbolsFill,
        symbolAsterisk: asterisk,
        symbolCircle: circle$1,
        symbolCross: cross$1,
        symbolDiamond: diamond,
        symbolDiamond2: diamond2,
        symbolPlus: plus,
        symbolSquare: square$1,
        symbolSquare2: square2,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolTriangle2: triangle2,
        symbolWye: wye,
        symbolTimes: times,
        symbolX: times,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending$1,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse$2,
        timeInterval: timeInterval,
        utcMillisecond: millisecond,
        utcMilliseconds: milliseconds,
        timeMillisecond: millisecond,
        timeMilliseconds: milliseconds,
        utcSecond: second,
        utcSeconds: seconds,
        timeSecond: second,
        timeSeconds: seconds,
        timeMinute: timeMinute,
        timeMinutes: timeMinutes,
        utcMinute: utcMinute,
        utcMinutes: utcMinutes,
        timeHour: timeHour,
        timeHours: timeHours,
        utcHour: utcHour,
        utcHours: utcHours,
        timeDay: timeDay,
        timeDays: timeDays,
        utcDay: utcDay,
        utcDays: utcDays,
        unixDay: unixDay,
        unixDays: unixDays,
        timeWeek: timeSunday,
        timeWeeks: timeSundays,
        timeSunday: timeSunday,
        timeSundays: timeSundays,
        timeMonday: timeMonday,
        timeMondays: timeMondays,
        timeTuesday: timeTuesday,
        timeTuesdays: timeTuesdays,
        timeWednesday: timeWednesday,
        timeWednesdays: timeWednesdays,
        timeThursday: timeThursday,
        timeThursdays: timeThursdays,
        timeFriday: timeFriday,
        timeFridays: timeFridays,
        timeSaturday: timeSaturday,
        timeSaturdays: timeSaturdays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        timeMonth: timeMonth,
        timeMonths: timeMonths,
        utcMonth: utcMonth,
        utcMonths: utcMonths,
        timeYear: timeYear,
        timeYears: timeYears,
        utcYear: utcYear,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso$1,
        isoParse: parseIso$1,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform$2,
        zoomIdentity: identity$3,
        ZoomTransform: Transform
    });

    function globals(defs) {
      defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
      defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
      defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

      defs.WGS84 = defs['EPSG:4326'];
      defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
      defs.GOOGLE = defs['EPSG:3857'];
      defs['EPSG:900913'] = defs['EPSG:3857'];
      defs['EPSG:102113'] = defs['EPSG:3857'];
    }

    var PJD_3PARAM = 1;
    var PJD_7PARAM = 2;
    var PJD_GRIDSHIFT = 3;
    var PJD_WGS84 = 4; // WGS84 or equivalent
    var PJD_NODATUM = 5; // WGS84 or equivalent
    var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
    var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
    var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
    var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
    var HALF_PI = Math.PI/2;
    // ellipoid pj_set_ell.c
    var SIXTH = 0.1666666666666666667;
    /* 1/6 */
    var RA4 = 0.04722222222222222222;
    /* 17/360 */
    var RA6 = 0.02215608465608465608;
    var EPSLN = 1.0e-10;
    // you'd think you could use Number.EPSILON above but that makes
    // Mollweide get into an infinate loop.

    var D2R$2 = 0.01745329251994329577;
    var R2D$1 = 57.29577951308232088;
    var FORTPI = Math.PI/4;
    var TWO_PI = Math.PI * 2;
    // SPI is slightly greater than Math.PI, so values that exceed the -180..180
    // degree range by a tiny amount don't get wrapped. This prevents points that
    // have drifted from their original location along the 180th meridian (due to
    // floating point error) from changing their sign.
    var SPI = 3.14159265359;

    var exports$3 = {};

    exports$3.greenwich = 0.0; //"0dE",
    exports$3.lisbon = -9.131906111111; //"9d07'54.862\"W",
    exports$3.paris = 2.337229166667; //"2d20'14.025\"E",
    exports$3.bogota = -74.080916666667; //"74d04'51.3\"W",
    exports$3.madrid = -3.687938888889; //"3d41'16.58\"W",
    exports$3.rome = 12.452333333333; //"12d27'8.4\"E",
    exports$3.bern = 7.439583333333; //"7d26'22.5\"E",
    exports$3.jakarta = 106.807719444444; //"106d48'27.79\"E",
    exports$3.ferro = -17.666666666667; //"17d40'W",
    exports$3.brussels = 4.367975; //"4d22'4.71\"E",
    exports$3.stockholm = 18.058277777778; //"18d3'29.8\"E",
    exports$3.athens = 23.7163375; //"23d42'58.815\"E",
    exports$3.oslo = 10.722916666667; //"10d43'22.5\"E"

    var units = {
      ft: {to_meter: 0.3048},
      'us-ft': {to_meter: 1200 / 3937}
    };

    var ignoredChar = /[\s_\-\/\(\)]/g;
    function match(obj, key) {
      if (obj[key]) {
        return obj[key];
      }
      var keys = Object.keys(obj);
      var lkey = key.toLowerCase().replace(ignoredChar, '');
      var i = -1;
      var testkey, processedKey;
      while (++i < keys.length) {
        testkey = keys[i];
        processedKey = testkey.toLowerCase().replace(ignoredChar, '');
        if (processedKey === lkey) {
          return obj[testkey];
        }
      }
    }

    function projStr(defData) {
      var self = {};
      var paramObj = defData.split('+').map(function(v) {
        return v.trim();
      }).filter(function(a) {
        return a;
      }).reduce(function(p, a) {
        var split = a.split('=');
        split.push(true);
        p[split[0].toLowerCase()] = split[1];
        return p;
      }, {});
      var paramName, paramVal, paramOutname;
      var params = {
        proj: 'projName',
        datum: 'datumCode',
        rf: function(v) {
          self.rf = parseFloat(v);
        },
        lat_0: function(v) {
          self.lat0 = v * D2R$2;
        },
        lat_1: function(v) {
          self.lat1 = v * D2R$2;
        },
        lat_2: function(v) {
          self.lat2 = v * D2R$2;
        },
        lat_ts: function(v) {
          self.lat_ts = v * D2R$2;
        },
        lon_0: function(v) {
          self.long0 = v * D2R$2;
        },
        lon_1: function(v) {
          self.long1 = v * D2R$2;
        },
        lon_2: function(v) {
          self.long2 = v * D2R$2;
        },
        alpha: function(v) {
          self.alpha = parseFloat(v) * D2R$2;
        },
        gamma: function(v) {
          self.rectified_grid_angle = parseFloat(v);
        },
        lonc: function(v) {
          self.longc = v * D2R$2;
        },
        x_0: function(v) {
          self.x0 = parseFloat(v);
        },
        y_0: function(v) {
          self.y0 = parseFloat(v);
        },
        k_0: function(v) {
          self.k0 = parseFloat(v);
        },
        k: function(v) {
          self.k0 = parseFloat(v);
        },
        a: function(v) {
          self.a = parseFloat(v);
        },
        b: function(v) {
          self.b = parseFloat(v);
        },
        r: function(v) {
          self.a = self.b = parseFloat(v);
        },
        r_a: function() {
          self.R_A = true;
        },
        zone: function(v) {
          self.zone = parseInt(v, 10);
        },
        south: function() {
          self.utmSouth = true;
        },
        towgs84: function(v) {
          self.datum_params = v.split(",").map(function(a) {
            return parseFloat(a);
          });
        },
        to_meter: function(v) {
          self.to_meter = parseFloat(v);
        },
        units: function(v) {
          self.units = v;
          var unit = match(units, v);
          if (unit) {
            self.to_meter = unit.to_meter;
          }
        },
        from_greenwich: function(v) {
          self.from_greenwich = v * D2R$2;
        },
        pm: function(v) {
          var pm = match(exports$3, v);
          self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R$2;
        },
        nadgrids: function(v) {
          if (v === '@null') {
            self.datumCode = 'none';
          }
          else {
            self.nadgrids = v;
          }
        },
        axis: function(v) {
          var legalAxis = "ewnsud";
          if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
            self.axis = v;
          }
        },
        approx: function() {
          self.approx = true;
        }
      };
      for (paramName in paramObj) {
        paramVal = paramObj[paramName];
        if (paramName in params) {
          paramOutname = params[paramName];
          if (typeof paramOutname === 'function') {
            paramOutname(paramVal);
          }
          else {
            self[paramOutname] = paramVal;
          }
        }
        else {
          self[paramName] = paramVal;
        }
      }
      if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
        self.datumCode = self.datumCode.toLowerCase();
      }
      return self;
    }

    var NEUTRAL = 1;
    var KEYWORD = 2;
    var NUMBER = 3;
    var QUOTED = 4;
    var AFTERQUOTE = 5;
    var ENDED = -1;
    var whitespace = /\s/;
    var latin = /[A-Za-z]/;
    var keyword = /[A-Za-z84_]/;
    var endThings = /[,\]]/;
    var digets = /[\d\.E\-\+]/;
    // const ignoredChar = /[\s_\-\/\(\)]/g;
    function Parser(text) {
      if (typeof text !== 'string') {
        throw new Error('not a string');
      }
      this.text = text.trim();
      this.level = 0;
      this.place = 0;
      this.root = null;
      this.stack = [];
      this.currentObject = null;
      this.state = NEUTRAL;
    }
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char)
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ',') {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === ']') {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }

        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === '[') {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = '';
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
    };

    function parseString(txt) {
      var parser = new Parser(txt);
      return parser.output();
    }

    function mapit(obj, key, value) {
      if (Array.isArray(key)) {
        value.unshift(key);
        key = null;
      }
      var thing = key ? {} : obj;

      var out = value.reduce(function(newObj, item) {
        sExpr(item, newObj);
        return newObj
      }, thing);
      if (key) {
        obj[key] = out;
      }
    }

    function sExpr(v, obj) {
      if (!Array.isArray(v)) {
        obj[v] = true;
        return;
      }
      var key = v.shift();
      if (key === 'PARAMETER') {
        key = v.shift();
      }
      if (v.length === 1) {
        if (Array.isArray(v[0])) {
          obj[key] = {};
          sExpr(v[0], obj[key]);
          return;
        }
        obj[key] = v[0];
        return;
      }
      if (!v.length) {
        obj[key] = true;
        return;
      }
      if (key === 'TOWGS84') {
        obj[key] = v;
        return;
      }
      if (key === 'AXIS') {
        if (!(key in obj)) {
          obj[key] = [];
        }
        obj[key].push(v);
        return;
      }
      if (!Array.isArray(key)) {
        obj[key] = {};
      }

      var i;
      switch (key) {
        case 'UNIT':
        case 'PRIMEM':
        case 'VERT_DATUM':
          obj[key] = {
            name: v[0].toLowerCase(),
            convert: v[1]
          };
          if (v.length === 3) {
            sExpr(v[2], obj[key]);
          }
          return;
        case 'SPHEROID':
        case 'ELLIPSOID':
          obj[key] = {
            name: v[0],
            a: v[1],
            rf: v[2]
          };
          if (v.length === 4) {
            sExpr(v[3], obj[key]);
          }
          return;
        case 'PROJECTEDCRS':
        case 'PROJCRS':
        case 'GEOGCS':
        case 'GEOCCS':
        case 'PROJCS':
        case 'LOCAL_CS':
        case 'GEODCRS':
        case 'GEODETICCRS':
        case 'GEODETICDATUM':
        case 'EDATUM':
        case 'ENGINEERINGDATUM':
        case 'VERT_CS':
        case 'VERTCRS':
        case 'VERTICALCRS':
        case 'COMPD_CS':
        case 'COMPOUNDCRS':
        case 'ENGINEERINGCRS':
        case 'ENGCRS':
        case 'FITTED_CS':
        case 'LOCAL_DATUM':
        case 'DATUM':
          v[0] = ['name', v[0]];
          mapit(obj, key, v);
          return;
        default:
          i = -1;
          while (++i < v.length) {
            if (!Array.isArray(v[i])) {
              return sExpr(v, obj[key]);
            }
          }
          return mapit(obj, key, v);
      }
    }

    var D2R$1 = 0.01745329251994329577;



    function rename(obj, params) {
      var outName = params[0];
      var inName = params[1];
      if (!(outName in obj) && (inName in obj)) {
        obj[outName] = obj[inName];
        if (params.length === 3) {
          obj[outName] = params[2](obj[outName]);
        }
      }
    }

    function d2r(input) {
      return input * D2R$1;
    }

    function cleanWKT(wkt) {
      if (wkt.type === 'GEOGCS') {
        wkt.projName = 'longlat';
      } else if (wkt.type === 'LOCAL_CS') {
        wkt.projName = 'identity';
        wkt.local = true;
      } else {
        if (typeof wkt.PROJECTION === 'object') {
          wkt.projName = Object.keys(wkt.PROJECTION)[0];
        } else {
          wkt.projName = wkt.PROJECTION;
        }
      }
      if (wkt.AXIS) {
        var axisOrder = '';
        for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
          var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
          if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
            axisOrder += 'n';
          } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
            axisOrder += 's';
          } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
            axisOrder += 'e';
          } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
            axisOrder += 'w';
          }
        }
        if (axisOrder.length === 2) {
          axisOrder += 'u';
        }
        if (axisOrder.length === 3) {
          wkt.axis = axisOrder;
        }
      }
      if (wkt.UNIT) {
        wkt.units = wkt.UNIT.name.toLowerCase();
        if (wkt.units === 'metre') {
          wkt.units = 'meter';
        }
        if (wkt.UNIT.convert) {
          if (wkt.type === 'GEOGCS') {
            if (wkt.DATUM && wkt.DATUM.SPHEROID) {
              wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
            }
          } else {
            wkt.to_meter = wkt.UNIT.convert;
          }
        }
      }
      var geogcs = wkt.GEOGCS;
      if (wkt.type === 'GEOGCS') {
        geogcs = wkt;
      }
      if (geogcs) {
        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
        //}
        if (geogcs.DATUM) {
          wkt.datumCode = geogcs.DATUM.name.toLowerCase();
        } else {
          wkt.datumCode = geogcs.name.toLowerCase();
        }
        if (wkt.datumCode.slice(0, 2) === 'd_') {
          wkt.datumCode = wkt.datumCode.slice(2);
        }
        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
          wkt.datumCode = 'nzgd49';
        }
        if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
          if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
            wkt.sphere = true;
          }
          wkt.datumCode = 'wgs84';
        }
        if (wkt.datumCode.slice(-6) === '_ferro') {
          wkt.datumCode = wkt.datumCode.slice(0, - 6);
        }
        if (wkt.datumCode.slice(-8) === '_jakarta') {
          wkt.datumCode = wkt.datumCode.slice(0, - 8);
        }
        if (~wkt.datumCode.indexOf('belge')) {
          wkt.datumCode = 'rnb72';
        }
        if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
          wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
          if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
            wkt.ellps = 'intl';
          }

          wkt.a = geogcs.DATUM.SPHEROID.a;
          wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
        }

        if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
          wkt.datum_params = geogcs.DATUM.TOWGS84;
        }
        if (~wkt.datumCode.indexOf('osgb_1936')) {
          wkt.datumCode = 'osgb36';
        }
        if (~wkt.datumCode.indexOf('osni_1952')) {
          wkt.datumCode = 'osni52';
        }
        if (~wkt.datumCode.indexOf('tm65')
          || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
          wkt.datumCode = 'ire65';
        }
        if (wkt.datumCode === 'ch1903+') {
          wkt.datumCode = 'ch1903';
        }
        if (~wkt.datumCode.indexOf('israel')) {
          wkt.datumCode = 'isr93';
        }
      }
      if (wkt.b && !isFinite(wkt.b)) {
        wkt.b = wkt.a;
      }

      function toMeter(input) {
        var ratio = wkt.to_meter || 1;
        return input * ratio;
      }
      var renamer = function(a) {
        return rename(wkt, a);
      };
      var list = [
        ['standard_parallel_1', 'Standard_Parallel_1'],
        ['standard_parallel_1', 'Latitude of 1st standard parallel'],
        ['standard_parallel_2', 'Standard_Parallel_2'],
        ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
        ['false_easting', 'False_Easting'],
        ['false_easting', 'False easting'],
        ['false-easting', 'Easting at false origin'],
        ['false_northing', 'False_Northing'],
        ['false_northing', 'False northing'],
        ['false_northing', 'Northing at false origin'],
        ['central_meridian', 'Central_Meridian'],
        ['central_meridian', 'Longitude of natural origin'],
        ['central_meridian', 'Longitude of false origin'],
        ['latitude_of_origin', 'Latitude_Of_Origin'],
        ['latitude_of_origin', 'Central_Parallel'],
        ['latitude_of_origin', 'Latitude of natural origin'],
        ['latitude_of_origin', 'Latitude of false origin'],
        ['scale_factor', 'Scale_Factor'],
        ['k0', 'scale_factor'],
        ['latitude_of_center', 'Latitude_Of_Center'],
        ['latitude_of_center', 'Latitude_of_center'],
        ['lat0', 'latitude_of_center', d2r],
        ['longitude_of_center', 'Longitude_Of_Center'],
        ['longitude_of_center', 'Longitude_of_center'],
        ['longc', 'longitude_of_center', d2r],
        ['x0', 'false_easting', toMeter],
        ['y0', 'false_northing', toMeter],
        ['long0', 'central_meridian', d2r],
        ['lat0', 'latitude_of_origin', d2r],
        ['lat0', 'standard_parallel_1', d2r],
        ['lat1', 'standard_parallel_1', d2r],
        ['lat2', 'standard_parallel_2', d2r],
        ['azimuth', 'Azimuth'],
        ['alpha', 'azimuth', d2r],
        ['srsCode', 'name']
      ];
      list.forEach(renamer);
      if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
        wkt.long0 = wkt.longc;
      }
      if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
        wkt.lat_ts = wkt.lat1;
      } else if (!wkt.lat_ts && wkt.lat0 && wkt.projName === 'Polar_Stereographic') {
        wkt.lat_ts = wkt.lat0;
        wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
      }
    }
    function wkt(wkt) {
      var lisp = parseString(wkt);
      var type = lisp.shift();
      var name = lisp.shift();
      lisp.unshift(['name', name]);
      lisp.unshift(['type', type]);
      var obj = {};
      sExpr(lisp, obj);
      cleanWKT(obj);
      return obj;
    }

    function defs(name) {
      /*global console*/
      var that = this;
      if (arguments.length === 2) {
        var def = arguments[1];
        if (typeof def === 'string') {
          if (def.charAt(0) === '+') {
            defs[name] = projStr(arguments[1]);
          }
          else {
            defs[name] = wkt(arguments[1]);
          }
        } else {
          defs[name] = def;
        }
      }
      else if (arguments.length === 1) {
        if (Array.isArray(name)) {
          return name.map(function(v) {
            if (Array.isArray(v)) {
              defs.apply(that, v);
            }
            else {
              defs(v);
            }
          });
        }
        else if (typeof name === 'string') {
          if (name in defs) {
            return defs[name];
          }
        }
        else if ('EPSG' in name) {
          defs['EPSG:' + name.EPSG] = name;
        }
        else if ('ESRI' in name) {
          defs['ESRI:' + name.ESRI] = name;
        }
        else if ('IAU2000' in name) {
          defs['IAU2000:' + name.IAU2000] = name;
        }
        else {
          console.log(name);
        }
        return;
      }


    }
    globals(defs);

    function testObj(code){
      return typeof code === 'string';
    }
    function testDef(code){
      return code in defs;
    }
    var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
    function testWKT(code){
      return codeWords.some(function (word) {
        return code.indexOf(word) > -1;
      });
    }
    var codes = ['3857', '900913', '3785', '102113'];
    function checkMercator(item) {
      var auth = match(item, 'authority');
      if (!auth) {
        return;
      }
      var code = match(auth, 'epsg');
      return code && codes.indexOf(code) > -1;
    }
    function checkProjStr(item) {
      var ext = match(item, 'extension');
      if (!ext) {
        return;
      }
      return match(ext, 'proj4');
    }
    function testProj(code){
      return code[0] === '+';
    }
    function parse(code){
      if (testObj(code)) {
        //check to see if this is a WKT string
        if (testDef(code)) {
          return defs[code];
        }
        if (testWKT(code)) {
          var out = wkt(code);
          // test of spetial case, due to this being a very common and often malformed
          if (checkMercator(out)) {
            return defs['EPSG:3857'];
          }
          var maybeProjStr = checkProjStr(out);
          if (maybeProjStr) {
            return projStr(maybeProjStr);
          }
          return out;
        }
        if (testProj(code)) {
          return projStr(code);
        }
      }else {
        return code;
      }
    }

    function extend$1(destination, source) {
      destination = destination || {};
      var value, property;
      if (!source) {
        return destination;
      }
      for (property in source) {
        value = source[property];
        if (value !== undefined) {
          destination[property] = value;
        }
      }
      return destination;
    }

    function msfnz(eccent, sinphi, cosphi) {
      var con = eccent * sinphi;
      return cosphi / (Math.sqrt(1 - con * con));
    }

    function sign$2(x) {
      return x<0 ? -1 : 1;
    }

    function adjust_lon(x) {
      return (Math.abs(x) <= SPI) ? x : (x - (sign$2(x) * TWO_PI));
    }

    function tsfnz(eccent, phi, sinphi) {
      var con = eccent * sinphi;
      var com = 0.5 * eccent;
      con = Math.pow(((1 - con) / (1 + con)), com);
      return (Math.tan(0.5 * (HALF_PI - phi)) / con);
    }

    function phi2z(eccent, ts) {
      var eccnth = 0.5 * eccent;
      var con, dphi;
      var phi = HALF_PI - 2 * Math.atan(ts);
      for (var i = 0; i <= 15; i++) {
        con = eccent * Math.sin(phi);
        dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }
      //console.log("phi2z has NoConvergence");
      return -9999;
    }

    function init$x() {
      var con = this.b / this.a;
      this.es = 1 - con * con;
      if(!('x0' in this)){
        this.x0 = 0;
      }
      if(!('y0' in this)){
        this.y0 = 0;
      }
      this.e = Math.sqrt(this.es);
      if (this.lat_ts) {
        if (this.sphere) {
          this.k0 = Math.cos(this.lat_ts);
        }
        else {
          this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
        }
      }
      else {
        if (!this.k0) {
          if (this.k) {
            this.k0 = this.k;
          }
          else {
            this.k0 = 1;
          }
        }
      }
    }

    /* Mercator forward equations--mapping lat,long to x,y
      --------------------------------------------------*/

    function forward$v(p) {
      var lon = p.x;
      var lat = p.y;
      // convert to radians
      if (lat * R2D$1 > 90 && lat * R2D$1 < -90 && lon * R2D$1 > 180 && lon * R2D$1 < -180) {
        return null;
      }

      var x, y;
      if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
        return null;
      }
      else {
        if (this.sphere) {
          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
          y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
        }
        else {
          var sinphi = Math.sin(lat);
          var ts = tsfnz(this.e, lat, sinphi);
          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
          y = this.y0 - this.a * this.k0 * Math.log(ts);
        }
        p.x = x;
        p.y = y;
        return p;
      }
    }

    /* Mercator inverse equations--mapping x,y to lat/long
      --------------------------------------------------*/
    function inverse$v(p) {

      var x = p.x - this.x0;
      var y = p.y - this.y0;
      var lon, lat;

      if (this.sphere) {
        lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
      }
      else {
        var ts = Math.exp(-y / (this.a * this.k0));
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
          return null;
        }
      }
      lon = adjust_lon(this.long0 + x / (this.a * this.k0));

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$x = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
    var merc = {
      init: init$x,
      forward: forward$v,
      inverse: inverse$v,
      names: names$x
    };

    function init$w() {
      //no-op for longlat
    }

    function identity$2(pt) {
      return pt;
    }
    var names$w = ["longlat", "identity"];
    var longlat = {
      init: init$w,
      forward: identity$2,
      inverse: identity$2,
      names: names$w
    };

    var projs = [merc, longlat];
    var names$v = {};
    var projStore = [];

    function add$2(proj, i) {
      var len = projStore.length;
      if (!proj.names) {
        console.log(i);
        return true;
      }
      projStore[len] = proj;
      proj.names.forEach(function(n) {
        names$v[n.toLowerCase()] = len;
      });
      return this;
    }

    function get(name) {
      if (!name) {
        return false;
      }
      var n = name.toLowerCase();
      if (typeof names$v[n] !== 'undefined' && projStore[names$v[n]]) {
        return projStore[names$v[n]];
      }
    }

    function start() {
      projs.forEach(add$2);
    }
    var projections = {
      start: start,
      add: add$2,
      get: get
    };

    var exports$2 = {};
    exports$2.MERIT = {
      a: 6378137.0,
      rf: 298.257,
      ellipseName: "MERIT 1983"
    };

    exports$2.SGS85 = {
      a: 6378136.0,
      rf: 298.257,
      ellipseName: "Soviet Geodetic System 85"
    };

    exports$2.GRS80 = {
      a: 6378137.0,
      rf: 298.257222101,
      ellipseName: "GRS 1980(IUGG, 1980)"
    };

    exports$2.IAU76 = {
      a: 6378140.0,
      rf: 298.257,
      ellipseName: "IAU 1976"
    };

    exports$2.airy = {
      a: 6377563.396,
      b: 6356256.910,
      ellipseName: "Airy 1830"
    };

    exports$2.APL4 = {
      a: 6378137,
      rf: 298.25,
      ellipseName: "Appl. Physics. 1965"
    };

    exports$2.NWL9D = {
      a: 6378145.0,
      rf: 298.25,
      ellipseName: "Naval Weapons Lab., 1965"
    };

    exports$2.mod_airy = {
      a: 6377340.189,
      b: 6356034.446,
      ellipseName: "Modified Airy"
    };

    exports$2.andrae = {
      a: 6377104.43,
      rf: 300.0,
      ellipseName: "Andrae 1876 (Den., Iclnd.)"
    };

    exports$2.aust_SA = {
      a: 6378160.0,
      rf: 298.25,
      ellipseName: "Australian Natl & S. Amer. 1969"
    };

    exports$2.GRS67 = {
      a: 6378160.0,
      rf: 298.2471674270,
      ellipseName: "GRS 67(IUGG 1967)"
    };

    exports$2.bessel = {
      a: 6377397.155,
      rf: 299.1528128,
      ellipseName: "Bessel 1841"
    };

    exports$2.bess_nam = {
      a: 6377483.865,
      rf: 299.1528128,
      ellipseName: "Bessel 1841 (Namibia)"
    };

    exports$2.clrk66 = {
      a: 6378206.4,
      b: 6356583.8,
      ellipseName: "Clarke 1866"
    };

    exports$2.clrk80 = {
      a: 6378249.145,
      rf: 293.4663,
      ellipseName: "Clarke 1880 mod."
    };

    exports$2.clrk80ign = {
      a: 6378249.2,
      b: 6356515,
      rf: 293.4660213,
      ellipseName: "Clarke 1880 (IGN)"
    };

    exports$2.clrk58 = {
      a: 6378293.645208759,
      rf: 294.2606763692654,
      ellipseName: "Clarke 1858"
    };

    exports$2.CPM = {
      a: 6375738.7,
      rf: 334.29,
      ellipseName: "Comm. des Poids et Mesures 1799"
    };

    exports$2.delmbr = {
      a: 6376428.0,
      rf: 311.5,
      ellipseName: "Delambre 1810 (Belgium)"
    };

    exports$2.engelis = {
      a: 6378136.05,
      rf: 298.2566,
      ellipseName: "Engelis 1985"
    };

    exports$2.evrst30 = {
      a: 6377276.345,
      rf: 300.8017,
      ellipseName: "Everest 1830"
    };

    exports$2.evrst48 = {
      a: 6377304.063,
      rf: 300.8017,
      ellipseName: "Everest 1948"
    };

    exports$2.evrst56 = {
      a: 6377301.243,
      rf: 300.8017,
      ellipseName: "Everest 1956"
    };

    exports$2.evrst69 = {
      a: 6377295.664,
      rf: 300.8017,
      ellipseName: "Everest 1969"
    };

    exports$2.evrstSS = {
      a: 6377298.556,
      rf: 300.8017,
      ellipseName: "Everest (Sabah & Sarawak)"
    };

    exports$2.fschr60 = {
      a: 6378166.0,
      rf: 298.3,
      ellipseName: "Fischer (Mercury Datum) 1960"
    };

    exports$2.fschr60m = {
      a: 6378155.0,
      rf: 298.3,
      ellipseName: "Fischer 1960"
    };

    exports$2.fschr68 = {
      a: 6378150.0,
      rf: 298.3,
      ellipseName: "Fischer 1968"
    };

    exports$2.helmert = {
      a: 6378200.0,
      rf: 298.3,
      ellipseName: "Helmert 1906"
    };

    exports$2.hough = {
      a: 6378270.0,
      rf: 297.0,
      ellipseName: "Hough"
    };

    exports$2.intl = {
      a: 6378388.0,
      rf: 297.0,
      ellipseName: "International 1909 (Hayford)"
    };

    exports$2.kaula = {
      a: 6378163.0,
      rf: 298.24,
      ellipseName: "Kaula 1961"
    };

    exports$2.lerch = {
      a: 6378139.0,
      rf: 298.257,
      ellipseName: "Lerch 1979"
    };

    exports$2.mprts = {
      a: 6397300.0,
      rf: 191.0,
      ellipseName: "Maupertius 1738"
    };

    exports$2.new_intl = {
      a: 6378157.5,
      b: 6356772.2,
      ellipseName: "New International 1967"
    };

    exports$2.plessis = {
      a: 6376523.0,
      rf: 6355863.0,
      ellipseName: "Plessis 1817 (France)"
    };

    exports$2.krass = {
      a: 6378245.0,
      rf: 298.3,
      ellipseName: "Krassovsky, 1942"
    };

    exports$2.SEasia = {
      a: 6378155.0,
      b: 6356773.3205,
      ellipseName: "Southeast Asia"
    };

    exports$2.walbeck = {
      a: 6376896.0,
      b: 6355834.8467,
      ellipseName: "Walbeck"
    };

    exports$2.WGS60 = {
      a: 6378165.0,
      rf: 298.3,
      ellipseName: "WGS 60"
    };

    exports$2.WGS66 = {
      a: 6378145.0,
      rf: 298.25,
      ellipseName: "WGS 66"
    };

    exports$2.WGS7 = {
      a: 6378135.0,
      rf: 298.26,
      ellipseName: "WGS 72"
    };

    var WGS84 = exports$2.WGS84 = {
      a: 6378137.0,
      rf: 298.257223563,
      ellipseName: "WGS 84"
    };

    exports$2.sphere = {
      a: 6370997.0,
      b: 6370997.0,
      ellipseName: "Normal Sphere (r=6370997)"
    };

    function eccentricity(a, b, rf, R_A) {
      var a2 = a * a; // used in geocentric
      var b2 = b * b; // used in geocentric
      var es = (a2 - b2) / a2; // e ^ 2
      var e = 0;
      if (R_A) {
        a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
        a2 = a * a;
        es = 0;
      } else {
        e = Math.sqrt(es); // eccentricity
      }
      var ep2 = (a2 - b2) / b2; // used in geocentric
      return {
        es: es,
        e: e,
        ep2: ep2
      };
    }
    function sphere(a, b, rf, ellps, sphere) {
      if (!a) { // do we have an ellipsoid?
        var ellipse = match(exports$2, ellps);
        if (!ellipse) {
          ellipse = WGS84;
        }
        a = ellipse.a;
        b = ellipse.b;
        rf = ellipse.rf;
      }

      if (rf && !b) {
        b = (1.0 - 1.0 / rf) * a;
      }
      if (rf === 0 || Math.abs(a - b) < EPSLN) {
        sphere = true;
        b = a;
      }
      return {
        a: a,
        b: b,
        rf: rf,
        sphere: sphere
      };
    }

    var exports$1 = {};
    exports$1.wgs84 = {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    };

    exports$1.ch1903 = {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    };

    exports$1.ggrs87 = {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    };

    exports$1.nad83 = {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    };

    exports$1.nad27 = {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    };

    exports$1.potsdam = {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    };

    exports$1.carthage = {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    };

    exports$1.hermannskogel = {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    };

    exports$1.militargeographische_institut = {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Militar-Geographische Institut"
    };

    exports$1.osni52 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    };

    exports$1.ire65 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    };

    exports$1.rassadiran = {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    };

    exports$1.nzgd49 = {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    };

    exports$1.osgb36 = {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Airy 1830"
    };

    exports$1.s_jtsk = {
      towgs84: "589,76,480",
      ellipse: 'bessel',
      datumName: 'S-JTSK (Ferro)'
    };

    exports$1.beduaram = {
      towgs84: '-106,-87,188',
      ellipse: 'clrk80',
      datumName: 'Beduaram'
    };

    exports$1.gunung_segara = {
      towgs84: '-403,684,41',
      ellipse: 'bessel',
      datumName: 'Gunung Segara Jakarta'
    };

    exports$1.rnb72 = {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    };

    function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
      var out = {};

      if (datumCode === undefined || datumCode === 'none') {
        out.datum_type = PJD_NODATUM;
      } else {
        out.datum_type = PJD_WGS84;
      }

      if (datum_params) {
        out.datum_params = datum_params.map(parseFloat);
        if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
          out.datum_type = PJD_3PARAM;
        }
        if (out.datum_params.length > 3) {
          if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
            out.datum_type = PJD_7PARAM;
            out.datum_params[3] *= SEC_TO_RAD;
            out.datum_params[4] *= SEC_TO_RAD;
            out.datum_params[5] *= SEC_TO_RAD;
            out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
          }
        }
      }

      if (nadgrids) {
        out.datum_type = PJD_GRIDSHIFT;
        out.grids = nadgrids;
      }
      out.a = a; //datum object also uses these values
      out.b = b;
      out.es = es;
      out.ep2 = ep2;
      return out;
    }

    /**
     * Resources for details of NTv2 file formats:
     * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
     * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
     */

    var loadedNadgrids = {};

    /**
     * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
     * as an ArrayBuffer.
     */
    function nadgrid(key, data) {
      var view = new DataView(data);
      var isLittleEndian = detectLittleEndian(view);
      var header = readHeader(view, isLittleEndian);
      var subgrids = readSubgrids(view, header, isLittleEndian);
      var nadgrid = {header: header, subgrids: subgrids};
      loadedNadgrids[key] = nadgrid;
      return nadgrid;
    }

    /**
     * Given a proj4 value for nadgrids, return an array of loaded grids
     */
    function getNadgrids(nadgrids) {
      // Format details: http://proj.maptools.org/gen_parms.html
      if (nadgrids === undefined) { return null; }
      var grids = nadgrids.split(',');
      return grids.map(parseNadgridString);
    }

    function parseNadgridString(value) {
      if (value.length === 0) {
        return null;
      }
      var optional = value[0] === '@';
      if (optional) {
        value = value.slice(1);
      }
      if (value === 'null') {
        return {name: 'null', mandatory: !optional, grid: null, isNull: true};
      }
      return {
        name: value,
        mandatory: !optional,
        grid: loadedNadgrids[value] || null,
        isNull: false
      };
    }

    function secondsToRadians(seconds) {
      return (seconds / 3600) * Math.PI / 180;
    }

    function detectLittleEndian(view) {
      var nFields = view.getInt32(8, false);
      if (nFields === 11) {
        return false;
      }
      nFields = view.getInt32(8, true);
      if (nFields !== 11) {
        console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
      }
      return true;
    }

    function readHeader(view, isLittleEndian) {
      return {
        nFields: view.getInt32(8, isLittleEndian),
        nSubgridFields: view.getInt32(24, isLittleEndian),
        nSubgrids: view.getInt32(40, isLittleEndian),
        shiftType: decodeString(view, 56, 56 + 8).trim(),
        fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
        fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
        toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
        toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
      };
    }

    function decodeString(view, start, end) {
      return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
    }

    function readSubgrids(view, header, isLittleEndian) {
      var gridOffset = 176;
      var grids = [];
      for (var i = 0; i < header.nSubgrids; i++) {
        var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
        var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
        var lngColumnCount = Math.round(
          1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
        var latColumnCount = Math.round(
          1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
        // Proj4 operates on radians whereas the coordinates are in seconds in the grid
        grids.push({
          ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
          del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
          lim: [lngColumnCount, latColumnCount],
          count: subHeader.gridNodeCount,
          cvs: mapNodes(nodes)
        });
        gridOffset += 176 + subHeader.gridNodeCount * 16;
      }
      return grids;
    }

    function mapNodes(nodes) {
      return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
    }

    function readGridHeader(view, offset, isLittleEndian) {
      return {
        name: decodeString(view, offset + 8, offset + 16).trim(),
        parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
        lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
        upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
        lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
        upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
        latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
        longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
        gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
      };
    }

    function readGridNodes(view, offset, gridHeader, isLittleEndian) {
      var nodesOffset = offset + 176;
      var gridRecordLength = 16;
      var gridShiftRecords = [];
      for (var i = 0; i < gridHeader.gridNodeCount; i++) {
        var record = {
          latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
          longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
          latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
          longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
        };
        gridShiftRecords.push(record);
      }
      return gridShiftRecords;
    }

    function Projection(srsCode,callback) {
      if (!(this instanceof Projection)) {
        return new Projection(srsCode);
      }
      callback = callback || function(error){
        if(error){
          throw error;
        }
      };
      var json = parse(srsCode);
      if(typeof json !== 'object'){
        callback(srsCode);
        return;
      }
      var ourProj = Projection.projections.get(json.projName);
      if(!ourProj){
        callback(srsCode);
        return;
      }
      if (json.datumCode && json.datumCode !== 'none') {
        var datumDef = match(exports$1, json.datumCode);
        if (datumDef) {
          json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
          json.ellps = datumDef.ellipse;
          json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
        }
      }
      json.k0 = json.k0 || 1.0;
      json.axis = json.axis || 'enu';
      json.ellps = json.ellps || 'wgs84';
      json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

      var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
      var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
      var nadgrids = getNadgrids(json.nadgrids);
      var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
        nadgrids);

      extend$1(this, json); // transfer everything over from the projection because we don't know what we'll need
      extend$1(this, ourProj); // transfer all the methods from the projection

      // copy the 4 things over we calculated in deriveConstants.sphere
      this.a = sphere_.a;
      this.b = sphere_.b;
      this.rf = sphere_.rf;
      this.sphere = sphere_.sphere;

      // copy the 3 things we calculated in deriveConstants.eccentricity
      this.es = ecc.es;
      this.e = ecc.e;
      this.ep2 = ecc.ep2;

      // add in the datum object
      this.datum = datumObj;

      // init the projection
      this.init();

      // legecy callback from back in the day when it went to spatialreference.org
      callback(null, this);

    }
    Projection.projections = projections;
    Projection.projections.start();

    function compareDatums(source, dest) {
      if (source.datum_type !== dest.datum_type) {
        return false; // false, datums are not equal
      } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
        // the tolerance for es is to ensure that GRS80 and WGS84
        // are considered identical
        return false;
      } else if (source.datum_type === PJD_3PARAM) {
        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
      } else if (source.datum_type === PJD_7PARAM) {
        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
      } else {
        return true; // datums are equal
      }
    } // cs_compare_datums()

    /*
     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
     * according to the current ellipsoid parameters.
     *
     *    Latitude  : Geodetic latitude in radians                     (input)
     *    Longitude : Geodetic longitude in radians                    (input)
     *    Height    : Geodetic height, in meters                       (input)
     *    X         : Calculated Geocentric X coordinate, in meters    (output)
     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
     *
     */
    function geodeticToGeocentric(p, es, a) {
      var Longitude = p.x;
      var Latitude = p.y;
      var Height = p.z ? p.z : 0; //Z value not always supplied

      var Rn; /*  Earth radius at location  */
      var Sin_Lat; /*  Math.sin(Latitude)  */
      var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
      var Cos_Lat; /*  Math.cos(Latitude)  */

      /*
       ** Don't blow up if Latitude is just a little out of the value
       ** range as it may just be a rounding issue.  Also removed longitude
       ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
       */
      if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
        Latitude = -HALF_PI;
      } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
        Latitude = HALF_PI;
      } else if (Latitude < -HALF_PI) {
        /* Latitude out of range */
        //..reportError('geocent:lat out of range:' + Latitude);
        return { x: -Infinity, y: -Infinity, z: p.z };
      } else if (Latitude > HALF_PI) {
        /* Latitude out of range */
        return { x: Infinity, y: Infinity, z: p.z };
      }

      if (Longitude > Math.PI) {
        Longitude -= (2 * Math.PI);
      }
      Sin_Lat = Math.sin(Latitude);
      Cos_Lat = Math.cos(Latitude);
      Sin2_Lat = Sin_Lat * Sin_Lat;
      Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
      return {
        x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
        y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
        z: ((Rn * (1 - es)) + Height) * Sin_Lat
      };
    } // cs_geodetic_to_geocentric()

    function geocentricToGeodetic(p, es, a, b) {
      /* local defintions and variables */
      /* end-criterium of loop, accuracy of sin(Latitude) */
      var genau = 1e-12;
      var genau2 = (genau * genau);
      var maxiter = 30;

      var P; /* distance between semi-minor axis and location */
      var RR; /* distance between center and location */
      var CT; /* sin of geocentric latitude */
      var ST; /* cos of geocentric latitude */
      var RX;
      var RK;
      var RN; /* Earth radius at location */
      var CPHI0; /* cos of start or old geodetic latitude in iterations */
      var SPHI0; /* sin of start or old geodetic latitude in iterations */
      var CPHI; /* cos of searched geodetic latitude */
      var SPHI; /* sin of searched geodetic latitude */
      var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
      var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

      var X = p.x;
      var Y = p.y;
      var Z = p.z ? p.z : 0.0; //Z value not always supplied
      var Longitude;
      var Latitude;
      var Height;

      P = Math.sqrt(X * X + Y * Y);
      RR = Math.sqrt(X * X + Y * Y + Z * Z);

      /*      special cases for latitude and longitude */
      if (P / a < genau) {

        /*  special case, if P=0. (X=0., Y=0.) */
        Longitude = 0.0;

        /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
         *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
        if (RR / a < genau) {
          Latitude = HALF_PI;
          Height = -b;
          return {
            x: p.x,
            y: p.y,
            z: p.z
          };
        }
      } else {
        /*  ellipsoidal (geodetic) longitude
         *  interval: -PI < Longitude <= +PI */
        Longitude = Math.atan2(Y, X);
      }

      /* --------------------------------------------------------------
       * Following iterative algorithm was developped by
       * "Institut for Erdmessung", University of Hannover, July 1988.
       * Internet: www.ife.uni-hannover.de
       * Iterative computation of CPHI,SPHI and Height.
       * Iteration of CPHI and SPHI to 10**-12 radian resp.
       * 2*10**-7 arcsec.
       * --------------------------------------------------------------
       */
      CT = Z / RR;
      ST = P / RR;
      RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
      CPHI0 = ST * (1.0 - es) * RX;
      SPHI0 = CT * RX;
      iter = 0;

      /* loop to find sin(Latitude) resp. Latitude
       * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
      do {
        iter++;
        RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

        /*  ellipsoidal (geodetic) height */
        Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

        RK = es * RN / (RN + Height);
        RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
        CPHI = ST * (1.0 - RK) * RX;
        SPHI = CT * RX;
        SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
        CPHI0 = CPHI;
        SPHI0 = SPHI;
      }
      while (SDPHI * SDPHI > genau2 && iter < maxiter);

      /*      ellipsoidal (geodetic) latitude */
      Latitude = Math.atan(SPHI / Math.abs(CPHI));
      return {
        x: Longitude,
        y: Latitude,
        z: Height
      };
    } // cs_geocentric_to_geodetic()

    /****************************************************************/
    // pj_geocentic_to_wgs84( p )
    //  p = point to transform in geocentric coordinates (x,y,z)


    /** point object, nothing fancy, just allows values to be
        passed back and forth by reference rather than by value.
        Other point classes may be used as long as they have
        x and y properties, which will get modified in the transform method.
    */
    function geocentricToWgs84(p, datum_type, datum_params) {

      if (datum_type === PJD_3PARAM) {
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: p.x + datum_params[0],
          y: p.y + datum_params[1],
          z: p.z + datum_params[2],
        };
      } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        // if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
          y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
          z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
        };
      }
    } // cs_geocentric_to_wgs84

    /****************************************************************/
    // pj_geocentic_from_wgs84()
    //  coordinate system definition,
    //  point to transform in geocentric coordinates (x,y,z)
    function geocentricFromWgs84(p, datum_type, datum_params) {

      if (datum_type === PJD_3PARAM) {
        //if( x[io] === HUGE_VAL )
        //    continue;
        return {
          x: p.x - datum_params[0],
          y: p.y - datum_params[1],
          z: p.z - datum_params[2],
        };

      } else if (datum_type === PJD_7PARAM) {
        var Dx_BF = datum_params[0];
        var Dy_BF = datum_params[1];
        var Dz_BF = datum_params[2];
        var Rx_BF = datum_params[3];
        var Ry_BF = datum_params[4];
        var Rz_BF = datum_params[5];
        var M_BF = datum_params[6];
        var x_tmp = (p.x - Dx_BF) / M_BF;
        var y_tmp = (p.y - Dy_BF) / M_BF;
        var z_tmp = (p.z - Dz_BF) / M_BF;
        //if( x[io] === HUGE_VAL )
        //    continue;

        return {
          x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
          y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
          z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
        };
      } //cs_geocentric_from_wgs84()
    }

    function checkParams(type) {
      return (type === PJD_3PARAM || type === PJD_7PARAM);
    }

    function datum_transform(source, dest, point) {
      // Short cut if the datums are identical.
      if (compareDatums(source, dest)) {
        return point; // in this case, zero is sucess,
        // whereas cs_compare_datums returns 1 to indicate TRUE
        // confusing, should fix this
      }

      // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
      if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
        return point;
      }

      // If this datum requires grid shifts, then apply it to geodetic coordinates.
      var source_a = source.a;
      var source_es = source.es;
      if (source.datum_type === PJD_GRIDSHIFT) {
        var gridShiftCode = applyGridShift(source, false, point);
        if (gridShiftCode !== 0) {
          return undefined;
        }
        source_a = SRS_WGS84_SEMIMAJOR;
        source_es = SRS_WGS84_ESQUARED;
      }

      var dest_a = dest.a;
      var dest_b = dest.b;
      var dest_es = dest.es;
      if (dest.datum_type === PJD_GRIDSHIFT) {
        dest_a = SRS_WGS84_SEMIMAJOR;
        dest_b = SRS_WGS84_SEMIMINOR;
        dest_es = SRS_WGS84_ESQUARED;
      }

      // Do we need to go through geocentric coordinates?
      if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
        return point;
      }

      // Convert to geocentric coordinates.
      point = geodeticToGeocentric(point, source_es, source_a);
      // Convert between datums
      if (checkParams(source.datum_type)) {
        point = geocentricToWgs84(point, source.datum_type, source.datum_params);
      }
      if (checkParams(dest.datum_type)) {
        point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
      }
      point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

      if (dest.datum_type === PJD_GRIDSHIFT) {
        var destGridShiftResult = applyGridShift(dest, true, point);
        if (destGridShiftResult !== 0) {
          return undefined;
        }
      }

      return point;
    }

    function applyGridShift(source, inverse, point) {
      if (source.grids === null || source.grids.length === 0) {
        console.log('Grid shift grids not found');
        return -1;
      }
      var input = {x: -point.x, y: point.y};
      var output = {x: Number.NaN, y: Number.NaN};
      var attemptedGrids = [];
      outer:
      for (var i = 0; i < source.grids.length; i++) {
        var grid = source.grids[i];
        attemptedGrids.push(grid.name);
        if (grid.isNull) {
          output = input;
          break;
        }
        if (grid.grid === null) {
          if (grid.mandatory) {
            console.log("Unable to find mandatory grid '" + grid.name + "'");
            return -1;
          }
          continue;
        }
        var subgrids = grid.grid.subgrids;
        for (var j = 0, jj = subgrids.length; j < jj; j++) {
          var subgrid = subgrids[j];
          // skip tables that don't match our point at all
          var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
          var minX = subgrid.ll[0] - epsilon;
          var minY = subgrid.ll[1] - epsilon;
          var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
          var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
          if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
            continue;
          }
          output = applySubgridShift(input, inverse, subgrid);
          if (!isNaN(output.x)) {
            break outer;
          }
        }
      }
      if (isNaN(output.x)) {
        console.log("Failed to find a grid shift table for location '"+
          -input.x * R2D$1 + " " + input.y * R2D$1 + " tried: '" + attemptedGrids + "'");
        return -1;
      }
      point.x = -output.x;
      point.y = output.y;
      return 0;
    }

    function applySubgridShift(pin, inverse, ct) {
      var val = {x: Number.NaN, y: Number.NaN};
      if (isNaN(pin.x)) { return val; }
      var tb = {x: pin.x, y: pin.y};
      tb.x -= ct.ll[0];
      tb.y -= ct.ll[1];
      tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
      var t = nadInterpolate(tb, ct);
      if (inverse) {
        if (isNaN(t.x)) {
          return val;
        }
        t.x = tb.x - t.x;
        t.y = tb.y - t.y;
        var i = 9, tol = 1e-12;
        var dif, del;
        do {
          del = nadInterpolate(t, ct);
          if (isNaN(del.x)) {
            console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
            break;
          }
          dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
          t.x += dif.x;
          t.y += dif.y;
        } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
        if (i < 0) {
          console.log("Inverse grid shift iterator failed to converge.");
          return val;
        }
        val.x = adjust_lon(t.x + ct.ll[0]);
        val.y = t.y + ct.ll[1];
      } else {
        if (!isNaN(t.x)) {
          val.x = pin.x + t.x;
          val.y = pin.y + t.y;
        }
      }
      return val;
    }

    function nadInterpolate(pin, ct) {
      var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
      var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
      var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
      var val= {x: Number.NaN, y: Number.NaN};
      var inx;
      if (indx.x < 0 || indx.x >= ct.lim[0]) {
        return val;
      }
      if (indx.y < 0 || indx.y >= ct.lim[1]) {
        return val;
      }
      inx = (indx.y * ct.lim[0]) + indx.x;
      var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx++;
      var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx += ct.lim[0];
      var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      inx--;
      var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
      var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
        m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
      val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
      val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
      return val;
    }

    function adjust_axis(crs, denorm, point) {
      var xin = point.x,
        yin = point.y,
        zin = point.z || 0.0;
      var v, t, i;
      var out = {};
      for (i = 0; i < 3; i++) {
        if (denorm && i === 2 && point.z === undefined) {
          continue;
        }
        if (i === 0) {
          v = xin;
          if ("ew".indexOf(crs.axis[i]) !== -1) {
            t = 'x';
          } else {
            t = 'y';
          }

        }
        else if (i === 1) {
          v = yin;
          if ("ns".indexOf(crs.axis[i]) !== -1) {
            t = 'y';
          } else {
            t = 'x';
          }
        }
        else {
          v = zin;
          t = 'z';
        }
        switch (crs.axis[i]) {
        case 'e':
          out[t] = v;
          break;
        case 'w':
          out[t] = -v;
          break;
        case 'n':
          out[t] = v;
          break;
        case 's':
          out[t] = -v;
          break;
        case 'u':
          if (point[t] !== undefined) {
            out.z = v;
          }
          break;
        case 'd':
          if (point[t] !== undefined) {
            out.z = -v;
          }
          break;
        default:
          //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
          return null;
        }
      }
      return out;
    }

    function common (array){
      var out = {
        x: array[0],
        y: array[1]
      };
      if (array.length>2) {
        out.z = array[2];
      }
      if (array.length>3) {
        out.m = array[3];
      }
      return out;
    }

    function checkSanity (point) {
      checkCoord(point.x);
      checkCoord(point.y);
    }
    function checkCoord(num) {
      if (typeof Number.isFinite === 'function') {
        if (Number.isFinite(num)) {
          return;
        }
        throw new TypeError('coordinates must be finite numbers');
      }
      if (typeof num !== 'number' || num !== num || !isFinite(num)) {
        throw new TypeError('coordinates must be finite numbers');
      }
    }

    function checkNotWGS(source, dest) {
      return (
        (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== 'WGS84') ||
        ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== 'WGS84');
    }

    function transform$1(source, dest, point, enforceAxis) {
      var wgs84;
      if (Array.isArray(point)) {
        point = common(point);
      } else {
        // Clone the point object so inputs don't get modified
        point = {
          x: point.x,
          y: point.y,
          z: point.z,
          m: point.m
        };
      }
      var hasZ = point.z !== undefined;
      checkSanity(point);
      // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
      if (source.datum && dest.datum && checkNotWGS(source, dest)) {
        wgs84 = new Projection('WGS84');
        point = transform$1(source, wgs84, point, enforceAxis);
        source = wgs84;
      }
      // DGR, 2010/11/12
      if (enforceAxis && source.axis !== 'enu') {
        point = adjust_axis(source, false, point);
      }
      // Transform source points to long/lat, if they aren't already.
      if (source.projName === 'longlat') {
        point = {
          x: point.x * D2R$2,
          y: point.y * D2R$2,
          z: point.z || 0
        };
      } else {
        if (source.to_meter) {
          point = {
            x: point.x * source.to_meter,
            y: point.y * source.to_meter,
            z: point.z || 0
          };
        }
        point = source.inverse(point); // Convert Cartesian to longlat
        if (!point) {
          return;
        }
      }
      // Adjust for the prime meridian if necessary
      if (source.from_greenwich) {
        point.x += source.from_greenwich;
      }

      // Convert datums if needed, and if possible.
      point = datum_transform(source.datum, dest.datum, point);
      if (!point) {
        return;
      }

      // Adjust for the prime meridian if necessary
      if (dest.from_greenwich) {
        point = {
          x: point.x - dest.from_greenwich,
          y: point.y,
          z: point.z || 0
        };
      }

      if (dest.projName === 'longlat') {
        // convert radians to decimal degrees
        point = {
          x: point.x * R2D$1,
          y: point.y * R2D$1,
          z: point.z || 0
        };
      } else { // else project
        point = dest.forward(point);
        if (dest.to_meter) {
          point = {
            x: point.x / dest.to_meter,
            y: point.y / dest.to_meter,
            z: point.z || 0
          };
        }
      }

      // DGR, 2010/11/12
      if (enforceAxis && dest.axis !== 'enu') {
        return adjust_axis(dest, true, point);
      }

      if (point && !hasZ) {
        delete point.z;
      }
      return point;
    }

    var wgs84 = Projection('WGS84');

    function transformer$1(from, to, coords, enforceAxis) {
      var transformedArray, out, keys;
      if (Array.isArray(coords)) {
        transformedArray = transform$1(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
        if (coords.length > 2) {
          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
            if (typeof transformedArray.z === 'number') {
              return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
            } else {
              return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
            }
          } else {
            return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
          }
        } else {
          return [transformedArray.x, transformedArray.y];
        }
      } else {
        out = transform$1(from, to, coords, enforceAxis);
        keys = Object.keys(coords);
        if (keys.length === 2) {
          return out;
        }
        keys.forEach(function (key) {
          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
            if (key === 'x' || key === 'y' || key === 'z') {
              return;
            }
          } else {
            if (key === 'x' || key === 'y') {
              return;
            }
          }
          out[key] = coords[key];
        });
        return out;
      }
    }

    function checkProj(item) {
      if (item instanceof Projection) {
        return item;
      }
      if (item.oProj) {
        return item.oProj;
      }
      return Projection(item);
    }

    function proj4(fromProj, toProj, coord) {
      fromProj = checkProj(fromProj);
      var single = false;
      var obj;
      if (typeof toProj === 'undefined') {
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
      } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
        coord = toProj;
        toProj = fromProj;
        fromProj = wgs84;
        single = true;
      }
      toProj = checkProj(toProj);
      if (coord) {
        return transformer$1(fromProj, toProj, coord);
      } else {
        obj = {
          forward: function (coords, enforceAxis) {
            return transformer$1(fromProj, toProj, coords, enforceAxis);
          },
          inverse: function (coords, enforceAxis) {
            return transformer$1(toProj, fromProj, coords, enforceAxis);
          }
        };
        if (single) {
          obj.oProj = toProj;
        }
        return obj;
      }
    }

    /**
     * UTM zones are grouped, and assigned to one of a group of 6
     * sets.
     *
     * {int} @private
     */
    var NUM_100K_SETS = 6;

    /**
     * The column letters (for easting) of the lower left value, per
     * set.
     *
     * {string} @private
     */
    var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

    /**
     * The row letters (for northing) of the lower left value, per
     * set.
     *
     * {string} @private
     */
    var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

    var A = 65; // A
    var I = 73; // I
    var O = 79; // O
    var V = 86; // V
    var Z = 90; // Z
    var mgrs = {
      forward: forward$u,
      inverse: inverse$u,
      toPoint: toPoint
    };
    /**
     * Conversion of lat/lon to MGRS.
     *
     * @param {object} ll Object literal with lat and lon properties on a
     *     WGS84 ellipsoid.
     * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
     *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
     * @return {string} the MGRS string for the given location and accuracy.
     */
    function forward$u(ll, accuracy) {
      accuracy = accuracy || 5; // default accuracy 1m
      return encode(LLtoUTM({
        lat: ll[1],
        lon: ll[0]
      }), accuracy);
    }
    /**
     * Conversion of MGRS to lat/lon.
     *
     * @param {string} mgrs MGRS string.
     * @return {array} An array with left (longitude), bottom (latitude), right
     *     (longitude) and top (latitude) values in WGS84, representing the
     *     bounding box for the provided MGRS reference.
     */
    function inverse$u(mgrs) {
      var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
      if (bbox.lat && bbox.lon) {
        return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
      }
      return [bbox.left, bbox.bottom, bbox.right, bbox.top];
    }
    function toPoint(mgrs) {
      var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
      if (bbox.lat && bbox.lon) {
        return [bbox.lon, bbox.lat];
      }
      return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
    }/**
     * Conversion from degrees to radians.
     *
     * @private
     * @param {number} deg the angle in degrees.
     * @return {number} the angle in radians.
     */
    function degToRad(deg) {
      return (deg * (Math.PI / 180.0));
    }

    /**
     * Conversion from radians to degrees.
     *
     * @private
     * @param {number} rad the angle in radians.
     * @return {number} the angle in degrees.
     */
    function radToDeg(rad) {
      return (180.0 * (rad / Math.PI));
    }

    /**
     * Converts a set of Longitude and Latitude co-ordinates to UTM
     * using the WGS84 ellipsoid.
     *
     * @private
     * @param {object} ll Object literal with lat and lon properties
     *     representing the WGS84 coordinate to be converted.
     * @return {object} Object literal containing the UTM value with easting,
     *     northing, zoneNumber and zoneLetter properties, and an optional
     *     accuracy property in digits. Returns null if the conversion failed.
     */
    function LLtoUTM(ll) {
      var Lat = ll.lat;
      var Long = ll.lon;
      var a = 6378137.0; //ellip.radius;
      var eccSquared = 0.00669438; //ellip.eccsq;
      var k0 = 0.9996;
      var LongOrigin;
      var eccPrimeSquared;
      var N, T, C, A, M;
      var LatRad = degToRad(Lat);
      var LongRad = degToRad(Long);
      var LongOriginRad;
      var ZoneNumber;
      // (int)
      ZoneNumber = Math.floor((Long + 180) / 6) + 1;

      //Make sure the longitude 180.00 is in Zone 60
      if (Long === 180) {
        ZoneNumber = 60;
      }

      // Special zone for Norway
      if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
        ZoneNumber = 32;
      }

      // Special zones for Svalbard
      if (Lat >= 72.0 && Lat < 84.0) {
        if (Long >= 0.0 && Long < 9.0) {
          ZoneNumber = 31;
        }
        else if (Long >= 9.0 && Long < 21.0) {
          ZoneNumber = 33;
        }
        else if (Long >= 21.0 && Long < 33.0) {
          ZoneNumber = 35;
        }
        else if (Long >= 33.0 && Long < 42.0) {
          ZoneNumber = 37;
        }
      }

      LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
      // in middle of
      // zone
      LongOriginRad = degToRad(LongOrigin);

      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

      N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
      T = Math.tan(LatRad) * Math.tan(LatRad);
      C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
      A = Math.cos(LatRad) * (LongRad - LongOriginRad);

      M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

      var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

      var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
      if (Lat < 0.0) {
        UTMNorthing += 10000000.0; //10000000 meter offset for
        // southern hemisphere
      }

      return {
        northing: Math.round(UTMNorthing),
        easting: Math.round(UTMEasting),
        zoneNumber: ZoneNumber,
        zoneLetter: getLetterDesignator(Lat)
      };
    }

    /**
     * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
     * class where the Zone can be specified as a single string eg."60N" which
     * is then broken down into the ZoneNumber and ZoneLetter.
     *
     * @private
     * @param {object} utm An object literal with northing, easting, zoneNumber
     *     and zoneLetter properties. If an optional accuracy property is
     *     provided (in meters), a bounding box will be returned instead of
     *     latitude and longitude.
     * @return {object} An object literal containing either lat and lon values
     *     (if no accuracy was provided), or top, right, bottom and left values
     *     for the bounding box calculated according to the provided accuracy.
     *     Returns null if the conversion failed.
     */
    function UTMtoLL(utm) {

      var UTMNorthing = utm.northing;
      var UTMEasting = utm.easting;
      var zoneLetter = utm.zoneLetter;
      var zoneNumber = utm.zoneNumber;
      // check the ZoneNummber is valid
      if (zoneNumber < 0 || zoneNumber > 60) {
        return null;
      }

      var k0 = 0.9996;
      var a = 6378137.0; //ellip.radius;
      var eccSquared = 0.00669438; //ellip.eccsq;
      var eccPrimeSquared;
      var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
      var N1, T1, C1, R1, D, M;
      var LongOrigin;
      var mu, phi1Rad;

      // remove 500,000 meter offset for longitude
      var x = UTMEasting - 500000.0;
      var y = UTMNorthing;

      // We must know somehow if we are in the Northern or Southern
      // hemisphere, this is the only time we use the letter So even
      // if the Zone letter isn't exactly correct it should indicate
      // the hemisphere correctly
      if (zoneLetter < 'N') {
        y -= 10000000.0; // remove 10,000,000 meter offset used
        // for southern hemisphere
      }

      // There are 60 zones with zone 1 being at West -180 to -174
      LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
      // in middle of
      // zone

      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

      M = y / k0;
      mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

      phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
      // double phi1 = ProjMath.radToDeg(phi1Rad);

      N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
      T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
      C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
      R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
      D = x / (N1 * k0);

      var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
      lat = radToDeg(lat);

      var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
      lon = LongOrigin + radToDeg(lon);

      var result;
      if (utm.accuracy) {
        var topRight = UTMtoLL({
          northing: utm.northing + utm.accuracy,
          easting: utm.easting + utm.accuracy,
          zoneLetter: utm.zoneLetter,
          zoneNumber: utm.zoneNumber
        });
        result = {
          top: topRight.lat,
          right: topRight.lon,
          bottom: lat,
          left: lon
        };
      }
      else {
        result = {
          lat: lat,
          lon: lon
        };
      }
      return result;
    }

    /**
     * Calculates the MGRS letter designator for the given latitude.
     *
     * @private
     * @param {number} lat The latitude in WGS84 to get the letter designator
     *     for.
     * @return {char} The letter designator.
     */
    function getLetterDesignator(lat) {
      //This is here as an error flag to show that the Latitude is
      //outside MGRS limits
      var LetterDesignator = 'Z';

      if ((84 >= lat) && (lat >= 72)) {
        LetterDesignator = 'X';
      }
      else if ((72 > lat) && (lat >= 64)) {
        LetterDesignator = 'W';
      }
      else if ((64 > lat) && (lat >= 56)) {
        LetterDesignator = 'V';
      }
      else if ((56 > lat) && (lat >= 48)) {
        LetterDesignator = 'U';
      }
      else if ((48 > lat) && (lat >= 40)) {
        LetterDesignator = 'T';
      }
      else if ((40 > lat) && (lat >= 32)) {
        LetterDesignator = 'S';
      }
      else if ((32 > lat) && (lat >= 24)) {
        LetterDesignator = 'R';
      }
      else if ((24 > lat) && (lat >= 16)) {
        LetterDesignator = 'Q';
      }
      else if ((16 > lat) && (lat >= 8)) {
        LetterDesignator = 'P';
      }
      else if ((8 > lat) && (lat >= 0)) {
        LetterDesignator = 'N';
      }
      else if ((0 > lat) && (lat >= -8)) {
        LetterDesignator = 'M';
      }
      else if ((-8 > lat) && (lat >= -16)) {
        LetterDesignator = 'L';
      }
      else if ((-16 > lat) && (lat >= -24)) {
        LetterDesignator = 'K';
      }
      else if ((-24 > lat) && (lat >= -32)) {
        LetterDesignator = 'J';
      }
      else if ((-32 > lat) && (lat >= -40)) {
        LetterDesignator = 'H';
      }
      else if ((-40 > lat) && (lat >= -48)) {
        LetterDesignator = 'G';
      }
      else if ((-48 > lat) && (lat >= -56)) {
        LetterDesignator = 'F';
      }
      else if ((-56 > lat) && (lat >= -64)) {
        LetterDesignator = 'E';
      }
      else if ((-64 > lat) && (lat >= -72)) {
        LetterDesignator = 'D';
      }
      else if ((-72 > lat) && (lat >= -80)) {
        LetterDesignator = 'C';
      }
      return LetterDesignator;
    }

    /**
     * Encodes a UTM location as MGRS string.
     *
     * @private
     * @param {object} utm An object literal with easting, northing,
     *     zoneLetter, zoneNumber
     * @param {number} accuracy Accuracy in digits (1-5).
     * @return {string} MGRS string for the given UTM location.
     */
    function encode(utm, accuracy) {
      // prepend with leading zeroes
      var seasting = "00000" + utm.easting,
        snorthing = "00000" + utm.northing;

      return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
    }

    /**
     * Get the two letter 100k designator for a given UTM easting,
     * northing and zone number value.
     *
     * @private
     * @param {number} easting
     * @param {number} northing
     * @param {number} zoneNumber
     * @return the two letter 100k designator for the given UTM location.
     */
    function get100kID(easting, northing, zoneNumber) {
      var setParm = get100kSetForZone(zoneNumber);
      var setColumn = Math.floor(easting / 100000);
      var setRow = Math.floor(northing / 100000) % 20;
      return getLetter100kID(setColumn, setRow, setParm);
    }

    /**
     * Given a UTM zone number, figure out the MGRS 100K set it is in.
     *
     * @private
     * @param {number} i An UTM zone number.
     * @return {number} the 100k set the UTM zone is in.
     */
    function get100kSetForZone(i) {
      var setParm = i % NUM_100K_SETS;
      if (setParm === 0) {
        setParm = NUM_100K_SETS;
      }

      return setParm;
    }

    /**
     * Get the two-letter MGRS 100k designator given information
     * translated from the UTM northing, easting and zone number.
     *
     * @private
     * @param {number} column the column index as it relates to the MGRS
     *        100k set spreadsheet, created from the UTM easting.
     *        Values are 1-8.
     * @param {number} row the row index as it relates to the MGRS 100k set
     *        spreadsheet, created from the UTM northing value. Values
     *        are from 0-19.
     * @param {number} parm the set block, as it relates to the MGRS 100k set
     *        spreadsheet, created from the UTM zone. Values are from
     *        1-60.
     * @return two letter MGRS 100k code.
     */
    function getLetter100kID(column, row, parm) {
      // colOrigin and rowOrigin are the letters at the origin of the set
      var index = parm - 1;
      var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
      var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

      // colInt and rowInt are the letters to build to return
      var colInt = colOrigin + column - 1;
      var rowInt = rowOrigin + row;
      var rollover = false;

      if (colInt > Z) {
        colInt = colInt - Z + A - 1;
        rollover = true;
      }

      if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
        colInt++;
      }

      if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
        colInt++;

        if (colInt === I) {
          colInt++;
        }
      }

      if (colInt > Z) {
        colInt = colInt - Z + A - 1;
      }

      if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
        rollover = true;
      }
      else {
        rollover = false;
      }

      if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
        rowInt++;
      }

      if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
        rowInt++;

        if (rowInt === I) {
          rowInt++;
        }
      }

      if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
      }

      var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
      return twoLetter;
    }

    /**
     * Decode the UTM parameters from a MGRS string.
     *
     * @private
     * @param {string} mgrsString an UPPERCASE coordinate string is expected.
     * @return {object} An object literal with easting, northing, zoneLetter,
     *     zoneNumber and accuracy (in meters) properties.
     */
    function decode(mgrsString) {

      if (mgrsString && mgrsString.length === 0) {
        throw ("MGRSPoint coverting from nothing");
      }

      var length = mgrsString.length;

      var hunK = null;
      var sb = "";
      var testChar;
      var i = 0;

      // get Zone number
      while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
        if (i >= 2) {
          throw ("MGRSPoint bad conversion from: " + mgrsString);
        }
        sb += testChar;
        i++;
      }

      var zoneNumber = parseInt(sb, 10);

      if (i === 0 || i + 3 > length) {
        // A good MGRS string has to be 4-5 digits long,
        // ##AAA/#AAA at least.
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }

      var zoneLetter = mgrsString.charAt(i++);

      // Should we check the zone letter here? Why not.
      if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
        throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
      }

      hunK = mgrsString.substring(i, i += 2);

      var set = get100kSetForZone(zoneNumber);

      var east100k = getEastingFromChar(hunK.charAt(0), set);
      var north100k = getNorthingFromChar(hunK.charAt(1), set);

      // We have a bug where the northing may be 2000000 too low.
      // How
      // do we know when to roll over?

      while (north100k < getMinNorthing(zoneLetter)) {
        north100k += 2000000;
      }

      // calculate the char index for easting/northing separator
      var remainder = length - i;

      if (remainder % 2 !== 0) {
        throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
      }

      var sep = remainder / 2;

      var sepEasting = 0.0;
      var sepNorthing = 0.0;
      var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
      if (sep > 0) {
        accuracyBonus = 100000.0 / Math.pow(10, sep);
        sepEastingString = mgrsString.substring(i, i + sep);
        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
        sepNorthingString = mgrsString.substring(i + sep);
        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
      }

      easting = sepEasting + east100k;
      northing = sepNorthing + north100k;

      return {
        easting: easting,
        northing: northing,
        zoneLetter: zoneLetter,
        zoneNumber: zoneNumber,
        accuracy: accuracyBonus
      };
    }

    /**
     * Given the first letter from a two-letter MGRS 100k zone, and given the
     * MGRS table set for the zone number, figure out the easting value that
     * should be added to the other, secondary easting value.
     *
     * @private
     * @param {char} e The first letter from a two-letter MGRS 100´k zone.
     * @param {number} set The MGRS table set for the zone number.
     * @return {number} The easting value for the given letter and set.
     */
    function getEastingFromChar(e, set) {
      // colOrigin is the letter at the origin of the set for the
      // column
      var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
      var eastingValue = 100000.0;
      var rewindMarker = false;

      while (curCol !== e.charCodeAt(0)) {
        curCol++;
        if (curCol === I) {
          curCol++;
        }
        if (curCol === O) {
          curCol++;
        }
        if (curCol > Z) {
          if (rewindMarker) {
            throw ("Bad character: " + e);
          }
          curCol = A;
          rewindMarker = true;
        }
        eastingValue += 100000.0;
      }

      return eastingValue;
    }

    /**
     * Given the second letter from a two-letter MGRS 100k zone, and given the
     * MGRS table set for the zone number, figure out the northing value that
     * should be added to the other, secondary northing value. You have to
     * remember that Northings are determined from the equator, and the vertical
     * cycle of letters mean a 2000000 additional northing meters. This happens
     * approx. every 18 degrees of latitude. This method does *NOT* count any
     * additional northings. You have to figure out how many 2000000 meters need
     * to be added for the zone letter of the MGRS coordinate.
     *
     * @private
     * @param {char} n Second letter of the MGRS 100k zone
     * @param {number} set The MGRS table set number, which is dependent on the
     *     UTM zone number.
     * @return {number} The northing value for the given letter and set.
     */
    function getNorthingFromChar(n, set) {

      if (n > 'V') {
        throw ("MGRSPoint given invalid Northing " + n);
      }

      // rowOrigin is the letter at the origin of the set for the
      // column
      var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
      var northingValue = 0.0;
      var rewindMarker = false;

      while (curRow !== n.charCodeAt(0)) {
        curRow++;
        if (curRow === I) {
          curRow++;
        }
        if (curRow === O) {
          curRow++;
        }
        // fixing a bug making whole application hang in this loop
        // when 'n' is a wrong character
        if (curRow > V) {
          if (rewindMarker) { // making sure that this loop ends
            throw ("Bad character: " + n);
          }
          curRow = A;
          rewindMarker = true;
        }
        northingValue += 100000.0;
      }

      return northingValue;
    }

    /**
     * The function getMinNorthing returns the minimum northing value of a MGRS
     * zone.
     *
     * Ported from Geotrans' c Lattitude_Band_Value structure table.
     *
     * @private
     * @param {char} zoneLetter The MGRS zone to get the min northing for.
     * @return {number}
     */
    function getMinNorthing(zoneLetter) {
      var northing;
      switch (zoneLetter) {
      case 'C':
        northing = 1100000.0;
        break;
      case 'D':
        northing = 2000000.0;
        break;
      case 'E':
        northing = 2800000.0;
        break;
      case 'F':
        northing = 3700000.0;
        break;
      case 'G':
        northing = 4600000.0;
        break;
      case 'H':
        northing = 5500000.0;
        break;
      case 'J':
        northing = 6400000.0;
        break;
      case 'K':
        northing = 7300000.0;
        break;
      case 'L':
        northing = 8200000.0;
        break;
      case 'M':
        northing = 9100000.0;
        break;
      case 'N':
        northing = 0.0;
        break;
      case 'P':
        northing = 800000.0;
        break;
      case 'Q':
        northing = 1700000.0;
        break;
      case 'R':
        northing = 2600000.0;
        break;
      case 'S':
        northing = 3500000.0;
        break;
      case 'T':
        northing = 4400000.0;
        break;
      case 'U':
        northing = 5300000.0;
        break;
      case 'V':
        northing = 6200000.0;
        break;
      case 'W':
        northing = 7000000.0;
        break;
      case 'X':
        northing = 7900000.0;
        break;
      default:
        northing = -1.0;
      }
      if (northing >= 0.0) {
        return northing;
      }
      else {
        throw ("Invalid zone letter: " + zoneLetter);
      }

    }

    function Point(x, y, z) {
      if (!(this instanceof Point)) {
        return new Point(x, y, z);
      }
      if (Array.isArray(x)) {
        this.x = x[0];
        this.y = x[1];
        this.z = x[2] || 0.0;
      } else if(typeof x === 'object') {
        this.x = x.x;
        this.y = x.y;
        this.z = x.z || 0.0;
      } else if (typeof x === 'string' && typeof y === 'undefined') {
        var coords = x.split(',');
        this.x = parseFloat(coords[0], 10);
        this.y = parseFloat(coords[1], 10);
        this.z = parseFloat(coords[2], 10) || 0.0;
      } else {
        this.x = x;
        this.y = y;
        this.z = z || 0.0;
      }
      console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
    }

    Point.fromMGRS = function(mgrsStr) {
      return new Point(toPoint(mgrsStr));
    };
    Point.prototype.toMGRS = function(accuracy) {
      return forward$u([this.x, this.y], accuracy);
    };

    var C00 = 1;
    var C02 = 0.25;
    var C04 = 0.046875;
    var C06 = 0.01953125;
    var C08 = 0.01068115234375;
    var C22 = 0.75;
    var C44 = 0.46875;
    var C46 = 0.01302083333333333333;
    var C48 = 0.00712076822916666666;
    var C66 = 0.36458333333333333333;
    var C68 = 0.00569661458333333333;
    var C88 = 0.3076171875;

    function pj_enfn(es) {
      var en = [];
      en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
      en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
      var t = es * es;
      en[2] = t * (C44 - es * (C46 + es * C48));
      t *= es;
      en[3] = t * (C66 - es * C68);
      en[4] = t * es * C88;
      return en;
    }

    function pj_mlfn(phi, sphi, cphi, en) {
      cphi *= sphi;
      sphi *= sphi;
      return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
    }

    var MAX_ITER$3 = 20;

    function pj_inv_mlfn(arg, es, en) {
      var k = 1 / (1 - es);
      var phi = arg;
      for (var i = MAX_ITER$3; i; --i) { /* rarely goes over 2 iterations */
        var s = Math.sin(phi);
        var t = 1 - es * s * s;
        //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
        //phi -= t * (t * Math.sqrt(t)) * k;
        t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
        phi -= t;
        if (Math.abs(t) < EPSLN) {
          return phi;
        }
      }
      //..reportError("cass:pj_inv_mlfn: Convergence error");
      return phi;
    }

    // Heavily based on this tmerc projection implementation

    function init$v() {
      this.x0 = this.x0 !== undefined ? this.x0 : 0;
      this.y0 = this.y0 !== undefined ? this.y0 : 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

      if (this.es) {
        this.en = pj_enfn(this.es);
        this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
      }
    }

    /**
        Transverse Mercator Forward  - long/lat to x/y
        long/lat in radians
      */
    function forward$t(p) {
      var lon = p.x;
      var lat = p.y;

      var delta_lon = adjust_lon(lon - this.long0);
      var con;
      var x, y;
      var sin_phi = Math.sin(lat);
      var cos_phi = Math.cos(lat);

      if (!this.es) {
        var b = cos_phi * Math.sin(delta_lon);

        if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
          return (93);
        }
        else {
          x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
          y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
          b = Math.abs(y);

          if (b >= 1) {
            if ((b - 1) > EPSLN) {
              return (93);
            }
            else {
              y = 0;
            }
          }
          else {
            y = Math.acos(y);
          }

          if (lat < 0) {
            y = -y;
          }

          y = this.a * this.k0 * (y - this.lat0) + this.y0;
        }
      }
      else {
        var al = cos_phi * delta_lon;
        var als = Math.pow(al, 2);
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
        var t = Math.pow(tq, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        al = al / Math.sqrt(con);
        var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

        x = this.a * (this.k0 * al * (1 +
          als / 6 * (1 - t + c +
          als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
          als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
          this.x0;

        y = this.a * (this.k0 * (ml - this.ml0 +
          sin_phi * delta_lon * al / 2 * (1 +
          als / 12 * (5 - t + 9 * c + 4 * cs +
          als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
          als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
          this.y0;
      }

      p.x = x;
      p.y = y;

      return p;
    }

    /**
        Transverse Mercator Inverse  -  x/y to long/lat
      */
    function inverse$t(p) {
      var con, phi;
      var lat, lon;
      var x = (p.x - this.x0) * (1 / this.a);
      var y = (p.y - this.y0) * (1 / this.a);

      if (!this.es) {
        var f = Math.exp(x / this.k0);
        var g = 0.5 * (f - 1 / f);
        var temp = this.lat0 + y / this.k0;
        var h = Math.cos(temp);
        con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
        lat = Math.asin(con);

        if (y < 0) {
          lat = -lat;
        }

        if ((g === 0) && (h === 0)) {
          lon = 0;
        }
        else {
          lon = adjust_lon(Math.atan2(g, h) + this.long0);
        }
      }
      else { // ellipsoidal form
        con = this.ml0 + y / this.k0;
        phi = pj_inv_mlfn(con, this.es, this.en);

        if (Math.abs(phi) < HALF_PI) {
          var sin_phi = Math.sin(phi);
          var cos_phi = Math.cos(phi);
          var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
          var c = this.ep2 * Math.pow(cos_phi, 2);
          var cs = Math.pow(c, 2);
          var t = Math.pow(tan_phi, 2);
          var ts = Math.pow(t, 2);
          con = 1 - this.es * Math.pow(sin_phi, 2);
          var d = x * Math.sqrt(con) / this.k0;
          var ds = Math.pow(d, 2);
          con = con * tan_phi;

          lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
            ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
            ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
            ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

          lon = adjust_lon(this.long0 + (d * (1 -
            ds / 6 * (1 + 2 * t + c -
            ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
            ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
        }
        else {
          lat = HALF_PI * sign$2(y);
          lon = 0;
        }
      }

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$u = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    var tmerc = {
      init: init$v,
      forward: forward$t,
      inverse: inverse$t,
      names: names$u
    };

    function sinh(x) {
      var r = Math.exp(x);
      r = (r - 1 / r) / 2;
      return r;
    }

    function hypot(x, y) {
      x = Math.abs(x);
      y = Math.abs(y);
      var a = Math.max(x, y);
      var b = Math.min(x, y) / (a ? a : 1);

      return a * Math.sqrt(1 + Math.pow(b, 2));
    }

    function log1py(x) {
      var y = 1 + x;
      var z = y - 1;

      return z === 0 ? x : x * Math.log(y) / z;
    }

    function asinhy(x) {
      var y = Math.abs(x);
      y = log1py(y * (1 + y / (hypot(1, y) + 1)));

      return x < 0 ? -y : y;
    }

    function gatg(pp, B) {
      var cos_2B = 2 * Math.cos(2 * B);
      var i = pp.length - 1;
      var h1 = pp[i];
      var h2 = 0;
      var h;

      while (--i >= 0) {
        h = -h2 + cos_2B * h1 + pp[i];
        h2 = h1;
        h1 = h;
      }

      return (B + h * Math.sin(2 * B));
    }

    function clens(pp, arg_r) {
      var r = 2 * Math.cos(arg_r);
      var i = pp.length - 1;
      var hr1 = pp[i];
      var hr2 = 0;
      var hr;

      while (--i >= 0) {
        hr = -hr2 + r * hr1 + pp[i];
        hr2 = hr1;
        hr1 = hr;
      }

      return Math.sin(arg_r) * hr;
    }

    function cosh(x) {
      var r = Math.exp(x);
      r = (r + 1 / r) / 2;
      return r;
    }

    function clens_cmplx(pp, arg_r, arg_i) {
      var sin_arg_r = Math.sin(arg_r);
      var cos_arg_r = Math.cos(arg_r);
      var sinh_arg_i = sinh(arg_i);
      var cosh_arg_i = cosh(arg_i);
      var r = 2 * cos_arg_r * cosh_arg_i;
      var i = -2 * sin_arg_r * sinh_arg_i;
      var j = pp.length - 1;
      var hr = pp[j];
      var hi1 = 0;
      var hr1 = 0;
      var hi = 0;
      var hr2;
      var hi2;

      while (--j >= 0) {
        hr2 = hr1;
        hi2 = hi1;
        hr1 = hr;
        hi1 = hi;
        hr = -hr2 + r * hr1 - i * hi1 + pp[j];
        hi = -hi2 + i * hr1 + r * hi1;
      }

      r = sin_arg_r * cosh_arg_i;
      i = cos_arg_r * sinh_arg_i;

      return [r * hr - i * hi, r * hi + i * hr];
    }

    // Heavily based on this etmerc projection implementation

    function init$u() {
      if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
        throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
      }
      if (this.approx) {
        // When '+approx' is set, use tmerc instead
        tmerc.init.apply(this);
        this.forward = tmerc.forward;
        this.inverse = tmerc.inverse;
      }

      this.x0 = this.x0 !== undefined ? this.x0 : 0;
      this.y0 = this.y0 !== undefined ? this.y0 : 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

      this.cgb = [];
      this.cbg = [];
      this.utg = [];
      this.gtu = [];

      var f = this.es / (1 + Math.sqrt(1 - this.es));
      var n = f / (2 - f);
      var np = n;

      this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
      this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

      np = np * n;
      this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
      this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

      np = np * n;
      this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
      this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

      np = np * n;
      this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
      this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

      np = np * n;
      this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
      this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

      np = np * n;
      this.cgb[5] = np * (601676 / 22275);
      this.cbg[5] = np * (444337 / 155925);

      np = Math.pow(n, 2);
      this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

      this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
      this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

      this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
      this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

      np = np * n;
      this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
      this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

      np = np * n;
      this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
      this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

      np = np * n;
      this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
      this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

      np = np * n;
      this.utg[5] = np * (-20648693 / 638668800);
      this.gtu[5] = np * (212378941 / 319334400);

      var Z = gatg(this.cbg, this.lat0);
      this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
    }

    function forward$s(p) {
      var Ce = adjust_lon(p.x - this.long0);
      var Cn = p.y;

      Cn = gatg(this.cbg, Cn);
      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
      Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
      Ce = asinhy(Math.tan(Ce));

      var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];

      var x;
      var y;

      if (Math.abs(Ce) <= 2.623395162778) {
        x = this.a * (this.Qn * Ce) + this.x0;
        y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
      }
      else {
        x = Infinity;
        y = Infinity;
      }

      p.x = x;
      p.y = y;

      return p;
    }

    function inverse$s(p) {
      var Ce = (p.x - this.x0) * (1 / this.a);
      var Cn = (p.y - this.y0) * (1 / this.a);

      Cn = (Cn - this.Zb) / this.Qn;
      Ce = Ce / this.Qn;

      var lon;
      var lat;

      if (Math.abs(Ce) <= 2.623395162778) {
        var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

        Cn = Cn + tmp[0];
        Ce = Ce + tmp[1];
        Ce = Math.atan(sinh(Ce));

        var sin_Cn = Math.sin(Cn);
        var cos_Cn = Math.cos(Cn);
        var sin_Ce = Math.sin(Ce);
        var cos_Ce = Math.cos(Ce);

        Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
        Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

        lon = adjust_lon(Ce + this.long0);
        lat = gatg(this.cgb, Cn);
      }
      else {
        lon = Infinity;
        lat = Infinity;
      }

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$t = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
    var etmerc = {
      init: init$u,
      forward: forward$s,
      inverse: inverse$s,
      names: names$t
    };

    function adjust_zone(zone, lon) {
      if (zone === undefined) {
        zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

        if (zone < 0) {
          return 0;
        } else if (zone > 60) {
          return 60;
        }
      }
      return zone;
    }

    var dependsOn = 'etmerc';


    function init$t() {
      var zone = adjust_zone(this.zone, this.long0);
      if (zone === undefined) {
        throw new Error('unknown utm zone');
      }
      this.lat0 = 0;
      this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R$2;
      this.x0 = 500000;
      this.y0 = this.utmSouth ? 10000000 : 0;
      this.k0 = 0.9996;

      etmerc.init.apply(this);
      this.forward = etmerc.forward;
      this.inverse = etmerc.inverse;
    }

    var names$s = ["Universal Transverse Mercator System", "utm"];
    var utm = {
      init: init$t,
      names: names$s,
      dependsOn: dependsOn
    };

    function srat(esinp, exp) {
      return (Math.pow((1 - esinp) / (1 + esinp), exp));
    }

    var MAX_ITER$2 = 20;

    function init$s() {
      var sphi = Math.sin(this.lat0);
      var cphi = Math.cos(this.lat0);
      cphi *= cphi;
      this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
      this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
      this.phic0 = Math.asin(sphi / this.C);
      this.ratexp = 0.5 * this.C * this.e;
      this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
    }

    function forward$r(p) {
      var lon = p.x;
      var lat = p.y;

      p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
      p.x = this.C * lon;
      return p;
    }

    function inverse$r(p) {
      var DEL_TOL = 1e-14;
      var lon = p.x / this.C;
      var lat = p.y;
      var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
      for (var i = MAX_ITER$2; i > 0; --i) {
        lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
        if (Math.abs(lat - p.y) < DEL_TOL) {
          break;
        }
        p.y = lat;
      }
      /* convergence failed */
      if (!i) {
        return null;
      }
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$r = ["gauss"];
    var gauss = {
      init: init$s,
      forward: forward$r,
      inverse: inverse$r,
      names: names$r
    };

    function init$r() {
      gauss.init.apply(this);
      if (!this.rc) {
        return;
      }
      this.sinc0 = Math.sin(this.phic0);
      this.cosc0 = Math.cos(this.phic0);
      this.R2 = 2 * this.rc;
      if (!this.title) {
        this.title = "Oblique Stereographic Alternative";
      }
    }

    function forward$q(p) {
      var sinc, cosc, cosl, k;
      p.x = adjust_lon(p.x - this.long0);
      gauss.forward.apply(this, [p]);
      sinc = Math.sin(p.y);
      cosc = Math.cos(p.y);
      cosl = Math.cos(p.x);
      k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
      p.x = k * cosc * Math.sin(p.x);
      p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
      p.x = this.a * p.x + this.x0;
      p.y = this.a * p.y + this.y0;
      return p;
    }

    function inverse$q(p) {
      var sinc, cosc, lon, lat, rho;
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      p.x /= this.k0;
      p.y /= this.k0;
      if ((rho = hypot(p.x, p.y))) {
        var c = 2 * Math.atan2(rho, this.R2);
        sinc = Math.sin(c);
        cosc = Math.cos(c);
        lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
        lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
      }
      else {
        lat = this.phic0;
        lon = 0;
      }

      p.x = lon;
      p.y = lat;
      gauss.inverse.apply(this, [p]);
      p.x = adjust_lon(p.x + this.long0);
      return p;
    }

    var names$q = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
    var sterea = {
      init: init$r,
      forward: forward$q,
      inverse: inverse$q,
      names: names$q
    };

    function ssfn_(phit, sinphi, eccen) {
      sinphi *= eccen;
      return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
    }

    function init$q() {

      // setting default parameters
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;

      this.coslat0 = Math.cos(this.lat0);
      this.sinlat0 = Math.sin(this.lat0);
      if (this.sphere) {
        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
          this.k0 = 0.5 * (1 + sign$2(this.lat0) * Math.sin(this.lat_ts));
        }
      }
      else {
        if (Math.abs(this.coslat0) <= EPSLN) {
          if (this.lat0 > 0) {
            //North pole
            //trace('stere:north pole');
            this.con = 1;
          }
          else {
            //South pole
            //trace('stere:south pole');
            this.con = -1;
          }
        }
        this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN) {
          // When k0 is 1 (default value) and lat_ts is a vaild number and lat0 is at a pole and lat_ts is not at a pole
          // Recalculate k0 using formula 21-35 from p161 of Snyder, 1987
          this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
        }
        this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
        this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
        this.cosX0 = Math.cos(this.X0);
        this.sinX0 = Math.sin(this.X0);
      }
    }

    // Stereographic forward equations--mapping lat,long to x,y
    function forward$p(p) {
      var lon = p.x;
      var lat = p.y;
      var sinlat = Math.sin(lat);
      var coslat = Math.cos(lat);
      var A, X, sinX, cosX, ts, rh;
      var dlon = adjust_lon(lon - this.long0);

      if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
        //case of the origine point
        //trace('stere:this is the origin point');
        p.x = NaN;
        p.y = NaN;
        return p;
      }
      if (this.sphere) {
        //trace('stere:sphere case');
        A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
        p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
        p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
        return p;
      }
      else {
        X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
        cosX = Math.cos(X);
        sinX = Math.sin(X);
        if (Math.abs(this.coslat0) <= EPSLN) {
          ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
          rh = 2 * this.a * this.k0 * ts / this.cons;
          p.x = this.x0 + rh * Math.sin(lon - this.long0);
          p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
          //trace(p.toString());
          return p;
        }
        else if (Math.abs(this.sinlat0) < EPSLN) {
          //Eq
          //trace('stere:equateur');
          A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
          p.y = A * sinX;
        }
        else {
          //other case
          //trace('stere:normal case');
          A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
          p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
        }
        p.x = A * cosX * Math.sin(dlon) + this.x0;
      }
      //trace(p.toString());
      return p;
    }

    //* Stereographic inverse equations--mapping x,y to lat/long
    function inverse$p(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var lon, lat, ts, ce, Chi;
      var rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (this.sphere) {
        var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
        lon = this.long0;
        lat = this.lat0;
        if (rh <= EPSLN) {
          p.x = lon;
          p.y = lat;
          return p;
        }
        lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
        if (Math.abs(this.coslat0) < EPSLN) {
          if (this.lat0 > 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
          }
          else {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
          }
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
        }
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        if (Math.abs(this.coslat0) <= EPSLN) {
          if (rh <= EPSLN) {
            lat = this.lat0;
            lon = this.long0;
            p.x = lon;
            p.y = lat;
            //trace(p.toString());
            return p;
          }
          p.x *= this.con;
          p.y *= this.con;
          ts = rh * this.cons / (2 * this.a * this.k0);
          lat = this.con * phi2z(this.e, ts);
          lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
          lon = this.long0;
          if (rh <= EPSLN) {
            Chi = this.X0;
          }
          else {
            Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
            lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
          }
          lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
        }
      }
      p.x = lon;
      p.y = lat;

      //trace(p.toString());
      return p;

    }

    var names$p = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
    var stere = {
      init: init$q,
      forward: forward$p,
      inverse: inverse$p,
      names: names$p,
      ssfn_: ssfn_
    };

    /*
      references:
        Formules et constantes pour le Calcul pour la
        projection cylindrique conforme à axe oblique et pour la transformation entre
        des systèmes de référence.
        http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
      */

    function init$p() {
      var phy0 = this.lat0;
      this.lambda0 = this.long0;
      var sinPhy0 = Math.sin(phy0);
      var semiMajorAxis = this.a;
      var invF = this.rf;
      var flattening = 1 / invF;
      var e2 = 2 * flattening - Math.pow(flattening, 2);
      var e = this.e = Math.sqrt(e2);
      this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
      this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
      this.b0 = Math.asin(sinPhy0 / this.alpha);
      var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
      var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
      var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
      this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
    }

    function forward$o(p) {
      var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
      var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
      var S = -this.alpha * (Sa1 + Sa2) + this.K;

      // spheric latitude
      var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

      // spheric longitude
      var I = this.alpha * (p.x - this.lambda0);

      // psoeudo equatorial rotation
      var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

      var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

      p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
      p.x = this.R * rotI + this.x0;
      return p;
    }

    function inverse$o(p) {
      var Y = p.x - this.x0;
      var X = p.y - this.y0;

      var rotI = Y / this.R;
      var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

      var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
      var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

      var lambda = this.lambda0 + I / this.alpha;

      var S = 0;
      var phy = b;
      var prevPhy = -1000;
      var iteration = 0;
      while (Math.abs(phy - prevPhy) > 0.0000001) {
        if (++iteration > 20) {
          //...reportError("omercFwdInfinity");
          return;
        }
        //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
        S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
        prevPhy = phy;
        phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
      }

      p.x = lambda;
      p.y = phy;
      return p;
    }

    var names$o = ["somerc"];
    var somerc = {
      init: init$p,
      forward: forward$o,
      inverse: inverse$o,
      names: names$o
    };

    var TOL = 1e-7;

    function isTypeA(P) {
      var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
      var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
      
      return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
    }


    /* Initialize the Oblique Mercator  projection
        ------------------------------------------*/
    function init$o() {  
      var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
        gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
      
      // only Type A uses the no_off or no_uoff property
      // https://github.com/OSGeo/proj.4/issues/104
      this.no_off = isTypeA(this);
      this.no_rot = 'no_rot' in this;
      
      var alp = false;
      if ("alpha" in this) {
        alp = true;
      }

      var gam = false;
      if ("rectified_grid_angle" in this) {
        gam = true;
      }

      if (alp) {
        alpha_c = this.alpha;
      }
      
      if (gam) {
        gamma = (this.rectified_grid_angle * D2R$2);
      }
      
      if (alp || gam) {
        lamc = this.longc;
      } else {
        lam1 = this.long1;
        phi1 = this.lat1;
        lam2 = this.long2;
        phi2 = this.lat2;
        
        if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
            Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
            Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
          throw new Error();
        }
      }
      
      var one_es = 1.0 - this.es;
      com = Math.sqrt(one_es);
      
      if (Math.abs(this.lat0) > EPSLN) {
        sinph0 = Math.sin(this.lat0);
        cosph0 = Math.cos(this.lat0);
        con = 1 - this.es * sinph0 * sinph0;
        this.B = cosph0 * cosph0;
        this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
        this.A = this.B * this.k0 * com / con;
        D = this.B * com / (cosph0 * Math.sqrt(con));
        F = D * D -1;
        
        if (F <= 0) {
          F = 0;
        } else {
          F = Math.sqrt(F);
          if (this.lat0 < 0) {
            F = -F;
          }
        }
        
        this.E = F += D;
        this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
      } else {
        this.B = 1 / com;
        this.A = this.k0;
        this.E = D = F = 1;
      }
      
      if (alp || gam) {
        if (alp) {
          gamma0 = Math.asin(Math.sin(alpha_c) / D);
          if (!gam) {
            gamma = alpha_c;
          }
        } else {
          gamma0 = gamma;
          alpha_c = Math.asin(D * Math.sin(gamma0));
        }
        this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
      } else {
        H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
        L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
        F = this.E / H;
        p = (L - H) / (L + H);
        J = this.E * this.E;
        J = (J - L * H) / (J + L * H);
        con = lam1 - lam2;
        
        if (con < -Math.pi) {
          lam2 -=TWO_PI;
        } else if (con > Math.pi) {
          lam2 += TWO_PI;
        }
        
        this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
        gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
        gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      
      this.singam = Math.sin(gamma0);
      this.cosgam = Math.cos(gamma0);
      this.sinrot = Math.sin(gamma);
      this.cosrot = Math.cos(gamma);
      
      this.rB = 1 / this.B;
      this.ArB = this.A * this.rB;
      this.BrA = 1 / this.ArB;
      this.A * this.B;
      
      if (this.no_off) {
        this.u_0 = 0;
      } else {
        this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
        
        if (this.lat0 < 0) {
          this.u_0 = - this.u_0;
        }  
      }
        
      F = 0.5 * gamma0;
      this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
      this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
    }


    /* Oblique Mercator forward equations--mapping lat,long to x,y
        ----------------------------------------------------------*/
    function forward$n(p) {
      var coords = {};
      var S, T, U, V, W, temp, u, v;
      p.x = p.x - this.lam0;
      
      if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
        W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
        
        temp = 1 / W;
        S = 0.5 * (W - temp);
        T = 0.5 * (W + temp);
        V = Math.sin(this.B * p.x);
        U = (S * this.singam - V * this.cosgam) / T;
            
        if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
          throw new Error();
        }
        
        v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
        temp = Math.cos(this.B * p.x);
        
        if (Math.abs(temp) < TOL) {
          u = this.A * p.x;
        } else {
          u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
        }    
      } else {
        v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
        u = this.ArB * p.y;
      }
         
      if (this.no_rot) {
        coords.x = u;
        coords.y = v;
      } else {
        u -= this.u_0;
        coords.x = v * this.cosrot + u * this.sinrot;
        coords.y = u * this.cosrot - v * this.sinrot;
      }
      
      coords.x = (this.a * coords.x + this.x0);
      coords.y = (this.a * coords.y + this.y0);
      
      return coords;
    }

    function inverse$n(p) {
      var u, v, Qp, Sp, Tp, Vp, Up;
      var coords = {};
      
      p.x = (p.x - this.x0) * (1.0 / this.a);
      p.y = (p.y - this.y0) * (1.0 / this.a);

      if (this.no_rot) {
        v = p.y;
        u = p.x;
      } else {
        v = p.x * this.cosrot - p.y * this.sinrot;
        u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
      }
      
      Qp = Math.exp(-this.BrA * v);
      Sp = 0.5 * (Qp - 1 / Qp);
      Tp = 0.5 * (Qp + 1 / Qp);
      Vp = Math.sin(this.BrA * u);
      Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
      
      if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
        coords.x = 0;
        coords.y = Up < 0 ? -HALF_PI : HALF_PI;
      } else {
        coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
        coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
        
        if (coords.y === Infinity) {
          throw new Error();
        }
            
        coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
      }
      
      coords.x += this.lam0;
      
      return coords;
    }

    var names$n = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    var omerc = {
      init: init$o,
      forward: forward$n,
      inverse: inverse$n,
      names: names$n
    };

    function init$n() {
      
      //double lat0;                    /* the reference latitude               */
      //double long0;                   /* the reference longitude              */
      //double lat1;                    /* first standard parallel              */
      //double lat2;                    /* second standard parallel             */
      //double r_maj;                   /* major axis                           */
      //double r_min;                   /* minor axis                           */
      //double false_east;              /* x offset in meters                   */
      //double false_north;             /* y offset in meters                   */
      
      //the above value can be set with proj4.defs
      //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

      if (!this.lat2) {
        this.lat2 = this.lat1;
      } //if lat2 is not defined
      if (!this.k0) {
        this.k0 = 1;
      }
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      // Standard Parallels cannot be equal and on opposite sides of the equator
      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }

      var temp = this.b / this.a;
      this.e = Math.sqrt(1 - temp * temp);

      var sin1 = Math.sin(this.lat1);
      var cos1 = Math.cos(this.lat1);
      var ms1 = msfnz(this.e, sin1, cos1);
      var ts1 = tsfnz(this.e, this.lat1, sin1);

      var sin2 = Math.sin(this.lat2);
      var cos2 = Math.cos(this.lat2);
      var ms2 = msfnz(this.e, sin2, cos2);
      var ts2 = tsfnz(this.e, this.lat2, sin2);

      var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
        this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
      }
      else {
        this.ns = sin1;
      }
      if (isNaN(this.ns)) {
        this.ns = sin1;
      }
      this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
      this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
      if (!this.title) {
        this.title = "Lambert Conformal Conic";
      }
    }

    // Lambert Conformal conic forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$m(p) {

      var lon = p.x;
      var lat = p.y;

      // singular cases :
      if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
        lat = sign$2(lat) * (HALF_PI - 2 * EPSLN);
      }

      var con = Math.abs(Math.abs(lat) - HALF_PI);
      var ts, rh1;
      if (con > EPSLN) {
        ts = tsfnz(this.e, lat, Math.sin(lat));
        rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
      }
      else {
        con = lat * this.ns;
        if (con <= 0) {
          return null;
        }
        rh1 = 0;
      }
      var theta = this.ns * adjust_lon(lon - this.long0);
      p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
      p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

      return p;
    }

    // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$m(p) {

      var rh1, con, ts;
      var lat, lon;
      var x = (p.x - this.x0) / this.k0;
      var y = (this.rh - (p.y - this.y0) / this.k0);
      if (this.ns > 0) {
        rh1 = Math.sqrt(x * x + y * y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(x * x + y * y);
        con = -1;
      }
      var theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2((con * x), (con * y));
      }
      if ((rh1 !== 0) || (this.ns > 0)) {
        con = 1 / this.ns;
        ts = Math.pow((rh1 / (this.a * this.f0)), con);
        lat = phi2z(this.e, ts);
        if (lat === -9999) {
          return null;
        }
      }
      else {
        lat = -HALF_PI;
      }
      lon = adjust_lon(theta / this.ns + this.long0);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$m = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc",
      "Lambert Conic Conformal (1SP)",
      "Lambert Conic Conformal (2SP)"
    ];

    var lcc = {
      init: init$n,
      forward: forward$m,
      inverse: inverse$m,
      names: names$m
    };

    function init$m() {
      this.a = 6377397.155;
      this.es = 0.006674372230614;
      this.e = Math.sqrt(this.es);
      if (!this.lat0) {
        this.lat0 = 0.863937979737193;
      }
      if (!this.long0) {
        this.long0 = 0.7417649320975901 - 0.308341501185665;
      }
      /* if scale not set default to 0.9999 */
      if (!this.k0) {
        this.k0 = 0.9999;
      }
      this.s45 = 0.785398163397448; /* 45 */
      this.s90 = 2 * this.s45;
      this.fi0 = this.lat0;
      this.e2 = this.es;
      this.e = Math.sqrt(this.e2);
      this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
      this.uq = 1.04216856380474;
      this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
      this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
      this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
      this.k1 = this.k0;
      this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
      this.s0 = 1.37008346281555;
      this.n = Math.sin(this.s0);
      this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
      this.ad = this.s90 - this.uq;
    }

    /* ellipsoid */
    /* calculate xy from lat/lon */
    /* Constants, identical to inverse transform function */
    function forward$l(p) {
      var gfi, u, deltav, s, d, eps, ro;
      var lon = p.x;
      var lat = p.y;
      var delta_lon = adjust_lon(lon - this.long0);
      /* Transformation */
      gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
      u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
      deltav = -delta_lon * this.alfa;
      s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
      d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
      eps = this.n * d;
      ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
      p.y = ro * Math.cos(eps) / 1;
      p.x = ro * Math.sin(eps) / 1;

      if (!this.czech) {
        p.y *= -1;
        p.x *= -1;
      }
      return (p);
    }

    /* calculate lat/lon from xy */
    function inverse$l(p) {
      var u, deltav, s, d, eps, ro, fi1;
      var ok;

      /* Transformation */
      /* revert y, x*/
      var tmp = p.x;
      p.x = p.y;
      p.y = tmp;
      if (!this.czech) {
        p.y *= -1;
        p.x *= -1;
      }
      ro = Math.sqrt(p.x * p.x + p.y * p.y);
      eps = Math.atan2(p.y, p.x);
      d = eps / Math.sin(this.s0);
      s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
      u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
      deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
      p.x = this.long0 - deltav / this.alfa;
      fi1 = u;
      ok = 0;
      var iter = 0;
      do {
        p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
        if (Math.abs(fi1 - p.y) < 0.0000000001) {
          ok = 1;
        }
        fi1 = p.y;
        iter += 1;
      } while (ok === 0 && iter < 15);
      if (iter >= 15) {
        return null;
      }

      return (p);
    }

    var names$l = ["Krovak", "krovak"];
    var krovak = {
      init: init$m,
      forward: forward$l,
      inverse: inverse$l,
      names: names$l
    };

    function mlfn(e0, e1, e2, e3, phi) {
      return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
    }

    function e0fn(x) {
      return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
    }

    function e1fn(x) {
      return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
    }

    function e2fn(x) {
      return (0.05859375 * x * x * (1 + 0.75 * x));
    }

    function e3fn(x) {
      return (x * x * x * (35 / 3072));
    }

    function gN(a, e, sinphi) {
      var temp = e * sinphi;
      return a / Math.sqrt(1 - temp * temp);
    }

    function adjust_lat(x) {
      return (Math.abs(x) < HALF_PI) ? x : (x - (sign$2(x) * Math.PI));
    }

    function imlfn(ml, e0, e1, e2, e3) {
      var phi;
      var dphi;

      phi = ml / e0;
      for (var i = 0; i < 15; i++) {
        dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }

      //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
      return NaN;
    }

    function init$l() {
      if (!this.sphere) {
        this.e0 = e0fn(this.es);
        this.e1 = e1fn(this.es);
        this.e2 = e2fn(this.es);
        this.e3 = e3fn(this.es);
        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }
    }

    /* Cassini forward equations--mapping lat,long to x,y
      -----------------------------------------------------------------------*/
    function forward$k(p) {

      /* Forward equations
          -----------------*/
      var x, y;
      var lam = p.x;
      var phi = p.y;
      lam = adjust_lon(lam - this.long0);

      if (this.sphere) {
        x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
        y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
      }
      else {
        //ellipsoid
        var sinphi = Math.sin(phi);
        var cosphi = Math.cos(phi);
        var nl = gN(this.a, this.e, sinphi);
        var tl = Math.tan(phi) * Math.tan(phi);
        var al = lam * Math.cos(phi);
        var asq = al * al;
        var cl = this.es * cosphi * cosphi / (1 - this.es);
        var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

        x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
        y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


      }

      p.x = x + this.x0;
      p.y = y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$k(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var x = p.x / this.a;
      var y = p.y / this.a;
      var phi, lam;

      if (this.sphere) {
        var dd = y + this.lat0;
        phi = Math.asin(Math.sin(dd) * Math.cos(x));
        lam = Math.atan2(Math.tan(x), Math.cos(dd));
      }
      else {
        /* ellipsoid */
        var ml1 = this.ml0 / this.a + y;
        var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
        if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
          p.x = this.long0;
          p.y = HALF_PI;
          if (y < 0) {
            p.y *= -1;
          }
          return p;
        }
        var nl1 = gN(this.a, this.e, Math.sin(phi1));

        var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
        var tl1 = Math.pow(Math.tan(phi1), 2);
        var dl = x * this.a / nl1;
        var dsq = dl * dl;
        phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
        lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

      }

      p.x = adjust_lon(lam + this.long0);
      p.y = adjust_lat(phi);
      return p;

    }

    var names$k = ["Cassini", "Cassini_Soldner", "cass"];
    var cass = {
      init: init$l,
      forward: forward$k,
      inverse: inverse$k,
      names: names$k
    };

    function qsfnz(eccent, sinphi) {
      var con;
      if (eccent > 1.0e-7) {
        con = eccent * sinphi;
        return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
      }
      else {
        return (2 * sinphi);
      }
    }

    /*
      reference
        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
      */

    var S_POLE = 1;

    var N_POLE = 2;
    var EQUIT = 3;
    var OBLIQ = 4;

    /* Initialize the Lambert Azimuthal Equal Area projection
      ------------------------------------------------------*/
    function init$k() {
      var t = Math.abs(this.lat0);
      if (Math.abs(t - HALF_PI) < EPSLN) {
        this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
      }
      else if (Math.abs(t) < EPSLN) {
        this.mode = this.EQUIT;
      }
      else {
        this.mode = this.OBLIQ;
      }
      if (this.es > 0) {
        var sinphi;

        this.qp = qsfnz(this.e, 1);
        this.mmf = 0.5 / (1 - this.es);
        this.apa = authset(this.es);
        switch (this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp);
          this.dd = 1 / this.rq;
          this.xmf = 1;
          this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp);
          sinphi = Math.sin(this.lat0);
          this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
          this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
          this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
          this.ymf = (this.xmf = this.rq) / this.dd;
          this.xmf *= this.dd;
          break;
        }
      }
      else {
        if (this.mode === this.OBLIQ) {
          this.sinph0 = Math.sin(this.lat0);
          this.cosph0 = Math.cos(this.lat0);
        }
      }
    }

    /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
      -----------------------------------------------------------------------*/
    function forward$j(p) {

      /* Forward equations
          -----------------*/
      var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
      var lam = p.x;
      var phi = p.y;

      lam = adjust_lon(lam - this.long0);
      if (this.sphere) {
        sinphi = Math.sin(phi);
        cosphi = Math.cos(phi);
        coslam = Math.cos(lam);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
          if (y <= EPSLN) {
            return null;
          }
          y = Math.sqrt(2 / y);
          x = y * cosphi * Math.sin(lam);
          y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        }
        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
          if (this.mode === this.N_POLE) {
            coslam = -coslam;
          }
          if (Math.abs(phi + this.lat0) < EPSLN) {
            return null;
          }
          y = FORTPI - phi * 0.5;
          y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
          x = y * Math.sin(lam);
          y *= coslam;
        }
      }
      else {
        sinb = 0;
        cosb = 0;
        b = 0;
        coslam = Math.cos(lam);
        sinlam = Math.sin(lam);
        sinphi = Math.sin(phi);
        q = qsfnz(this.e, sinphi);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          sinb = q / this.qp;
          cosb = Math.sqrt(1 - sinb * sinb);
        }
        switch (this.mode) {
        case this.OBLIQ:
          b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
          break;
        case this.EQUIT:
          b = 1 + cosb * coslam;
          break;
        case this.N_POLE:
          b = HALF_PI + phi;
          q = this.qp - q;
          break;
        case this.S_POLE:
          b = phi - HALF_PI;
          q = this.qp + q;
          break;
        }
        if (Math.abs(b) < EPSLN) {
          return null;
        }
        switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          b = Math.sqrt(2 / b);
          if (this.mode === this.OBLIQ) {
            y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
          }
          else {
            y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
          }
          x = this.xmf * b * cosb * sinlam;
          break;
        case this.N_POLE:
        case this.S_POLE:
          if (q >= 0) {
            x = (b = Math.sqrt(q)) * sinlam;
            y = coslam * ((this.mode === this.S_POLE) ? b : -b);
          }
          else {
            x = y = 0;
          }
          break;
        }
      }

      p.x = this.a * x + this.x0;
      p.y = this.a * y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$j(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var x = p.x / this.a;
      var y = p.y / this.a;
      var lam, phi, cCe, sCe, q, rho, ab;
      if (this.sphere) {
        var cosz = 0,
          rh, sinz = 0;

        rh = Math.sqrt(x * x + y * y);
        phi = rh * 0.5;
        if (phi > 1) {
          return null;
        }
        phi = 2 * Math.asin(phi);
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          sinz = Math.sin(phi);
          cosz = Math.cos(phi);
        }
        switch (this.mode) {
        case this.EQUIT:
          phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
          x *= sinz;
          y = cosz * rh;
          break;
        case this.OBLIQ:
          phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
          x *= sinz * this.cosph0;
          y = (cosz - Math.sin(phi) * this.sinph0) * rh;
          break;
        case this.N_POLE:
          y = -y;
          phi = HALF_PI - phi;
          break;
        case this.S_POLE:
          phi -= HALF_PI;
          break;
        }
        lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
      }
      else {
        ab = 0;
        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
          x /= this.dd;
          y *= this.dd;
          rho = Math.sqrt(x * x + y * y);
          if (rho < EPSLN) {
            p.x = this.long0;
            p.y = this.lat0;
            return p;
          }
          sCe = 2 * Math.asin(0.5 * rho / this.rq);
          cCe = Math.cos(sCe);
          x *= (sCe = Math.sin(sCe));
          if (this.mode === this.OBLIQ) {
            ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
            q = this.qp * ab;
            y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
          }
          else {
            ab = y * sCe / rho;
            q = this.qp * ab;
            y = rho * cCe;
          }
        }
        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
          if (this.mode === this.N_POLE) {
            y = -y;
          }
          q = (x * x + y * y);
          if (!q) {
            p.x = this.long0;
            p.y = this.lat0;
            return p;
          }
          ab = 1 - q / this.qp;
          if (this.mode === this.S_POLE) {
            ab = -ab;
          }
        }
        lam = Math.atan2(x, y);
        phi = authlat(Math.asin(ab), this.apa);
      }

      p.x = adjust_lon(this.long0 + lam);
      p.y = phi;
      return p;
    }

    /* determine latitude from authalic latitude */
    var P00 = 0.33333333333333333333;

    var P01 = 0.17222222222222222222;
    var P02 = 0.10257936507936507936;
    var P10 = 0.06388888888888888888;
    var P11 = 0.06640211640211640211;
    var P20 = 0.01641501294219154443;

    function authset(es) {
      var t;
      var APA = [];
      APA[0] = es * P00;
      t = es * es;
      APA[0] += t * P01;
      APA[1] = t * P10;
      t *= es;
      APA[0] += t * P02;
      APA[1] += t * P11;
      APA[2] = t * P20;
      return APA;
    }

    function authlat(beta, APA) {
      var t = beta + beta;
      return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
    }

    var names$j = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    var laea = {
      init: init$k,
      forward: forward$j,
      inverse: inverse$j,
      names: names$j,
      S_POLE: S_POLE,
      N_POLE: N_POLE,
      EQUIT: EQUIT,
      OBLIQ: OBLIQ
    };

    function asinz(x) {
      if (Math.abs(x) > 1) {
        x = (x > 1) ? 1 : -1;
      }
      return Math.asin(x);
    }

    function init$j() {

      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2);
      this.e3 = Math.sqrt(this.es);

      this.sin_po = Math.sin(this.lat1);
      this.cos_po = Math.cos(this.lat1);
      this.t1 = this.sin_po;
      this.con = this.sin_po;
      this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
      this.qs1 = qsfnz(this.e3, this.sin_po);

      this.sin_po = Math.sin(this.lat2);
      this.cos_po = Math.cos(this.lat2);
      this.t2 = this.sin_po;
      this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
      this.qs2 = qsfnz(this.e3, this.sin_po);

      this.sin_po = Math.sin(this.lat0);
      this.cos_po = Math.cos(this.lat0);
      this.t3 = this.sin_po;
      this.qs0 = qsfnz(this.e3, this.sin_po);

      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
        this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
      }
      else {
        this.ns0 = this.con;
      }
      this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
      this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
    }

    /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
      -------------------------------------------------------------------*/
    function forward$i(p) {

      var lon = p.x;
      var lat = p.y;

      this.sin_phi = Math.sin(lat);
      this.cos_phi = Math.cos(lat);

      var qs = qsfnz(this.e3, this.sin_phi);
      var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
      var theta = this.ns0 * adjust_lon(lon - this.long0);
      var x = rh1 * Math.sin(theta) + this.x0;
      var y = this.rh - rh1 * Math.cos(theta) + this.y0;

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$i(p) {
      var rh1, qs, con, theta, lon, lat;

      p.x -= this.x0;
      p.y = this.rh - p.y + this.y0;
      if (this.ns0 >= 0) {
        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
        con = -1;
      }
      theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2(con * p.x, con * p.y);
      }
      con = rh1 * this.ns0 / this.a;
      if (this.sphere) {
        lat = Math.asin((this.c - con * con) / (2 * this.ns0));
      }
      else {
        qs = (this.c - con * con) / this.ns0;
        lat = this.phi1z(this.e3, qs);
      }

      lon = adjust_lon(theta / this.ns0 + this.long0);
      p.x = lon;
      p.y = lat;
      return p;
    }

    /* Function to compute phi1, the latitude for the inverse of the
       Albers Conical Equal-Area projection.
    -------------------------------------------*/
    function phi1z(eccent, qs) {
      var sinphi, cosphi, con, com, dphi;
      var phi = asinz(0.5 * qs);
      if (eccent < EPSLN) {
        return phi;
      }

      var eccnts = eccent * eccent;
      for (var i = 1; i <= 25; i++) {
        sinphi = Math.sin(phi);
        cosphi = Math.cos(phi);
        con = eccent * sinphi;
        com = 1 - con * con;
        dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
        phi = phi + dphi;
        if (Math.abs(dphi) <= 1e-7) {
          return phi;
        }
      }
      return null;
    }

    var names$i = ["Albers_Conic_Equal_Area", "Albers", "aea"];
    var aea = {
      init: init$j,
      forward: forward$i,
      inverse: inverse$i,
      names: names$i,
      phi1z: phi1z
    };

    /*
      reference:
        Wolfram Mathworld "Gnomonic Projection"
        http://mathworld.wolfram.com/GnomonicProjection.html
        Accessed: 12th November 2009
      */
    function init$i() {

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.sin_p14 = Math.sin(this.lat0);
      this.cos_p14 = Math.cos(this.lat0);
      // Approximation for projecting points to the horizon (infinity)
      this.infinity_dist = 1000 * this.a;
      this.rc = 1;
    }

    /* Gnomonic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$h(p) {
      var sinphi, cosphi; /* sin and cos value        */
      var dlon; /* delta longitude value      */
      var coslon; /* cos of longitude        */
      var ksp; /* scale factor          */
      var g;
      var x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      dlon = adjust_lon(lon - this.long0);

      sinphi = Math.sin(lat);
      cosphi = Math.cos(lat);

      coslon = Math.cos(dlon);
      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
      ksp = 1;
      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
        x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
      }
      else {

        // Point is in the opposing hemisphere and is unprojectable
        // We still need to return a reasonable point, so we project
        // to infinity, on a bearing
        // equivalent to the northern hemisphere equivalent
        // This is a reasonable approximation for short shapes and lines that
        // straddle the horizon.

        x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
        y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

      }
      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$h(p) {
      var rh; /* Rho */
      var sinc, cosc;
      var c;
      var lon, lat;

      /* Inverse equations
          -----------------*/
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      p.x /= this.k0;
      p.y /= this.k0;

      if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
        c = Math.atan2(rh, this.rc);
        sinc = Math.sin(c);
        cosc = Math.cos(c);

        lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
        lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
        lon = adjust_lon(this.long0 + lon);
      }
      else {
        lat = this.phic0;
        lon = 0;
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$h = ["gnom"];
    var gnom = {
      init: init$i,
      forward: forward$h,
      inverse: inverse$h,
      names: names$h
    };

    function iqsfnz(eccent, q) {
      var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
      if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
        if (q < 0) {
          return (-1 * HALF_PI);
        }
        else {
          return HALF_PI;
        }
      }
      //var phi = 0.5* q/(1-eccent*eccent);
      var phi = Math.asin(0.5 * q);
      var dphi;
      var sin_phi;
      var cos_phi;
      var con;
      for (var i = 0; i < 30; i++) {
        sin_phi = Math.sin(phi);
        cos_phi = Math.cos(phi);
        con = eccent * sin_phi;
        dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
          return phi;
        }
      }

      //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
      return NaN;
    }

    /*
      reference:
        "Cartographic Projection Procedures for the UNIX Environment-
        A User's Manual" by Gerald I. Evenden,
        USGS Open File Report 90-284and Release 4 Interim Reports (2003)
    */
    function init$h() {
      //no-op
      if (!this.sphere) {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }

    /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
        ------------------------------------------------------------*/
    function forward$g(p) {
      var lon = p.x;
      var lat = p.y;
      var x, y;
      /* Forward equations
          -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      if (this.sphere) {
        x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
        y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
      }
      else {
        var qs = qsfnz(this.e, Math.sin(lat));
        x = this.x0 + this.a * this.k0 * dlon;
        y = this.y0 + this.a * qs * 0.5 / this.k0;
      }

      p.x = x;
      p.y = y;
      return p;
    }

    /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
        ------------------------------------------------------------*/
    function inverse$g(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var lon, lat;

      if (this.sphere) {
        lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
        lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
      }
      else {
        lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
        lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$g = ["cea"];
    var cea = {
      init: init$h,
      forward: forward$g,
      inverse: inverse$g,
      names: names$g
    };

    function init$g() {

      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;
      this.lat_ts = this.lat_ts || 0;
      this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

      this.rc = Math.cos(this.lat_ts);
    }

    // forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$f(p) {

      var lon = p.x;
      var lat = p.y;

      var dlon = adjust_lon(lon - this.long0);
      var dlat = adjust_lat(lat - this.lat0);
      p.x = this.x0 + (this.a * dlon * this.rc);
      p.y = this.y0 + (this.a * dlat);
      return p;
    }

    // inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$f(p) {

      var x = p.x;
      var y = p.y;

      p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
      p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
      return p;
    }

    var names$f = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
    var eqc = {
      init: init$g,
      forward: forward$f,
      inverse: inverse$f,
      names: names$f
    };

    var MAX_ITER$1 = 20;

    function init$f() {
      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
      this.e = Math.sqrt(this.es);
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
    }

    /* Polyconic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$e(p) {
      var lon = p.x;
      var lat = p.y;
      var x, y, el;
      var dlon = adjust_lon(lon - this.long0);
      el = dlon * Math.sin(lat);
      if (this.sphere) {
        if (Math.abs(lat) <= EPSLN) {
          x = this.a * dlon;
          y = -1 * this.a * this.lat0;
        }
        else {
          x = this.a * Math.sin(el) / Math.tan(lat);
          y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
        }
      }
      else {
        if (Math.abs(lat) <= EPSLN) {
          x = this.a * dlon;
          y = -1 * this.ml0;
        }
        else {
          var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
          x = nl * Math.sin(el);
          y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
        }

      }
      p.x = x + this.x0;
      p.y = y + this.y0;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$e(p) {
      var lon, lat, x, y, i;
      var al, bl;
      var phi, dphi;
      x = p.x - this.x0;
      y = p.y - this.y0;

      if (this.sphere) {
        if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
          lon = adjust_lon(x / this.a + this.long0);
          lat = 0;
        }
        else {
          al = this.lat0 + y / this.a;
          bl = x * x / this.a / this.a + al * al;
          phi = al;
          var tanphi;
          for (i = MAX_ITER$1; i; --i) {
            tanphi = Math.tan(phi);
            dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
            phi += dphi;
            if (Math.abs(dphi) <= EPSLN) {
              lat = phi;
              break;
            }
          }
          lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
        }
      }
      else {
        if (Math.abs(y + this.ml0) <= EPSLN) {
          lat = 0;
          lon = adjust_lon(this.long0 + x / this.a);
        }
        else {

          al = (this.ml0 + y) / this.a;
          bl = x * x / this.a / this.a + al * al;
          phi = al;
          var cl, mln, mlnp, ma;
          var con;
          for (i = MAX_ITER$1; i; --i) {
            con = this.e * Math.sin(phi);
            cl = Math.sqrt(1 - con * con) * Math.tan(phi);
            mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
            mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
            ma = mln / this.a;
            dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
            phi -= dphi;
            if (Math.abs(dphi) <= EPSLN) {
              lat = phi;
              break;
            }
          }

          //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
          cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
          lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$e = ["Polyconic", "poly"];
    var poly = {
      init: init$f,
      forward: forward$e,
      inverse: inverse$e,
      names: names$e
    };

    function init$e() {
      this.A = [];
      this.A[1] = 0.6399175073;
      this.A[2] = -0.1358797613;
      this.A[3] = 0.063294409;
      this.A[4] = -0.02526853;
      this.A[5] = 0.0117879;
      this.A[6] = -0.0055161;
      this.A[7] = 0.0026906;
      this.A[8] = -0.001333;
      this.A[9] = 0.00067;
      this.A[10] = -0.00034;

      this.B_re = [];
      this.B_im = [];
      this.B_re[1] = 0.7557853228;
      this.B_im[1] = 0;
      this.B_re[2] = 0.249204646;
      this.B_im[2] = 0.003371507;
      this.B_re[3] = -0.001541739;
      this.B_im[3] = 0.041058560;
      this.B_re[4] = -0.10162907;
      this.B_im[4] = 0.01727609;
      this.B_re[5] = -0.26623489;
      this.B_im[5] = -0.36249218;
      this.B_re[6] = -0.6870983;
      this.B_im[6] = -1.1651967;

      this.C_re = [];
      this.C_im = [];
      this.C_re[1] = 1.3231270439;
      this.C_im[1] = 0;
      this.C_re[2] = -0.577245789;
      this.C_im[2] = -0.007809598;
      this.C_re[3] = 0.508307513;
      this.C_im[3] = -0.112208952;
      this.C_re[4] = -0.15094762;
      this.C_im[4] = 0.18200602;
      this.C_re[5] = 1.01418179;
      this.C_im[5] = 1.64497696;
      this.C_re[6] = 1.9660549;
      this.C_im[6] = 2.5127645;

      this.D = [];
      this.D[1] = 1.5627014243;
      this.D[2] = 0.5185406398;
      this.D[3] = -0.03333098;
      this.D[4] = -0.1052906;
      this.D[5] = -0.0368594;
      this.D[6] = 0.007317;
      this.D[7] = 0.01220;
      this.D[8] = 0.00394;
      this.D[9] = -0.0013;
    }

    /**
        New Zealand Map Grid Forward  - long/lat to x/y
        long/lat in radians
      */
    function forward$d(p) {
      var n;
      var lon = p.x;
      var lat = p.y;

      var delta_lat = lat - this.lat0;
      var delta_lon = lon - this.long0;

      // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
      // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
      var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
      var d_lambda = delta_lon;
      var d_phi_n = 1; // d_phi^0

      var d_psi = 0;
      for (n = 1; n <= 10; n++) {
        d_phi_n = d_phi_n * d_phi;
        d_psi = d_psi + this.A[n] * d_phi_n;
      }

      // 2. Calculate theta
      var th_re = d_psi;
      var th_im = d_lambda;

      // 3. Calculate z
      var th_n_re = 1;
      var th_n_im = 0; // theta^0
      var th_n_re1;
      var th_n_im1;

      var z_re = 0;
      var z_im = 0;
      for (n = 1; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
        z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
      }

      // 4. Calculate easting and northing
      p.x = (z_im * this.a) + this.x0;
      p.y = (z_re * this.a) + this.y0;

      return p;
    }

    /**
        New Zealand Map Grid Inverse  -  x/y to long/lat
      */
    function inverse$d(p) {
      var n;
      var x = p.x;
      var y = p.y;

      var delta_x = x - this.x0;
      var delta_y = y - this.y0;

      // 1. Calculate z
      var z_re = delta_y / this.a;
      var z_im = delta_x / this.a;

      // 2a. Calculate theta - first approximation gives km accuracy
      var z_n_re = 1;
      var z_n_im = 0; // z^0
      var z_n_re1;
      var z_n_im1;

      var th_re = 0;
      var th_im = 0;
      for (n = 1; n <= 6; n++) {
        z_n_re1 = z_n_re * z_re - z_n_im * z_im;
        z_n_im1 = z_n_im * z_re + z_n_re * z_im;
        z_n_re = z_n_re1;
        z_n_im = z_n_im1;
        th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
        th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
      }

      // 2b. Iterate to refine the accuracy of the calculation
      //        0 iterations gives km accuracy
      //        1 iteration gives m accuracy -- good enough for most mapping applications
      //        2 iterations bives mm accuracy
      for (var i = 0; i < this.iterations; i++) {
        var th_n_re = th_re;
        var th_n_im = th_im;
        var th_n_re1;
        var th_n_im1;

        var num_re = z_re;
        var num_im = z_im;
        for (n = 2; n <= 6; n++) {
          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
          th_n_re = th_n_re1;
          th_n_im = th_n_im1;
          num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
          num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
        }

        th_n_re = 1;
        th_n_im = 0;
        var den_re = this.B_re[1];
        var den_im = this.B_im[1];
        for (n = 2; n <= 6; n++) {
          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
          th_n_re = th_n_re1;
          th_n_im = th_n_im1;
          den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
          den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
        }

        // Complex division
        var den2 = den_re * den_re + den_im * den_im;
        th_re = (num_re * den_re + num_im * den_im) / den2;
        th_im = (num_im * den_re - num_re * den_im) / den2;
      }

      // 3. Calculate d_phi              ...                                    // and d_lambda
      var d_psi = th_re;
      var d_lambda = th_im;
      var d_psi_n = 1; // d_psi^0

      var d_phi = 0;
      for (n = 1; n <= 9; n++) {
        d_psi_n = d_psi_n * d_psi;
        d_phi = d_phi + this.D[n] * d_psi_n;
      }

      // 4. Calculate latitude and longitude
      // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
      var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
      var lon = this.long0 + d_lambda;

      p.x = lon;
      p.y = lat;

      return p;
    }

    var names$d = ["New_Zealand_Map_Grid", "nzmg"];
    var nzmg = {
      init: init$e,
      forward: forward$d,
      inverse: inverse$d,
      names: names$d
    };

    /*
      reference
        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
      */


    /* Initialize the Miller Cylindrical projection
      -------------------------------------------*/
    function init$d() {
      //no-op
    }

    /* Miller Cylindrical forward equations--mapping lat,long to x,y
        ------------------------------------------------------------*/
    function forward$c(p) {
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      var x = this.x0 + this.a * dlon;
      var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

      p.x = x;
      p.y = y;
      return p;
    }

    /* Miller Cylindrical inverse equations--mapping x,y to lat/long
        ------------------------------------------------------------*/
    function inverse$c(p) {
      p.x -= this.x0;
      p.y -= this.y0;

      var lon = adjust_lon(this.long0 + p.x / this.a);
      var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$c = ["Miller_Cylindrical", "mill"];
    var mill = {
      init: init$d,
      forward: forward$c,
      inverse: inverse$c,
      names: names$c
    };

    var MAX_ITER = 20;


    function init$c() {
      /* Place parameters in static storage for common use
        -------------------------------------------------*/


      if (!this.sphere) {
        this.en = pj_enfn(this.es);
      }
      else {
        this.n = 1;
        this.m = 0;
        this.es = 0;
        this.C_y = Math.sqrt((this.m + 1) / this.n);
        this.C_x = this.C_y / (this.m + 1);
      }

    }

    /* Sinusoidal forward equations--mapping lat,long to x,y
      -----------------------------------------------------*/
    function forward$b(p) {
      var x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
        -----------------*/
      lon = adjust_lon(lon - this.long0);

      if (this.sphere) {
        if (!this.m) {
          lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
        }
        else {
          var k = this.n * Math.sin(lat);
          for (var i = MAX_ITER; i; --i) {
            var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
            lat -= V;
            if (Math.abs(V) < EPSLN) {
              break;
            }
          }
        }
        x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
        y = this.a * this.C_y * lat;

      }
      else {

        var s = Math.sin(lat);
        var c = Math.cos(lat);
        y = this.a * pj_mlfn(lat, s, c, this.en);
        x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
      }

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$b(p) {
      var lat, temp, lon, s;

      p.x -= this.x0;
      lon = p.x / this.a;
      p.y -= this.y0;
      lat = p.y / this.a;

      if (this.sphere) {
        lat /= this.C_y;
        lon = lon / (this.C_x * (this.m + Math.cos(lat)));
        if (this.m) {
          lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
        }
        else if (this.n !== 1) {
          lat = asinz(Math.sin(lat) / this.n);
        }
        lon = adjust_lon(lon + this.long0);
        lat = adjust_lat(lat);
      }
      else {
        lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
        s = Math.abs(lat);
        if (s < HALF_PI) {
          s = Math.sin(lat);
          temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
          //temp = this.long0 + p.x / (this.a * Math.cos(lat));
          lon = adjust_lon(temp);
        }
        else if ((s - EPSLN) < HALF_PI) {
          lon = this.long0;
        }
      }
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$b = ["Sinusoidal", "sinu"];
    var sinu = {
      init: init$c,
      forward: forward$b,
      inverse: inverse$b,
      names: names$b
    };

    function init$b() {}
    /* Mollweide forward equations--mapping lat,long to x,y
        ----------------------------------------------------*/
    function forward$a(p) {

      /* Forward equations
          -----------------*/
      var lon = p.x;
      var lat = p.y;

      var delta_lon = adjust_lon(lon - this.long0);
      var theta = lat;
      var con = Math.PI * Math.sin(lat);

      /* Iterate using the Newton-Raphson method to find theta
          -----------------------------------------------------*/
      while (true) {
        var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
        theta += delta_theta;
        if (Math.abs(delta_theta) < EPSLN) {
          break;
        }
      }
      theta /= 2;

      /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
           this is done here because of precision problems with "cos(theta)"
           --------------------------------------------------------------------------*/
      if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
        delta_lon = 0;
      }
      var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
      var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$a(p) {
      var theta;
      var arg;

      /* Inverse equations
          -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      arg = p.y / (1.4142135623731 * this.a);

      /* Because of division by zero problems, 'arg' can not be 1.  Therefore
           a number very close to one is used instead.
           -------------------------------------------------------------------*/
      if (Math.abs(arg) > 0.999999999999) {
        arg = 0.999999999999;
      }
      theta = Math.asin(arg);
      var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
      if (lon < (-Math.PI)) {
        lon = -Math.PI;
      }
      if (lon > Math.PI) {
        lon = Math.PI;
      }
      arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
      if (Math.abs(arg) > 1) {
        arg = 1;
      }
      var lat = Math.asin(arg);

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$a = ["Mollweide", "moll"];
    var moll = {
      init: init$b,
      forward: forward$a,
      inverse: inverse$a,
      names: names$a
    };

    function init$a() {

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      // Standard Parallels cannot be equal and on opposite sides of the equator
      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
        return;
      }
      this.lat2 = this.lat2 || this.lat1;
      this.temp = this.b / this.a;
      this.es = 1 - Math.pow(this.temp, 2);
      this.e = Math.sqrt(this.es);
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);

      this.sinphi = Math.sin(this.lat1);
      this.cosphi = Math.cos(this.lat1);

      this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

      if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
        this.ns = this.sinphi;
      }
      else {
        this.sinphi = Math.sin(this.lat2);
        this.cosphi = Math.cos(this.lat2);
        this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
        this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
        this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
      }
      this.g = this.ml1 + this.ms1 / this.ns;
      this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
      this.rh = this.a * (this.g - this.ml0);
    }

    /* Equidistant Conic forward equations--mapping lat,long to x,y
      -----------------------------------------------------------*/
    function forward$9(p) {
      var lon = p.x;
      var lat = p.y;
      var rh1;

      /* Forward equations
          -----------------*/
      if (this.sphere) {
        rh1 = this.a * (this.g - lat);
      }
      else {
        var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
        rh1 = this.a * (this.g - ml);
      }
      var theta = this.ns * adjust_lon(lon - this.long0);
      var x = this.x0 + rh1 * Math.sin(theta);
      var y = this.y0 + this.rh - rh1 * Math.cos(theta);
      p.x = x;
      p.y = y;
      return p;
    }

    /* Inverse equations
      -----------------*/
    function inverse$9(p) {
      p.x -= this.x0;
      p.y = this.rh - p.y + this.y0;
      var con, rh1, lat, lon;
      if (this.ns >= 0) {
        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
        con = 1;
      }
      else {
        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
        con = -1;
      }
      var theta = 0;
      if (rh1 !== 0) {
        theta = Math.atan2(con * p.x, con * p.y);
      }

      if (this.sphere) {
        lon = adjust_lon(this.long0 + theta / this.ns);
        lat = adjust_lat(this.g - rh1 / this.a);
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        var ml = this.g - rh1 / this.a;
        lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
        lon = adjust_lon(this.long0 + theta / this.ns);
        p.x = lon;
        p.y = lat;
        return p;
      }

    }

    var names$9 = ["Equidistant_Conic", "eqdc"];
    var eqdc = {
      init: init$a,
      forward: forward$9,
      inverse: inverse$9,
      names: names$9
    };

    /* Initialize the Van Der Grinten projection
      ----------------------------------------*/
    function init$9() {
      //this.R = 6370997; //Radius of earth
      this.R = this.a;
    }

    function forward$8(p) {

      var lon = p.x;
      var lat = p.y;

      /* Forward equations
        -----------------*/
      var dlon = adjust_lon(lon - this.long0);
      var x, y;

      if (Math.abs(lat) <= EPSLN) {
        x = this.x0 + this.R * dlon;
        y = this.y0;
      }
      var theta = asinz(2 * Math.abs(lat / Math.PI));
      if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
        x = this.x0;
        if (lat >= 0) {
          y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
        }
        else {
          y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
        }
        //  return(OK);
      }
      var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
      var asq = al * al;
      var sinth = Math.sin(theta);
      var costh = Math.cos(theta);

      var g = costh / (sinth + costh - 1);
      var gsq = g * g;
      var m = g * (2 / sinth - 1);
      var msq = m * m;
      var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
      if (dlon < 0) {
        con = -con;
      }
      x = this.x0 + con;
      //con = Math.abs(con / (Math.PI * this.R));
      var q = asq + g;
      con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
      if (lat >= 0) {
        //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
        y = this.y0 + con;
      }
      else {
        //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
        y = this.y0 - con;
      }
      p.x = x;
      p.y = y;
      return p;
    }

    /* Van Der Grinten inverse equations--mapping x,y to lat/long
      ---------------------------------------------------------*/
    function inverse$8(p) {
      var lon, lat;
      var xx, yy, xys, c1, c2, c3;
      var a1;
      var m1;
      var con;
      var th1;
      var d;

      /* inverse equations
        -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      con = Math.PI * this.R;
      xx = p.x / con;
      yy = p.y / con;
      xys = xx * xx + yy * yy;
      c1 = -Math.abs(yy) * (1 + xys);
      c2 = c1 - 2 * yy * yy + xx * xx;
      c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
      d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
      a1 = (c1 - c2 * c2 / 3 / c3) / c3;
      m1 = 2 * Math.sqrt(-a1 / 3);
      con = ((3 * d) / a1) / m1;
      if (Math.abs(con) > 1) {
        if (con >= 0) {
          con = 1;
        }
        else {
          con = -1;
        }
      }
      th1 = Math.acos(con) / 3;
      if (p.y >= 0) {
        lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
      }
      else {
        lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
      }

      if (Math.abs(xx) < EPSLN) {
        lon = this.long0;
      }
      else {
        lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
      }

      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$8 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
    var vandg = {
      init: init$9,
      forward: forward$8,
      inverse: inverse$8,
      names: names$8
    };

    function init$8() {
      this.sin_p12 = Math.sin(this.lat0);
      this.cos_p12 = Math.cos(this.lat0);
    }

    function forward$7(p) {
      var lon = p.x;
      var lat = p.y;
      var sinphi = Math.sin(p.y);
      var cosphi = Math.cos(p.y);
      var dlon = adjust_lon(lon - this.long0);
      var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
      if (this.sphere) {
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North Pole case
          p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
          p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South Pole case
          p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
          p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
          return p;
        }
        else {
          //default case
          cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
          c = Math.acos(cos_c);
          kp = c ? c / Math.sin(c) : 1;
          p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
          p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
          return p;
        }
      }
      else {
        e0 = e0fn(this.es);
        e1 = e1fn(this.es);
        e2 = e2fn(this.es);
        e3 = e3fn(this.es);
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North Pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
          p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
          p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South Pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
          p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
          p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
          return p;
        }
        else {
          //Default case
          tanphi = sinphi / cosphi;
          Nl1 = gN(this.a, this.e, this.sin_p12);
          Nl = gN(this.a, this.e, sinphi);
          psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
          Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
          if (Az === 0) {
            s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
          }
          else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
            s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
          }
          else {
            s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
          }
          G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
          H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
          GH = G * H;
          Hs = H * H;
          s2 = s * s;
          s3 = s2 * s;
          s4 = s3 * s;
          s5 = s4 * s;
          c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
          p.x = this.x0 + c * Math.sin(Az);
          p.y = this.y0 + c * Math.cos(Az);
          return p;
        }
      }


    }

    function inverse$7(p) {
      p.x -= this.x0;
      p.y -= this.y0;
      var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
      if (this.sphere) {
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        if (rh > (2 * HALF_PI * this.a)) {
          return;
        }
        z = rh / this.a;

        sinz = Math.sin(z);
        cosz = Math.cos(z);

        lon = this.long0;
        if (Math.abs(rh) <= EPSLN) {
          lat = this.lat0;
        }
        else {
          lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
          con = Math.abs(this.lat0) - HALF_PI;
          if (Math.abs(con) <= EPSLN) {
            if (this.lat0 >= 0) {
              lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
            }
            else {
              lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
            }
          }
          else {
            /*con = cosz - this.sin_p12 * Math.sin(lat);
            if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
              //no-op, just keep the lon value as is
            } else {
              var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
              lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
            }*/
            lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
          }
        }

        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        e0 = e0fn(this.es);
        e1 = e1fn(this.es);
        e2 = e2fn(this.es);
        e3 = e3fn(this.es);
        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
          //North pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          M = Mlp - rh;
          lat = imlfn(M / this.a, e0, e1, e2, e3);
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
          p.x = lon;
          p.y = lat;
          return p;
        }
        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
          //South pole case
          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          M = rh - Mlp;

          lat = imlfn(M / this.a, e0, e1, e2, e3);
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
          p.x = lon;
          p.y = lat;
          return p;
        }
        else {
          //default case
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          Az = Math.atan2(p.x, p.y);
          N1 = gN(this.a, this.e, this.sin_p12);
          cosAz = Math.cos(Az);
          tmp = this.e * this.cos_p12 * cosAz;
          A = -tmp * tmp / (1 - this.es);
          B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
          D = rh / N1;
          Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
          F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
          psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
          lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
          sinpsi = Math.sin(psi);
          lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
          p.x = lon;
          p.y = lat;
          return p;
        }
      }

    }

    var names$7 = ["Azimuthal_Equidistant", "aeqd"];
    var aeqd = {
      init: init$8,
      forward: forward$7,
      inverse: inverse$7,
      names: names$7
    };

    function init$7() {
      //double temp;      /* temporary variable    */

      /* Place parameters in static storage for common use
          -------------------------------------------------*/
      this.sin_p14 = Math.sin(this.lat0);
      this.cos_p14 = Math.cos(this.lat0);
    }

    /* Orthographic forward equations--mapping lat,long to x,y
        ---------------------------------------------------*/
    function forward$6(p) {
      var sinphi, cosphi; /* sin and cos value        */
      var dlon; /* delta longitude value      */
      var coslon; /* cos of longitude        */
      var ksp; /* scale factor          */
      var g, x, y;
      var lon = p.x;
      var lat = p.y;
      /* Forward equations
          -----------------*/
      dlon = adjust_lon(lon - this.long0);

      sinphi = Math.sin(lat);
      cosphi = Math.cos(lat);

      coslon = Math.cos(dlon);
      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
      ksp = 1;
      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
        x = this.a * ksp * cosphi * Math.sin(dlon);
        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
      }
      p.x = x;
      p.y = y;
      return p;
    }

    function inverse$6(p) {
      var rh; /* height above ellipsoid      */
      var z; /* angle          */
      var sinz, cosz; /* sin of z and cos of z      */
      var con;
      var lon, lat;
      /* Inverse equations
          -----------------*/
      p.x -= this.x0;
      p.y -= this.y0;
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      z = asinz(rh / this.a);

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
        p.x = lon;
        p.y = lat;
        return p;
      }
      lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
      p.x = lon;
      p.y = lat;
      return p;
    }

    var names$6 = ["ortho"];
    var ortho = {
      init: init$7,
      forward: forward$6,
      inverse: inverse$6,
      names: names$6
    };

    // QSC projection rewritten from the original PROJ4

    /* constants */
    var FACE_ENUM = {
        FRONT: 1,
        RIGHT: 2,
        BACK: 3,
        LEFT: 4,
        TOP: 5,
        BOTTOM: 6
    };

    var AREA_ENUM = {
        AREA_0: 1,
        AREA_1: 2,
        AREA_2: 3,
        AREA_3: 4
    };

    function init$6() {

      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.lat0 = this.lat0 || 0;
      this.long0 = this.long0 || 0;
      this.lat_ts = this.lat_ts || 0;
      this.title = this.title || "Quadrilateralized Spherical Cube";

      /* Determine the cube face from the center of projection. */
      if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
        this.face = FACE_ENUM.TOP;
      } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
        this.face = FACE_ENUM.BOTTOM;
      } else if (Math.abs(this.long0) <= FORTPI) {
        this.face = FACE_ENUM.FRONT;
      } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
        this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
      } else {
        this.face = FACE_ENUM.BACK;
      }

      /* Fill in useful values for the ellipsoid <-> sphere shift
       * described in [LK12]. */
      if (this.es !== 0) {
        this.one_minus_f = 1 - (this.a - this.b) / this.a;
        this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
      }
    }

    // QSC forward equations--mapping lat,long to x,y
    // -----------------------------------------------------------------
    function forward$5(p) {
      var xy = {x: 0, y: 0};
      var lat, lon;
      var theta, phi;
      var t, mu;
      /* nu; */
      var area = {value: 0};

      // move lon according to projection's lon
      p.x -= this.long0;

      /* Convert the geodetic latitude to a geocentric latitude.
       * This corresponds to the shift from the ellipsoid to the sphere
       * described in [LK12]. */
      if (this.es !== 0) {//if (P->es != 0) {
        lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
      } else {
        lat = p.y;
      }

      /* Convert the input lat, lon into theta, phi as used by QSC.
       * This depends on the cube face and the area on it.
       * For the top and bottom face, we can compute theta and phi
       * directly from phi, lam. For the other faces, we must use
       * unit sphere cartesian coordinates as an intermediate step. */
      lon = p.x; //lon = lp.lam;
      if (this.face === FACE_ENUM.TOP) {
        phi = HALF_PI - lat;
        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_0;
          theta = lon - HALF_PI;
        } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_1;
          theta = (lon > 0.0 ? lon - SPI : lon + SPI);
        } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
          area.value = AREA_ENUM.AREA_2;
          theta = lon + HALF_PI;
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta = lon;
        }
      } else if (this.face === FACE_ENUM.BOTTOM) {
        phi = HALF_PI + lat;
        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_0;
          theta = -lon + HALF_PI;
        } else if (lon < FORTPI && lon >= -FORTPI) {
          area.value = AREA_ENUM.AREA_1;
          theta = -lon;
        } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_2;
          theta = -lon - HALF_PI;
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
        }
      } else {
        var q, r, s;
        var sinlat, coslat;
        var sinlon, coslon;

        if (this.face === FACE_ENUM.RIGHT) {
          lon = qsc_shift_lon_origin(lon, +HALF_PI);
        } else if (this.face === FACE_ENUM.BACK) {
          lon = qsc_shift_lon_origin(lon, +SPI);
        } else if (this.face === FACE_ENUM.LEFT) {
          lon = qsc_shift_lon_origin(lon, -HALF_PI);
        }
        sinlat = Math.sin(lat);
        coslat = Math.cos(lat);
        sinlon = Math.sin(lon);
        coslon = Math.cos(lon);
        q = coslat * coslon;
        r = coslat * sinlon;
        s = sinlat;

        if (this.face === FACE_ENUM.FRONT) {
          phi = Math.acos(q);
          theta = qsc_fwd_equat_face_theta(phi, s, r, area);
        } else if (this.face === FACE_ENUM.RIGHT) {
          phi = Math.acos(r);
          theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
        } else if (this.face === FACE_ENUM.BACK) {
          phi = Math.acos(-q);
          theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
        } else if (this.face === FACE_ENUM.LEFT) {
          phi = Math.acos(-r);
          theta = qsc_fwd_equat_face_theta(phi, s, q, area);
        } else {
          /* Impossible */
          phi = theta = 0;
          area.value = AREA_ENUM.AREA_0;
        }
      }

      /* Compute mu and nu for the area of definition.
       * For mu, see Eq. (3-21) in [OL76], but note the typos:
       * compare with Eq. (3-14). For nu, see Eq. (3-38). */
      mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
      t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

      /* Apply the result to the real area. */
      if (area.value === AREA_ENUM.AREA_1) {
        mu += HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_2) {
        mu += SPI;
      } else if (area.value === AREA_ENUM.AREA_3) {
        mu += 1.5 * SPI;
      }

      /* Now compute x, y from mu and nu */
      xy.x = t * Math.cos(mu);
      xy.y = t * Math.sin(mu);
      xy.x = xy.x * this.a + this.x0;
      xy.y = xy.y * this.a + this.y0;

      p.x = xy.x;
      p.y = xy.y;
      return p;
    }

    // QSC inverse equations--mapping x,y to lat/long
    // -----------------------------------------------------------------
    function inverse$5(p) {
      var lp = {lam: 0, phi: 0};
      var mu, nu, cosmu, tannu;
      var tantheta, theta, cosphi, phi;
      var t;
      var area = {value: 0};

      /* de-offset */
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      /* Convert the input x, y to the mu and nu angles as used by QSC.
       * This depends on the area of the cube face. */
      nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
      mu = Math.atan2(p.y, p.x);
      if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
        area.value = AREA_ENUM.AREA_0;
      } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
        area.value = AREA_ENUM.AREA_1;
        mu -= HALF_PI;
      } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
        area.value = AREA_ENUM.AREA_2;
        mu = (mu < 0.0 ? mu + SPI : mu - SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        mu += HALF_PI;
      }

      /* Compute phi and theta for the area of definition.
       * The inverse projection is not described in the original paper, but some
       * good hints can be found here (as of 2011-12-14):
       * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
       * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
      t = (SPI / 12) * Math.tan(mu);
      tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
      theta = Math.atan(tantheta);
      cosmu = Math.cos(mu);
      tannu = Math.tan(nu);
      cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
      if (cosphi < -1) {
        cosphi = -1;
      } else if (cosphi > +1) {
        cosphi = +1;
      }

      /* Apply the result to the real area on the cube face.
       * For the top and bottom face, we can compute phi and lam directly.
       * For the other faces, we must use unit sphere cartesian coordinates
       * as an intermediate step. */
      if (this.face === FACE_ENUM.TOP) {
        phi = Math.acos(cosphi);
        lp.phi = HALF_PI - phi;
        if (area.value === AREA_ENUM.AREA_0) {
          lp.lam = theta + HALF_PI;
        } else if (area.value === AREA_ENUM.AREA_1) {
          lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
        } else if (area.value === AREA_ENUM.AREA_2) {
          lp.lam = theta - HALF_PI;
        } else /* area.value == AREA_ENUM.AREA_3 */ {
          lp.lam = theta;
        }
      } else if (this.face === FACE_ENUM.BOTTOM) {
        phi = Math.acos(cosphi);
        lp.phi = phi - HALF_PI;
        if (area.value === AREA_ENUM.AREA_0) {
          lp.lam = -theta + HALF_PI;
        } else if (area.value === AREA_ENUM.AREA_1) {
          lp.lam = -theta;
        } else if (area.value === AREA_ENUM.AREA_2) {
          lp.lam = -theta - HALF_PI;
        } else /* area.value == AREA_ENUM.AREA_3 */ {
          lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
        }
      } else {
        /* Compute phi and lam via cartesian unit sphere coordinates. */
        var q, r, s;
        q = cosphi;
        t = q * q;
        if (t >= 1) {
          s = 0;
        } else {
          s = Math.sqrt(1 - t) * Math.sin(theta);
        }
        t += s * s;
        if (t >= 1) {
          r = 0;
        } else {
          r = Math.sqrt(1 - t);
        }
        /* Rotate q,r,s into the correct area. */
        if (area.value === AREA_ENUM.AREA_1) {
          t = r;
          r = -s;
          s = t;
        } else if (area.value === AREA_ENUM.AREA_2) {
          r = -r;
          s = -s;
        } else if (area.value === AREA_ENUM.AREA_3) {
          t = r;
          r = s;
          s = -t;
        }
        /* Rotate q,r,s into the correct cube face. */
        if (this.face === FACE_ENUM.RIGHT) {
          t = q;
          q = -r;
          r = t;
        } else if (this.face === FACE_ENUM.BACK) {
          q = -q;
          r = -r;
        } else if (this.face === FACE_ENUM.LEFT) {
          t = q;
          q = r;
          r = -t;
        }
        /* Now compute phi and lam from the unit sphere coordinates. */
        lp.phi = Math.acos(-s) - HALF_PI;
        lp.lam = Math.atan2(r, q);
        if (this.face === FACE_ENUM.RIGHT) {
          lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
        } else if (this.face === FACE_ENUM.BACK) {
          lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
        } else if (this.face === FACE_ENUM.LEFT) {
          lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
        }
      }

      /* Apply the shift from the sphere to the ellipsoid as described
       * in [LK12]. */
      if (this.es !== 0) {
        var invert_sign;
        var tanphi, xa;
        invert_sign = (lp.phi < 0 ? 1 : 0);
        tanphi = Math.tan(lp.phi);
        xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
        lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
        if (invert_sign) {
          lp.phi = -lp.phi;
        }
      }

      lp.lam += this.long0;
      p.x = lp.lam;
      p.y = lp.phi;
      return p;
    }

    /* Helper function for forward projection: compute the theta angle
     * and determine the area number. */
    function qsc_fwd_equat_face_theta(phi, y, x, area) {
      var theta;
      if (phi < EPSLN) {
        area.value = AREA_ENUM.AREA_0;
        theta = 0.0;
      } else {
        theta = Math.atan2(y, x);
        if (Math.abs(theta) <= FORTPI) {
          area.value = AREA_ENUM.AREA_0;
        } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
          area.value = AREA_ENUM.AREA_1;
          theta -= HALF_PI;
        } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
          area.value = AREA_ENUM.AREA_2;
          theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
        } else {
          area.value = AREA_ENUM.AREA_3;
          theta += HALF_PI;
        }
      }
      return theta;
    }

    /* Helper function: shift the longitude. */
    function qsc_shift_lon_origin(lon, offset) {
      var slon = lon + offset;
      if (slon < -SPI) {
        slon += TWO_PI;
      } else if (slon > +SPI) {
        slon -= TWO_PI;
      }
      return slon;
    }

    var names$5 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    var qsc = {
      init: init$6,
      forward: forward$5,
      inverse: inverse$5,
      names: names$5
    };

    // Robinson projection

    var COEFS_X = [
        [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
        [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
        [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
        [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
        [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
        [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
        [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
        [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
        [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
        [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
        [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
        [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
        [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
        [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
        [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
        [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
        [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
        [0.5722, -0.00906601, 0.000182, 6.24051e-06],
        [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
    ];

    var COEFS_Y = [
        [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
        [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
        [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
        [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
        [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
        [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
        [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
        [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
        [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
        [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
        [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
        [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
        [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
        [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
        [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
        [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
        [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
        [0.9761, 0.00616527, -0.000256, -4.2106e-06],
        [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
    ];

    var FXC = 0.8487;
    var FYC = 1.3523;
    var C1 = R2D$1/5; // rad to 5-degree interval
    var RC1 = 1/C1;
    var NODES = 18;

    var poly3_val = function(coefs, x) {
        return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
    };

    var poly3_der = function(coefs, x) {
        return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
    };

    function newton_rapshon(f_df, start, max_err, iters) {
        var x = start;
        for (; iters; --iters) {
            var upd = f_df(x);
            x -= upd;
            if (Math.abs(upd) < max_err) {
                break;
            }
        }
        return x;
    }

    function init$5() {
        this.x0 = this.x0 || 0;
        this.y0 = this.y0 || 0;
        this.long0 = this.long0 || 0;
        this.es = 0;
        this.title = this.title || "Robinson";
    }

    function forward$4(ll) {
        var lon = adjust_lon(ll.x - this.long0);

        var dphi = Math.abs(ll.y);
        var i = Math.floor(dphi * C1);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        dphi = R2D$1 * (dphi - RC1 * i);
        var xy = {
            x: poly3_val(COEFS_X[i], dphi) * lon,
            y: poly3_val(COEFS_Y[i], dphi)
        };
        if (ll.y < 0) {
            xy.y = -xy.y;
        }

        xy.x = xy.x * this.a * FXC + this.x0;
        xy.y = xy.y * this.a * FYC + this.y0;
        return xy;
    }

    function inverse$4(xy) {
        var ll = {
            x: (xy.x - this.x0) / (this.a * FXC),
            y: Math.abs(xy.y - this.y0) / (this.a * FYC)
        };

        if (ll.y >= 1) { // pathologic case
            ll.x /= COEFS_X[NODES][0];
            ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
        } else {
            // find table interval
            var i = Math.floor(ll.y * NODES);
            if (i < 0) {
                i = 0;
            } else if (i >= NODES) {
                i = NODES - 1;
            }
            for (;;) {
                if (COEFS_Y[i][0] > ll.y) {
                    --i;
                } else if (COEFS_Y[i+1][0] <= ll.y) {
                    ++i;
                } else {
                    break;
                }
            }
            // linear interpolation in 5 degree interval
            var coefs = COEFS_Y[i];
            var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
            // find t so that poly3_val(coefs, t) = ll.y
            t = newton_rapshon(function(x) {
                return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
            }, t, EPSLN, 100);

            ll.x /= poly3_val(COEFS_X[i], t);
            ll.y = (5 * i + t) * D2R$2;
            if (xy.y < 0) {
                ll.y = -ll.y;
            }
        }

        ll.x = adjust_lon(ll.x + this.long0);
        return ll;
    }

    var names$4 = ["Robinson", "robin"];
    var robin = {
      init: init$5,
      forward: forward$4,
      inverse: inverse$4,
      names: names$4
    };

    function init$4() {
        this.name = 'geocent';

    }

    function forward$3(p) {
        var point = geodeticToGeocentric(p, this.es, this.a);
        return point;
    }

    function inverse$3(p) {
        var point = geocentricToGeodetic(p, this.es, this.a, this.b);
        return point;
    }

    var names$3 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
    var geocent = {
        init: init$4,
        forward: forward$3,
        inverse: inverse$3,
        names: names$3
    };

    var mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };

    var params = {
      h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
      azi:   { def: 0, num: true, degrees: true }, // default is North
      tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
      long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
      lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
    };

    function init$3() {
      Object.keys(params).forEach(function (p) {
        if (typeof this[p] === "undefined") {
          this[p] = params[p].def;
        } else if (params[p].num && isNaN(this[p])) {
          throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
        } else if (params[p].num) {
          this[p] = parseFloat(this[p]);
        }
        if (params[p].degrees) {
          this[p] = this[p] * D2R$2;
        }
      }.bind(this));

      if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
        this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
      } else if (Math.abs(this.lat0) < EPSLN) {
        this.mode = mode.EQUIT;
      } else {
        this.mode = mode.OBLIQ;
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }

      this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

      if (this.pn1 <= 0 || this.pn1 > 1e10) {
        throw new Error("Invalid height");
      }
      
      this.p = 1 + this.pn1;
      this.rp = 1 / this.p;
      this.h1 = 1 / this.pn1;
      this.pfact = (this.p + 1) * this.h1;
      this.es = 0;

      var omega = this.tilt;
      var gamma = this.azi;
      this.cg = Math.cos(gamma);
      this.sg = Math.sin(gamma);
      this.cw = Math.cos(omega);
      this.sw = Math.sin(omega);
    }

    function forward$2(p) {
      p.x -= this.long0;
      var sinphi = Math.sin(p.y);
      var cosphi = Math.cos(p.y);
      var coslam = Math.cos(p.x);
      var x, y;
      switch (this.mode) {
        case mode.OBLIQ:
          y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
          break;
        case mode.EQUIT:
          y = cosphi * coslam;
          break;
        case mode.S_POLE:
          y = -sinphi;
          break;
        case mode.N_POLE:
          y = sinphi;
          break;
      }
      y = this.pn1 / (this.p - y);
      x = y * cosphi * Math.sin(p.x);

      switch (this.mode) {
        case mode.OBLIQ:
          y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
          break;
        case mode.EQUIT:
          y *= sinphi;
          break;
        case mode.N_POLE:
          y *= -(cosphi * coslam);
          break;
        case mode.S_POLE:
          y *= cosphi * coslam;
          break;
      }

      // Tilt 
      var yt, ba;
      yt = y * this.cg + x * this.sg;
      ba = 1 / (yt * this.sw * this.h1 + this.cw);
      x = (x * this.cg - y * this.sg) * this.cw * ba;
      y = yt * ba;

      p.x = x * this.a;
      p.y = y * this.a;
      return p;
    }

    function inverse$2(p) {
      p.x /= this.a;
      p.y /= this.a;
      var r = { x: p.x, y: p.y };

      // Un-Tilt
      var bm, bq, yt;
      yt = 1 / (this.pn1 - p.y * this.sw);
      bm = this.pn1 * p.x * yt;
      bq = this.pn1 * p.y * this.cw * yt;
      p.x = bm * this.cg + bq * this.sg;
      p.y = bq * this.cg - bm * this.sg;

      var rh = hypot(p.x, p.y);
      if (Math.abs(rh) < EPSLN) {
        r.x = 0;
        r.y = p.y;
      } else {
        var cosz, sinz;
        sinz = 1 - rh * rh * this.pfact;
        sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
        cosz = Math.sqrt(1 - sinz * sinz);
        switch (this.mode) {
          case mode.OBLIQ:
            r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
            p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
            p.x *= sinz * this.cosph0;
            break;
          case mode.EQUIT:
            r.y = Math.asin(p.y * sinz / rh);
            p.y = cosz * rh;
            p.x *= sinz;
            break;
          case mode.N_POLE:
            r.y = Math.asin(cosz);
            p.y = -p.y;
            break;
          case mode.S_POLE:
            r.y = -Math.asin(cosz);
            break;
        }
        r.x = Math.atan2(p.x, p.y);
      }

      p.x = r.x + this.long0;
      p.y = r.y;
      return p;
    }

    var names$2 = ["Tilted_Perspective", "tpers"];
    var tpers = {
      init: init$3,
      forward: forward$2,
      inverse: inverse$2,
      names: names$2
    };

    function init$2() {
        this.flip_axis = (this.sweep === 'x' ? 1 : 0);
        this.h = Number(this.h);
        this.radius_g_1 = this.h / this.a;

        if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
            throw new Error();
        }

        this.radius_g = 1.0 + this.radius_g_1;
        this.C = this.radius_g * this.radius_g - 1.0;

        if (this.es !== 0.0) {
            var one_es = 1.0 - this.es;
            var rone_es = 1 / one_es;

            this.radius_p = Math.sqrt(one_es);
            this.radius_p2 = one_es;
            this.radius_p_inv2 = rone_es;

            this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
        } else {
            this.radius_p = 1.0;
            this.radius_p2 = 1.0;
            this.radius_p_inv2 = 1.0;

            this.shape = 'sphere';  // Use as a condition in the forward and inverse functions.
        }

        if (!this.title) {
            this.title = "Geostationary Satellite View";
        }
    }

    function forward$1(p) {
        var lon = p.x;
        var lat = p.y;
        var tmp, v_x, v_y, v_z;
        lon = lon - this.long0;

        if (this.shape === 'ellipse') {
            lat = Math.atan(this.radius_p2 * Math.tan(lat));
            var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));

            v_x = r * Math.cos(lon) * Math.cos(lat);
            v_y = r * Math.sin(lon) * Math.cos(lat);
            v_z = r * Math.sin(lat);

            if (((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2) < 0.0) {
                p.x = Number.NaN;
                p.y = Number.NaN;
                return p;
            }

            tmp = this.radius_g - v_x;
            if (this.flip_axis) {
                p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
                p.y = this.radius_g_1 * Math.atan(v_z / tmp);
            } else {
                p.x = this.radius_g_1 * Math.atan(v_y / tmp);
                p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
            }
        } else if (this.shape === 'sphere') {
            tmp = Math.cos(lat);
            v_x = Math.cos(lon) * tmp;
            v_y = Math.sin(lon) * tmp;
            v_z = Math.sin(lat);
            tmp = this.radius_g - v_x;

            if (this.flip_axis) {
                p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
                p.y = this.radius_g_1 * Math.atan(v_z / tmp);
            } else {
                p.x = this.radius_g_1 * Math.atan(v_y / tmp);
                p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
            }
        }
        p.x = p.x * this.a;
        p.y = p.y * this.a;
        return p;
    }

    function inverse$1(p) {
        var v_x = -1.0;
        var v_y = 0.0;
        var v_z = 0.0;
        var a, b, det, k;

        p.x = p.x / this.a;
        p.y = p.y / this.a;

        if (this.shape === 'ellipse') {
            if (this.flip_axis) {
                v_z = Math.tan(p.y / this.radius_g_1);
                v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);
            } else {
                v_y = Math.tan(p.x / this.radius_g_1);
                v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);
            }

            var v_zp = v_z / this.radius_p;
            a = v_y * v_y + v_zp * v_zp + v_x * v_x;
            b = 2 * this.radius_g * v_x;
            det = (b * b) - 4 * a * this.C;

            if (det < 0.0) {
                p.x = Number.NaN;
                p.y = Number.NaN;
                return p;
            }

            k = (-b - Math.sqrt(det)) / (2.0 * a);
            v_x = this.radius_g + k * v_x;
            v_y *= k;
            v_z *= k;

            p.x = Math.atan2(v_y, v_x);
            p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
            p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
        } else if (this.shape === 'sphere') {
            if (this.flip_axis) {
                v_z = Math.tan(p.y / this.radius_g_1);
                v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
            } else {
                v_y = Math.tan(p.x / this.radius_g_1);
                v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
            }

            a = v_y * v_y + v_z * v_z + v_x * v_x;
            b = 2 * this.radius_g * v_x;
            det = (b * b) - 4 * a * this.C;
            if (det < 0.0) {
                p.x = Number.NaN;
                p.y = Number.NaN;
                return p;
            }

            k = (-b - Math.sqrt(det)) / (2.0 * a);
            v_x = this.radius_g + k * v_x;
            v_y *= k;
            v_z *= k;

            p.x = Math.atan2(v_y, v_x);
            p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
        }
        p.x = p.x + this.long0;
        return p;
    }

    var names$1 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
    var geos = {
        init: init$2,
        forward: forward$1,
        inverse: inverse$1,
        names: names$1,
    };

    /**
     * Copyright 2018 Bernie Jenny, Monash University, Melbourne, Australia.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * Equal Earth is a projection inspired by the Robinson projection, but unlike
     * the Robinson projection retains the relative size of areas. The projection
     * was designed in 2018 by Bojan Savric, Tom Patterson and Bernhard Jenny.
     *
     * Publication:
     * Bojan Savric, Tom Patterson & Bernhard Jenny (2018). The Equal Earth map
     * projection, International Journal of Geographical Information Science,
     * DOI: 10.1080/13658816.2018.1504949
     *
     * Code released August 2018
     * Ported to JavaScript and adapted for mapshaper-proj by Matthew Bloch August 2018
     * Modified for proj4js by Andreas Hocevar by Andreas Hocevar March 2024
     */

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = Math.sqrt(3) / 2.0;

    function init$1() {
      this.es = 0;
      this.long0 = this.long0 !== undefined ? this.long0 : 0;
    }

    function forward(p) {
      var lam = adjust_lon(p.x - this.long0);
      var phi = p.y;
      var paramLat = Math.asin(M * Math.sin(phi)),
      paramLatSq = paramLat * paramLat,
      paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
      p.x = lam * Math.cos(paramLat) /
      (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
      p.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));

      p.x = this.a * p.x + this.x0;
      p.y = this.a * p.y + this.y0;
      return p;
    }

    function inverse(p) {
      p.x = (p.x - this.x0) / this.a;
      p.y = (p.y - this.y0) / this.a;

      var EPS = 1e-9,
          NITER = 12,
          paramLat = p.y,
          paramLatSq, paramLatPow6, fy, fpy, dlat, i;

      for (i = 0; i < NITER; ++i) {
        paramLatSq = paramLat * paramLat;
        paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
        fy = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p.y;
        fpy = A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
        paramLat -= dlat = fy / fpy;
        if (Math.abs(dlat) < EPS) {
            break;
        }
      }
      paramLatSq = paramLat * paramLat;
      paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
      p.x = M * p.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) /
              Math.cos(paramLat);
      p.y = Math.asin(Math.sin(paramLat) / M);

      p.x = adjust_lon(p.x + this.long0);
      return p;
    }

    var names = ["eqearth", "Equal Earth", "Equal_Earth"];
    var eqearth = {
      init: init$1,
      forward: forward,
      inverse: inverse,
      names: names
    };

    function includedProjections(proj4){
      proj4.Proj.projections.add(tmerc);
      proj4.Proj.projections.add(etmerc);
      proj4.Proj.projections.add(utm);
      proj4.Proj.projections.add(sterea);
      proj4.Proj.projections.add(stere);
      proj4.Proj.projections.add(somerc);
      proj4.Proj.projections.add(omerc);
      proj4.Proj.projections.add(lcc);
      proj4.Proj.projections.add(krovak);
      proj4.Proj.projections.add(cass);
      proj4.Proj.projections.add(laea);
      proj4.Proj.projections.add(aea);
      proj4.Proj.projections.add(gnom);
      proj4.Proj.projections.add(cea);
      proj4.Proj.projections.add(eqc);
      proj4.Proj.projections.add(poly);
      proj4.Proj.projections.add(nzmg);
      proj4.Proj.projections.add(mill);
      proj4.Proj.projections.add(sinu);
      proj4.Proj.projections.add(moll);
      proj4.Proj.projections.add(eqdc);
      proj4.Proj.projections.add(vandg);
      proj4.Proj.projections.add(aeqd);
      proj4.Proj.projections.add(ortho);
      proj4.Proj.projections.add(qsc);
      proj4.Proj.projections.add(robin);
      proj4.Proj.projections.add(geocent);
      proj4.Proj.projections.add(tpers);
      proj4.Proj.projections.add(geos);
      proj4.Proj.projections.add(eqearth);
    }

    proj4.defaultDatum = 'WGS84'; //default datum
    proj4.Proj = Projection;
    proj4.WGS84 = new proj4.Proj('WGS84');
    proj4.Point = Point;
    proj4.toPoint = common;
    proj4.defs = defs;
    proj4.nadgrid = nadgrid;
    proj4.transform = transform$1;
    proj4.mgrs = mgrs;
    proj4.version = '__VERSION__';
    includedProjections(proj4);

    /**
     * @module helpers
     */
    /**
     * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
     *
     * @memberof helpers
     * @type {number}
     */
    var earthRadius = 6371008.8;
    /**
     * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
     *
     * @memberof helpers
     * @type {Object}
     */
    var factors = {
        centimeters: earthRadius * 100,
        centimetres: earthRadius * 100,
        degrees: earthRadius / 111325,
        feet: earthRadius * 3.28084,
        inches: earthRadius * 39.37,
        kilometers: earthRadius / 1000,
        kilometres: earthRadius / 1000,
        meters: earthRadius,
        metres: earthRadius,
        miles: earthRadius / 1609.344,
        millimeters: earthRadius * 1000,
        millimetres: earthRadius * 1000,
        nauticalmiles: earthRadius / 1852,
        radians: 1,
        yards: earthRadius * 1.0936,
    };
    /**
     * Units of measurement factors based on 1 meter.
     *
     * @memberof helpers
     * @type {Object}
     */
    var unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1000,
        kilometres: 1 / 1000,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1000,
        millimetres: 1000,
        nauticalmiles: 1 / 1852,
        radians: 1 / earthRadius,
        yards: 1.0936133,
    };
    /**
     * Area of measurement factors based on 1 square meter.
     *
     * @memberof helpers
     * @type {Object}
     */
    var areaFactors = {
        acres: 0.000247105,
        centimeters: 10000,
        centimetres: 10000,
        feet: 10.763910417,
        hectares: 0.0001,
        inches: 1550.003100006,
        kilometers: 0.000001,
        kilometres: 0.000001,
        meters: 1,
        metres: 1,
        miles: 3.86e-7,
        millimeters: 1000000,
        millimetres: 1000000,
        yards: 1.195990046,
    };
    /**
     * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
     *
     * @name feature
     * @param {Geometry} geometry input geometry
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature} a GeoJSON Feature
     * @example
     * var geometry = {
     *   "type": "Point",
     *   "coordinates": [110, 50]
     * };
     *
     * var feature = turf.feature(geometry);
     *
     * //=feature
     */
    function feature(geom, properties, options) {
        if (options === void 0) { options = {}; }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
            feat.id = options.id;
        }
        if (options.bbox) {
            feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
    }
    /**
     * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
     * For GeometryCollection type use `helpers.geometryCollection`
     *
     * @name geometry
     * @param {string} type Geometry Type
     * @param {Array<any>} coordinates Coordinates
     * @param {Object} [options={}] Optional Parameters
     * @returns {Geometry} a GeoJSON Geometry
     * @example
     * var type = "Point";
     * var coordinates = [110, 50];
     * var geometry = turf.geometry(type, coordinates);
     * // => geometry
     */
    function geometry$1(type, coordinates, _options) {
        switch (type) {
            case "Point":
                return point(coordinates).geometry;
            case "LineString":
                return lineString(coordinates).geometry;
            case "Polygon":
                return polygon(coordinates).geometry;
            case "MultiPoint":
                return multiPoint(coordinates).geometry;
            case "MultiLineString":
                return multiLineString(coordinates).geometry;
            case "MultiPolygon":
                return multiPolygon(coordinates).geometry;
            default:
                throw new Error(type + " is invalid");
        }
    }
    /**
     * Creates a {@link Point} {@link Feature} from a Position.
     *
     * @name point
     * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<Point>} a Point feature
     * @example
     * var point = turf.point([-75.343, 39.984]);
     *
     * //=point
     */
    function point(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        if (!coordinates) {
            throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
            throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
            throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
            throw new Error("coordinates must contain numbers");
        }
        var geom = {
            type: "Point",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    /**
     * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
     *
     * @name points
     * @param {Array<Array<number>>} coordinates an array of Points
     * @param {Object} [properties={}] Translate these properties to each Feature
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
     * associated with the FeatureCollection
     * @param {string|number} [options.id] Identifier associated with the FeatureCollection
     * @returns {FeatureCollection<Point>} Point Feature
     * @example
     * var points = turf.points([
     *   [-75, 39],
     *   [-80, 45],
     *   [-78, 50]
     * ]);
     *
     * //=points
     */
    function points(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        return featureCollection$1(coordinates.map(function (coords) {
            return point(coords, properties);
        }), options);
    }
    /**
     * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
     *
     * @name polygon
     * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<Polygon>} Polygon Feature
     * @example
     * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
     *
     * //=polygon
     */
    function polygon(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
            var ring = coordinates_1[_i];
            if (ring.length < 4) {
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            }
            for (var j = 0; j < ring[ring.length - 1].length; j++) {
                // Check if first point of Polygon contains two numbers
                if (ring[ring.length - 1][j] !== ring[0][j]) {
                    throw new Error("First and last Position are not equivalent.");
                }
            }
        }
        var geom = {
            type: "Polygon",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    /**
     * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
     *
     * @name polygons
     * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the FeatureCollection
     * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
     * @example
     * var polygons = turf.polygons([
     *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
     *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
     * ]);
     *
     * //=polygons
     */
    function polygons(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        return featureCollection$1(coordinates.map(function (coords) {
            return polygon(coords, properties);
        }), options);
    }
    /**
     * Creates a {@link LineString} {@link Feature} from an Array of Positions.
     *
     * @name lineString
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<LineString>} LineString Feature
     * @example
     * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
     * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
     *
     * //=linestring1
     * //=linestring2
     */
    function lineString(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        if (coordinates.length < 2) {
            throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
            type: "LineString",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    /**
     * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
     *
     * @name lineStrings
     * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
     * associated with the FeatureCollection
     * @param {string|number} [options.id] Identifier associated with the FeatureCollection
     * @returns {FeatureCollection<LineString>} LineString FeatureCollection
     * @example
     * var linestrings = turf.lineStrings([
     *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
     *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
     * ]);
     *
     * //=linestrings
     */
    function lineStrings(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        return featureCollection$1(coordinates.map(function (coords) {
            return lineString(coords, properties);
        }), options);
    }
    /**
     * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
     *
     * @name featureCollection
     * @param {Feature[]} features input features
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {FeatureCollection} FeatureCollection of Features
     * @example
     * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
     * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
     * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
     *
     * var collection = turf.featureCollection([
     *   locationA,
     *   locationB,
     *   locationC
     * ]);
     *
     * //=collection
     */
    function featureCollection$1(features, options) {
        if (options === void 0) { options = {}; }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
            fc.id = options.id;
        }
        if (options.bbox) {
            fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
    }
    /**
     * Creates a {@link Feature<MultiLineString>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiLineString
     * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<MultiLineString>} a MultiLineString feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
     *
     * //=multiLine
     */
    function multiLineString(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "MultiLineString",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    /**
     * Creates a {@link Feature<MultiPoint>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPoint
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<MultiPoint>} a MultiPoint feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPt = turf.multiPoint([[0,0],[10,10]]);
     *
     * //=multiPt
     */
    function multiPoint(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "MultiPoint",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    /**
     * Creates a {@link Feature<MultiPolygon>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPolygon
     * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<MultiPolygon>} a multipolygon feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
     *
     * //=multiPoly
     *
     */
    function multiPolygon(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "MultiPolygon",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    /**
     * Creates a {@link Feature<GeometryCollection>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name geometryCollection
     * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
     * @example
     * var pt = turf.geometry("Point", [100, 0]);
     * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
     * var collection = turf.geometryCollection([pt, line]);
     *
     * // => collection
     */
    function geometryCollection(geometries, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "GeometryCollection",
            geometries: geometries,
        };
        return feature(geom, properties, options);
    }
    /**
     * Round number to precision
     *
     * @param {number} num Number
     * @param {number} [precision=0] Precision
     * @returns {number} rounded number
     * @example
     * turf.round(120.4321)
     * //=120
     *
     * turf.round(120.4321, 2)
     * //=120.43
     */
    function round$1(num, precision) {
        if (precision === void 0) { precision = 0; }
        if (precision && !(precision >= 0)) {
            throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
    }
    /**
     * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @name radiansToLength
     * @param {number} radians in radians across the sphere
     * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
     * meters, kilometres, kilometers.
     * @returns {number} distance
     */
    function radiansToLength(radians, units) {
        if (units === void 0) { units = "kilometers"; }
        var factor = factors[units];
        if (!factor) {
            throw new Error(units + " units is invalid");
        }
        return radians * factor;
    }
    /**
     * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @name lengthToRadians
     * @param {number} distance in real units
     * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
     * meters, kilometres, kilometers.
     * @returns {number} radians
     */
    function lengthToRadians(distance, units) {
        if (units === void 0) { units = "kilometers"; }
        var factor = factors[units];
        if (!factor) {
            throw new Error(units + " units is invalid");
        }
        return distance / factor;
    }
    /**
     * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
     *
     * @name lengthToDegrees
     * @param {number} distance in real units
     * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
     * meters, kilometres, kilometers.
     * @returns {number} degrees
     */
    function lengthToDegrees(distance, units) {
        return radiansToDegrees(lengthToRadians(distance, units));
    }
    /**
     * Converts any bearing angle from the north line direction (positive clockwise)
     * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
     *
     * @name bearingToAzimuth
     * @param {number} bearing angle, between -180 and +180 degrees
     * @returns {number} angle between 0 and 360 degrees
     */
    function bearingToAzimuth(bearing) {
        var angle = bearing % 360;
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    }
    /**
     * Converts an angle in radians to degrees
     *
     * @name radiansToDegrees
     * @param {number} radians angle in radians
     * @returns {number} degrees between 0 and 360 degrees
     */
    function radiansToDegrees(radians) {
        var degrees = radians % (2 * Math.PI);
        return (degrees * 180) / Math.PI;
    }
    /**
     * Converts an angle in degrees to radians
     *
     * @name degreesToRadians
     * @param {number} degrees angle between 0 and 360 degrees
     * @returns {number} angle in radians
     */
    function degreesToRadians(degrees) {
        var radians = degrees % 360;
        return (radians * Math.PI) / 180;
    }
    /**
     * Converts a length to the requested unit.
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @param {number} length to be converted
     * @param {Units} [originalUnit="kilometers"] of the length
     * @param {Units} [finalUnit="kilometers"] returned unit
     * @returns {number} the converted length
     */
    function convertLength(length, originalUnit, finalUnit) {
        if (originalUnit === void 0) { originalUnit = "kilometers"; }
        if (finalUnit === void 0) { finalUnit = "kilometers"; }
        if (!(length >= 0)) {
            throw new Error("length must be a positive number");
        }
        return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
    }
    /**
     * Converts a area to the requested unit.
     * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
     * @param {number} area to be converted
     * @param {Units} [originalUnit="meters"] of the distance
     * @param {Units} [finalUnit="kilometers"] returned unit
     * @returns {number} the converted area
     */
    function convertArea(area, originalUnit, finalUnit) {
        if (originalUnit === void 0) { originalUnit = "meters"; }
        if (finalUnit === void 0) { finalUnit = "kilometers"; }
        if (!(area >= 0)) {
            throw new Error("area must be a positive number");
        }
        var startFactor = areaFactors[originalUnit];
        if (!startFactor) {
            throw new Error("invalid original units");
        }
        var finalFactor = areaFactors[finalUnit];
        if (!finalFactor) {
            throw new Error("invalid final units");
        }
        return (area / startFactor) * finalFactor;
    }
    /**
     * isNumber
     *
     * @param {*} num Number to validate
     * @returns {boolean} true/false
     * @example
     * turf.isNumber(123)
     * //=true
     * turf.isNumber('foo')
     * //=false
     */
    function isNumber(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    /**
     * isObject
     *
     * @param {*} input variable to validate
     * @returns {boolean} true/false
     * @example
     * turf.isObject({elevation: 10})
     * //=true
     * turf.isObject('foo')
     * //=false
     */
    function isObject(input) {
        return !!input && input.constructor === Object;
    }
    /**
     * Validate BBox
     *
     * @private
     * @param {Array<number>} bbox BBox to validate
     * @returns {void}
     * @throws Error if BBox is not valid
     * @example
     * validateBBox([-180, -40, 110, 50])
     * //=OK
     * validateBBox([-180, -40])
     * //=Error
     * validateBBox('Foo')
     * //=Error
     * validateBBox(5)
     * //=Error
     * validateBBox(null)
     * //=Error
     * validateBBox(undefined)
     * //=Error
     */
    function validateBBox(bbox) {
        if (!bbox) {
            throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox)) {
            throw new Error("bbox must be an Array");
        }
        if (bbox.length !== 4 && bbox.length !== 6) {
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox.forEach(function (num) {
            if (!isNumber(num)) {
                throw new Error("bbox must only contain numbers");
            }
        });
    }
    /**
     * Validate Id
     *
     * @private
     * @param {string|number} id Id to validate
     * @returns {void}
     * @throws Error if Id is not valid
     * @example
     * validateId([-180, -40, 110, 50])
     * //=Error
     * validateId([-180, -40])
     * //=Error
     * validateId('Foo')
     * //=OK
     * validateId(5)
     * //=OK
     * validateId(null)
     * //=Error
     * validateId(undefined)
     * //=Error
     */
    function validateId(id) {
        if (!id) {
            throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
            throw new Error("id must be a number or a string");
        }
    }

    var index$6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        earthRadius: earthRadius,
        factors: factors,
        unitsFactors: unitsFactors,
        areaFactors: areaFactors,
        feature: feature,
        geometry: geometry$1,
        point: point,
        points: points,
        polygon: polygon,
        polygons: polygons,
        lineString: lineString,
        lineStrings: lineStrings,
        featureCollection: featureCollection$1,
        multiLineString: multiLineString,
        multiPoint: multiPoint,
        multiPolygon: multiPolygon,
        geometryCollection: geometryCollection,
        round: round$1,
        radiansToLength: radiansToLength,
        lengthToRadians: lengthToRadians,
        lengthToDegrees: lengthToDegrees,
        bearingToAzimuth: bearingToAzimuth,
        radiansToDegrees: radiansToDegrees,
        degreesToRadians: degreesToRadians,
        convertLength: convertLength,
        convertArea: convertArea,
        isNumber: isNumber,
        isObject: isObject,
        validateBBox: validateBBox,
        validateId: validateId
    });

    /**
     * Callback for coordEach
     *
     * @callback coordEachCallback
     * @param {Array<number>} currentCoord The current coordinate being processed.
     * @param {number} coordIndex The current index of the coordinate being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     */

    /**
     * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
     *
     * @name coordEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
     * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=currentCoord
     *   //=coordIndex
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     * });
     */
    function coordEach$1(geojson, callback, excludeWrapCoord) {
      // Handles null Geometry -- Skips this GeoJSON
      if (geojson === null) return;
      var j,
        k,
        l,
        geometry,
        stopG,
        coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === "FeatureCollection",
        isFeature = type === "Feature",
        stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = isFeatureCollection
          ? geojson.features[featureIndex].geometry
          : isFeature
          ? geojson.geometry
          : geojson;
        isGeometryCollection = geometryMaybeCollection
          ? geometryMaybeCollection.type === "GeometryCollection"
          : false;
        stopG = isGeometryCollection
          ? geometryMaybeCollection.geometries.length
          : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
          var multiFeatureIndex = 0;
          var geometryIndex = 0;
          geometry = isGeometryCollection
            ? geometryMaybeCollection.geometries[geomIndex]
            : geometryMaybeCollection;

          // Handles null Geometry -- Skips this geometry
          if (geometry === null) continue;
          coords = geometry.coordinates;
          var geomType = geometry.type;

          wrapShrink =
            excludeWrapCoord &&
            (geomType === "Polygon" || geomType === "MultiPolygon")
              ? 1
              : 0;

          switch (geomType) {
            case null:
              break;
            case "Point":
              if (
                callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
              coordIndex++;
              multiFeatureIndex++;
              break;
            case "LineString":
            case "MultiPoint":
              for (j = 0; j < coords.length; j++) {
                if (
                  callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false
                )
                  return false;
                coordIndex++;
                if (geomType === "MultiPoint") multiFeatureIndex++;
              }
              if (geomType === "LineString") multiFeatureIndex++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (j = 0; j < coords.length; j++) {
                for (k = 0; k < coords[j].length - wrapShrink; k++) {
                  if (
                    callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false
                  )
                    return false;
                  coordIndex++;
                }
                if (geomType === "MultiLineString") multiFeatureIndex++;
                if (geomType === "Polygon") geometryIndex++;
              }
              if (geomType === "Polygon") multiFeatureIndex++;
              break;
            case "MultiPolygon":
              for (j = 0; j < coords.length; j++) {
                geometryIndex = 0;
                for (k = 0; k < coords[j].length; k++) {
                  for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                    if (
                      callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false
                    )
                      return false;
                    coordIndex++;
                  }
                  geometryIndex++;
                }
                multiFeatureIndex++;
              }
              break;
            case "GeometryCollection":
              for (j = 0; j < geometry.geometries.length; j++)
                if (
                  coordEach$1(geometry.geometries[j], callback, excludeWrapCoord) ===
                  false
                )
                  return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }

    /**
     * Callback for coordReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback coordReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Array<number>} currentCoord The current coordinate being processed.
     * @param {number} coordIndex The current index of the coordinate being processed.
     * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     */

    /**
     * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
     *
     * @name coordReduce
     * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=previousValue
     *   //=currentCoord
     *   //=coordIndex
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     *   return currentCoord;
     * });
     */
    function coordReduce$1(geojson, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach$1(
        geojson,
        function (
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        ) {
          if (coordIndex === 0 && initialValue === undefined)
            previousValue = currentCoord;
          else
            previousValue = callback(
              previousValue,
              currentCoord,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            );
        },
        excludeWrapCoord
      );
      return previousValue;
    }

    /**
     * Callback for propEach
     *
     * @callback propEachCallback
     * @param {Object} currentProperties The current Properties being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Iterate over properties in any GeoJSON object, similar to Array.forEach()
     *
     * @name propEach
     * @param {FeatureCollection|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentProperties, featureIndex)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.propEach(features, function (currentProperties, featureIndex) {
     *   //=currentProperties
     *   //=featureIndex
     * });
     */
    function propEach$1(geojson, callback) {
      var i;
      switch (geojson.type) {
        case "FeatureCollection":
          for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
          }
          break;
        case "Feature":
          callback(geojson.properties, 0);
          break;
      }
    }

    /**
     * Callback for propReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback propReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {*} currentProperties The current Properties being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Reduce properties in any GeoJSON object into a single value,
     * similar to how Array.reduce works. However, in this case we lazily run
     * the reduction, so an array of all properties is unnecessary.
     *
     * @name propReduce
     * @param {FeatureCollection|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
     *   //=previousValue
     *   //=currentProperties
     *   //=featureIndex
     *   return currentProperties
     * });
     */
    function propReduce$1(geojson, callback, initialValue) {
      var previousValue = initialValue;
      propEach$1(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined)
          previousValue = currentProperties;
        else
          previousValue = callback(previousValue, currentProperties, featureIndex);
      });
      return previousValue;
    }

    /**
     * Callback for featureEach
     *
     * @callback featureEachCallback
     * @param {Feature<any>} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Iterate over features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name featureEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.featureEach(features, function (currentFeature, featureIndex) {
     *   //=currentFeature
     *   //=featureIndex
     * });
     */
    function featureEach$2(geojson, callback) {
      if (geojson.type === "Feature") {
        callback(geojson, 0);
      } else if (geojson.type === "FeatureCollection") {
        for (var i = 0; i < geojson.features.length; i++) {
          if (callback(geojson.features[i], i) === false) break;
        }
      }
    }

    /**
     * Callback for featureReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback featureReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name featureReduce
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=featureIndex
     *   return currentFeature
     * });
     */
    function featureReduce$1(geojson, callback, initialValue) {
      var previousValue = initialValue;
      featureEach$2(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined)
          previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
      });
      return previousValue;
    }

    /**
     * Get all coordinates from any GeoJSON object.
     *
     * @name coordAll
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @returns {Array<Array<number>>} coordinate position array
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * var coords = turf.coordAll(features);
     * //= [[26, 37], [36, 53]]
     */
    function coordAll$1(geojson) {
      var coords = [];
      coordEach$1(geojson, function (coord) {
        coords.push(coord);
      });
      return coords;
    }

    /**
     * Callback for geomEach
     *
     * @callback geomEachCallback
     * @param {Geometry} currentGeometry The current Geometry being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {Object} featureProperties The current Feature Properties being processed.
     * @param {Array<number>} featureBBox The current Feature BBox being processed.
     * @param {number|string} featureId The current Feature Id being processed.
     */

    /**
     * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
     *
     * @name geomEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
     *   //=currentGeometry
     *   //=featureIndex
     *   //=featureProperties
     *   //=featureBBox
     *   //=featureId
     * });
     */
    function geomEach$1(geojson, callback) {
      var i,
        j,
        g,
        geometry,
        stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === "FeatureCollection",
        isFeature = geojson.type === "Feature",
        stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (i = 0; i < stop; i++) {
        geometryMaybeCollection = isFeatureCollection
          ? geojson.features[i].geometry
          : isFeature
          ? geojson.geometry
          : geojson;
        featureProperties = isFeatureCollection
          ? geojson.features[i].properties
          : isFeature
          ? geojson.properties
          : {};
        featureBBox = isFeatureCollection
          ? geojson.features[i].bbox
          : isFeature
          ? geojson.bbox
          : undefined;
        featureId = isFeatureCollection
          ? geojson.features[i].id
          : isFeature
          ? geojson.id
          : undefined;
        isGeometryCollection = geometryMaybeCollection
          ? geometryMaybeCollection.type === "GeometryCollection"
          : false;
        stopG = isGeometryCollection
          ? geometryMaybeCollection.geometries.length
          : 1;

        for (g = 0; g < stopG; g++) {
          geometry = isGeometryCollection
            ? geometryMaybeCollection.geometries[g]
            : geometryMaybeCollection;

          // Handle null Geometry
          if (geometry === null) {
            if (
              callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false
            )
              return false;
            continue;
          }
          switch (geometry.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon": {
              if (
                callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false
              )
                return false;
              break;
            }
            case "GeometryCollection": {
              for (j = 0; j < geometry.geometries.length; j++) {
                if (
                  callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false
                )
                  return false;
              }
              break;
            }
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
      }
    }

    /**
     * Callback for geomReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback geomReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Geometry} currentGeometry The current Geometry being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {Object} featureProperties The current Feature Properties being processed.
     * @param {Array<number>} featureBBox The current Feature BBox being processed.
     * @param {number|string} featureId The current Feature Id being processed.
     */

    /**
     * Reduce geometry in any GeoJSON object, similar to Array.reduce().
     *
     * @name geomReduce
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
     *   //=previousValue
     *   //=currentGeometry
     *   //=featureIndex
     *   //=featureProperties
     *   //=featureBBox
     *   //=featureId
     *   return currentGeometry
     * });
     */
    function geomReduce$1(geojson, callback, initialValue) {
      var previousValue = initialValue;
      geomEach$1(
        geojson,
        function (
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) {
          if (featureIndex === 0 && initialValue === undefined)
            previousValue = currentGeometry;
          else
            previousValue = callback(
              previousValue,
              currentGeometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            );
        }
      );
      return previousValue;
    }

    /**
     * Callback for flattenEach
     *
     * @callback flattenEachCallback
     * @param {Feature} currentFeature The current flattened feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     */

    /**
     * Iterate over flattened features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name flattenEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
     * ]);
     *
     * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
     *   //=currentFeature
     *   //=featureIndex
     *   //=multiFeatureIndex
     * });
     */
    function flattenEach$1(geojson, callback) {
      geomEach$1(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = geometry === null ? null : geometry.type;
        switch (type) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            if (
              callback(
                feature(geometry, properties, { bbox: bbox, id: id }),
                featureIndex,
                0
              ) === false
            )
              return false;
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
          case "MultiPoint":
            geomType = "Point";
            break;
          case "MultiLineString":
            geomType = "LineString";
            break;
          case "MultiPolygon":
            geomType = "Polygon";
            break;
        }

        for (
          var multiFeatureIndex = 0;
          multiFeatureIndex < geometry.coordinates.length;
          multiFeatureIndex++
        ) {
          var coordinate = geometry.coordinates[multiFeatureIndex];
          var geom = {
            type: geomType,
            coordinates: coordinate,
          };
          if (
            callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===
            false
          )
            return false;
        }
      });
    }

    /**
     * Callback for flattenReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback flattenReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     */

    /**
     * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
     *
     * @name flattenReduce
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
     * ]);
     *
     * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   return currentFeature
     * });
     */
    function flattenReduce$1(geojson, callback, initialValue) {
      var previousValue = initialValue;
      flattenEach$1(
        geojson,
        function (currentFeature, featureIndex, multiFeatureIndex) {
          if (
            featureIndex === 0 &&
            multiFeatureIndex === 0 &&
            initialValue === undefined
          )
            previousValue = currentFeature;
          else
            previousValue = callback(
              previousValue,
              currentFeature,
              featureIndex,
              multiFeatureIndex
            );
        }
      );
      return previousValue;
    }

    /**
     * Callback for segmentEach
     *
     * @callback segmentEachCallback
     * @param {Feature<LineString>} currentSegment The current Segment being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     * @param {number} segmentIndex The current index of the Segment being processed.
     * @returns {void}
     */

    /**
     * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
     * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
     * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
     * @returns {void}
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     *
     * // Iterate over GeoJSON by 2-vertex segments
     * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
     *   //=currentSegment
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     *   //=segmentIndex
     * });
     *
     * // Calculate the total number of segments
     * var total = 0;
     * turf.segmentEach(polygon, function () {
     *     total++;
     * });
     */
    function segmentEach$1(geojson, callback) {
      flattenEach$1(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;

        // Generate 2-vertex line segments
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (
          coordEach$1(
            feature,
            function (
              currentCoord,
              coordIndex,
              featureIndexCoord,
              multiPartIndexCoord,
              geometryIndex
            ) {
              // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
              if (
                previousCoords === undefined ||
                featureIndex > previousFeatureIndex ||
                multiPartIndexCoord > previousMultiIndex ||
                geometryIndex > prevGeomIndex
              ) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = lineString(
                [previousCoords, currentCoord],
                feature.properties
              );
              if (
                callback(
                  currentSegment,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex,
                  segmentIndex
                ) === false
              )
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false
        )
          return false;
      });
    }

    /**
     * Callback for segmentReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback segmentReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<LineString>} currentSegment The current Segment being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     * @param {number} segmentIndex The current index of the Segment being processed.
     */

    /**
     * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
     * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
     * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {void}
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     *
     * // Iterate over GeoJSON by 2-vertex segments
     * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
     *   //= previousSegment
     *   //= currentSegment
     *   //= featureIndex
     *   //= multiFeatureIndex
     *   //= geometryIndex
     *   //= segmentIndex
     *   return currentSegment
     * });
     *
     * // Calculate the total number of segments
     * var initialValue = 0
     * var total = turf.segmentReduce(polygon, function (previousValue) {
     *     previousValue++;
     *     return previousValue;
     * }, initialValue);
     */
    function segmentReduce$1(geojson, callback, initialValue) {
      var previousValue = initialValue;
      var started = false;
      segmentEach$1(
        geojson,
        function (
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) {
          if (started === false && initialValue === undefined)
            previousValue = currentSegment;
          else
            previousValue = callback(
              previousValue,
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            );
          started = true;
        }
      );
      return previousValue;
    }

    /**
     * Callback for lineEach
     *
     * @callback lineEachCallback
     * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
     * @param {number} featureIndex The current index of the Feature being processed
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
     * @param {number} geometryIndex The current index of the Geometry being processed
     */

    /**
     * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
     * similar to Array.forEach.
     *
     * @name lineEach
     * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
     * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
     * @example
     * var multiLine = turf.multiLineString([
     *   [[26, 37], [35, 45]],
     *   [[36, 53], [38, 50], [41, 55]]
     * ]);
     *
     * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=currentLine
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     * });
     */
    function lineEach$1(geojson, callback) {
      // validation
      if (!geojson) throw new Error("geojson is required");

      flattenEach$1(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
          case "LineString":
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)
              return false;
            break;
          case "Polygon":
            for (
              var geometryIndex = 0;
              geometryIndex < coords.length;
              geometryIndex++
            ) {
              if (
                callback(
                  lineString(coords[geometryIndex], feature.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
            }
            break;
        }
      });
    }

    /**
     * Callback for lineReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback lineReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
     * @param {number} featureIndex The current index of the Feature being processed
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
     * @param {number} geometryIndex The current index of the Geometry being processed
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name lineReduce
     * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
     * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var multiPoly = turf.multiPolygon([
     *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
     *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
     * ]);
     *
     * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=previousValue
     *   //=currentLine
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     *   return currentLine
     * });
     */
    function lineReduce$1(geojson, callback, initialValue) {
      var previousValue = initialValue;
      lineEach$1(
        geojson,
        function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
          if (featureIndex === 0 && initialValue === undefined)
            previousValue = currentLine;
          else
            previousValue = callback(
              previousValue,
              currentLine,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            );
        }
      );
      return previousValue;
    }

    /**
     * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
     *
     * Negative indexes are permitted.
     * Point & MultiPoint will always return null.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.featureIndex=0] Feature Index
     * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
     * @param {number} [options.geometryIndex=0] Geometry Index
     * @param {number} [options.segmentIndex=0] Segment Index
     * @param {Object} [options.properties={}] Translate Properties to output LineString
     * @param {BBox} [options.bbox={}] Translate BBox to output LineString
     * @param {number|string} [options.id={}] Translate Id to output LineString
     * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
     * @example
     * var multiLine = turf.multiLineString([
     *     [[10, 10], [50, 30], [30, 40]],
     *     [[-10, -10], [-50, -30], [-30, -40]]
     * ]);
     *
     * // First Segment (defaults are 0)
     * turf.findSegment(multiLine);
     * // => Feature<LineString<[[10, 10], [50, 30]]>>
     *
     * // First Segment of 2nd Multi Feature
     * turf.findSegment(multiLine, {multiFeatureIndex: 1});
     * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
     *
     * // Last Segment of Last Multi Feature
     * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
     * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
     */
    function findSegment$1(geojson, options) {
      // Optional Parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var segmentIndex = options.segmentIndex || 0;

      // Find FeatureIndex
      var properties = options.properties;
      var geometry;

      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }

      // Find SegmentIndex
      if (geometry === null) return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
          if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
          return lineString(
            [coords[segmentIndex], coords[segmentIndex + 1]],
            properties,
            options
          );
        case "Polygon":
          if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
          return lineString(
            [
              coords[geometryIndex][segmentIndex],
              coords[geometryIndex][segmentIndex + 1],
            ],
            properties,
            options
          );
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
          return lineString(
            [
              coords[multiFeatureIndex][segmentIndex],
              coords[multiFeatureIndex][segmentIndex + 1],
            ],
            properties,
            options
          );
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex =
              coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
          return lineString(
            [
              coords[multiFeatureIndex][geometryIndex][segmentIndex],
              coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],
            ],
            properties,
            options
          );
      }
      throw new Error("geojson is invalid");
    }

    /**
     * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
     *
     * Negative indexes are permitted.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.featureIndex=0] Feature Index
     * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
     * @param {number} [options.geometryIndex=0] Geometry Index
     * @param {number} [options.coordIndex=0] Coord Index
     * @param {Object} [options.properties={}] Translate Properties to output Point
     * @param {BBox} [options.bbox={}] Translate BBox to output Point
     * @param {number|string} [options.id={}] Translate Id to output Point
     * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
     * @example
     * var multiLine = turf.multiLineString([
     *     [[10, 10], [50, 30], [30, 40]],
     *     [[-10, -10], [-50, -30], [-30, -40]]
     * ]);
     *
     * // First Segment (defaults are 0)
     * turf.findPoint(multiLine);
     * // => Feature<Point<[10, 10]>>
     *
     * // First Segment of the 2nd Multi-Feature
     * turf.findPoint(multiLine, {multiFeatureIndex: 1});
     * // => Feature<Point<[-10, -10]>>
     *
     * // Last Segment of last Multi-Feature
     * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
     * // => Feature<Point<[-30, -40]>>
     */
    function findPoint$1(geojson, options) {
      // Optional Parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var coordIndex = options.coordIndex || 0;

      // Find FeatureIndex
      var properties = options.properties;
      var geometry;

      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }

      // Find Coord Index
      if (geometry === null) return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
          return point(coords, properties, options);
        case "MultiPoint":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          return point(coords[multiFeatureIndex], properties, options);
        case "LineString":
          if (coordIndex < 0) coordIndex = coords.length + coordIndex;
          return point(coords[coordIndex], properties, options);
        case "Polygon":
          if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
          if (coordIndex < 0)
            coordIndex = coords[geometryIndex].length + coordIndex;
          return point(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (coordIndex < 0)
            coordIndex = coords[multiFeatureIndex].length + coordIndex;
          return point(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (coordIndex < 0)
            coordIndex =
              coords[multiFeatureIndex][geometryIndex].length - coordIndex;
          return point(
            coords[multiFeatureIndex][geometryIndex][coordIndex],
            properties,
            options
          );
      }
      throw new Error("geojson is invalid");
    }

    var index$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        coordAll: coordAll$1,
        coordEach: coordEach$1,
        coordReduce: coordReduce$1,
        featureEach: featureEach$2,
        featureReduce: featureReduce$1,
        findPoint: findPoint$1,
        findSegment: findSegment$1,
        flattenEach: flattenEach$1,
        flattenReduce: flattenReduce$1,
        geomEach: geomEach$1,
        geomReduce: geomReduce$1,
        lineEach: lineEach$1,
        lineReduce: lineReduce$1,
        propEach: propEach$1,
        propReduce: propReduce$1,
        segmentEach: segmentEach$1,
        segmentReduce: segmentReduce$1
    });

    /**
     * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
     *
     * @name bbox
     * @param {GeoJSON} geojson any GeoJSON object
     * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
     * var bbox = turf.bbox(line);
     * var bboxPolygon = turf.bboxPolygon(bbox);
     *
     * //addToMap
     * var addToMap = [line, bboxPolygon]
     */
    function bbox$2(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        coordEach$1(geojson, function (coord) {
            if (result[0] > coord[0]) {
                result[0] = coord[0];
            }
            if (result[1] > coord[1]) {
                result[1] = coord[1];
            }
            if (result[2] < coord[0]) {
                result[2] = coord[0];
            }
            if (result[3] < coord[1]) {
                result[3] = coord[1];
            }
        });
        return result;
    }
    bbox$2["default"] = bbox$2;

    /**
     * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
     *
     * @name getCoord
     * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
     * @returns {Array<number>} coordinates
     * @example
     * var pt = turf.point([10, 10]);
     *
     * var coord = turf.getCoord(pt);
     * //= [10, 10]
     */
    function getCoord(coord) {
        if (!coord) {
            throw new Error("coord is required");
        }
        if (!Array.isArray(coord)) {
            if (coord.type === "Feature" &&
                coord.geometry !== null &&
                coord.geometry.type === "Point") {
                return coord.geometry.coordinates;
            }
            if (coord.type === "Point") {
                return coord.coordinates;
            }
        }
        if (Array.isArray(coord) &&
            coord.length >= 2 &&
            !Array.isArray(coord[0]) &&
            !Array.isArray(coord[1])) {
            return coord;
        }
        throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    /**
     * Unwrap coordinates from a Feature, Geometry Object or an Array
     *
     * @name getCoords
     * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
     * @returns {Array<any>} coordinates
     * @example
     * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
     *
     * var coords = turf.getCoords(poly);
     * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
     */
    function getCoords(coords) {
        if (Array.isArray(coords)) {
            return coords;
        }
        // Feature
        if (coords.type === "Feature") {
            if (coords.geometry !== null) {
                return coords.geometry.coordinates;
            }
        }
        else {
            // Geometry
            if (coords.coordinates) {
                return coords.coordinates;
            }
        }
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }
    /**
     * Checks if coordinates contains a number
     *
     * @name containsNumber
     * @param {Array<any>} coordinates GeoJSON Coordinates
     * @returns {boolean} true if Array contains a number
     */
    function containsNumber(coordinates) {
        if (coordinates.length > 1 &&
            isNumber(coordinates[0]) &&
            isNumber(coordinates[1])) {
            return true;
        }
        if (Array.isArray(coordinates[0]) && coordinates[0].length) {
            return containsNumber(coordinates[0]);
        }
        throw new Error("coordinates must only contain numbers");
    }
    /**
     * Enforce expectations about types of GeoJSON objects for Turf.
     *
     * @name geojsonType
     * @param {GeoJSON} value any GeoJSON object
     * @param {string} type expected GeoJSON type
     * @param {string} name name of calling function
     * @throws {Error} if value is not the expected type.
     */
    function geojsonType(value, type, name) {
        if (!type || !name) {
            throw new Error("type and name required");
        }
        if (!value || value.type !== type) {
            throw new Error("Invalid input to " +
                name +
                ": must be a " +
                type +
                ", given " +
                value.type);
        }
    }
    /**
     * Enforce expectations about types of {@link Feature} inputs for Turf.
     * Internally this uses {@link geojsonType} to judge geometry types.
     *
     * @name featureOf
     * @param {Feature} feature a feature with an expected geometry type
     * @param {string} type expected GeoJSON type
     * @param {string} name name of calling function
     * @throws {Error} error if value is not the expected type.
     */
    function featureOf(feature, type, name) {
        if (!feature) {
            throw new Error("No feature passed");
        }
        if (!name) {
            throw new Error(".featureOf() requires a name");
        }
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " +
                name +
                ": must be a " +
                type +
                ", given " +
                feature.geometry.type);
        }
    }
    /**
     * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
     * Internally this uses {@link geojsonType} to judge geometry types.
     *
     * @name collectionOf
     * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
     * @param {string} type expected GeoJSON type
     * @param {string} name name of calling function
     * @throws {Error} if value is not the expected type.
     */
    function collectionOf(featureCollection, type, name) {
        if (!featureCollection) {
            throw new Error("No featureCollection passed");
        }
        if (!name) {
            throw new Error(".collectionOf() requires a name");
        }
        if (!featureCollection || featureCollection.type !== "FeatureCollection") {
            throw new Error("Invalid input to " + name + ", FeatureCollection required");
        }
        for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
            var feature = _a[_i];
            if (!feature || feature.type !== "Feature" || !feature.geometry) {
                throw new Error("Invalid input to " + name + ", Feature with geometry required");
            }
            if (!feature.geometry || feature.geometry.type !== type) {
                throw new Error("Invalid input to " +
                    name +
                    ": must be a " +
                    type +
                    ", given " +
                    feature.geometry.type);
            }
        }
    }
    /**
     * Get Geometry from Feature or Geometry Object
     *
     * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
     * @returns {Geometry|null} GeoJSON Geometry Object
     * @throws {Error} if geojson is not a Feature or Geometry Object
     * @example
     * var point = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Point",
     *     "coordinates": [110, 40]
     *   }
     * }
     * var geom = turf.getGeom(point)
     * //={"type": "Point", "coordinates": [110, 40]}
     */
    function getGeom(geojson) {
        if (geojson.type === "Feature") {
            return geojson.geometry;
        }
        return geojson;
    }
    /**
     * Get GeoJSON object's type, Geometry type is prioritize.
     *
     * @param {GeoJSON} geojson GeoJSON object
     * @param {string} [name="geojson"] name of the variable to display in error message (unused)
     * @returns {string} GeoJSON type
     * @example
     * var point = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Point",
     *     "coordinates": [110, 40]
     *   }
     * }
     * var geom = turf.getType(point)
     * //="Point"
     */
    function getType$1(geojson, _name) {
        if (geojson.type === "FeatureCollection") {
            return "FeatureCollection";
        }
        if (geojson.type === "GeometryCollection") {
            return "GeometryCollection";
        }
        if (geojson.type === "Feature" && geojson.geometry !== null) {
            return geojson.geometry.type;
        }
        return geojson.type;
    }

    var index$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCoord: getCoord,
        getCoords: getCoords,
        containsNumber: containsNumber,
        geojsonType: geojsonType,
        featureOf: featureOf,
        collectionOf: collectionOf,
        getGeom: getGeom,
        getType: getType$1
    });

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$1.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    /**
     * @license GNU Affero General Public License.
     * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
     * v. 1.2.0
     * https://github.com/RaumZeit/MarchingSquares.js
     *
     * MarchingSquaresJS is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Affero General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * MarchingSquaresJS is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU Affero General Public License for more details.
     *
     * As additional permission under GNU Affero General Public License version 3
     * section 7, third-party projects (personal or commercial) may distribute,
     * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
     * requirement that said third-party project for that reason alone becomes
     * subject to any requirement of the GNU Affero General Public License version 3.
     * Any modifications to MarchingSquaresJS, however, must be shared with the public
     * and made available.
     *
     * In summary this:
     * - allows you to use MarchingSquaresJS at no cost
     * - allows you to use MarchingSquaresJS for both personal and commercial purposes
     * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
     *   license as long as this license notice is included
     * - enables you to keep the source code of your program that uses MarchingSquaresJS
     *   undisclosed
     * - forces you to share any modifications you have made to MarchingSquaresJS,
     *   e.g. bug-fixes
     *
     * You should have received a copy of the GNU Affero General Public License
     * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
     */

    /**
     * Compute the isocontour(s) of a scalar 2D field given
     * a certain threshold by applying the Marching Squares
     * Algorithm. The function returns a list of path coordinates
     */
    var defaultSettings$1 = {
      successCallback: null,
      verbose: false,
    };

    var settings$1 = {};

    function isoContours(data, threshold, options) {
      /* process options */
      options = options ? options : {};

      var optionKeys = Object.keys(defaultSettings$1);

      for (var i = 0; i < optionKeys.length; i++) {
        var key = optionKeys[i];
        var val = options[key];
        val =
          typeof val !== "undefined" && val !== null ? val : defaultSettings$1[key];

        settings$1[key] = val;
      }

      if (settings$1.verbose)
        console.log(
          "MarchingSquaresJS-isoContours: computing isocontour for " + threshold
        );

      var ret = contourGrid2Paths(computeContourGrid(data, threshold));

      if (typeof settings$1.successCallback === "function")
        settings$1.successCallback(ret);

      return ret;
    }

    /*
      Thats all for the public interface, below follows the actual
      implementation
    */

    /*
    ################################
    Isocontour implementation below
    ################################
    */

    /* assume that x1 == 1 &&  x0 == 0 */
    function interpolateX$1(y, y0, y1) {
      return (y - y0) / (y1 - y0);
    }

    /* compute the isocontour 4-bit grid */
    function computeContourGrid(data, threshold) {
      var rows = data.length - 1;
      var cols = data[0].length - 1;
      var ContourGrid = { rows: rows, cols: cols, cells: [] };

      for (var j = 0; j < rows; ++j) {
        ContourGrid.cells[j] = [];
        for (var i = 0; i < cols; ++i) {
          /* compose the 4-bit corner representation */
          var cval = 0;

          var tl = data[j + 1][i];
          var tr = data[j + 1][i + 1];
          var br = data[j][i + 1];
          var bl = data[j][i];

          if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
            continue;
          }
          cval |= tl >= threshold ? 8 : 0;
          cval |= tr >= threshold ? 4 : 0;
          cval |= br >= threshold ? 2 : 0;
          cval |= bl >= threshold ? 1 : 0;

          /* resolve ambiguity for cval == 5 || 10 via averaging */
          var flipped = false;
          if (cval === 5 || cval === 10) {
            var average = (tl + tr + br + bl) / 4;
            if (cval === 5 && average < threshold) {
              cval = 10;
              flipped = true;
            } else if (cval === 10 && average < threshold) {
              cval = 5;
              flipped = true;
            }
          }

          /* add cell to ContourGrid if it contains edges */
          if (cval !== 0 && cval !== 15) {
            var top, bottom, left, right;
            top = bottom = left = right = 0.5;
            /* interpolate edges of cell */
            if (cval === 1) {
              left = 1 - interpolateX$1(threshold, tl, bl);
              bottom = 1 - interpolateX$1(threshold, br, bl);
            } else if (cval === 2) {
              bottom = interpolateX$1(threshold, bl, br);
              right = 1 - interpolateX$1(threshold, tr, br);
            } else if (cval === 3) {
              left = 1 - interpolateX$1(threshold, tl, bl);
              right = 1 - interpolateX$1(threshold, tr, br);
            } else if (cval === 4) {
              top = interpolateX$1(threshold, tl, tr);
              right = interpolateX$1(threshold, br, tr);
            } else if (cval === 5) {
              top = interpolateX$1(threshold, tl, tr);
              right = interpolateX$1(threshold, br, tr);
              bottom = 1 - interpolateX$1(threshold, br, bl);
              left = 1 - interpolateX$1(threshold, tl, bl);
            } else if (cval === 6) {
              bottom = interpolateX$1(threshold, bl, br);
              top = interpolateX$1(threshold, tl, tr);
            } else if (cval === 7) {
              left = 1 - interpolateX$1(threshold, tl, bl);
              top = interpolateX$1(threshold, tl, tr);
            } else if (cval === 8) {
              left = interpolateX$1(threshold, bl, tl);
              top = 1 - interpolateX$1(threshold, tr, tl);
            } else if (cval === 9) {
              bottom = 1 - interpolateX$1(threshold, br, bl);
              top = 1 - interpolateX$1(threshold, tr, tl);
            } else if (cval === 10) {
              top = 1 - interpolateX$1(threshold, tr, tl);
              right = 1 - interpolateX$1(threshold, tr, br);
              bottom = interpolateX$1(threshold, bl, br);
              left = interpolateX$1(threshold, bl, tl);
            } else if (cval === 11) {
              top = 1 - interpolateX$1(threshold, tr, tl);
              right = 1 - interpolateX$1(threshold, tr, br);
            } else if (cval === 12) {
              left = interpolateX$1(threshold, bl, tl);
              right = interpolateX$1(threshold, br, tr);
            } else if (cval === 13) {
              bottom = 1 - interpolateX$1(threshold, br, bl);
              right = interpolateX$1(threshold, br, tr);
            } else if (cval === 14) {
              left = interpolateX$1(threshold, bl, tl);
              bottom = interpolateX$1(threshold, bl, br);
            } else {
              console.log(
                "MarchingSquaresJS-isoContours: Illegal cval detected: " + cval
              );
            }
            ContourGrid.cells[j][i] = {
              cval: cval,
              flipped: flipped,
              top: top,
              right: right,
              bottom: bottom,
              left: left,
            };
          }
        }
      }

      return ContourGrid;
    }

    function isSaddle(cell) {
      return cell.cval === 5 || cell.cval === 10;
    }

    function isTrivial(cell) {
      return cell.cval === 0 || cell.cval === 15;
    }

    function clearCell(cell) {
      if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {
        cell.cval = 15;
      }
    }

    function getXY(cell, edge) {
      if (edge === "top") {
        return [cell.top, 1.0];
      } else if (edge === "bottom") {
        return [cell.bottom, 0.0];
      } else if (edge === "right") {
        return [1.0, cell.right];
      } else if (edge === "left") {
        return [0.0, cell.left];
      }
    }

    function contourGrid2Paths(grid) {
      var paths = [];
      var path_idx = 0;
      var epsilon = 1e-7;

      grid.cells.forEach(function (g, j) {
        g.forEach(function (gg, i) {
          if (typeof gg !== "undefined" && !isSaddle(gg) && !isTrivial(gg)) {
            var p = tracePath(grid.cells, j, i);
            var merged = false;
            /* we may try to merge paths at this point */
            if (p.info === "mergeable") {
              /*
                search backwards through the path array to find an entry
                that starts with where the current path ends...
              */
              var x = p.path[p.path.length - 1][0],
                y = p.path[p.path.length - 1][1];

              for (var k = path_idx - 1; k >= 0; k--) {
                if (
                  Math.abs(paths[k][0][0] - x) <= epsilon &&
                  Math.abs(paths[k][0][1] - y) <= epsilon
                ) {
                  for (var l = p.path.length - 2; l >= 0; --l) {
                    paths[k].unshift(p.path[l]);
                  }
                  merged = true;
                  break;
                }
              }
            }
            if (!merged) paths[path_idx++] = p.path;
          }
        });
      });

      return paths;
    }

    /*
      construct consecutive line segments from starting cell by
      walking arround the enclosed area clock-wise
      */
    function tracePath(grid, j, i) {
      var maxj = grid.length;
      var p = [];
      var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];
      var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];
      var dx, dy;
      var startEdge = [
        "none",
        "left",
        "bottom",
        "left",
        "right",
        "none",
        "bottom",
        "left",
        "top",
        "top",
        "none",
        "top",
        "right",
        "right",
        "bottom",
        "none",
      ];
      var nextEdge = [
        "none",
        "bottom",
        "right",
        "right",
        "top",
        "top",
        "top",
        "top",
        "left",
        "bottom",
        "right",
        "right",
        "left",
        "bottom",
        "left",
        "none",
      ];
      var edge;

      var currentCell = grid[j][i];

      var cval = currentCell.cval;
      var edge = startEdge[cval];

      var pt = getXY(currentCell, edge);

      /* push initial segment */
      p.push([i + pt[0], j + pt[1]]);
      edge = nextEdge[cval];
      pt = getXY(currentCell, edge);
      p.push([i + pt[0], j + pt[1]]);
      clearCell(currentCell);

      /* now walk arround the enclosed area in clockwise-direction */
      var k = i + dxContour[cval];
      var l = j + dyContour[cval];
      var prev_cval = cval;

      while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {
        currentCell = grid[l][k];
        if (typeof currentCell === "undefined") {
          /* path ends here */
          //console.log(k + " " + l + " is undefined, stopping path!");
          break;
        }
        cval = currentCell.cval;
        if (cval === 0 || cval === 15) {
          return { path: p, info: "mergeable" };
        }
        edge = nextEdge[cval];
        dx = dxContour[cval];
        dy = dyContour[cval];
        if (cval === 5 || cval === 10) {
          /* select upper or lower band, depending on previous cells cval */
          if (cval === 5) {
            if (currentCell.flipped) {
              /* this is actually a flipped case 10 */
              if (dyContour[prev_cval] === -1) {
                edge = "left";
                dx = -1;
                dy = 0;
              } else {
                edge = "right";
                dx = 1;
                dy = 0;
              }
            } else {
              /* real case 5 */
              if (dxContour[prev_cval] === -1) {
                edge = "bottom";
                dx = 0;
                dy = -1;
              }
            }
          } else if (cval === 10) {
            if (currentCell.flipped) {
              /* this is actually a flipped case 5 */
              if (dxContour[prev_cval] === -1) {
                edge = "top";
                dx = 0;
                dy = 1;
              } else {
                edge = "bottom";
                dx = 0;
                dy = -1;
              }
            } else {
              /* real case 10 */
              if (dyContour[prev_cval] === 1) {
                edge = "left";
                dx = -1;
                dy = 0;
              }
            }
          }
        }
        pt = getXY(currentCell, edge);
        p.push([k + pt[0], l + pt[1]]);
        clearCell(currentCell);
        k += dx;
        l += dy;
        prev_cval = cval;
      }

      return { path: p, info: "closed" };
    }

    /**
     * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}
     * of the 'property' values
     *
     * @name gridToMatrix
     * @param {FeatureCollection<Point>} grid of points
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
     * @param {boolean} [options.flip=false] returns the matrix upside-down
     * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,
     * the grid points with coordinates on the matrix
     * @returns {Array<Array<number>>} matrix of property values
     * @example
     *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
     *   var cellSize = 3;
     *   var grid = turf.pointGrid(extent, cellSize);
     *   // add a random property to each point between 0 and 60
     *   for (var i = 0; i < grid.features.length; i++) {
     *     grid.features[i].properties.elevation = (Math.random() * 60);
     *   }
     *   gridToMatrix(grid);
     *   //= [
     *     [ 1, 13, 10,  9, 10, 13, 18],
     *     [34,  8,  5,  4,  5,  8, 13],
     *     [10,  5,  2,  1,  2,  5,  4],
     *     [ 0,  4, 56, 19,  1,  4,  9],
     *     [10,  5,  2,  1,  2,  5, 10],
     *     [57,  8,  5,  4,  5,  0, 57],
     *     [ 3, 13, 10,  9,  5, 13, 18],
     *     [18, 13, 10,  9, 78, 13, 18]
     *   ]
     */
    function gridToMatrix$1(grid, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var flip = options.flip;
      var flags = options.flags;

      // validation
      collectionOf(grid, "Point", "input must contain Points");

      var pointsMatrix = sortPointsByLatLng$1(grid, flip);

      var matrix = [];
      // create property matrix from sorted points
      // looping order matters here
      for (var r = 0; r < pointsMatrix.length; r++) {
        var pointRow = pointsMatrix[r];
        var row = [];
        for (var c = 0; c < pointRow.length; c++) {
          var point = pointRow[c];
          // Check if zProperty exist
          if (point.properties[zProperty]) row.push(point.properties[zProperty]);
          else row.push(0);
          // add flags
          if (flags === true) point.properties.matrixPosition = [r, c];
        }
        matrix.push(row);
      }

      return matrix;
    }

    /**
     * Sorts points by latitude and longitude, creating a 2-dimensional array of points
     *
     * @private
     * @param {FeatureCollection<Point>} points GeoJSON Point features
     * @param {boolean} [flip=false] returns the matrix upside-down
     * @returns {Array<Array<Point>>} points ordered by latitude and longitude
     */
    function sortPointsByLatLng$1(points, flip) {
      var pointsByLatitude = {};

      // divide points by rows with the same latitude
      featureEach$2(points, function (point) {
        var lat = getCoords(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
      });

      // sort points (with the same latitude) by longitude
      var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function (a, b) {
          return getCoords(a)[0] - getCoords(b)[0];
        });
        return rowOrderedByLongitude;
      });

      // sort rows (of points with the same latitude) by latitude
      var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {
        if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];
        else return getCoords(b[0])[1] - getCoords(a[0])[1];
      });

      return pointMatrix;
    }

    /**
     * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of
     * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).
     *
     * @name isolines
     * @param {FeatureCollection<Point>} pointGrid input points
     * @param {Array<number>} breaks values of `zProperty` where to draw isolines
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
     * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines
     * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;
     * the breaks array will define the order in which the isolines are created
     * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines
     * @example
     * // create a grid of points with random z-values in their properties
     * var extent = [0, 30, 20, 50];
     * var cellWidth = 100;
     * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});
     *
     * for (var i = 0; i < pointGrid.features.length; i++) {
     *     pointGrid.features[i].properties.temperature = Math.random() * 10;
     * }
     * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     *
     * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});
     *
     * //addToMap
     * var addToMap = [lines];
     */
    function isolines(pointGrid, breaks, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var commonProperties = options.commonProperties || {};
      var breaksProperties = options.breaksProperties || [];

      // Input validation
      collectionOf(pointGrid, "Point", "Input must contain Points");
      if (!breaks) throw new Error("breaks is required");
      if (!Array.isArray(breaks)) throw new Error("breaks must be an Array");
      if (!isObject(commonProperties))
        throw new Error("commonProperties must be an Object");
      if (!Array.isArray(breaksProperties))
        throw new Error("breaksProperties must be an Array");

      // Isoline methods
      var matrix = gridToMatrix$1(pointGrid, { zProperty: zProperty, flip: true });
      var createdIsoLines = createIsoLines(
        matrix,
        breaks,
        zProperty,
        commonProperties,
        breaksProperties
      );
      var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);

      return featureCollection$1(scaledIsolines);
    }

    /**
     * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid
     *
     * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it
     * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be
     * rescaled, with turfjs, to the original area and proportions on the map
     *
     * @private
     * @param {Array<Array<number>>} matrix Grid Data
     * @param {Array<number>} breaks Breaks
     * @param {string} zProperty name of the z-values property
     * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines
     * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline
     * @returns {Array<MultiLineString>} isolines
     */
    function createIsoLines(
      matrix,
      breaks,
      zProperty,
      commonProperties,
      breaksProperties
    ) {
      var results = [];
      for (var i = 1; i < breaks.length; i++) {
        var threshold = +breaks[i]; // make sure it's a number

        var properties = objectAssign({}, commonProperties, breaksProperties[i]);
        properties[zProperty] = threshold;
        var isoline = multiLineString(isoContours(matrix, threshold), properties);

        results.push(isoline);
      }
      return results;
    }

    /**
     * Translates and scales isolines
     *
     * @private
     * @param {Array<MultiLineString>} createdIsoLines to be rescaled
     * @param {Array<Array<number>>} matrix Grid Data
     * @param {Object} points Points by Latitude
     * @returns {Array<MultiLineString>} isolines
     */
    function rescaleIsolines(createdIsoLines, matrix, points) {
      // get dimensions (on the map) of the original grid
      var gridBbox = bbox$2(points); // [ minX, minY, maxX, maxY ]
      var originalWidth = gridBbox[2] - gridBbox[0];
      var originalHeigth = gridBbox[3] - gridBbox[1];

      // get origin, which is the first point of the last row on the rectangular data on the map
      var x0 = gridBbox[0];
      var y0 = gridBbox[1];

      // get number of cells per side
      var matrixWidth = matrix[0].length - 1;
      var matrixHeight = matrix.length - 1;

      // calculate the scaling factor between matrix and rectangular grid on the map
      var scaleX = originalWidth / matrixWidth;
      var scaleY = originalHeigth / matrixHeight;

      var resize = function (point) {
        point[0] = point[0] * scaleX + x0;
        point[1] = point[1] * scaleY + y0;
      };

      // resize and shift each point/line of the createdIsoLines
      createdIsoLines.forEach(function (isoline) {
        coordEach$1(isoline, resize);
      });
      return createdIsoLines;
    }

    var rbush_min$1 = createCommonjsModule(function (module, exports) {
    !function(t,i){module.exports=i();}(commonjsGlobal,function(){function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h);}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--;}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1);}}(t,r,e||0,a||t.length-1,h||n);}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r;}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear();};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return -1}function a(t,i){h(t,0,t.children.length,i,t);}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h);}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return (t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return {children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r);}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h));}i=e.pop();}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return !1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return !0;n.push(e);}}i=n.pop();}return !1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else {if(this.data.height<n.height){var r=this.data;this.data=n,n=r;}this._insert(n,this.data.height-n.height-1,!0);}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0]);}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1));}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s);}i=h||i.children[0];}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i);},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o);},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox);},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p);}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r);},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a);}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s);}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t);},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox);},r});
    });

    class TinyQueue {
        constructor(data = [], compare = defaultCompare) {
            this.data = data;
            this.length = this.data.length;
            this.compare = compare;

            if (this.length > 0) {
                for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
            }
        }

        push(item) {
            this.data.push(item);
            this.length++;
            this._up(this.length - 1);
        }

        pop() {
            if (this.length === 0) return undefined;

            const top = this.data[0];
            const bottom = this.data.pop();
            this.length--;

            if (this.length > 0) {
                this.data[0] = bottom;
                this._down(0);
            }

            return top;
        }

        peek() {
            return this.data[0];
        }

        _up(pos) {
            const {data, compare} = this;
            const item = data[pos];

            while (pos > 0) {
                const parent = (pos - 1) >> 1;
                const current = data[parent];
                if (compare(item, current) >= 0) break;
                data[pos] = current;
                pos = parent;
            }

            data[pos] = item;
        }

        _down(pos) {
            const {data, compare} = this;
            const halfLength = this.length >> 1;
            const item = data[pos];

            while (pos < halfLength) {
                let left = (pos << 1) + 1;
                let best = data[left];
                const right = left + 1;

                if (right < this.length && compare(data[right], best) < 0) {
                    left = right;
                    best = data[right];
                }
                if (compare(best, item) >= 0) break;

                data[pos] = best;
                pos = left;
            }

            data[pos] = item;
        }
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

    var tinyqueue = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': TinyQueue
    });

    var flat$1 = function pointInPolygonFlat (point, vs, start, end) {
        var x = point[0], y = point[1];
        var inside = false;
        if (start === undefined) start = 0;
        if (end === undefined) end = vs.length;
        var len = (end-start)/2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
            var xi = vs[start+i*2+0], yi = vs[start+i*2+1];
            var xj = vs[start+j*2+0], yj = vs[start+j*2+1];
            var intersect = ((yi > y) !== (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    };

    // ray-casting algorithm based on
    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html

    var nested$1 = function pointInPolygonNested (point, vs, start, end) {
        var x = point[0], y = point[1];
        var inside = false;
        if (start === undefined) start = 0;
        if (end === undefined) end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
            var xi = vs[i+start][0], yi = vs[i+start][1];
            var xj = vs[j+start][0], yj = vs[j+start][1];
            var intersect = ((yi > y) !== (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    };

    var pointInPolygon = function pointInPolygon (point, vs, start, end) {
        if (vs.length > 0 && Array.isArray(vs[0])) {
            return nested$1(point, vs, start, end);
        } else {
            return flat$1(point, vs, start, end);
        }
    };
    var nested = nested$1;
    var flat = flat$1;
    pointInPolygon.nested = nested;
    pointInPolygon.flat = flat;

    var orient2d_min = createCommonjsModule(function (module, exports) {
    !function(t,e){e(exports);}(commonjsGlobal,function(t){const e=134217729,n=33306690738754706e-32;function r(t,e,n,r,o){let f,i,u,c,s=e[0],a=r[0],d=0,l=0;a>s==a>-s?(f=s,s=e[++d]):(f=a,a=r[++l]);let p=0;if(d<t&&l<n)for(a>s==a>-s?(u=f-((i=s+f)-s),s=e[++d]):(u=f-((i=a+f)-a),a=r[++l]),f=i,0!==u&&(o[p++]=u);d<t&&l<n;)a>s==a>-s?(u=f-((i=f+s)-(c=i-f))+(s-c),s=e[++d]):(u=f-((i=f+a)-(c=i-f))+(a-c),a=r[++l]),f=i,0!==u&&(o[p++]=u);for(;d<t;)u=f-((i=f+s)-(c=i-f))+(s-c),s=e[++d],f=i,0!==u&&(o[p++]=u);for(;l<n;)u=f-((i=f+a)-(c=i-f))+(a-c),a=r[++l],f=i,0!==u&&(o[p++]=u);return 0===f&&0!==p||(o[p++]=f),p}function o(t){return new Float64Array(t)}const f=33306690738754716e-32,i=22204460492503146e-32,u=11093356479670487e-47,c=o(4),s=o(8),a=o(12),d=o(16),l=o(4);t.orient2d=function(t,o,p,b,y,h){const M=(o-h)*(p-y),x=(t-y)*(b-h),j=M-x;if(0===M||0===x||M>0!=x>0)return j;const m=Math.abs(M+x);return Math.abs(j)>=f*m?j:-function(t,o,f,p,b,y,h){let M,x,j,m,_,v,w,A,F,O,P,g,k,q,z,B,C,D;const E=t-b,G=f-b,H=o-y,I=p-y;_=(z=(A=E-(w=(v=e*E)-(v-E)))*(O=I-(F=(v=e*I)-(v-I)))-((q=E*I)-w*F-A*F-w*O))-(P=z-(C=(A=H-(w=(v=e*H)-(v-H)))*(O=G-(F=(v=e*G)-(v-G)))-((B=H*G)-w*F-A*F-w*O))),c[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),c[1]=k-(P+_)+(_-B),_=(D=g+P)-g,c[2]=g-(D-_)+(P-_),c[3]=D;let J=function(t,e){let n=e[0];for(let r=1;r<t;r++)n+=e[r];return n}(4,c),K=i*h;if(J>=K||-J>=K)return J;if(M=t-(E+(_=t-E))+(_-b),j=f-(G+(_=f-G))+(_-b),x=o-(H+(_=o-H))+(_-y),m=p-(I+(_=p-I))+(_-y),0===M&&0===x&&0===j&&0===m)return J;if(K=u*h+n*Math.abs(J),(J+=E*m+I*M-(H*j+G*x))>=K||-J>=K)return J;_=(z=(A=M-(w=(v=e*M)-(v-M)))*(O=I-(F=(v=e*I)-(v-I)))-((q=M*I)-w*F-A*F-w*O))-(P=z-(C=(A=x-(w=(v=e*x)-(v-x)))*(O=G-(F=(v=e*G)-(v-G)))-((B=x*G)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const L=r(4,c,4,l,s);_=(z=(A=E-(w=(v=e*E)-(v-E)))*(O=m-(F=(v=e*m)-(v-m)))-((q=E*m)-w*F-A*F-w*O))-(P=z-(C=(A=H-(w=(v=e*H)-(v-H)))*(O=j-(F=(v=e*j)-(v-j)))-((B=H*j)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const N=r(L,s,4,l,a);_=(z=(A=M-(w=(v=e*M)-(v-M)))*(O=m-(F=(v=e*m)-(v-m)))-((q=M*m)-w*F-A*F-w*O))-(P=z-(C=(A=x-(w=(v=e*x)-(v-x)))*(O=j-(F=(v=e*j)-(v-j)))-((B=x*j)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const Q=r(N,a,4,l,d);return d[Q-1]}(t,o,p,b,y,h,m)},t.orient2dfast=function(t,e,n,r,o,f){return (e-f)*(n-o)-(t-o)*(r-f)},Object.defineProperty(t,"__esModule",{value:!0});});
    });

    var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tinyqueue);

    var Queue = require$$0$2;

    var orient = orient2d_min.orient2d;

    // Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18
    if (Queue.default) {
        Queue = Queue.default;
    }

    var concaveman_1 = concaveman;
    var _default$4 = concaveman;

    function concaveman(points, concavity, lengthThreshold) {
        // a relative measure of concavity; higher value means simpler hull
        concavity = Math.max(0, concavity === undefined ? 2 : concavity);

        // when a segment goes below this length threshold, it won't be drilled down further
        lengthThreshold = lengthThreshold || 0;

        // start with a convex hull of the points
        var hull = fastConvexHull(points);

        // index the points with an R-tree
        var tree = new rbush_min$1(16);
        tree.toBBox = function (a) {
            return {
                minX: a[0],
                minY: a[1],
                maxX: a[0],
                maxY: a[1]
            };
        };
        tree.compareMinX = function (a, b) { return a[0] - b[0]; };
        tree.compareMinY = function (a, b) { return a[1] - b[1]; };

        tree.load(points);

        // turn the convex hull into a linked list and populate the initial edge queue with the nodes
        var queue = [];
        for (var i = 0, last; i < hull.length; i++) {
            var p = hull[i];
            tree.remove(p);
            last = insertNode$1(p, last);
            queue.push(last);
        }

        // index the segments with an R-tree (for intersection checks)
        var segTree = new rbush_min$1(16);
        for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));

        var sqConcavity = concavity * concavity;
        var sqLenThreshold = lengthThreshold * lengthThreshold;

        // process edges one by one
        while (queue.length) {
            var node = queue.shift();
            var a = node.p;
            var b = node.next.p;

            // skip the edge if it's already short enough
            var sqLen = getSqDist$1(a, b);
            if (sqLen < sqLenThreshold) continue;

            var maxSqLen = sqLen / sqConcavity;

            // find the best connection point for the current edge to flex inward to
            p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);

            // if we found a connection and it satisfies our concavity measure
            if (p && Math.min(getSqDist$1(p, a), getSqDist$1(p, b)) <= maxSqLen) {
                // connect the edge endpoints through this point and add 2 new edges to the queue
                queue.push(node);
                queue.push(insertNode$1(p, node));

                // update point and segment indexes
                tree.remove(p);
                segTree.remove(node);
                segTree.insert(updateBBox(node));
                segTree.insert(updateBBox(node.next));
            }
        }

        // convert the resulting hull linked list to an array of points
        node = last;
        var concave = [];
        do {
            concave.push(node.p);
            node = node.next;
        } while (node !== last);

        concave.push(node.p);

        return concave;
    }

    function findCandidate(tree, a, b, c, d, maxDist, segTree) {
        var queue = new Queue([], compareDist);
        var node = tree.data;

        // search through the point R-tree with a depth-first search using a priority queue
        // in the order of distance to the edge (b, c)
        while (node) {
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];

                var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
                if (dist > maxDist) continue; // skip the node if it's farther than we ever need

                queue.push({
                    node: child,
                    dist: dist
                });
            }

            while (queue.length && !queue.peek().node.children) {
                var item = queue.pop();
                var p = item.node;

                // skip all points that are as close to adjacent edges (a,b) and (c,d),
                // and points that would introduce self-intersections when connected
                var d0 = sqSegDist(p, a, b);
                var d1 = sqSegDist(p, c, d);
                if (item.dist < d0 && item.dist < d1 &&
                    noIntersections(b, p, segTree) &&
                    noIntersections(c, p, segTree)) return p;
            }

            node = queue.pop();
            if (node) node = node.node;
        }

        return null;
    }

    function compareDist(a, b) {
        return a.dist - b.dist;
    }

    // square distance from a segment bounding box to the given one
    function sqSegBoxDist(a, b, bbox) {
        if (inside(a, bbox) || inside(b, bbox)) return 0;
        var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
        if (d1 === 0) return 0;
        var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
        if (d2 === 0) return 0;
        var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
        if (d3 === 0) return 0;
        var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
        if (d4 === 0) return 0;
        return Math.min(d1, d2, d3, d4);
    }

    function inside(a, bbox) {
        return a[0] >= bbox.minX &&
               a[0] <= bbox.maxX &&
               a[1] >= bbox.minY &&
               a[1] <= bbox.maxY;
    }

    // check if the edge (a,b) doesn't intersect any other edges
    function noIntersections(a, b, segTree) {
        var minX = Math.min(a[0], b[0]);
        var minY = Math.min(a[1], b[1]);
        var maxX = Math.max(a[0], b[0]);
        var maxY = Math.max(a[1], b[1]);

        var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});
        for (var i = 0; i < edges.length; i++) {
            if (intersects$3(edges[i].p, edges[i].next.p, a, b)) return false;
        }
        return true;
    }

    function cross(p1, p2, p3) {
        return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }

    // check if the edges (p1,q1) and (p2,q2) intersect
    function intersects$3(p1, q1, p2, q2) {
        return p1 !== q2 && q1 !== p2 &&
            cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&
            cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
    }

    // update the bounding box of a node's edge
    function updateBBox(node) {
        var p1 = node.p;
        var p2 = node.next.p;
        node.minX = Math.min(p1[0], p2[0]);
        node.minY = Math.min(p1[1], p2[1]);
        node.maxX = Math.max(p1[0], p2[0]);
        node.maxY = Math.max(p1[1], p2[1]);
        return node;
    }

    // speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points
    function fastConvexHull(points) {
        var left = points[0];
        var top = points[0];
        var right = points[0];
        var bottom = points[0];

        // find the leftmost, rightmost, topmost and bottommost points
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            if (p[0] < left[0]) left = p;
            if (p[0] > right[0]) right = p;
            if (p[1] < top[1]) top = p;
            if (p[1] > bottom[1]) bottom = p;
        }

        // filter out points that are inside the resulting quadrilateral
        var cull = [left, top, right, bottom];
        var filtered = cull.slice();
        for (i = 0; i < points.length; i++) {
            if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);
        }

        // get convex hull around the filtered points
        return convexHull(filtered);
    }

    // create a new node in a doubly linked list
    function insertNode$1(p, prev) {
        var node = {
            p: p,
            prev: null,
            next: null,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0
        };

        if (!prev) {
            node.prev = node;
            node.next = node;

        } else {
            node.next = prev.next;
            node.prev = prev;
            prev.next.prev = node;
            prev.next = node;
        }
        return node;
    }

    // square distance between 2 points
    function getSqDist$1(p1, p2) {

        var dx = p1[0] - p2[0],
            dy = p1[1] - p2[1];

        return dx * dx + dy * dy;
    }

    // square distance from a point to a segment
    function sqSegDist(p, p1, p2) {

        var x = p1[0],
            y = p1[1],
            dx = p2[0] - x,
            dy = p2[1] - y;

        if (dx !== 0 || dy !== 0) {

            var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

            if (t > 1) {
                x = p2[0];
                y = p2[1];

            } else if (t > 0) {
                x += dx * t;
                y += dy * t;
            }
        }

        dx = p[0] - x;
        dy = p[1] - y;

        return dx * dx + dy * dy;
    }

    // segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday
    function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
        var ux = x1 - x0;
        var uy = y1 - y0;
        var vx = x3 - x2;
        var vy = y3 - y2;
        var wx = x0 - x2;
        var wy = y0 - y2;
        var a = ux * ux + uy * uy;
        var b = ux * vx + uy * vy;
        var c = vx * vx + vy * vy;
        var d = ux * wx + uy * wy;
        var e = vx * wx + vy * wy;
        var D = a * c - b * b;

        var sc, sN, tc, tN;
        var sD = D;
        var tD = D;

        if (D === 0) {
            sN = 0;
            sD = 1;
            tN = e;
            tD = c;
        } else {
            sN = b * e - c * d;
            tN = a * e - b * d;
            if (sN < 0) {
                sN = 0;
                tN = e;
                tD = c;
            } else if (sN > sD) {
                sN = sD;
                tN = e + b;
                tD = c;
            }
        }

        if (tN < 0.0) {
            tN = 0.0;
            if (-d < 0.0) sN = 0.0;
            else if (-d > a) sN = sD;
            else {
                sN = -d;
                sD = a;
            }
        } else if (tN > tD) {
            tN = tD;
            if ((-d + b) < 0.0) sN = 0;
            else if (-d + b > a) sN = sD;
            else {
                sN = -d + b;
                sD = a;
            }
        }

        sc = sN === 0 ? 0 : sN / sD;
        tc = tN === 0 ? 0 : tN / tD;

        var cx = (1 - sc) * x0 + sc * x1;
        var cy = (1 - sc) * y0 + sc * y1;
        var cx2 = (1 - tc) * x2 + tc * x3;
        var cy2 = (1 - tc) * y2 + tc * y3;
        var dx = cx2 - cx;
        var dy = cy2 - cy;

        return dx * dx + dy * dy;
    }

    function compareByX(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
    }

    function convexHull(points) {
        points.sort(compareByX);

        var lower = [];
        for (var i = 0; i < points.length; i++) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
                lower.pop();
            }
            lower.push(points[i]);
        }

        var upper = [];
        for (var ii = points.length - 1; ii >= 0; ii--) {
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
                upper.pop();
            }
            upper.push(points[ii]);
        }

        upper.pop();
        lower.pop();
        return lower.concat(upper);
    }

    var concaveman$1 = concaveman_1;
    concaveman_1.default = _default$4;

    /**
     * Takes a {@link Feature} or a {@link FeatureCollection} and returns a convex hull {@link Polygon}.
     *
     * Internally this uses
     * the [convex-hull](https://github.com/mikolalysenko/convex-hull) module that implements a
     * [monotone chain hull](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).
     *
     * @name convex
     * @param {GeoJSON} geojson input Feature or FeatureCollection
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.concavity=Infinity] 1 - thin shape. Infinity - convex hull.
     * @param {Object} [options.properties={}] Translate Properties to Feature
     * @returns {Feature<Polygon>} a convex hull
     * @example
     * var points = turf.featureCollection([
     *   turf.point([10.195312, 43.755225]),
     *   turf.point([10.404052, 43.8424511]),
     *   turf.point([10.579833, 43.659924]),
     *   turf.point([10.360107, 43.516688]),
     *   turf.point([10.14038, 43.588348]),
     *   turf.point([10.195312, 43.755225])
     * ]);
     *
     * var hull = turf.convex(points);
     *
     * //addToMap
     * var addToMap = [points, hull]
     */
    function convex(geojson, options) {
        if (options === void 0) { options = {}; }
        // Default parameters
        options.concavity = options.concavity || Infinity;
        // Container
        var points = [];
        // Convert all points to flat 2D coordinate Array
        coordEach$1(geojson, function (coord) {
            points.push([coord[0], coord[1]]);
        });
        if (!points.length) {
            return null;
        }
        var convexHull = concaveman$1(points, options.concavity);
        // Convex hull should have at least 3 different vertices in order to create a valid polygon
        if (convexHull.length > 3) {
            return polygon([convexHull]);
        }
        return null;
    }

    // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
    // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
    // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    /**
     * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
     * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
     *
     * @name booleanPointInPolygon
     * @param {Coord} point input point
     * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
     * the point is inside the polygon otherwise false.
     * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
     * @example
     * var pt = turf.point([-77, 44]);
     * var poly = turf.polygon([[
     *   [-81, 41],
     *   [-81, 47],
     *   [-72, 47],
     *   [-72, 41],
     *   [-81, 41]
     * ]]);
     *
     * turf.booleanPointInPolygon(pt, poly);
     * //= true
     */
    function booleanPointInPolygon(point, polygon, options) {
        if (options === void 0) { options = {}; }
        // validation
        if (!point) {
            throw new Error("point is required");
        }
        if (!polygon) {
            throw new Error("polygon is required");
        }
        var pt = getCoord(point);
        var geom = getGeom(polygon);
        var type = geom.type;
        var bbox = polygon.bbox;
        var polys = geom.coordinates;
        // Quick elimination if point is not inside bbox
        if (bbox && inBBox(pt, bbox) === false) {
            return false;
        }
        // normalize to multipolygon
        if (type === "Polygon") {
            polys = [polys];
        }
        var insidePoly = false;
        for (var i = 0; i < polys.length && !insidePoly; i++) {
            // check if it is in the outer ring first
            if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
                var inHole = false;
                var k = 1;
                // check for the point in any of the holes
                while (k < polys[i].length && !inHole) {
                    if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                        inHole = true;
                    }
                    k++;
                }
                if (!inHole) {
                    insidePoly = true;
                }
            }
        }
        return insidePoly;
    }
    /**
     * inRing
     *
     * @private
     * @param {Array<number>} pt [x,y]
     * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
     * @param {boolean} ignoreBoundary ignoreBoundary
     * @returns {boolean} inRing
     */
    function inRing(pt, ring, ignoreBoundary) {
        var isInside = false;
        if (ring[0][0] === ring[ring.length - 1][0] &&
            ring[0][1] === ring[ring.length - 1][1]) {
            ring = ring.slice(0, ring.length - 1);
        }
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var xi = ring[i][0];
            var yi = ring[i][1];
            var xj = ring[j][0];
            var yj = ring[j][1];
            var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&
                (xi - pt[0]) * (xj - pt[0]) <= 0 &&
                (yi - pt[1]) * (yj - pt[1]) <= 0;
            if (onBoundary) {
                return !ignoreBoundary;
            }
            var intersect = yi > pt[1] !== yj > pt[1] &&
                pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;
            if (intersect) {
                isInside = !isInside;
            }
        }
        return isInside;
    }
    /**
     * inBBox
     *
     * @private
     * @param {Position} pt point [x,y]
     * @param {BBox} bbox BBox [west, south, east, north]
     * @returns {boolean} true/false if point is inside BBox
     */
    function inBBox(pt, bbox) {
        return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);
    }

    /**
     * Finds {@link Points} or {@link MultiPoint} coordinate positions that fall within {@link (Multi)Polygon(s)}.
     *
     * @name pointsWithinPolygon
     * @param {Feature|FeatureCollection<Point|MultiPoint>} points Point(s) or MultiPoint(s) as input search
     * @param {FeatureCollection|Geometry|Feature<Polygon|MultiPolygon>} polygons (Multi)Polygon(s) to check if points are within
     * @returns {FeatureCollection<Point|MultiPoint>} Point(s) or MultiPoint(s) with positions that land within at least one polygon.  The geometry type will match what was passsed in
     * @example
     * var points = turf.points([
     *     [-46.6318, -23.5523],
     *     [-46.6246, -23.5325],
     *     [-46.6062, -23.5513],
     *     [-46.663, -23.554],
     *     [-46.643, -23.557]
     * ]);
     *
     * var searchWithin = turf.polygon([[
     *     [-46.653,-23.543],
     *     [-46.634,-23.5346],
     *     [-46.613,-23.543],
     *     [-46.614,-23.559],
     *     [-46.631,-23.567],
     *     [-46.653,-23.560],
     *     [-46.653,-23.543]
     * ]]);
     *
     * var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);
     *
     * //addToMap
     * var addToMap = [points, searchWithin, ptsWithin]
     * turf.featureEach(ptsWithin, function (currentFeature) {
     *   currentFeature.properties['marker-size'] = 'large';
     *   currentFeature.properties['marker-color'] = '#000';
     * });
     */
    function pointsWithinPolygon(points, polygons) {
      var results = [];
      featureEach$2(points, function (point) {
        var contained = false;
        if (point.geometry.type === "Point") {
          geomEach$1(polygons, function (polygon) {
            if (booleanPointInPolygon(point, polygon)) contained = true;
          });
          if (contained) {
            results.push(point);
          }
        } else if (point.geometry.type === "MultiPoint") {
          var pointsWithin = [];
          geomEach$1(polygons, function (polygon) {
            coordEach$1(point, function (pointCoord) {
              if (booleanPointInPolygon(pointCoord, polygon)) {
                contained = true;
                pointsWithin.push(pointCoord);
              }
            });
          });
          if (contained) {
            results.push(multiPoint(pointsWithin));
          }
        } else {
          throw new Error("Input geometry must be a Point or MultiPoint");
        }
      });
      return featureCollection$1(results);
    }

    //http://en.wikipedia.org/wiki/Haversine_formula
    //http://www.movable-type.co.uk/scripts/latlong.html
    /**
     * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
     * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
     *
     * @name distance
     * @param {Coord | Point} from origin point or coordinate
     * @param {Coord | Point} to destination point or coordinate
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
     * @returns {number} distance between the two points
     * @example
     * var from = turf.point([-75.343, 39.984]);
     * var to = turf.point([-75.534, 39.123]);
     * var options = {units: 'miles'};
     *
     * var distance = turf.distance(from, to, options);
     *
     * //addToMap
     * var addToMap = [from, to];
     * from.properties.distance = distance;
     * to.properties.distance = distance;
     */
    function distance$1(from, to, options) {
        if (options === void 0) { options = {}; }
        var coordinates1 = getCoord(from);
        var coordinates2 = getCoord(to);
        var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
        var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
        var lat1 = degreesToRadians(coordinates1[1]);
        var lat2 = degreesToRadians(coordinates2[1]);
        var a = Math.pow(Math.sin(dLat / 2), 2) +
            Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
        return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
    }

    // http://en.wikipedia.org/wiki/Delaunay_triangulation
    /**
     * Takes a set of {@link Point|points} and creates a
     * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
     * or a TIN for short, returned as a collection of Polygons. These are often used
     * for developing elevation contour maps or stepped heat visualizations.
     *
     * If an optional z-value property is provided then it is added as properties called `a`, `b`,
     * and `c` representing its value at each of the points that represent the corners of the
     * triangle.
     *
     * @name tin
     * @param {FeatureCollection<Point>} points input points
     * @param {String} [z] name of the property from which to pull z values
     * This is optional: if not given, then there will be no extra data added to the derived triangles.
     * @returns {FeatureCollection<Polygon>} TIN output
     * @example
     * // generate some random point data
     * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});
     *
     * // add a random property to each point between 0 and 9
     * for (var i = 0; i < points.features.length; i++) {
     *   points.features[i].properties.z = ~~(Math.random() * 9);
     * }
     * var tin = turf.tin(points, 'z');
     *
     * //addToMap
     * var addToMap = [tin, points]
     * for (var i = 0; i < tin.features.length; i++) {
     *   var properties  = tin.features[i].properties;
     *   properties.fill = '#' + properties.a + properties.b + properties.c;
     * }
     */
    function tin(points, z) {
        // break down points
        var isPointZ = false;
        return featureCollection$1(triangulate(points.features.map(function (p) {
            var point = {
                x: p.geometry.coordinates[0],
                y: p.geometry.coordinates[1],
            };
            if (z) {
                point.z = p.properties[z];
            }
            else if (p.geometry.coordinates.length === 3) {
                isPointZ = true;
                point.z = p.geometry.coordinates[2];
            }
            return point;
        })).map(function (triangle) {
            var a = [triangle.a.x, triangle.a.y];
            var b = [triangle.b.x, triangle.b.y];
            var c = [triangle.c.x, triangle.c.y];
            var properties = {};
            // Add z coordinates to triangle points if user passed
            // them in that way otherwise add it as a property.
            if (isPointZ) {
                a.push(triangle.a.z);
                b.push(triangle.b.z);
                c.push(triangle.c.z);
            }
            else {
                properties = {
                    a: triangle.a.z,
                    b: triangle.b.z,
                    c: triangle.c.z,
                };
            }
            return polygon([[a, b, c, a]], properties);
        }));
    }
    var Triangle = /** @class */ (function () {
        function Triangle(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
            var A = b.x - a.x;
            var B = b.y - a.y;
            var C = c.x - a.x;
            var D = c.y - a.y;
            var E = A * (a.x + b.x) + B * (a.y + b.y);
            var F = C * (a.x + c.x) + D * (a.y + c.y);
            var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
            var dx;
            var dy;
            // If the points of the triangle are collinear, then just find the
            // extremes and use the midpoint as the center of the circumcircle.
            this.x = (D * E - B * F) / G;
            this.y = (A * F - C * E) / G;
            dx = this.x - a.x;
            dy = this.y - a.y;
            this.r = dx * dx + dy * dy;
        }
        return Triangle;
    }());
    function byX(a, b) {
        return b.x - a.x;
    }
    function dedup$1(edges) {
        var j = edges.length;
        var a;
        var b;
        var i;
        var m;
        var n;
        outer: while (j) {
            b = edges[--j];
            a = edges[--j];
            i = j;
            while (i) {
                n = edges[--i];
                m = edges[--i];
                if ((a === m && b === n) || (a === n && b === m)) {
                    edges.splice(j, 2);
                    edges.splice(i, 2);
                    j -= 2;
                    continue outer;
                }
            }
        }
    }
    function triangulate(vertices) {
        // Bail if there aren't enough vertices to form any triangles.
        if (vertices.length < 3) {
            return [];
        }
        // Ensure the vertex array is in order of descending X coordinate
        // (which is needed to ensure a subquadratic runtime), and then find
        // the bounding box around the points.
        vertices.sort(byX);
        var i = vertices.length - 1;
        var xmin = vertices[i].x;
        var xmax = vertices[0].x;
        var ymin = vertices[i].y;
        var ymax = ymin;
        var epsilon = 1e-12;
        var a;
        var b;
        var c;
        var A;
        var B;
        var G;
        while (i--) {
            if (vertices[i].y < ymin) {
                ymin = vertices[i].y;
            }
            if (vertices[i].y > ymax) {
                ymax = vertices[i].y;
            }
        }
        // Find a supertriangle, which is a triangle that surrounds all the
        // vertices. This is used like something of a sentinel value to remove
        // cases in the main algorithm, and is removed before we return any
        // results.
        // Once found, put it in the "open" list. (The "open" list is for
        // triangles who may still need to be considered; the "closed" list is
        // for triangles which do not.)
        var dx = xmax - xmin;
        var dy = ymax - ymin;
        var dmax = dx > dy ? dx : dy;
        var xmid = (xmax + xmin) * 0.5;
        var ymid = (ymax + ymin) * 0.5;
        var open = [
            new Triangle({
                __sentinel: true,
                x: xmid - 20 * dmax,
                y: ymid - dmax,
            }, {
                __sentinel: true,
                x: xmid,
                y: ymid + 20 * dmax,
            }, {
                __sentinel: true,
                x: xmid + 20 * dmax,
                y: ymid - dmax,
            }),
        ];
        var closed = [];
        var edges = [];
        var j;
        // Incrementally add each vertex to the mesh.
        i = vertices.length;
        while (i--) {
            // For each open triangle, check to see if the current point is
            // inside it's circumcircle. If it is, remove the triangle and add
            // it's edges to an edge list.
            edges.length = 0;
            j = open.length;
            while (j--) {
                // If this point is to the right of this triangle's circumcircle,
                // then this triangle should never get checked again. Remove it
                // from the open list, add it to the closed list, and skip.
                dx = vertices[i].x - open[j].x;
                if (dx > 0 && dx * dx > open[j].r) {
                    closed.push(open[j]);
                    open.splice(j, 1);
                    continue;
                }
                // If not, skip this triangle.
                dy = vertices[i].y - open[j].y;
                if (dx * dx + dy * dy > open[j].r) {
                    continue;
                }
                // Remove the triangle and add it's edges to the edge list.
                edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
                open.splice(j, 1);
            }
            // Remove any doubled edges.
            dedup$1(edges);
            // Add a new triangle for each edge.
            j = edges.length;
            while (j) {
                b = edges[--j];
                a = edges[--j];
                c = vertices[i];
                // Avoid adding colinear triangles (which have error-prone
                // circumcircles)
                A = b.x - a.x;
                B = b.y - a.y;
                G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
                if (Math.abs(G) > epsilon) {
                    open.push(new Triangle(a, b, c));
                }
            }
        }
        // Copy any remaining open triangles to the closed list, and then
        // remove any triangles that share a vertex with the supertriangle.
        Array.prototype.push.apply(closed, open);
        i = closed.length;
        while (i--) {
            if (closed[i].a.__sentinel ||
                closed[i].b.__sentinel ||
                closed[i].c.__sentinel) {
                closed.splice(i, 1);
            }
        }
        return closed;
    }

    /**
     * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
     * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
     *
     * @name clone
     * @param {GeoJSON} geojson GeoJSON Object
     * @returns {GeoJSON} cloned GeoJSON Object
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
     *
     * var lineCloned = turf.clone(line);
     */
    function clone(geojson) {
        if (!geojson) {
            throw new Error("geojson is required");
        }
        switch (geojson.type) {
            case "Feature":
                return cloneFeature(geojson);
            case "FeatureCollection":
                return cloneFeatureCollection(geojson);
            case "Point":
            case "LineString":
            case "Polygon":
            case "MultiPoint":
            case "MultiLineString":
            case "MultiPolygon":
            case "GeometryCollection":
                return cloneGeometry(geojson);
            default:
                throw new Error("unknown GeoJSON type");
        }
    }
    /**
     * Clone Feature
     *
     * @private
     * @param {Feature<any>} geojson GeoJSON Feature
     * @returns {Feature<any>} cloned Feature
     */
    function cloneFeature(geojson) {
        var cloned = { type: "Feature" };
        // Preserve Foreign Members
        Object.keys(geojson).forEach(function (key) {
            switch (key) {
                case "type":
                case "properties":
                case "geometry":
                    return;
                default:
                    cloned[key] = geojson[key];
            }
        });
        // Add properties & geometry last
        cloned.properties = cloneProperties(geojson.properties);
        cloned.geometry = cloneGeometry(geojson.geometry);
        return cloned;
    }
    /**
     * Clone Properties
     *
     * @private
     * @param {Object} properties GeoJSON Properties
     * @returns {Object} cloned Properties
     */
    function cloneProperties(properties) {
        var cloned = {};
        if (!properties) {
            return cloned;
        }
        Object.keys(properties).forEach(function (key) {
            var value = properties[key];
            if (typeof value === "object") {
                if (value === null) {
                    // handle null
                    cloned[key] = null;
                }
                else if (Array.isArray(value)) {
                    // handle Array
                    cloned[key] = value.map(function (item) {
                        return item;
                    });
                }
                else {
                    // handle generic Object
                    cloned[key] = cloneProperties(value);
                }
            }
            else {
                cloned[key] = value;
            }
        });
        return cloned;
    }
    /**
     * Clone Feature Collection
     *
     * @private
     * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
     * @returns {FeatureCollection<any>} cloned Feature Collection
     */
    function cloneFeatureCollection(geojson) {
        var cloned = { type: "FeatureCollection" };
        // Preserve Foreign Members
        Object.keys(geojson).forEach(function (key) {
            switch (key) {
                case "type":
                case "features":
                    return;
                default:
                    cloned[key] = geojson[key];
            }
        });
        // Add features
        cloned.features = geojson.features.map(function (feature) {
            return cloneFeature(feature);
        });
        return cloned;
    }
    /**
     * Clone Geometry
     *
     * @private
     * @param {Geometry<any>} geometry GeoJSON Geometry
     * @returns {Geometry<any>} cloned Geometry
     */
    function cloneGeometry(geometry) {
        var geom = { type: geometry.type };
        if (geometry.bbox) {
            geom.bbox = geometry.bbox;
        }
        if (geometry.type === "GeometryCollection") {
            geom.geometries = geometry.geometries.map(function (g) {
                return cloneGeometry(g);
            });
            return geom;
        }
        geom.coordinates = deepSlice(geometry.coordinates);
        return geom;
    }
    /**
     * Deep Slice coordinates
     *
     * @private
     * @param {Coordinates} coords Coordinates
     * @returns {Coordinates} all coordinates sliced
     */
    function deepSlice(coords) {
        var cloned = coords;
        if (typeof cloned[0] !== "object") {
            return cloned.slice();
        }
        return cloned.map(function (coord) {
            return deepSlice(coord);
        });
    }

    /**
     * Merges all connected (non-forking, non-junctioning) line strings into single lineStrings.
     * [LineString] -> LineString|MultiLineString
     *
     * @param {FeatureCollection<LineString|MultiLineString>} geojson Lines to dissolve
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.mutate=false] Prevent input mutation
     * @returns {Feature<LineString|MultiLineString>} Dissolved lines
     */
    function lineDissolve(geojson, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        options = options || {};
        if (!isObject(options)) {
            throw new Error("options is invalid");
        }
        var mutate = options.mutate;
        // Validation
        if (getType$1(geojson) !== "FeatureCollection") {
            throw new Error("geojson must be a FeatureCollection");
        }
        if (!geojson.features.length) {
            throw new Error("geojson is empty");
        }
        // Clone geojson to avoid side effects
        if (mutate === false || mutate === undefined) {
            geojson = clone(geojson);
        }
        var result = [];
        var lastLine = lineReduce$1(geojson, function (previousLine, currentLine) {
            // Attempt to merge this LineString with the other LineStrings, updating
            // the reference as it is merged with others and grows.
            var merged = mergeLineStrings(previousLine, currentLine);
            // Accumulate the merged LineString
            if (merged) {
                return merged;
                // Put the unmerged LineString back into the list
            }
            else {
                result.push(previousLine);
                return currentLine;
            }
        });
        // Append the last line
        if (lastLine) {
            result.push(lastLine);
        }
        // Return null if no lines were dissolved
        if (!result.length) {
            return null;
            // Return LineString if only 1 line was dissolved
        }
        else if (result.length === 1) {
            return result[0];
            // Return MultiLineString if multiple lines were dissolved with gaps
        }
        else {
            return multiLineString(result.map(function (line) {
                return line.coordinates;
            }));
        }
    }
    // [Number, Number] -> String
    function coordId(coord) {
        return coord[0].toString() + "," + coord[1].toString();
    }
    /**
     * LineString, LineString -> LineString
     *
     * @private
     * @param {Feature<LineString>} a line1
     * @param {Feature<LineString>} b line2
     * @returns {Feature<LineString>|null} Merged LineString
     */
    function mergeLineStrings(a, b) {
        var coords1 = a.geometry.coordinates;
        var coords2 = b.geometry.coordinates;
        var s1 = coordId(coords1[0]);
        var e1 = coordId(coords1[coords1.length - 1]);
        var s2 = coordId(coords2[0]);
        var e2 = coordId(coords2[coords2.length - 1]);
        // TODO: handle case where more than one of these is true!
        var coords;
        if (s1 === e2) {
            coords = coords2.concat(coords1.slice(1));
        }
        else if (s2 === e1) {
            coords = coords1.concat(coords2.slice(1));
        }
        else if (s1 === s2) {
            coords = coords1.slice(1).reverse().concat(coords2);
        }
        else if (e1 === e2) {
            coords = coords1.concat(coords2.reverse().slice(1));
        }
        else {
            return null;
        }
        return lineString(coords);
    }

    function identity$1(x) {
      return x;
    }

    function transform(transform) {
      if (transform == null) return identity$1;
      var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1];
      return function(input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2, n = input.length, output = new Array(n);
        output[0] = (x0 += input[0]) * kx + dx;
        output[1] = (y0 += input[1]) * ky + dy;
        while (j < n) output[j] = input[j], ++j;
        return output;
      };
    }

    function reverse$1(array, n) {
      var t, j = array.length, i = j - n;
      while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
    }

    function object(topology, o) {
      var transformPoint = transform(topology.transform),
          arcs = topology.arcs;

      function arc(i, points) {
        if (points.length) points.pop();
        for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
          points.push(transformPoint(a[k], k));
        }
        if (i < 0) reverse$1(points, n);
      }

      function point(p) {
        return transformPoint(p);
      }

      function line(arcs) {
        var points = [];
        for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
        if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
        return points;
      }

      function ring(arcs) {
        var points = line(arcs);
        while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
        return points;
      }

      function polygon(arcs) {
        return arcs.map(ring);
      }

      function geometry(o) {
        var type = o.type, coordinates;
        switch (type) {
          case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
          case "Point": coordinates = point(o.coordinates); break;
          case "MultiPoint": coordinates = o.coordinates.map(point); break;
          case "LineString": coordinates = line(o.arcs); break;
          case "MultiLineString": coordinates = o.arcs.map(line); break;
          case "Polygon": coordinates = polygon(o.arcs); break;
          case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
          default: return null;
        }
        return {type: type, coordinates: coordinates};
      }

      return geometry(o);
    }

    function stitch(topology, arcs) {
      var stitchedArcs = {},
          fragmentByStart = {},
          fragmentByEnd = {},
          fragments = [],
          emptyIndex = -1;

      // Stitch empty arcs first, since they may be subsumed by other arcs.
      arcs.forEach(function(i, j) {
        var arc = topology.arcs[i < 0 ? ~i : i], t;
        if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
          t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
        }
      });

      arcs.forEach(function(i) {
        var e = ends(i),
            start = e[0],
            end = e[1],
            f, g;

        if (f = fragmentByEnd[start]) {
          delete fragmentByEnd[f.end];
          f.push(i);
          f.end = end;
          if (g = fragmentByStart[end]) {
            delete fragmentByStart[g.start];
            var fg = g === f ? f : f.concat(g);
            fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else if (f = fragmentByStart[end]) {
          delete fragmentByStart[f.start];
          f.unshift(i);
          f.start = start;
          if (g = fragmentByEnd[start]) {
            delete fragmentByEnd[g.end];
            var gf = g === f ? f : g.concat(f);
            fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else {
          f = [i];
          fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }
      });

      function ends(i) {
        var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
        if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
        else p1 = arc[arc.length - 1];
        return i < 0 ? [p1, p0] : [p0, p1];
      }

      function flush(fragmentByEnd, fragmentByStart) {
        for (var k in fragmentByEnd) {
          var f = fragmentByEnd[k];
          delete fragmentByStart[f.start];
          delete f.start;
          delete f.end;
          f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
          fragments.push(f);
        }
      }

      flush(fragmentByEnd, fragmentByStart);
      flush(fragmentByStart, fragmentByEnd);
      arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

      return fragments;
    }

    function planarRingArea(ring) {
      var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
      while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
      return Math.abs(area); // Note: doubled area!
    }

    function merge$2(topology) {
      return object(topology, mergeArcs.apply(this, arguments));
    }

    function mergeArcs(topology, objects) {
      var polygonsByArc = {},
          polygons = [],
          groups = [];

      objects.forEach(geometry);

      function geometry(o) {
        switch (o.type) {
          case "GeometryCollection": o.geometries.forEach(geometry); break;
          case "Polygon": extract(o.arcs); break;
          case "MultiPolygon": o.arcs.forEach(extract); break;
        }
      }

      function extract(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
          });
        });
        polygons.push(polygon);
      }

      function area(ring) {
        return planarRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
      }

      polygons.forEach(function(polygon) {
        if (!polygon._) {
          var group = [],
              neighbors = [polygon];
          polygon._ = 1;
          groups.push(group);
          while (polygon = neighbors.pop()) {
            group.push(polygon);
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                  if (!polygon._) {
                    polygon._ = 1;
                    neighbors.push(polygon);
                  }
                });
              });
            });
          }
        }
      });

      polygons.forEach(function(polygon) {
        delete polygon._;
      });

      return {
        type: "MultiPolygon",
        arcs: groups.map(function(polygons) {
          var arcs = [], n;

          // Extract the exterior (unique) arcs.
          polygons.forEach(function(polygon) {
            polygon.forEach(function(ring) {
              ring.forEach(function(arc) {
                if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                  arcs.push(arc);
                }
              });
            });
          });

          // Stitch the arcs into one or more rings.
          arcs = stitch(topology, arcs);

          // If more than one ring is returned,
          // at most one of these rings can be the exterior;
          // choose the one with the greatest absolute area.
          if ((n = arcs.length) > 1) {
            for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
              if ((ki = area(arcs[i])) > k) {
                t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
              }
            }
          }

          return arcs;
        }).filter(function(arcs) {
          return arcs.length > 0;
        })
      };
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    // Computes the bounding box of the specified hash of GeoJSON objects.
    function bounds(objects) {
      var x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      function boundGeometry(geometry) {
        if (geometry != null && hasOwnProperty.call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
      }

      var boundGeometryType = {
        GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },
        Point: function(o) { boundPoint(o.coordinates); },
        MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },
        LineString: function(o) { boundLine(o.arcs); },
        MultiLineString: function(o) { o.arcs.forEach(boundLine); },
        Polygon: function(o) { o.arcs.forEach(boundLine); },
        MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }
      };

      function boundPoint(coordinates) {
        var x = coordinates[0],
            y = coordinates[1];
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      function boundLine(coordinates) {
        coordinates.forEach(boundPoint);
      }

      function boundMultiLine(coordinates) {
        coordinates.forEach(boundLine);
      }

      for (var key in objects) {
        boundGeometry(objects[key]);
      }

      return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;
    }

    function hashset(size, hash, equal, type, empty) {
      if (arguments.length === 3) {
        type = Array;
        empty = null;
      }

      var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
          mask = size - 1;

      for (var i = 0; i < size; ++i) {
        store[i] = empty;
      }

      function add(value) {
        var index = hash(value) & mask,
            match = store[index],
            collisions = 0;
        while (match != empty) {
          if (equal(match, value)) return true;
          if (++collisions >= size) throw new Error("full hashset");
          match = store[index = (index + 1) & mask];
        }
        store[index] = value;
        return true;
      }

      function has(value) {
        var index = hash(value) & mask,
            match = store[index],
            collisions = 0;
        while (match != empty) {
          if (equal(match, value)) return true;
          if (++collisions >= size) break;
          match = store[index = (index + 1) & mask];
        }
        return false;
      }

      function values() {
        var values = [];
        for (var i = 0, n = store.length; i < n; ++i) {
          var match = store[i];
          if (match != empty) values.push(match);
        }
        return values;
      }

      return {
        add: add,
        has: has,
        values: values
      };
    }

    function hashmap(size, hash, equal, keyType, keyEmpty, valueType) {
      if (arguments.length === 3) {
        keyType = valueType = Array;
        keyEmpty = null;
      }

      var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
          valstore = new valueType(size),
          mask = size - 1;

      for (var i = 0; i < size; ++i) {
        keystore[i] = keyEmpty;
      }

      function set(key, value) {
        var index = hash(key) & mask,
            matchKey = keystore[index],
            collisions = 0;
        while (matchKey != keyEmpty) {
          if (equal(matchKey, key)) return valstore[index] = value;
          if (++collisions >= size) throw new Error("full hashmap");
          matchKey = keystore[index = (index + 1) & mask];
        }
        keystore[index] = key;
        valstore[index] = value;
        return value;
      }

      function maybeSet(key, value) {
        var index = hash(key) & mask,
            matchKey = keystore[index],
            collisions = 0;
        while (matchKey != keyEmpty) {
          if (equal(matchKey, key)) return valstore[index];
          if (++collisions >= size) throw new Error("full hashmap");
          matchKey = keystore[index = (index + 1) & mask];
        }
        keystore[index] = key;
        valstore[index] = value;
        return value;
      }

      function get(key, missingValue) {
        var index = hash(key) & mask,
            matchKey = keystore[index],
            collisions = 0;
        while (matchKey != keyEmpty) {
          if (equal(matchKey, key)) return valstore[index];
          if (++collisions >= size) break;
          matchKey = keystore[index = (index + 1) & mask];
        }
        return missingValue;
      }

      function keys() {
        var keys = [];
        for (var i = 0, n = keystore.length; i < n; ++i) {
          var matchKey = keystore[i];
          if (matchKey != keyEmpty) keys.push(matchKey);
        }
        return keys;
      }

      return {
        set: set,
        maybeSet: maybeSet, // set if unset
        get: get,
        keys: keys
      };
    }

    function equalPoint(pointA, pointB) {
      return pointA[0] === pointB[0] && pointA[1] === pointB[1];
    }

    // TODO if quantized, use simpler Int32 hashing?

    var buffer$1 = new ArrayBuffer(16),
        floats = new Float64Array(buffer$1),
        uints = new Uint32Array(buffer$1);

    function hashPoint(point) {
      floats[0] = point[0];
      floats[1] = point[1];
      var hash = uints[0] ^ uints[1];
      hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
      return hash & 0x7fffffff;
    }

    // Given an extracted (pre-)topology, identifies all of the junctions. These are
    // the points at which arcs (lines or rings) will need to be cut so that each
    // arc is represented uniquely.
    //
    // A junction is a point where at least one arc deviates from another arc going
    // through the same point. For example, consider the point B. If there is a arc
    // through ABC and another arc through CBA, then B is not a junction because in
    // both cases the adjacent point pairs are {A,C}. However, if there is an
    // additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.
    //
    // For a closed ring ABCA, the first point A’s adjacent points are the second
    // and last point {B,C}. For a line, the first and last point are always
    // considered junctions, even if the line is closed; this ensures that a closed
    // line is never rotated.
    function join(topology) {
      var coordinates = topology.coordinates,
          lines = topology.lines,
          rings = topology.rings,
          indexes = index(),
          visitedByIndex = new Int32Array(coordinates.length),
          leftByIndex = new Int32Array(coordinates.length),
          rightByIndex = new Int32Array(coordinates.length),
          junctionByIndex = new Int8Array(coordinates.length),
          junctionCount = 0, // upper bound on number of junctions
          i, n,
          previousIndex,
          currentIndex,
          nextIndex;

      for (i = 0, n = coordinates.length; i < n; ++i) {
        visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
      }

      for (i = 0, n = lines.length; i < n; ++i) {
        var line = lines[i],
            lineStart = line[0],
            lineEnd = line[1];
        currentIndex = indexes[lineStart];
        nextIndex = indexes[++lineStart];
        ++junctionCount, junctionByIndex[currentIndex] = 1; // start
        while (++lineStart <= lineEnd) {
          sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
        }
        ++junctionCount, junctionByIndex[nextIndex] = 1; // end
      }

      for (i = 0, n = coordinates.length; i < n; ++i) {
        visitedByIndex[i] = -1;
      }

      for (i = 0, n = rings.length; i < n; ++i) {
        var ring = rings[i],
            ringStart = ring[0] + 1,
            ringEnd = ring[1];
        previousIndex = indexes[ringEnd - 1];
        currentIndex = indexes[ringStart - 1];
        nextIndex = indexes[ringStart];
        sequence(i, previousIndex, currentIndex, nextIndex);
        while (++ringStart <= ringEnd) {
          sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
        }
      }

      function sequence(i, previousIndex, currentIndex, nextIndex) {
        if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection
        visitedByIndex[currentIndex] = i;
        var leftIndex = leftByIndex[currentIndex];
        if (leftIndex >= 0) {
          var rightIndex = rightByIndex[currentIndex];
          if ((leftIndex !== previousIndex || rightIndex !== nextIndex)
            && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {
            ++junctionCount, junctionByIndex[currentIndex] = 1;
          }
        } else {
          leftByIndex[currentIndex] = previousIndex;
          rightByIndex[currentIndex] = nextIndex;
        }
      }

      function index() {
        var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),
            indexes = new Int32Array(coordinates.length);

        for (var i = 0, n = coordinates.length; i < n; ++i) {
          indexes[i] = indexByPoint.maybeSet(i, i);
        }

        return indexes;
      }

      function hashIndex(i) {
        return hashPoint(coordinates[i]);
      }

      function equalIndex(i, j) {
        return equalPoint(coordinates[i], coordinates[j]);
      }

      visitedByIndex = leftByIndex = rightByIndex = null;

      var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;

      // Convert back to a standard hashset by point for caller convenience.
      for (i = 0, n = coordinates.length; i < n; ++i) {
        if (junctionByIndex[j = indexes[i]]) {
          junctionByPoint.add(coordinates[j]);
        }
      }

      return junctionByPoint;
    }

    // Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared
    // point sequences are identified. The topology can then be subsequently deduped
    // to remove exact duplicate arcs.
    function cut(topology) {
      var junctions = join(topology),
          coordinates = topology.coordinates,
          lines = topology.lines,
          rings = topology.rings,
          next,
          i, n;

      for (i = 0, n = lines.length; i < n; ++i) {
        var line = lines[i],
            lineMid = line[0],
            lineEnd = line[1];
        while (++lineMid < lineEnd) {
          if (junctions.has(coordinates[lineMid])) {
            next = {0: lineMid, 1: line[1]};
            line[1] = lineMid;
            line = line.next = next;
          }
        }
      }

      for (i = 0, n = rings.length; i < n; ++i) {
        var ring = rings[i],
            ringStart = ring[0],
            ringMid = ringStart,
            ringEnd = ring[1],
            ringFixed = junctions.has(coordinates[ringStart]);
        while (++ringMid < ringEnd) {
          if (junctions.has(coordinates[ringMid])) {
            if (ringFixed) {
              next = {0: ringMid, 1: ring[1]};
              ring[1] = ringMid;
              ring = ring.next = next;
            } else { // For the first junction, we can rotate rather than cut.
              rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
              coordinates[ringEnd] = coordinates[ringStart];
              ringFixed = true;
              ringMid = ringStart; // restart; we may have skipped junctions
            }
          }
        }
      }

      return topology;
    }

    function rotateArray(array, start, end, offset) {
      reverse(array, start, end);
      reverse(array, start, start + offset);
      reverse(array, start + offset, end);
    }

    function reverse(array, start, end) {
      for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {
        t = array[start], array[start] = array[end], array[end] = t;
      }
    }

    // Given a cut topology, combines duplicate arcs.
    function dedup(topology) {
      var coordinates = topology.coordinates,
          lines = topology.lines, line,
          rings = topology.rings, ring,
          arcCount = lines.length + rings.length,
          i, n;

      delete topology.lines;
      delete topology.rings;

      // Count the number of (non-unique) arcs to initialize the hashmap safely.
      for (i = 0, n = lines.length; i < n; ++i) {
        line = lines[i]; while (line = line.next) ++arcCount;
      }
      for (i = 0, n = rings.length; i < n; ++i) {
        ring = rings[i]; while (ring = ring.next) ++arcCount;
      }

      var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),
          arcs = topology.arcs = [];

      for (i = 0, n = lines.length; i < n; ++i) {
        line = lines[i];
        do {
          dedupLine(line);
        } while (line = line.next);
      }

      for (i = 0, n = rings.length; i < n; ++i) {
        ring = rings[i];
        if (ring.next) { // arc is no longer closed
          do {
            dedupLine(ring);
          } while (ring = ring.next);
        } else {
          dedupRing(ring);
        }
      }

      function dedupLine(arc) {
        var startPoint,
            endPoint,
            startArcs, startArc,
            endArcs, endArc,
            i, n;

        // Does this arc match an existing arc in order?
        if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
          for (i = 0, n = startArcs.length; i < n; ++i) {
            startArc = startArcs[i];
            if (equalLine(startArc, arc)) {
              arc[0] = startArc[0];
              arc[1] = startArc[1];
              return;
            }
          }
        }

        // Does this arc match an existing arc in reverse order?
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
          for (i = 0, n = endArcs.length; i < n; ++i) {
            endArc = endArcs[i];
            if (reverseEqualLine(endArc, arc)) {
              arc[1] = endArc[0];
              arc[0] = endArc[1];
              return;
            }
          }
        }

        if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);
        if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
        arcs.push(arc);
      }

      function dedupRing(arc) {
        var endPoint,
            endArcs,
            endArc,
            i, n;

        // Does this arc match an existing line in order, or reverse order?
        // Rings are closed, so their start point and end point is the same.
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
          for (i = 0, n = endArcs.length; i < n; ++i) {
            endArc = endArcs[i];
            if (equalRing(endArc, arc)) {
              arc[0] = endArc[0];
              arc[1] = endArc[1];
              return;
            }
            if (reverseEqualRing(endArc, arc)) {
              arc[0] = endArc[1];
              arc[1] = endArc[0];
              return;
            }
          }
        }

        // Otherwise, does this arc match an existing ring in order, or reverse order?
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
          for (i = 0, n = endArcs.length; i < n; ++i) {
            endArc = endArcs[i];
            if (equalRing(endArc, arc)) {
              arc[0] = endArc[0];
              arc[1] = endArc[1];
              return;
            }
            if (reverseEqualRing(endArc, arc)) {
              arc[0] = endArc[1];
              arc[1] = endArc[0];
              return;
            }
          }
        }

        if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
        arcs.push(arc);
      }

      function equalLine(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0],
            ja = arcA[1], jb = arcB[1];
        if (ia - ja !== ib - jb) return false;
        for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;
        return true;
      }

      function reverseEqualLine(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0],
            ja = arcA[1], jb = arcB[1];
        if (ia - ja !== ib - jb) return false;
        for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;
        return true;
      }

      function equalRing(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0],
            ja = arcA[1], jb = arcB[1],
            n = ja - ia;
        if (n !== jb - ib) return false;
        var ka = findMinimumOffset(arcA),
            kb = findMinimumOffset(arcB);
        for (var i = 0; i < n; ++i) {
          if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;
        }
        return true;
      }

      function reverseEqualRing(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0],
            ja = arcA[1], jb = arcB[1],
            n = ja - ia;
        if (n !== jb - ib) return false;
        var ka = findMinimumOffset(arcA),
            kb = n - findMinimumOffset(arcB);
        for (var i = 0; i < n; ++i) {
          if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;
        }
        return true;
      }

      // Rings are rotated to a consistent, but arbitrary, start point.
      // This is necessary to detect when a ring and a rotated copy are dupes.
      function findMinimumOffset(arc) {
        var start = arc[0],
            end = arc[1],
            mid = start,
            minimum = mid,
            minimumPoint = coordinates[mid];
        while (++mid < end) {
          var point = coordinates[mid];
          if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
            minimum = mid;
            minimumPoint = point;
          }
        }
        return minimum - start;
      }

      return topology;
    }

    // Given an array of arcs in absolute (but already quantized!) coordinates,
    // converts to fixed-point delta encoding.
    // This is a destructive operation that modifies the given arcs!
    function delta(arcs) {
      var i = -1,
          n = arcs.length;

      while (++i < n) {
        var arc = arcs[i],
            j = 0,
            k = 1,
            m = arc.length,
            point = arc[0],
            x0 = point[0],
            y0 = point[1],
            x1,
            y1;

        while (++j < m) {
          point = arc[j], x1 = point[0], y1 = point[1];
          if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
        }

        if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.

        arc.length = k;
      }

      return arcs;
    }

    // Extracts the lines and rings from the specified hash of geometry objects.
    //
    // Returns an object with three properties:
    //
    // * coordinates - shared buffer of [x, y] coordinates
    // * lines - lines extracted from the hash, of the form [start, end]
    // * rings - rings extracted from the hash, of the form [start, end]
    //
    // For each ring or line, start and end represent inclusive indexes into the
    // coordinates buffer. For rings (and closed lines), coordinates[start] equals
    // coordinates[end].
    //
    // For each line or polygon geometry in the input hash, including nested
    // geometries as in geometry collections, the `coordinates` array is replaced
    // with an equivalent `arcs` array that, for each line (for line string
    // geometries) or ring (for polygon geometries), points to one of the above
    // lines or rings.
    function extract(objects) {
      var index = -1,
          lines = [],
          rings = [],
          coordinates = [];

      function extractGeometry(geometry) {
        if (geometry && hasOwnProperty.call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
      }

      var extractGeometryType = {
        GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },
        LineString: function(o) { o.arcs = extractLine(o.arcs); },
        MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },
        Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },
        MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }
      };

      function extractLine(line) {
        for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];
        var arc = {0: index - n + 1, 1: index};
        lines.push(arc);
        return arc;
      }

      function extractRing(ring) {
        for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];
        var arc = {0: index - n + 1, 1: index};
        rings.push(arc);
        return arc;
      }

      function extractMultiRing(rings) {
        return rings.map(extractRing);
      }

      for (var key in objects) {
        extractGeometry(objects[key]);
      }

      return {
        type: "Topology",
        coordinates: coordinates,
        lines: lines,
        rings: rings,
        objects: objects
      };
    }

    // Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.
    // Any null input geometry objects are represented as {type: null} in the output.
    // Any feature.{id,properties,bbox} are transferred to the output geometry object.
    // Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!
    function geometry(inputs) {
      var outputs = {}, key;
      for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
      return outputs;
    }

    function geomifyObject(input) {
      return input == null ? {type: null}
          : (input.type === "FeatureCollection" ? geomifyFeatureCollection
          : input.type === "Feature" ? geomifyFeature
          : geomifyGeometry)(input);
    }

    function geomifyFeatureCollection(input) {
      var output = {type: "GeometryCollection", geometries: input.features.map(geomifyFeature)};
      if (input.bbox != null) output.bbox = input.bbox;
      return output;
    }

    function geomifyFeature(input) {
      var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars
      if (input.id != null) output.id = input.id;
      if (input.bbox != null) output.bbox = input.bbox;
      for (key in input.properties) { output.properties = input.properties; break; }
      return output;
    }

    function geomifyGeometry(input) {
      if (input == null) return {type: null};
      var output = input.type === "GeometryCollection" ? {type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry)}
          : input.type === "Point" || input.type === "MultiPoint" ? {type: input.type, coordinates: input.coordinates}
          : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?
      if (input.bbox != null) output.bbox = input.bbox;
      return output;
    }

    function prequantize(objects, bbox, n) {
      var x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3],
          kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,
          ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;

      function quantizePoint(input) {
        return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
      }

      function quantizePoints(input, m) {
        var i = -1,
            j = 0,
            n = input.length,
            output = new Array(n), // pessimistic
            pi,
            px,
            py,
            x,
            y;

        while (++i < n) {
          pi = input[i];
          x = Math.round((pi[0] - x0) * kx);
          y = Math.round((pi[1] - y0) * ky);
          if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points
        }

        output.length = j;
        while (j < m) j = output.push([output[0][0], output[0][1]]);
        return output;
      }

      function quantizeLine(input) {
        return quantizePoints(input, 2);
      }

      function quantizeRing(input) {
        return quantizePoints(input, 4);
      }

      function quantizePolygon(input) {
        return input.map(quantizeRing);
      }

      function quantizeGeometry(o) {
        if (o != null && hasOwnProperty.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
      }

      var quantizeGeometryType = {
        GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },
        Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },
        MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },
        LineString: function(o) { o.arcs = quantizeLine(o.arcs); },
        MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },
        Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },
        MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }
      };

      for (var key in objects) {
        quantizeGeometry(objects[key]);
      }

      return {
        scale: [1 / kx, 1 / ky],
        translate: [x0, y0]
      };
    }

    // Constructs the TopoJSON Topology for the specified hash of features.
    // Each object in the specified hash must be a GeoJSON object,
    // meaning FeatureCollection, a Feature or a geometry object.
    function topology(objects, quantization) {
      var bbox = bounds(objects = geometry(objects)),
          transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),
          topology = dedup(cut(extract(objects))),
          coordinates = topology.coordinates,
          indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);

      objects = topology.objects; // for garbage collection
      topology.bbox = bbox;
      topology.arcs = topology.arcs.map(function(arc, i) {
        indexByArc.set(arc, i);
        return coordinates.slice(arc[0], arc[1] + 1);
      });

      delete topology.coordinates;
      coordinates = null;

      function indexGeometry(geometry) {
        if (geometry && hasOwnProperty.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
      }

      var indexGeometryType = {
        GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },
        LineString: function(o) { o.arcs = indexArcs(o.arcs); },
        MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },
        Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },
        MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }
      };

      function indexArcs(arc) {
        var indexes = [];
        do {
          var index = indexByArc.get(arc);
          indexes.push(arc[0] < arc[1] ? index : ~index);
        } while (arc = arc.next);
        return indexes;
      }

      function indexMultiArcs(arcs) {
        return arcs.map(indexArcs);
      }

      for (var key in objects) {
        indexGeometry(objects[key]);
      }

      if (transform) {
        topology.transform = transform;
        topology.arcs = delta(topology.arcs);
      }

      return topology;
    }

    function hashArc(arc) {
      var i = arc[0], j = arc[1], t;
      if (j < i) t = i, i = j, j = t;
      return i + 31 * j;
    }

    function equalArc(arcA, arcB) {
      var ia = arcA[0], ja = arcA[1],
          ib = arcB[0], jb = arcB[1], t;
      if (ja < ia) t = ia, ia = ja, ja = t;
      if (jb < ib) t = ib, ib = jb, jb = t;
      return ia === ib && ja === jb;
    }

    /**
     * Dissolves all overlapping (Multi)Polygon
     *
     * @param {FeatureCollection<Polygon|MultiPolygon>} geojson Polygons to dissolve
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.mutate=false] Prevent input mutation
     * @returns {Feature<Polygon|MultiPolygon>} Dissolved Polygons
     */
    function polygonDissolve(geojson, options) {
        if (options === void 0) { options = {}; }
        // Validation
        if (getType$1(geojson) !== "FeatureCollection") {
            throw new Error("geojson must be a FeatureCollection");
        }
        if (!geojson.features.length) {
            throw new Error("geojson is empty");
        }
        // Clone geojson to avoid side effects
        // Topojson modifies in place, so we need to deep clone first
        if (options.mutate === false || options.mutate === undefined) {
            geojson = clone(geojson);
        }
        var geoms = [];
        flattenEach$1(geojson, function (feature) {
            geoms.push(feature.geometry);
        });
        var topo = topology({ geoms: geometryCollection(geoms).geometry });
        var merged = merge$2(topo, topo.objects.geoms.geometries);
        return merged;
    }

    /**
     * Transform function: attempts to dissolve geojson objects where possible
     * [GeoJSON] -> GeoJSON geometry
     *
     * @private
     * @param {FeatureCollection<LineString|MultiLineString|Polygon|MultiPolygon>} geojson Features to dissolved
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.mutate=false] Prevent input mutation
     * @returns {Feature<MultiLineString|MultiPolygon>} Dissolved Features
     */
    function dissolve$1(geojson, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        options = options || {};
        if (!isObject(options)) {
            throw new Error("options is invalid");
        }
        var mutate = options.mutate;
        // Validation
        if (getType$1(geojson) !== "FeatureCollection") {
            throw new Error("geojson must be a FeatureCollection");
        }
        if (!geojson.features.length) {
            throw new Error("geojson is empty");
        }
        // Clone geojson to avoid side effects
        // Topojson modifies in place, so we need to deep clone first
        if (mutate === false || mutate === undefined) {
            geojson = clone(geojson);
        }
        // Assert homogenity
        var type = getHomogenousType(geojson);
        if (!type) {
            throw new Error("geojson must be homogenous");
        }
        // Data => Typescript hack
        var data = geojson;
        switch (type) {
            case "LineString":
                return lineDissolve(data, options);
            case "Polygon":
                return polygonDissolve(data, options);
            default:
                throw new Error(type + " is not supported");
        }
    }
    /**
     * Checks if GeoJSON is Homogenous
     *
     * @private
     * @param {GeoJSON} geojson GeoJSON
     * @returns {string|null} Homogenous type or null if multiple types
     */
    function getHomogenousType(geojson) {
        var types = {};
        flattenEach$1(geojson, function (feature) {
            types[feature.geometry.type] = true;
        });
        var keys = Object.keys(types);
        if (keys.length === 1) {
            return keys[0];
        }
        return null;
    }

    /**
     * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.
     * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.
     *
     * @name concave
     * @param {FeatureCollection<Point>} points input points
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.maxEdge=Infinity] the length (in 'units') of an edge necessary for part of the
     * hull to become concave.
     * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
     * @returns {Feature<(Polygon|MultiPolygon)>|null} a concave hull (null value is returned if unable to compute hull)
     * @example
     * var points = turf.featureCollection([
     *   turf.point([-63.601226, 44.642643]),
     *   turf.point([-63.591442, 44.651436]),
     *   turf.point([-63.580799, 44.648749]),
     *   turf.point([-63.573589, 44.641788]),
     *   turf.point([-63.587665, 44.64533]),
     *   turf.point([-63.595218, 44.64765])
     * ]);
     * var options = {units: 'miles', maxEdge: 1};
     *
     * var hull = turf.concave(points, options);
     *
     * //addToMap
     * var addToMap = [points, hull]
     */
    function concave(points, options) {
        if (options === void 0) { options = {}; }
        var maxEdge = options.maxEdge || Infinity;
        var cleaned = removeDuplicates(points);
        var tinPolys = tin(cleaned);
        // calculate length of all edges and area of all triangles
        // and remove triangles that fail the max length test
        tinPolys.features = tinPolys.features.filter(function (triangle) {
            var pt1 = triangle.geometry.coordinates[0][0];
            var pt2 = triangle.geometry.coordinates[0][1];
            var pt3 = triangle.geometry.coordinates[0][2];
            var dist1 = distance$1(pt1, pt2, options);
            var dist2 = distance$1(pt2, pt3, options);
            var dist3 = distance$1(pt1, pt3, options);
            return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
        });
        if (tinPolys.features.length < 1) {
            return null;
        }
        // merge the adjacent triangles
        var dissolved = dissolve$1(tinPolys);
        // geojson-dissolve always returns a MultiPolygon
        if (dissolved.coordinates.length === 1) {
            dissolved.coordinates = dissolved.coordinates[0];
            dissolved.type = "Polygon";
        }
        return feature(dissolved);
    }
    /**
     * Removes duplicated points in a collection returning a new collection
     *
     * @private
     * @param {FeatureCollection<Point>} points to be cleaned
     * @returns {FeatureCollection<Point>} cleaned set of points
     */
    function removeDuplicates(points) {
        var cleaned = [];
        var existing = {};
        featureEach$2(points, function (pt) {
            if (!pt.geometry) {
                return;
            }
            var key = pt.geometry.coordinates.join("-");
            if (!Object.prototype.hasOwnProperty.call(existing, key)) {
                cleaned.push(pt);
                existing[key] = true;
            }
        });
        return featureCollection$1(cleaned);
    }

    var quickselect = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
    	module.exports = factory() ;
    }(commonjsGlobal, (function () {
    function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
    }

    function quickselectStep(arr, k, left, right, compare) {

        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                quickselectStep(arr, k, newLeft, newRight, compare);
            }

            var t = arr[k];
            var i = left;
            var j = right;

            swap(arr, left, k);
            if (compare(arr[right], t) > 0) swap(arr, left, right);

            while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) i++;
                while (compare(arr[j], t) > 0) j--;
            }

            if (compare(arr[left], t) === 0) swap(arr, left, j);
            else {
                j++;
                swap(arr, j, right);
            }

            if (j <= k) left = j + 1;
            if (k <= j) right = j - 1;
        }
    }

    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

    return quickselect;

    })));
    });

    var rbush_1 = rbush;
    var _default$3 = rbush;



    function rbush(maxEntries, format) {
        if (!(this instanceof rbush)) return new rbush(maxEntries, format);

        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

        if (format) {
            this._initFormat(format);
        }

        this.clear();
    }

    rbush.prototype = {

        all: function () {
            return this._all(this.data, []);
        },

        search: function (bbox) {

            var node = this.data,
                result = [],
                toBBox = this.toBBox;

            if (!intersects$2(bbox, node)) return result;

            var nodesToSearch = [],
                i, len, child, childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects$2(bbox, childBBox)) {
                        if (node.leaf) result.push(child);
                        else if (contains(bbox, childBBox)) this._all(child, result);
                        else nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return result;
        },

        collides: function (bbox) {

            var node = this.data,
                toBBox = this.toBBox;

            if (!intersects$2(bbox, node)) return false;

            var nodesToSearch = [],
                i, len, child, childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects$2(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox)) return true;
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return false;
        },

        load: function (data) {
            if (!(data && data.length)) return this;

            if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                }
                return this;
            }

            // recursively build the tree with the given data from scratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);

            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;

            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this._splitRoot(this.data, node);

            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }

                // insert the small tree into the large tree at appropriate level
                this._insert(node, this.data.height - node.height - 1, true);
            }

            return this;
        },

        insert: function (item) {
            if (item) this._insert(item, this.data.height - 1);
            return this;
        },

        clear: function () {
            this.data = createNode([]);
            return this;
        },

        remove: function (item, equalsFn) {
            if (!item) return this;

            var node = this.data,
                bbox = this.toBBox(item),
                path = [],
                indexes = [],
                i, parent, index, goingUp;

            // depth-first iterative tree traversal
            while (node || path.length) {

                if (!node) { // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }

                if (node.leaf) { // check current node
                    index = findItem(item, node.children, equalsFn);

                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this._condense(path);
                        return this;
                    }
                }

                if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];

                } else if (parent) { // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;

                } else node = null; // nothing found
            }

            return this;
        },

        toBBox: function (item) { return item; },

        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,

        toJSON: function () { return this.data; },

        fromJSON: function (data) {
            this.data = data;
            return this;
        },

        _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
                if (node.leaf) result.push.apply(result, node.children);
                else nodesToSearch.push.apply(nodesToSearch, node.children);

                node = nodesToSearch.pop();
            }
            return result;
        },

        _build: function (items, left, right, height) {

            var N = right - left + 1,
                M = this._maxEntries,
                node;

            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }

            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));

                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }

            node = createNode([]);
            node.leaf = false;
            node.height = height;

            // split the items into M mostly square tiles

            var N2 = Math.ceil(N / M),
                N1 = N2 * Math.ceil(Math.sqrt(M)),
                i, j, right2, right3;

            multiSelect(items, left, right, N1, this.compareMinX);

            for (i = left; i <= right; i += N1) {

                right2 = Math.min(i + N1 - 1, right);

                multiSelect(items, i, right2, N2, this.compareMinY);

                for (j = i; j <= right2; j += N2) {

                    right3 = Math.min(j + N2 - 1, right2);

                    // pack each entry recursively
                    node.children.push(this._build(items, j, right3, height - 1));
                }
            }

            calcBBox(node, this.toBBox);

            return node;
        },

        _chooseSubtree: function (bbox, node, level, path) {

            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

            while (true) {
                path.push(node);

                if (node.leaf || path.length - 1 === level) break;

                minArea = minEnlargement = Infinity;

                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;

                    // choose entry with the least area enlargement
                    if (enlargement < minEnlargement) {
                        minEnlargement = enlargement;
                        minArea = area < minArea ? area : minArea;
                        targetNode = child;

                    } else if (enlargement === minEnlargement) {
                        // otherwise choose one with the smallest area
                        if (area < minArea) {
                            minArea = area;
                            targetNode = child;
                        }
                    }
                }

                node = targetNode || node.children[0];
            }

            return node;
        },

        _insert: function (item, level, isNode) {

            var toBBox = this.toBBox,
                bbox = isNode ? item : toBBox(item),
                insertPath = [];

            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);

            // put the item into the node
            node.children.push(item);
            extend(node, bbox);

            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                } else break;
            }

            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
        },

        // split overflowed node into two
        _split: function (insertPath, level) {

            var node = insertPath[level],
                M = node.children.length,
                m = this._minEntries;

            this._chooseSplitAxis(node, m, M);

            var splitIndex = this._chooseSplitIndex(node, m, M);

            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;

            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);

            if (level) insertPath[level - 1].children.push(newNode);
            else this._splitRoot(node, newNode);
        },

        _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        },

        _chooseSplitIndex: function (node, m, M) {

            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

            minOverlap = minArea = Infinity;

            for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);

                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);

                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;

                    minArea = area < minArea ? area : minArea;

                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }

            return index;
        },

        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {

            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                xMargin = this._allDistMargin(node, m, M, compareMinX),
                yMargin = this._allDistMargin(node, m, M, compareMinY);

            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
        },

        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {

            node.children.sort(compare);

            var toBBox = this.toBBox,
                leftBBox = distBBox(node, 0, m, toBBox),
                rightBBox = distBBox(node, M - m, M, toBBox),
                margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                i, child;

            for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }

            for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
            }

            return margin;
        },

        _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
            }
        },

        _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);

                    } else this.clear();

                } else calcBBox(path[i], this.toBBox);
            }
        },

        _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)

            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls

            var compareArr = ['return a', ' - b', ';'];

            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

            this.toBBox = new Function('a',
                'return {minX: a' + format[0] +
                ', minY: a' + format[1] +
                ', maxX: a' + format[2] +
                ', maxY: a' + format[3] + '};');
        }
    };

    function findItem(item, items, equalsFn) {
        if (!equalsFn) return items.indexOf(item);

        for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i])) return i;
        }
        return -1;
    }

    // calculate node's bbox from bboxes of its children
    function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
    }

    // min bounding rectangle of node children from k to p-1
    function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;

        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend(destNode, node.leaf ? toBBox(child) : child);
        }

        return destNode;
    }

    function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
    }

    function compareNodeMinX(a, b) { return a.minX - b.minX; }
    function compareNodeMinY(a, b) { return a.minY - b.minY; }

    function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
    function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

    function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
               (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX),
            minY = Math.max(a.minY, b.minY),
            maxX = Math.min(a.maxX, b.maxX),
            maxY = Math.min(a.maxY, b.maxY);

        return Math.max(0, maxX - minX) *
               Math.max(0, maxY - minY);
    }

    function contains(a, b) {
        return a.minX <= b.minX &&
               a.minY <= b.minY &&
               b.maxX <= a.maxX &&
               b.maxY <= a.maxY;
    }

    function intersects$2(a, b) {
        return b.minX <= a.maxX &&
               b.minY <= a.maxY &&
               b.maxX >= a.minX &&
               b.maxY >= a.minY;
    }

    function createNode(children) {
        return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }

    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach

    function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right],
            mid;

        while (stack.length) {
            right = stack.pop();
            left = stack.pop();

            if (right - left <= n) continue;

            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);

            stack.push(left, mid, mid, right);
        }
    }
    rbush_1.default = _default$3;

    /**
     * Merges a specified property from a FeatureCollection of points into a
     * FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty`
     * for polygons, this finds every point that lies within each polygon, collects the
     * `inProperty` values from those points, and adds them as an array to `outProperty`
     * on the polygon.
     *
     * @name collect
     * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate
     * @param {FeatureCollection<Point>} points points to be aggregated
     * @param {string} inProperty property to be nested from
     * @param {string} outProperty property to be nested into
     * @returns {FeatureCollection<Polygon>} polygons with properties listed based on `outField`
     * @example
     * var poly1 = turf.polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);
     * var poly2 = turf.polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);
     * var polyFC = turf.featureCollection([poly1, poly2]);
     * var pt1 = turf.point([5,5], {population: 200});
     * var pt2 = turf.point([1,3], {population: 600});
     * var pt3 = turf.point([14,2], {population: 100});
     * var pt4 = turf.point([13,1], {population: 200});
     * var pt5 = turf.point([19,7], {population: 300});
     * var pointFC = turf.featureCollection([pt1, pt2, pt3, pt4, pt5]);
     * var collected = turf.collect(polyFC, pointFC, 'population', 'values');
     * var values = collected.features[0].properties.values
     * //=values => [200, 600]
     *
     * //addToMap
     * var addToMap = [pointFC, collected]
     */
    function collect(polygons, points, inProperty, outProperty) {
        var rtree = rbush_1(6);
        var treeItems = points.features.map(function (item) {
            var _a;
            return {
                minX: item.geometry.coordinates[0],
                minY: item.geometry.coordinates[1],
                maxX: item.geometry.coordinates[0],
                maxY: item.geometry.coordinates[1],
                property: (_a = item.properties) === null || _a === void 0 ? void 0 : _a[inProperty],
            };
        });
        rtree.load(treeItems);
        polygons.features.forEach(function (poly) {
            if (!poly.properties) {
                poly.properties = {};
            }
            var bbox = bbox$2(poly);
            var potentialPoints = rtree.search({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
            });
            var values = [];
            potentialPoints.forEach(function (pt) {
                if (booleanPointInPolygon([pt.minX, pt.minY], poly)) {
                    values.push(pt.property);
                }
            });
            poly.properties[outProperty] = values;
        });
        return polygons;
    }

    /**
     * Takes input features and flips all of their coordinates from `[x, y]` to `[y, x]`.
     *
     * @name flip
     * @param {GeoJSON} geojson input features
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} a feature or set of features of the same type as `input` with flipped coordinates
     * @example
     * var serbia = turf.point([20.566406, 43.421008]);
     *
     * var saudiArabia = turf.flip(serbia);
     *
     * //addToMap
     * var addToMap = [serbia, saudiArabia];
     */
    function flip$1(geojson, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var mutate = options.mutate;

      if (!geojson) throw new Error("geojson is required");
      // ensure that we don't modify features in-place and changes to the
      // output do not change the previous feature, including changes to nested
      // properties.
      if (mutate === false || mutate === undefined) geojson = clone(geojson);

      coordEach$1(geojson, function (coord) {
        var x = coord[0];
        var y = coord[1];
        coord[0] = y;
        coord[1] = x;
      });
      return geojson;
    }

    // To-Do => Improve Typescript GeoJSON handling
    /**
     * Removes redundant coordinates from any GeoJSON Geometry.
     *
     * @name cleanCoords
     * @param {Geometry|Feature} geojson Feature or Geometry
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated
     * @returns {Geometry|Feature} the cleaned input Feature/Geometry
     * @example
     * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);
     * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);
     *
     * turf.cleanCoords(line).geometry.coordinates;
     * //= [[0, 0], [0, 10]]
     *
     * turf.cleanCoords(multiPoint).geometry.coordinates;
     * //= [[0, 0], [2, 2]]
     */
    function cleanCoords(geojson, options) {
        if (options === void 0) { options = {}; }
        // Backwards compatible with v4.0
        var mutate = typeof options === "object" ? options.mutate : options;
        if (!geojson)
            throw new Error("geojson is required");
        var type = getType$1(geojson);
        // Store new "clean" points in this Array
        var newCoords = [];
        switch (type) {
            case "LineString":
                newCoords = cleanLine(geojson);
                break;
            case "MultiLineString":
            case "Polygon":
                getCoords(geojson).forEach(function (line) {
                    newCoords.push(cleanLine(line));
                });
                break;
            case "MultiPolygon":
                getCoords(geojson).forEach(function (polygons) {
                    var polyPoints = [];
                    polygons.forEach(function (ring) {
                        polyPoints.push(cleanLine(ring));
                    });
                    newCoords.push(polyPoints);
                });
                break;
            case "Point":
                return geojson;
            case "MultiPoint":
                var existing = {};
                getCoords(geojson).forEach(function (coord) {
                    var key = coord.join("-");
                    if (!Object.prototype.hasOwnProperty.call(existing, key)) {
                        newCoords.push(coord);
                        existing[key] = true;
                    }
                });
                break;
            default:
                throw new Error(type + " geometry not supported");
        }
        // Support input mutation
        if (geojson.coordinates) {
            if (mutate === true) {
                geojson.coordinates = newCoords;
                return geojson;
            }
            return { type: type, coordinates: newCoords };
        }
        else {
            if (mutate === true) {
                geojson.geometry.coordinates = newCoords;
                return geojson;
            }
            return feature({ type: type, coordinates: newCoords }, geojson.properties, {
                bbox: geojson.bbox,
                id: geojson.id,
            });
        }
    }
    /**
     * Clean Coords
     *
     * @private
     * @param {Array<number>|LineString} line Line
     * @returns {Array<number>} Cleaned coordinates
     */
    function cleanLine(line) {
        var points = getCoords(line);
        // handle "clean" segment
        if (points.length === 2 && !equals$1(points[0], points[1]))
            return points;
        var newPoints = [];
        var secondToLast = points.length - 1;
        var newPointsLength = newPoints.length;
        newPoints.push(points[0]);
        for (var i = 1; i < secondToLast; i++) {
            var prevAddedPoint = newPoints[newPoints.length - 1];
            if (points[i][0] === prevAddedPoint[0] &&
                points[i][1] === prevAddedPoint[1])
                continue;
            else {
                newPoints.push(points[i]);
                newPointsLength = newPoints.length;
                if (newPointsLength > 2) {
                    if (isPointOnLineSegment$3(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
                        newPoints.splice(newPoints.length - 2, 1);
                }
            }
        }
        newPoints.push(points[points.length - 1]);
        newPointsLength = newPoints.length;
        if (equals$1(points[0], points[points.length - 1]) && newPointsLength < 4)
            throw new Error("invalid polygon");
        if (isPointOnLineSegment$3(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
            newPoints.splice(newPoints.length - 2, 1);
        return newPoints;
    }
    /**
     * Compares two points and returns if they are equals
     *
     * @private
     * @param {Position} pt1 point
     * @param {Position} pt2 point
     * @returns {boolean} true if they are equals
     */
    function equals$1(pt1, pt2) {
        return pt1[0] === pt2[0] && pt1[1] === pt2[1];
    }
    /**
     * Returns if `point` is on the segment between `start` and `end`.
     * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)
     *
     * @private
     * @param {Position} start coord pair of start of line
     * @param {Position} end coord pair of end of line
     * @param {Position} point coord pair of point to check
     * @returns {boolean} true/false
     */
    function isPointOnLineSegment$3(start, end, point) {
        var x = point[0], y = point[1];
        var startX = start[0], startY = start[1];
        var endX = end[0], endY = end[1];
        var dxc = x - startX;
        var dyc = y - startY;
        var dxl = endX - startX;
        var dyl = endY - startY;
        var cross = dxc * dyl - dyc * dxl;
        if (cross !== 0)
            return false;
        else if (Math.abs(dxl) >= Math.abs(dyl))
            return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
        else
            return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
    }

    /*
     (c) 2013, Vladimir Agafonkin
     Simplify.js, a high-performance JS polyline simplification library
     mourner.github.io/simplify-js
    */

    // to suit your point format, run search/replace for '.x' and '.y';
    // for 3D version, see 3d branch (configurability would draw significant performance overhead)

    // square distance between 2 points
    function getSqDist(p1, p2) {
      var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

      return dx * dx + dy * dy;
    }

    // square distance from a point to a segment
    function getSqSegDist(p, p1, p2) {
      var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

      if (dx !== 0 || dy !== 0) {
        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }

      dx = p.x - x;
      dy = p.y - y;

      return dx * dx + dy * dy;
    }
    // rest of the code doesn't care about point format

    // basic distance-based simplification
    function simplifyRadialDist(points, sqTolerance) {
      var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

      for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }

      if (prevPoint !== point) newPoints.push(point);

      return newPoints;
    }

    function simplifyDPStep(points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance,
        index;

      for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        if (index - first > 1)
          simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1)
          simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    }

    // simplification using Ramer-Douglas-Peucker algorithm
    function simplifyDouglasPeucker(points, sqTolerance) {
      var last = points.length - 1;

      var simplified = [points[0]];
      simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);

      return simplified;
    }

    // both algorithms combined for awesome performance
    function simplify(points, tolerance, highestQuality) {
      if (points.length <= 2) return points;

      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
      points = simplifyDouglasPeucker(points, sqTolerance);

      return points;
    }

    /**
     * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses
     * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.
     *
     * @name simplify
     * @param {GeoJSON} geojson object to be simplified
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.tolerance=1] simplification tolerance
     * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} a simplified GeoJSON
     * @example
     * var geojson = turf.polygon([[
     *   [-70.603637, -33.399918],
     *   [-70.614624, -33.395332],
     *   [-70.639343, -33.392466],
     *   [-70.659942, -33.394759],
     *   [-70.683975, -33.404504],
     *   [-70.697021, -33.419406],
     *   [-70.701141, -33.434306],
     *   [-70.700454, -33.446339],
     *   [-70.694274, -33.458369],
     *   [-70.682601, -33.465816],
     *   [-70.668869, -33.472117],
     *   [-70.646209, -33.473835],
     *   [-70.624923, -33.472117],
     *   [-70.609817, -33.468107],
     *   [-70.595397, -33.458369],
     *   [-70.587158, -33.442901],
     *   [-70.587158, -33.426283],
     *   [-70.590591, -33.414248],
     *   [-70.594711, -33.406224],
     *   [-70.603637, -33.399918]
     * ]]);
     * var options = {tolerance: 0.01, highQuality: false};
     * var simplified = turf.simplify(geojson, options);
     *
     * //addToMap
     * var addToMap = [geojson, simplified]
     */
    function simplify$1(geojson, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var tolerance = options.tolerance !== undefined ? options.tolerance : 1;
      var highQuality = options.highQuality || false;
      var mutate = options.mutate || false;

      if (!geojson) throw new Error("geojson is required");
      if (tolerance && tolerance < 0) throw new Error("invalid tolerance");

      // Clone geojson to avoid side effects
      if (mutate !== true) geojson = clone(geojson);

      geomEach$1(geojson, function (geom) {
        simplifyGeom(geom, tolerance, highQuality);
      });
      return geojson;
    }

    /**
     * Simplifies a feature's coordinates
     *
     * @private
     * @param {Geometry} geometry to be simplified
     * @param {number} [tolerance=1] simplification tolerance
     * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm
     * @returns {Geometry} output
     */
    function simplifyGeom(geometry, tolerance, highQuality) {
      var type = geometry.type;

      // "unsimplyfiable" geometry types
      if (type === "Point" || type === "MultiPoint") return geometry;

      // Remove any extra coordinates
      cleanCoords(geometry, true);

      var coordinates = geometry.coordinates;
      switch (type) {
        case "LineString":
          geometry["coordinates"] = simplifyLine(
            coordinates,
            tolerance,
            highQuality
          );
          break;
        case "MultiLineString":
          geometry["coordinates"] = coordinates.map(function (lines) {
            return simplifyLine(lines, tolerance, highQuality);
          });
          break;
        case "Polygon":
          geometry["coordinates"] = simplifyPolygon(
            coordinates,
            tolerance,
            highQuality
          );
          break;
        case "MultiPolygon":
          geometry["coordinates"] = coordinates.map(function (rings) {
            return simplifyPolygon(rings, tolerance, highQuality);
          });
      }
      return geometry;
    }

    /**
     * Simplifies the coordinates of a LineString with simplify-js
     *
     * @private
     * @param {Array<number>} coordinates to be processed
     * @param {number} tolerance simplification tolerance
     * @param {boolean} highQuality whether or not to spend more time to create a higher-quality
     * @returns {Array<Array<number>>} simplified coords
     */
    function simplifyLine(coordinates, tolerance, highQuality) {
      return simplify(
        coordinates.map(function (coord) {
          return { x: coord[0], y: coord[1], z: coord[2] };
        }),
        tolerance,
        highQuality
      ).map(function (coords) {
        return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
      });
    }

    /**
     * Simplifies the coordinates of a Polygon with simplify-js
     *
     * @private
     * @param {Array<number>} coordinates to be processed
     * @param {number} tolerance simplification tolerance
     * @param {boolean} highQuality whether or not to spend more time to create a higher-quality
     * @returns {Array<Array<Array<number>>>} simplified coords
     */
    function simplifyPolygon(coordinates, tolerance, highQuality) {
      return coordinates.map(function (ring) {
        var pts = ring.map(function (coord) {
          return { x: coord[0], y: coord[1] };
        });
        if (pts.length < 4) {
          throw new Error("invalid polygon");
        }
        var simpleRing = simplify(pts, tolerance, highQuality).map(function (
          coords
        ) {
          return [coords.x, coords.y];
        });
        //remove 1 percent of tolerance until enough points to make a triangle
        while (!checkValidity(simpleRing)) {
          tolerance -= tolerance * 0.01;
          simpleRing = simplify(pts, tolerance, highQuality).map(function (
            coords
          ) {
            return [coords.x, coords.y];
          });
        }
        if (
          simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||
          simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]
        ) {
          simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
      });
    }

    /**
     * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last
     *
     * @private
     * @param {Array<number>} ring coordinates to be checked
     * @returns {boolean} true if valid
     */
    function checkValidity(ring) {
      if (ring.length < 3) return false;
      //if the last point is the same as the first, it's not a triangle
      return !(
        ring.length === 3 &&
        ring[2][0] === ring[0][0] &&
        ring[2][1] === ring[0][1]
      );
    }

    /**
     * BezierSpline
     * https://github.com/leszekr/bezier-spline-js
     *
     * @private
     * @copyright
     * Copyright (c) 2013 Leszek Rybicki
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    var Spline = /** @class */ (function () {
        function Spline(options) {
            this.points = options.points || [];
            this.duration = options.duration || 10000;
            this.sharpness = options.sharpness || 0.85;
            this.centers = [];
            this.controls = [];
            this.stepLength = options.stepLength || 60;
            this.length = this.points.length;
            this.delay = 0;
            // this is to ensure compatibility with the 2d version
            for (var i = 0; i < this.length; i++) {
                this.points[i].z = this.points[i].z || 0;
            }
            for (var i = 0; i < this.length - 1; i++) {
                var p1 = this.points[i];
                var p2 = this.points[i + 1];
                this.centers.push({
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2,
                    z: (p1.z + p2.z) / 2,
                });
            }
            this.controls.push([this.points[0], this.points[0]]);
            for (var i = 0; i < this.centers.length - 1; i++) {
                var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
                var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
                var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
                this.controls.push([
                    {
                        x: (1.0 - this.sharpness) * this.points[i + 1].x +
                            this.sharpness * (this.centers[i].x + dx),
                        y: (1.0 - this.sharpness) * this.points[i + 1].y +
                            this.sharpness * (this.centers[i].y + dy),
                        z: (1.0 - this.sharpness) * this.points[i + 1].z +
                            this.sharpness * (this.centers[i].z + dz),
                    },
                    {
                        x: (1.0 - this.sharpness) * this.points[i + 1].x +
                            this.sharpness * (this.centers[i + 1].x + dx),
                        y: (1.0 - this.sharpness) * this.points[i + 1].y +
                            this.sharpness * (this.centers[i + 1].y + dy),
                        z: (1.0 - this.sharpness) * this.points[i + 1].z +
                            this.sharpness * (this.centers[i + 1].z + dz),
                    },
                ]);
            }
            this.controls.push([
                this.points[this.length - 1],
                this.points[this.length - 1],
            ]);
            this.steps = this.cacheSteps(this.stepLength);
            return this;
        }
        /**
         * Caches an array of equidistant (more or less) points on the curve.
         */
        Spline.prototype.cacheSteps = function (mindist) {
            var steps = [];
            var laststep = this.pos(0);
            steps.push(0);
            for (var t = 0; t < this.duration; t += 10) {
                var step = this.pos(t);
                var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) +
                    (step.y - laststep.y) * (step.y - laststep.y) +
                    (step.z - laststep.z) * (step.z - laststep.z));
                if (dist > mindist) {
                    steps.push(t);
                    laststep = step;
                }
            }
            return steps;
        };
        /**
         * returns angle and speed in the given point in the curve
         */
        Spline.prototype.vector = function (t) {
            var p1 = this.pos(t + 10);
            var p2 = this.pos(t - 10);
            return {
                angle: (180 * Math.atan2(p1.y - p2.y, p1.x - p2.x)) / 3.14,
                speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) +
                    (p2.y - p1.y) * (p2.y - p1.y) +
                    (p2.z - p1.z) * (p2.z - p1.z)),
            };
        };
        /**
         * Gets the position of the point, given time.
         *
         * WARNING: The speed is not constant. The time it takes between control points is constant.
         *
         * For constant speed, use Spline.steps[i];
         */
        Spline.prototype.pos = function (time) {
            var t = time - this.delay;
            if (t < 0) {
                t = 0;
            }
            if (t > this.duration) {
                t = this.duration - 1;
            }
            // t = t-this.delay;
            var t2 = t / this.duration;
            if (t2 >= 1) {
                return this.points[this.length - 1];
            }
            var n = Math.floor((this.points.length - 1) * t2);
            var t1 = (this.length - 1) * t2 - n;
            return bezier$1(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
        };
        return Spline;
    }());
    function bezier$1(t, p1, c1, c2, p2) {
        var b = B(t);
        var pos = {
            x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
            y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
            z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3],
        };
        return pos;
    }
    function B(t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return [
            t3,
            3 * t2 * (1 - t),
            3 * t * (1 - t) * (1 - t),
            (1 - t) * (1 - t) * (1 - t),
        ];
    }

    /**
     * Takes a {@link LineString|line} and returns a curved version
     * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)
     * algorithm.
     *
     * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).
     *
     * @name bezierSpline
     * @param {Feature<LineString>} line input LineString
     * @param {Object} [options={}] Optional parameters
     * @param {Object} [options.properties={}] Translate properties to output
     * @param {number} [options.resolution=10000] time in milliseconds between points
     * @param {number} [options.sharpness=0.85] a measure of how curvy the path should be between splines
     * @returns {Feature<LineString>} curved line
     * @example
     * var line = turf.lineString([
     *   [-76.091308, 18.427501],
     *   [-76.695556, 18.729501],
     *   [-76.552734, 19.40443],
     *   [-74.61914, 19.134789],
     *   [-73.652343, 20.07657],
     *   [-73.157958, 20.210656]
     * ]);
     *
     * var curved = turf.bezierSpline(line);
     *
     * //addToMap
     * var addToMap = [line, curved]
     * curved.properties = { stroke: '#0F0' };
     */
    function bezier(line, options) {
        if (options === void 0) { options = {}; }
        // Optional params
        var resolution = options.resolution || 10000;
        var sharpness = options.sharpness || 0.85;
        var coords = [];
        var points = getGeom(line).coordinates.map(function (pt) {
            return { x: pt[0], y: pt[1] };
        });
        var spline = new Spline({
            duration: resolution,
            points: points,
            sharpness: sharpness,
        });
        var pushCoord = function (time) {
            var pos = spline.pos(time);
            if (Math.floor(time / 100) % 2 === 0) {
                coords.push([pos.x, pos.y]);
            }
        };
        for (var i = 0; i < spline.duration; i += 10) {
            pushCoord(i);
        }
        pushCoord(spline.duration);
        return lineString(coords, options.properties);
    }

    /**
     * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and/or {@link MultiPolygon|multipolygons} and performs a spatial join.
     *
     * @name tag
     * @param {FeatureCollection<Point>} points input points
     * @param {FeatureCollection<Polygon|MultiPolygon>} polygons input (multi)polygons
     * @param {string} field property in `polygons` to add to joined {<Point>} features
     * @param {string} outField property in `points` in which to store joined property from `polygons`
     * @returns {FeatureCollection<Point>} points with `containingPolyId` property containing values from `polyId`
     * @example
     * var pt1 = turf.point([-77, 44]);
     * var pt2 = turf.point([-77, 38]);
     * var poly1 = turf.polygon([[
     *   [-81, 41],
     *   [-81, 47],
     *   [-72, 47],
     *   [-72, 41],
     *   [-81, 41]
     * ]], {pop: 3000});
     * var poly2 = turf.polygon([[
     *   [-81, 35],
     *   [-81, 41],
     *   [-72, 41],
     *   [-72, 35],
     *   [-81, 35]
     * ]], {pop: 1000});
     *
     * var points = turf.featureCollection([pt1, pt2]);
     * var polygons = turf.featureCollection([poly1, poly2]);
     *
     * var tagged = turf.tag(points, polygons, 'pop', 'population');
     *
     * //addToMap
     * var addToMap = [tagged, polygons]
     */
    function tag(points, polygons, field, outField) {
      // prevent mutations
      points = clone(points);
      polygons = clone(polygons);
      featureEach$2(points, function (pt) {
        if (!pt.properties) pt.properties = {};
        featureEach$2(polygons, function (poly) {
          if (pt.properties[outField] === undefined) {
            if (booleanPointInPolygon(pt, poly))
              pt.properties[outField] = poly.properties[field];
          }
        });
      });
      return points;
    }

    // http://stackoverflow.com/questions/11935175/sampling-a-random-subset-from-an-array

    /**
     * Takes a {@link FeatureCollection} and returns a FeatureCollection with given number of {@link Feature|features} at random.
     *
     * @name sample
     * @param {FeatureCollection} featurecollection set of input features
     * @param {number} num number of features to select
     * @returns {FeatureCollection} a FeatureCollection with `n` features
     * @example
     * var points = turf.randomPoint(100, {bbox: [-80, 30, -60, 60]});
     *
     * var sample = turf.sample(points, 5);
     *
     * //addToMap
     * var addToMap = [points, sample]
     * turf.featureEach(sample, function (currentFeature) {
     *   currentFeature.properties['marker-size'] = 'large';
     *   currentFeature.properties['marker-color'] = '#000';
     * });
     */
    function sample(featurecollection, num) {
      if (!featurecollection) throw new Error("featurecollection is required");
      if (num === null || num === undefined) throw new Error("num is required");
      if (typeof num !== "number") throw new Error("num must be a number");

      var outFC = featureCollection$1(
        getRandomSubarray(featurecollection.features, num)
      );
      return outFC;
    }

    function getRandomSubarray(arr, size) {
      var shuffled = arr.slice(0),
        i = arr.length,
        min = i - size,
        temp,
        index;
      while (i-- > min) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
      }
      return shuffled.slice(min);
    }

    /**
     * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
     *
     * @name bboxPolygon
     * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
     * @param {Object} [options={}] Optional parameters
     * @param {Properties} [options.properties={}] Translate properties to Polygon
     * @param {string|number} [options.id={}] Translate Id to Polygon
     * @returns {Feature<Polygon>} a Polygon representation of the bounding box
     * @example
     * var bbox = [0, 0, 10, 10];
     *
     * var poly = turf.bboxPolygon(bbox);
     *
     * //addToMap
     * var addToMap = [poly]
     */
    function bboxPolygon(bbox, options) {
        if (options === void 0) { options = {}; }
        // Convert BBox positions to Numbers
        // No performance loss for including Number()
        // https://github.com/Turfjs/turf/issues/1119
        var west = Number(bbox[0]);
        var south = Number(bbox[1]);
        var east = Number(bbox[2]);
        var north = Number(bbox[3]);
        if (bbox.length === 6) {
            throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
        }
        var lowLeft = [west, south];
        var topLeft = [west, north];
        var topRight = [east, north];
        var lowRight = [east, south];
        return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox, id: options.id });
    }

    /**
     * Takes any number of features and returns a rectangular {@link Polygon} that encompasses all vertices.
     *
     * @name envelope
     * @param {GeoJSON} geojson input features
     * @returns {Feature<Polygon>} a rectangular Polygon feature that encompasses all vertices
     * @example
     * var features = turf.featureCollection([
     *   turf.point([-75.343, 39.984], {"name": "Location A"}),
     *   turf.point([-75.833, 39.284], {"name": "Location B"}),
     *   turf.point([-75.534, 39.123], {"name": "Location C"})
     * ]);
     *
     * var enveloped = turf.envelope(features);
     *
     * //addToMap
     * var addToMap = [features, enveloped];
     */
    function envelope(geojson) {
      return bboxPolygon(bbox$2(geojson));
    }

    /**
     * Takes a bounding box and calculates the minimum square bounding box that
     * would contain the input.
     *
     * @name square
     * @param {BBox} bbox extent in [west, south, east, north] order
     * @returns {BBox} a square surrounding `bbox`
     * @example
     * var bbox = [-20, -20, -15, 0];
     * var squared = turf.square(bbox);
     *
     * //addToMap
     * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]
     */
    function square(bbox) {
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];

      var horizontalDistance = distance$1(bbox.slice(0, 2), [east, south]);
      var verticalDistance = distance$1(bbox.slice(0, 2), [west, north]);
      if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (south + north) / 2;
        return [
          west,
          verticalMidpoint - (east - west) / 2,
          east,
          verticalMidpoint + (east - west) / 2,
        ];
      } else {
        var horizontalMidpoint = (west + east) / 2;
        return [
          horizontalMidpoint - (north - south) / 2,
          south,
          horizontalMidpoint + (north - south) / 2,
          north,
        ];
      }
    }

    // http://en.wikipedia.org/wiki/Haversine_formula
    /**
     * Takes a {@link Point} and calculates the location of a destination point given a distance in
     * degrees, radians, miles, or kilometers; and bearing in degrees.
     * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
     *
     * @name destination
     * @param {Coord} origin starting point
     * @param {number} distance distance from the origin point
     * @param {number} bearing ranging from -180 to 180
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
     * @param {Object} [options.properties={}] Translate properties to Point
     * @returns {Feature<Point>} destination point
     * @example
     * var point = turf.point([-75.343, 39.984]);
     * var distance = 50;
     * var bearing = 90;
     * var options = {units: 'miles'};
     *
     * var destination = turf.destination(point, distance, bearing, options);
     *
     * //addToMap
     * var addToMap = [point, destination]
     * destination.properties['marker-color'] = '#f00';
     * point.properties['marker-color'] = '#0f0';
     */
    function destination(origin, distance, bearing, options) {
        if (options === void 0) { options = {}; }
        // Handle input
        var coordinates1 = getCoord(origin);
        var longitude1 = degreesToRadians(coordinates1[0]);
        var latitude1 = degreesToRadians(coordinates1[1]);
        var bearingRad = degreesToRadians(bearing);
        var radians = lengthToRadians(distance, options.units);
        // Main
        var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
            Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
        var longitude2 = longitude1 +
            Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
        var lng = radiansToDegrees(longitude2);
        var lat = radiansToDegrees(latitude2);
        return point([lng, lat], options.properties);
    }

    /**
     * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
     *
     * @name circle
     * @param {Feature<Point>|number[]} center center point
     * @param {number} radius radius of the circle
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.steps=64] number of steps
     * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
     * @param {Object} [options.properties={}] properties
     * @returns {Feature<Polygon>} circle polygon
     * @example
     * var center = [-75.343, 39.984];
     * var radius = 5;
     * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};
     * var circle = turf.circle(center, radius, options);
     *
     * //addToMap
     * var addToMap = [turf.point(center), circle]
     */
    function circle(center, radius, options) {
        if (options === void 0) { options = {}; }
        // default params
        var steps = options.steps || 64;
        var properties = options.properties
            ? options.properties
            : !Array.isArray(center) && center.type === "Feature" && center.properties
                ? center.properties
                : {};
        // main
        var coordinates = [];
        for (var i = 0; i < steps; i++) {
            coordinates.push(destination(center, radius, (i * -360) / steps, options).geometry
                .coordinates);
        }
        coordinates.push(coordinates[0]);
        return polygon([coordinates], properties);
    }

    // http://en.wikipedia.org/wiki/Haversine_formula
    // http://www.movable-type.co.uk/scripts/latlong.html
    /**
     * Takes two {@link Point|points} and finds the geographic bearing between them,
     * i.e. the angle measured in degrees from the north line (0 degrees)
     *
     * @name bearing
     * @param {Coord} start starting Point
     * @param {Coord} end ending Point
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.final=false] calculates the final bearing if true
     * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
     * @example
     * var point1 = turf.point([-75.343, 39.984]);
     * var point2 = turf.point([-75.534, 39.123]);
     *
     * var bearing = turf.bearing(point1, point2);
     *
     * //addToMap
     * var addToMap = [point1, point2]
     * point1.properties['marker-color'] = '#f00'
     * point2.properties['marker-color'] = '#0f0'
     * point1.properties.bearing = bearing
     */
    function bearing(start, end, options) {
        if (options === void 0) { options = {}; }
        // Reverse calculation
        if (options.final === true) {
            return calculateFinalBearing(start, end);
        }
        var coordinates1 = getCoord(start);
        var coordinates2 = getCoord(end);
        var lon1 = degreesToRadians(coordinates1[0]);
        var lon2 = degreesToRadians(coordinates2[0]);
        var lat1 = degreesToRadians(coordinates1[1]);
        var lat2 = degreesToRadians(coordinates2[1]);
        var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
        var b = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
        return radiansToDegrees(Math.atan2(a, b));
    }
    /**
     * Calculates Final Bearing
     *
     * @private
     * @param {Coord} start starting Point
     * @param {Coord} end ending Point
     * @returns {number} bearing
     */
    function calculateFinalBearing(start, end) {
        // Swap start & end
        var bear = bearing(end, start);
        bear = (bear + 180) % 360;
        return bear;
    }

    /**
     * Takes two {@link Point|points} and returns a point midway between them.
     * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.
     *
     * @name midpoint
     * @param {Coord} point1 first point
     * @param {Coord} point2 second point
     * @returns {Feature<Point>} a point midway between `pt1` and `pt2`
     * @example
     * var point1 = turf.point([144.834823, -37.771257]);
     * var point2 = turf.point([145.14244, -37.830937]);
     *
     * var midpoint = turf.midpoint(point1, point2);
     *
     * //addToMap
     * var addToMap = [point1, point2, midpoint];
     * midpoint.properties['marker-color'] = '#f00';
     */
    function midpoint(point1, point2) {
      var dist = distance$1(point1, point2);
      var heading = bearing(point1, point2);
      var midpoint = destination(point1, dist / 2, heading);

      return midpoint;
    }

    /**
     * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
     *
     * @name center
     * @param {GeoJSON} geojson GeoJSON to be centered
     * @param {Object} [options={}] Optional parameters
     * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point
     * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point
     * @param {Object} [options.id={}] Translate GeoJSON Id to Point
     * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
     * @example
     * var features = turf.points([
     *   [-97.522259, 35.4691],
     *   [-97.502754, 35.463455],
     *   [-97.508269, 35.463245]
     * ]);
     *
     * var center = turf.center(features);
     *
     * //addToMap
     * var addToMap = [features, center]
     * center.properties['marker-size'] = 'large';
     * center.properties['marker-color'] = '#000';
     */
    function center(geojson, options) {
        if (options === void 0) { options = {}; }
        var ext = bbox$2(geojson);
        var x = (ext[0] + ext[2]) / 2;
        var y = (ext[1] + ext[3]) / 2;
        return point([x, y], options.properties, options);
    }

    /**
     * Takes one or more features and calculates the centroid using the mean of all vertices.
     * This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.
     *
     * @name centroid
     * @param {GeoJSON} geojson GeoJSON to be centered
     * @param {Object} [options={}] Optional Parameters
     * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties
     * @returns {Feature<Point>} the centroid of the input features
     * @example
     * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
     *
     * var centroid = turf.centroid(polygon);
     *
     * //addToMap
     * var addToMap = [polygon, centroid]
     */
    function centroid(geojson, options) {
        if (options === void 0) { options = {}; }
        var xSum = 0;
        var ySum = 0;
        var len = 0;
        coordEach$1(geojson, function (coord) {
            xSum += coord[0];
            ySum += coord[1];
            len++;
        }, true);
        return point([xSum / len, ySum / len], options.properties);
    }

    /**
     * Takes any {@link Feature} or a {@link FeatureCollection} and returns its [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) using this formula: [Centroid of Polygon](https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon).
     *
     * @name centerOfMass
     * @param {GeoJSON} geojson GeoJSON to be centered
     * @param {Object} [options={}] Optional Parameters
     * @param {Object} [options.properties={}] Translate Properties to Feature
     * @returns {Feature<Point>} the center of mass
     * @example
     * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
     *
     * var center = turf.centerOfMass(polygon);
     *
     * //addToMap
     * var addToMap = [polygon, center]
     */
    function centerOfMass(geojson, options) {
        if (options === void 0) { options = {}; }
        switch (getType$1(geojson)) {
            case "Point":
                return point(getCoord(geojson), options.properties);
            case "Polygon":
                var coords = [];
                coordEach$1(geojson, function (coord) {
                    coords.push(coord);
                });
                // First, we neutralize the feature (set it around coordinates [0,0]) to prevent rounding errors
                // We take any point to translate all the points around 0
                var centre = centroid(geojson, { properties: options.properties });
                var translation = centre.geometry.coordinates;
                var sx = 0;
                var sy = 0;
                var sArea = 0;
                var i, pi, pj, xi, xj, yi, yj, a;
                var neutralizedPoints = coords.map(function (point) {
                    return [point[0] - translation[0], point[1] - translation[1]];
                });
                for (i = 0; i < coords.length - 1; i++) {
                    // pi is the current point
                    pi = neutralizedPoints[i];
                    xi = pi[0];
                    yi = pi[1];
                    // pj is the next point (pi+1)
                    pj = neutralizedPoints[i + 1];
                    xj = pj[0];
                    yj = pj[1];
                    // a is the common factor to compute the signed area and the final coordinates
                    a = xi * yj - xj * yi;
                    // sArea is the sum used to compute the signed area
                    sArea += a;
                    // sx and sy are the sums used to compute the final coordinates
                    sx += (xi + xj) * a;
                    sy += (yi + yj) * a;
                }
                // Shape has no area: fallback on turf.centroid
                if (sArea === 0) {
                    return centre;
                }
                else {
                    // Compute the signed area, and factorize 1/6A
                    var area = sArea * 0.5;
                    var areaFactor = 1 / (6 * area);
                    // Compute the final coordinates, adding back the values that have been neutralized
                    return point([translation[0] + areaFactor * sx, translation[1] + areaFactor * sy], options.properties);
                }
            default:
                // Not a polygon: Compute the convex hull and work with that
                var hull = convex(geojson);
                if (hull)
                    return centerOfMass(hull, { properties: options.properties });
                // Hull is empty: fallback on the centroid
                else
                    return centroid(geojson, { properties: options.properties });
        }
    }

    /**
     * Combines a {@link FeatureCollection} of {@link Point}, {@link LineString}, or {@link Polygon} features
     * into {@link MultiPoint}, {@link MultiLineString}, or {@link MultiPolygon} features.
     *
     * @name combine
     * @param {FeatureCollection<Point|LineString|Polygon>} fc a FeatureCollection of any type
     * @returns {FeatureCollection<MultiPoint|MultiLineString|MultiPolygon>} a FeatureCollection of corresponding type to input
     * @example
     * var fc = turf.featureCollection([
     *   turf.point([19.026432, 47.49134]),
     *   turf.point([19.074497, 47.509548])
     * ]);
     *
     * var combined = turf.combine(fc);
     *
     * //addToMap
     * var addToMap = [combined]
     */
    function combine(fc) {
        var groups = {
            MultiPoint: {
                coordinates: [],
                properties: [],
            },
            MultiLineString: {
                coordinates: [],
                properties: [],
            },
            MultiPolygon: {
                coordinates: [],
                properties: [],
            },
        };
        featureEach$2(fc, function (feature) {
            var _a, _b, _c;
            var _d;
            switch ((_d = feature.geometry) === null || _d === void 0 ? void 0 : _d.type) {
                case "Point":
                    groups.MultiPoint.coordinates.push(feature.geometry.coordinates);
                    groups.MultiPoint.properties.push(feature.properties);
                    break;
                case "MultiPoint":
                    (_a = groups.MultiPoint.coordinates).push.apply(_a, feature.geometry.coordinates);
                    groups.MultiPoint.properties.push(feature.properties);
                    break;
                case "LineString":
                    groups.MultiLineString.coordinates.push(feature.geometry.coordinates);
                    groups.MultiLineString.properties.push(feature.properties);
                    break;
                case "MultiLineString":
                    (_b = groups.MultiLineString.coordinates).push.apply(_b, feature.geometry.coordinates);
                    groups.MultiLineString.properties.push(feature.properties);
                    break;
                case "Polygon":
                    groups.MultiPolygon.coordinates.push(feature.geometry.coordinates);
                    groups.MultiPolygon.properties.push(feature.properties);
                    break;
                case "MultiPolygon":
                    (_c = groups.MultiPolygon.coordinates).push.apply(_c, feature.geometry.coordinates);
                    groups.MultiPolygon.properties.push(feature.properties);
                    break;
            }
        });
        return featureCollection$1(Object.keys(groups)
            .filter(function (key) {
            return groups[key].coordinates.length;
        })
            .sort()
            .map(function (key) {
            var geometry = { type: key, coordinates: groups[key].coordinates };
            var properties = { collectedProperties: groups[key].properties };
            return feature(geometry, properties);
        }));
    }

    /**
     * Takes a feature or set of features and returns all positions as {@link Point|points}.
     *
     * @name explode
     * @param {GeoJSON} geojson input features
     * @returns {FeatureCollection<point>} points representing the exploded input features
     * @throws {Error} if it encounters an unknown geometry type
     * @example
     * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
     *
     * var explode = turf.explode(polygon);
     *
     * //addToMap
     * var addToMap = [polygon, explode]
     */
    function explode$1(geojson) {
      var points = [];
      if (geojson.type === "FeatureCollection") {
        featureEach$2(geojson, function (feature) {
          coordEach$1(feature, function (coord) {
            points.push(point(coord, feature.properties));
          });
        });
      } else {
        coordEach$1(geojson, function (coord) {
          points.push(point(coord, geojson.properties));
        });
      }
      return featureCollection$1(points);
    }

    var earcut_1 = earcut;
    var _default$2 = earcut;

    function earcut(data, holeIndices, dim) {

        dim = dim || 2;

        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];

        if (!outerNode || outerNode.next === outerNode.prev) return triangles;

        var minX, minY, maxX, maxY, x, y, invSize;

        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];

            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }

            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 32767 / invSize : 0;
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

        return triangles;
    }

    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;

        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }

        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }

        return last;
    }

    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;

        var p = start,
            again;
        do {
            again = false;

            if (!p.steiner && (equals(p, p.next) || area$1(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;

            } else {
                p = p.next;
            }
        } while (again || p !== end);

        return end;
    }

    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;

        // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

        var stop = ear,
            prev, next;

        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;

            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim | 0);
                triangles.push(ear.i / dim | 0);
                triangles.push(next.i / dim | 0);

                removeNode(ear);

                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;

                continue;
            }

            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }

                break;
            }
        }
    }

    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area$1(a, b, c) >= 0) return false; // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

        // triangle bbox; min & max are calculated like this for speed
        var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

        var p = c.next;
        while (p !== a) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
                pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
                area$1(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }

        return true;
    }

    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area$1(a, b, c) >= 0) return false; // reflex, can't be an ear

        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

        // triangle bbox; min & max are calculated like this for speed
        var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

        // z-order range for the current triangle bbox;
        var minZ = zOrder(x0, y0, minX, minY, invSize),
            maxZ = zOrder(x1, y1, minX, minY, invSize);

        var p = ear.prevZ,
            n = ear.nextZ;

        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area$1(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;

            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area$1(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }

        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area$1(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }

        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
                pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area$1(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }

        return true;
    }

    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;

            if (!equals(a, b) && intersects$1(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

                triangles.push(a.i / dim | 0);
                triangles.push(p.i / dim | 0);
                triangles.push(b.i / dim | 0);

                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);

                p = start = b;
            }
            p = p.next;
        } while (p !== start);

        return filterPoints(p);
    }

    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);

                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);

                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                    earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            outerNode = eliminateHole(queue[i], outerNode);
        }

        return outerNode;
    }

    function compareX(a, b) {
        return a.x - b.x;
    }

    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
            return outerNode;
        }

        var bridgeReverse = splitPolygon(bridge, hole);

        // filter collinear points around the cuts
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
    }

    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    m = p.x < p.next.x ? p : p.next;
                    if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
                }
            }
            p = p.next;
        } while (p !== outerNode);

        if (!m) return null;

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m;

        do {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                if (locallyInside(p, hole) &&
                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                    m = p;
                    tanMin = tan;
                }
            }

            p = p.next;
        } while (p !== stop);

        return m;
    }

    // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector(m, p) {
        return area$1(m.prev, m, p.prev) < 0 && area$1(p.next, m, m.next) < 0;
    }

    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked(p);
    }

    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;

                while (pSize > 0 || (qSize > 0 && q)) {

                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }

                    if (tail) tail.nextZ = e;
                    else list = e;

                    e.prevZ = tail;
                    tail = e;
                }

                p = q;
            }

            tail.nextZ = null;
            inSize *= 2;

        } while (numMerges > 1);

        return list;
    }

    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;

        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
            p = p.next;
        } while (p !== start);

        return leftmost;
    }

    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
               (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
               (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }

    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
               (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
                (area$1(a.prev, a, b.prev) || area$1(a, b.prev, b)) || // does not create opposite-facing sectors
                equals(a, b) && area$1(a.prev, a, a.next) > 0 && area$1(b.prev, b, b.next) > 0); // special zero-length case
    }

    // signed area of a triangle
    function area$1(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    // check if two segments intersect
    function intersects$1(p1, q1, p2, q2) {
        var o1 = sign$1(area$1(p1, q1, p2));
        var o2 = sign$1(area$1(p1, q1, q2));
        var o3 = sign$1(area$1(p2, q2, p1));
        var o4 = sign$1(area$1(p2, q2, q1));

        if (o1 !== o2 && o3 !== o4) return true; // general case

        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

        return false;
    }

    // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }

    function sign$1(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
    }

    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    intersects$1(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);

        return false;
    }

    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area$1(a.prev, a, a.next) < 0 ?
            area$1(a, b, a.next) >= 0 && area$1(a, a.prev, b) >= 0 :
            area$1(a, b, a.prev) < 0 || area$1(a, a.next, b) < 0;
    }

    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);

        return inside;
    }

    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node$2(a.i, a.x, a.y),
            b2 = new Node$2(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
    }

    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node$2(i, x, y);

        if (!last) {
            p.prev = p;
            p.next = p;

        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    function Node$2(i, x, y) {
        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = 0;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
    }

    // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation
    earcut.deviation = function (data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
        }

        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs(
                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }

        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    };

    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }

    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    earcut.flatten = function (data) {
        var dim = data[0][0].length,
            result = {vertices: [], holes: [], dimensions: dim},
            holeIndex = 0;

        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    };
    earcut_1.default = _default$2;

    /**
     * Tesselates a {@link Feature<Polygon>} into a {@link FeatureCollection<Polygon>} of triangles
     * using [earcut](https://github.com/mapbox/earcut).
     *
     * @name tesselate
     * @param {Feature<Polygon>} poly the polygon to tesselate
     * @returns {FeatureCollection<Polygon>} a geometrycollection feature
     * @example
     * var poly = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);
     * var triangles = turf.tesselate(poly);
     *
     * //addToMap
     * var addToMap = [poly, triangles]
     */
    function tesselate(poly) {
      if (
        !poly.geometry ||
        (poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon")
      ) {
        throw new Error("input must be a Polygon or MultiPolygon");
      }

      var fc = { type: "FeatureCollection", features: [] };

      if (poly.geometry.type === "Polygon") {
        fc.features = processPolygon$2(poly.geometry.coordinates);
      } else {
        poly.geometry.coordinates.forEach(function (coordinates) {
          fc.features = fc.features.concat(processPolygon$2(coordinates));
        });
      }

      return fc;
    }

    function processPolygon$2(coordinates) {
      var data = flattenCoords(coordinates);
      var dim = 2;
      var result = earcut_1(data.vertices, data.holes, dim);

      var features = [];
      var vertices = [];

      result.forEach(function (vert, i) {
        var index = result[i];
        vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
      });

      for (var i = 0; i < vertices.length; i += 3) {
        var coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push(polygon([coords]));
      }

      return features;
    }

    function flattenCoords(data) {
      var dim = data[0][0].length,
        result = { vertices: [], holes: [], dimensions: dim },
        holeIndex = 0;

      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }

      return result;
    }

    /**
     * Takes a reference {@link Point|point} and a FeatureCollection of Features
     * with Point geometries and returns the
     * point from the FeatureCollection closest to the reference. This calculation
     * is geodesic.
     *
     * @name nearestPoint
     * @param {Coord} targetPoint the reference point
     * @param {FeatureCollection<Point>} points against input point set
     * @returns {Feature<Point>} the closest point in the set to the reference point
     * @example
     * var targetPoint = turf.point([28.965797, 41.010086], {"marker-color": "#0F0"});
     * var points = turf.featureCollection([
     *     turf.point([28.973865, 41.011122]),
     *     turf.point([28.948459, 41.024204]),
     *     turf.point([28.938674, 41.013324])
     * ]);
     *
     * var nearest = turf.nearestPoint(targetPoint, points);
     *
     * //addToMap
     * var addToMap = [targetPoint, points, nearest];
     * nearest.properties['marker-color'] = '#F00';
     */
    function nearestPoint(targetPoint, points) {
        // Input validation
        if (!targetPoint)
            throw new Error("targetPoint is required");
        if (!points)
            throw new Error("points is required");
        var nearest;
        var minDist = Infinity;
        var bestFeatureIndex = 0;
        featureEach$2(points, function (pt, featureIndex) {
            var distanceToPoint = distance$1(targetPoint, pt);
            if (distanceToPoint < minDist) {
                bestFeatureIndex = featureIndex;
                minDist = distanceToPoint;
            }
        });
        nearest = clone(points.features[bestFeatureIndex]);
        nearest.properties.featureIndex = bestFeatureIndex;
        nearest.properties.distanceToPoint = minDist;
        return nearest;
    }

    /**
     * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a
     * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
     *
     * @name lineSegment
     * @param {GeoJSON} geojson GeoJSON Polygon or LineString
     * @returns {FeatureCollection<LineString>} 2-vertex line segments
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     * var segments = turf.lineSegment(polygon);
     *
     * //addToMap
     * var addToMap = [polygon, segments]
     */
    function lineSegment(geojson) {
        if (!geojson) {
            throw new Error("geojson is required");
        }
        var results = [];
        flattenEach$1(geojson, function (feature) {
            lineSegmentFeature(feature, results);
        });
        return featureCollection$1(results);
    }
    /**
     * Line Segment
     *
     * @private
     * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
     * @param {Array} results push to results
     * @returns {void}
     */
    function lineSegmentFeature(geojson, results) {
        var coords = [];
        var geometry = geojson.geometry;
        if (geometry !== null) {
            switch (geometry.type) {
                case "Polygon":
                    coords = getCoords(geometry);
                    break;
                case "LineString":
                    coords = [getCoords(geometry)];
            }
            coords.forEach(function (coord) {
                var segments = createSegments(coord, geojson.properties);
                segments.forEach(function (segment) {
                    segment.id = results.length;
                    results.push(segment);
                });
            });
        }
    }
    /**
     * Create Segments from LineString coordinates
     *
     * @private
     * @param {Array<Array<number>>} coords LineString coordinates
     * @param {*} properties GeoJSON properties
     * @returns {Array<Feature<LineString>>} line segments
     */
    function createSegments(coords, properties) {
        var segments = [];
        coords.reduce(function (previousCoords, currentCoords) {
            var segment = lineString([previousCoords, currentCoords], properties);
            segment.bbox = bbox$1(previousCoords, currentCoords);
            segments.push(segment);
            return currentCoords;
        });
        return segments;
    }
    /**
     * Create BBox between two coordinates (faster than @turf/bbox)
     *
     * @private
     * @param {Array<number>} coords1 Point coordinate
     * @param {Array<number>} coords2 Point coordinate
     * @returns {BBox} [west, south, east, north]
     */
    function bbox$1(coords1, coords2) {
        var x1 = coords1[0];
        var y1 = coords1[1];
        var x2 = coords2[0];
        var y2 = coords2[1];
        var west = x1 < x2 ? x1 : x2;
        var south = y1 < y2 ? y1 : y2;
        var east = x1 > x2 ? x1 : x2;
        var north = y1 > y2 ? y1 : y2;
        return [west, south, east, north];
    }

    var rbush_min = createCommonjsModule(function (module, exports) {
    !function(t,i){module.exports=i();}(commonjsGlobal,function(){function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h);}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--;}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1);}}(t,r,e||0,a||t.length-1,h||n);}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r;}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear();};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return -1}function a(t,i){h(t,0,t.children.length,i,t);}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h);}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return (t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return {children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r);}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h));}i=e.pop();}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return !1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return !0;n.push(e);}}i=n.pop();}return !1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else {if(this.data.height<n.height){var r=this.data;this.data=n,n=r;}this._insert(n,this.data.height-n.height-1,!0);}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0]);}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1));}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s);}i=h||i.children[0];}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i);},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o);},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox);},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p);}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r);},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a);}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s);}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t);},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox);},r});
    });

    var js$2 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @module helpers
     */
    /**
     * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
     *
     * @memberof helpers
     * @type {number}
     */
    exports.earthRadius = 6371008.8;
    /**
     * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
     *
     * @memberof helpers
     * @type {Object}
     */
    exports.factors = {
        centimeters: exports.earthRadius * 100,
        centimetres: exports.earthRadius * 100,
        degrees: exports.earthRadius / 111325,
        feet: exports.earthRadius * 3.28084,
        inches: exports.earthRadius * 39.37,
        kilometers: exports.earthRadius / 1000,
        kilometres: exports.earthRadius / 1000,
        meters: exports.earthRadius,
        metres: exports.earthRadius,
        miles: exports.earthRadius / 1609.344,
        millimeters: exports.earthRadius * 1000,
        millimetres: exports.earthRadius * 1000,
        nauticalmiles: exports.earthRadius / 1852,
        radians: 1,
        yards: exports.earthRadius * 1.0936,
    };
    /**
     * Units of measurement factors based on 1 meter.
     *
     * @memberof helpers
     * @type {Object}
     */
    exports.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1000,
        kilometres: 1 / 1000,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1000,
        millimetres: 1000,
        nauticalmiles: 1 / 1852,
        radians: 1 / exports.earthRadius,
        yards: 1.0936133,
    };
    /**
     * Area of measurement factors based on 1 square meter.
     *
     * @memberof helpers
     * @type {Object}
     */
    exports.areaFactors = {
        acres: 0.000247105,
        centimeters: 10000,
        centimetres: 10000,
        feet: 10.763910417,
        hectares: 0.0001,
        inches: 1550.003100006,
        kilometers: 0.000001,
        kilometres: 0.000001,
        meters: 1,
        metres: 1,
        miles: 3.86e-7,
        millimeters: 1000000,
        millimetres: 1000000,
        yards: 1.195990046,
    };
    /**
     * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
     *
     * @name feature
     * @param {Geometry} geometry input geometry
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature} a GeoJSON Feature
     * @example
     * var geometry = {
     *   "type": "Point",
     *   "coordinates": [110, 50]
     * };
     *
     * var feature = turf.feature(geometry);
     *
     * //=feature
     */
    function feature(geom, properties, options) {
        if (options === void 0) { options = {}; }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
            feat.id = options.id;
        }
        if (options.bbox) {
            feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
    }
    exports.feature = feature;
    /**
     * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
     * For GeometryCollection type use `helpers.geometryCollection`
     *
     * @name geometry
     * @param {string} type Geometry Type
     * @param {Array<any>} coordinates Coordinates
     * @param {Object} [options={}] Optional Parameters
     * @returns {Geometry} a GeoJSON Geometry
     * @example
     * var type = "Point";
     * var coordinates = [110, 50];
     * var geometry = turf.geometry(type, coordinates);
     * // => geometry
     */
    function geometry(type, coordinates, _options) {
        switch (type) {
            case "Point":
                return point(coordinates).geometry;
            case "LineString":
                return lineString(coordinates).geometry;
            case "Polygon":
                return polygon(coordinates).geometry;
            case "MultiPoint":
                return multiPoint(coordinates).geometry;
            case "MultiLineString":
                return multiLineString(coordinates).geometry;
            case "MultiPolygon":
                return multiPolygon(coordinates).geometry;
            default:
                throw new Error(type + " is invalid");
        }
    }
    exports.geometry = geometry;
    /**
     * Creates a {@link Point} {@link Feature} from a Position.
     *
     * @name point
     * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<Point>} a Point feature
     * @example
     * var point = turf.point([-75.343, 39.984]);
     *
     * //=point
     */
    function point(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        if (!coordinates) {
            throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
            throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
            throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
            throw new Error("coordinates must contain numbers");
        }
        var geom = {
            type: "Point",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    exports.point = point;
    /**
     * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
     *
     * @name points
     * @param {Array<Array<number>>} coordinates an array of Points
     * @param {Object} [properties={}] Translate these properties to each Feature
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
     * associated with the FeatureCollection
     * @param {string|number} [options.id] Identifier associated with the FeatureCollection
     * @returns {FeatureCollection<Point>} Point Feature
     * @example
     * var points = turf.points([
     *   [-75, 39],
     *   [-80, 45],
     *   [-78, 50]
     * ]);
     *
     * //=points
     */
    function points(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        return featureCollection(coordinates.map(function (coords) {
            return point(coords, properties);
        }), options);
    }
    exports.points = points;
    /**
     * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
     *
     * @name polygon
     * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<Polygon>} Polygon Feature
     * @example
     * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
     *
     * //=polygon
     */
    function polygon(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
            var ring = coordinates_1[_i];
            if (ring.length < 4) {
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            }
            for (var j = 0; j < ring[ring.length - 1].length; j++) {
                // Check if first point of Polygon contains two numbers
                if (ring[ring.length - 1][j] !== ring[0][j]) {
                    throw new Error("First and last Position are not equivalent.");
                }
            }
        }
        var geom = {
            type: "Polygon",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    exports.polygon = polygon;
    /**
     * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
     *
     * @name polygons
     * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the FeatureCollection
     * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
     * @example
     * var polygons = turf.polygons([
     *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
     *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
     * ]);
     *
     * //=polygons
     */
    function polygons(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        return featureCollection(coordinates.map(function (coords) {
            return polygon(coords, properties);
        }), options);
    }
    exports.polygons = polygons;
    /**
     * Creates a {@link LineString} {@link Feature} from an Array of Positions.
     *
     * @name lineString
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<LineString>} LineString Feature
     * @example
     * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
     * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
     *
     * //=linestring1
     * //=linestring2
     */
    function lineString(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        if (coordinates.length < 2) {
            throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
            type: "LineString",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    exports.lineString = lineString;
    /**
     * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
     *
     * @name lineStrings
     * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
     * associated with the FeatureCollection
     * @param {string|number} [options.id] Identifier associated with the FeatureCollection
     * @returns {FeatureCollection<LineString>} LineString FeatureCollection
     * @example
     * var linestrings = turf.lineStrings([
     *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
     *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
     * ]);
     *
     * //=linestrings
     */
    function lineStrings(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        return featureCollection(coordinates.map(function (coords) {
            return lineString(coords, properties);
        }), options);
    }
    exports.lineStrings = lineStrings;
    /**
     * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
     *
     * @name featureCollection
     * @param {Feature[]} features input features
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {FeatureCollection} FeatureCollection of Features
     * @example
     * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
     * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
     * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
     *
     * var collection = turf.featureCollection([
     *   locationA,
     *   locationB,
     *   locationC
     * ]);
     *
     * //=collection
     */
    function featureCollection(features, options) {
        if (options === void 0) { options = {}; }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
            fc.id = options.id;
        }
        if (options.bbox) {
            fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
    }
    exports.featureCollection = featureCollection;
    /**
     * Creates a {@link Feature<MultiLineString>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiLineString
     * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<MultiLineString>} a MultiLineString feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
     *
     * //=multiLine
     */
    function multiLineString(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "MultiLineString",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    exports.multiLineString = multiLineString;
    /**
     * Creates a {@link Feature<MultiPoint>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPoint
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<MultiPoint>} a MultiPoint feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPt = turf.multiPoint([[0,0],[10,10]]);
     *
     * //=multiPt
     */
    function multiPoint(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "MultiPoint",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    exports.multiPoint = multiPoint;
    /**
     * Creates a {@link Feature<MultiPolygon>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPolygon
     * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<MultiPolygon>} a multipolygon feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
     *
     * //=multiPoly
     *
     */
    function multiPolygon(coordinates, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "MultiPolygon",
            coordinates: coordinates,
        };
        return feature(geom, properties, options);
    }
    exports.multiPolygon = multiPolygon;
    /**
     * Creates a {@link Feature<GeometryCollection>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name geometryCollection
     * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Object} [options={}] Optional Parameters
     * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
     * @param {string|number} [options.id] Identifier associated with the Feature
     * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
     * @example
     * var pt = turf.geometry("Point", [100, 0]);
     * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
     * var collection = turf.geometryCollection([pt, line]);
     *
     * // => collection
     */
    function geometryCollection(geometries, properties, options) {
        if (options === void 0) { options = {}; }
        var geom = {
            type: "GeometryCollection",
            geometries: geometries,
        };
        return feature(geom, properties, options);
    }
    exports.geometryCollection = geometryCollection;
    /**
     * Round number to precision
     *
     * @param {number} num Number
     * @param {number} [precision=0] Precision
     * @returns {number} rounded number
     * @example
     * turf.round(120.4321)
     * //=120
     *
     * turf.round(120.4321, 2)
     * //=120.43
     */
    function round(num, precision) {
        if (precision === void 0) { precision = 0; }
        if (precision && !(precision >= 0)) {
            throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
    }
    exports.round = round;
    /**
     * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @name radiansToLength
     * @param {number} radians in radians across the sphere
     * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
     * meters, kilometres, kilometers.
     * @returns {number} distance
     */
    function radiansToLength(radians, units) {
        if (units === void 0) { units = "kilometers"; }
        var factor = exports.factors[units];
        if (!factor) {
            throw new Error(units + " units is invalid");
        }
        return radians * factor;
    }
    exports.radiansToLength = radiansToLength;
    /**
     * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @name lengthToRadians
     * @param {number} distance in real units
     * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
     * meters, kilometres, kilometers.
     * @returns {number} radians
     */
    function lengthToRadians(distance, units) {
        if (units === void 0) { units = "kilometers"; }
        var factor = exports.factors[units];
        if (!factor) {
            throw new Error(units + " units is invalid");
        }
        return distance / factor;
    }
    exports.lengthToRadians = lengthToRadians;
    /**
     * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
     *
     * @name lengthToDegrees
     * @param {number} distance in real units
     * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
     * meters, kilometres, kilometers.
     * @returns {number} degrees
     */
    function lengthToDegrees(distance, units) {
        return radiansToDegrees(lengthToRadians(distance, units));
    }
    exports.lengthToDegrees = lengthToDegrees;
    /**
     * Converts any bearing angle from the north line direction (positive clockwise)
     * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
     *
     * @name bearingToAzimuth
     * @param {number} bearing angle, between -180 and +180 degrees
     * @returns {number} angle between 0 and 360 degrees
     */
    function bearingToAzimuth(bearing) {
        var angle = bearing % 360;
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    }
    exports.bearingToAzimuth = bearingToAzimuth;
    /**
     * Converts an angle in radians to degrees
     *
     * @name radiansToDegrees
     * @param {number} radians angle in radians
     * @returns {number} degrees between 0 and 360 degrees
     */
    function radiansToDegrees(radians) {
        var degrees = radians % (2 * Math.PI);
        return (degrees * 180) / Math.PI;
    }
    exports.radiansToDegrees = radiansToDegrees;
    /**
     * Converts an angle in degrees to radians
     *
     * @name degreesToRadians
     * @param {number} degrees angle between 0 and 360 degrees
     * @returns {number} angle in radians
     */
    function degreesToRadians(degrees) {
        var radians = degrees % 360;
        return (radians * Math.PI) / 180;
    }
    exports.degreesToRadians = degreesToRadians;
    /**
     * Converts a length to the requested unit.
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @param {number} length to be converted
     * @param {Units} [originalUnit="kilometers"] of the length
     * @param {Units} [finalUnit="kilometers"] returned unit
     * @returns {number} the converted length
     */
    function convertLength(length, originalUnit, finalUnit) {
        if (originalUnit === void 0) { originalUnit = "kilometers"; }
        if (finalUnit === void 0) { finalUnit = "kilometers"; }
        if (!(length >= 0)) {
            throw new Error("length must be a positive number");
        }
        return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
    }
    exports.convertLength = convertLength;
    /**
     * Converts a area to the requested unit.
     * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
     * @param {number} area to be converted
     * @param {Units} [originalUnit="meters"] of the distance
     * @param {Units} [finalUnit="kilometers"] returned unit
     * @returns {number} the converted area
     */
    function convertArea(area, originalUnit, finalUnit) {
        if (originalUnit === void 0) { originalUnit = "meters"; }
        if (finalUnit === void 0) { finalUnit = "kilometers"; }
        if (!(area >= 0)) {
            throw new Error("area must be a positive number");
        }
        var startFactor = exports.areaFactors[originalUnit];
        if (!startFactor) {
            throw new Error("invalid original units");
        }
        var finalFactor = exports.areaFactors[finalUnit];
        if (!finalFactor) {
            throw new Error("invalid final units");
        }
        return (area / startFactor) * finalFactor;
    }
    exports.convertArea = convertArea;
    /**
     * isNumber
     *
     * @param {*} num Number to validate
     * @returns {boolean} true/false
     * @example
     * turf.isNumber(123)
     * //=true
     * turf.isNumber('foo')
     * //=false
     */
    function isNumber(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    exports.isNumber = isNumber;
    /**
     * isObject
     *
     * @param {*} input variable to validate
     * @returns {boolean} true/false
     * @example
     * turf.isObject({elevation: 10})
     * //=true
     * turf.isObject('foo')
     * //=false
     */
    function isObject(input) {
        return !!input && input.constructor === Object;
    }
    exports.isObject = isObject;
    /**
     * Validate BBox
     *
     * @private
     * @param {Array<number>} bbox BBox to validate
     * @returns {void}
     * @throws Error if BBox is not valid
     * @example
     * validateBBox([-180, -40, 110, 50])
     * //=OK
     * validateBBox([-180, -40])
     * //=Error
     * validateBBox('Foo')
     * //=Error
     * validateBBox(5)
     * //=Error
     * validateBBox(null)
     * //=Error
     * validateBBox(undefined)
     * //=Error
     */
    function validateBBox(bbox) {
        if (!bbox) {
            throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox)) {
            throw new Error("bbox must be an Array");
        }
        if (bbox.length !== 4 && bbox.length !== 6) {
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox.forEach(function (num) {
            if (!isNumber(num)) {
                throw new Error("bbox must only contain numbers");
            }
        });
    }
    exports.validateBBox = validateBBox;
    /**
     * Validate Id
     *
     * @private
     * @param {string|number} id Id to validate
     * @returns {void}
     * @throws Error if Id is not valid
     * @example
     * validateId([-180, -40, 110, 50])
     * //=Error
     * validateId([-180, -40])
     * //=Error
     * validateId('Foo')
     * //=OK
     * validateId(5)
     * //=OK
     * validateId(null)
     * //=Error
     * validateId(undefined)
     * //=Error
     */
    function validateId(id) {
        if (!id) {
            throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
            throw new Error("id must be a number or a string");
        }
    }
    exports.validateId = validateId;
    });

    var helpers = js$2;

    /**
     * Callback for coordEach
     *
     * @callback coordEachCallback
     * @param {Array<number>} currentCoord The current coordinate being processed.
     * @param {number} coordIndex The current index of the coordinate being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     */

    /**
     * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
     *
     * @name coordEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
     * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=currentCoord
     *   //=coordIndex
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     * });
     */
    function coordEach(geojson, callback, excludeWrapCoord) {
      // Handles null Geometry -- Skips this GeoJSON
      if (geojson === null) return;
      var j,
        k,
        l,
        geometry,
        stopG,
        coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === "FeatureCollection",
        isFeature = type === "Feature",
        stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = isFeatureCollection
          ? geojson.features[featureIndex].geometry
          : isFeature
          ? geojson.geometry
          : geojson;
        isGeometryCollection = geometryMaybeCollection
          ? geometryMaybeCollection.type === "GeometryCollection"
          : false;
        stopG = isGeometryCollection
          ? geometryMaybeCollection.geometries.length
          : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
          var multiFeatureIndex = 0;
          var geometryIndex = 0;
          geometry = isGeometryCollection
            ? geometryMaybeCollection.geometries[geomIndex]
            : geometryMaybeCollection;

          // Handles null Geometry -- Skips this geometry
          if (geometry === null) continue;
          coords = geometry.coordinates;
          var geomType = geometry.type;

          wrapShrink =
            excludeWrapCoord &&
            (geomType === "Polygon" || geomType === "MultiPolygon")
              ? 1
              : 0;

          switch (geomType) {
            case null:
              break;
            case "Point":
              if (
                callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
              coordIndex++;
              multiFeatureIndex++;
              break;
            case "LineString":
            case "MultiPoint":
              for (j = 0; j < coords.length; j++) {
                if (
                  callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false
                )
                  return false;
                coordIndex++;
                if (geomType === "MultiPoint") multiFeatureIndex++;
              }
              if (geomType === "LineString") multiFeatureIndex++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (j = 0; j < coords.length; j++) {
                for (k = 0; k < coords[j].length - wrapShrink; k++) {
                  if (
                    callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false
                  )
                    return false;
                  coordIndex++;
                }
                if (geomType === "MultiLineString") multiFeatureIndex++;
                if (geomType === "Polygon") geometryIndex++;
              }
              if (geomType === "Polygon") multiFeatureIndex++;
              break;
            case "MultiPolygon":
              for (j = 0; j < coords.length; j++) {
                geometryIndex = 0;
                for (k = 0; k < coords[j].length; k++) {
                  for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                    if (
                      callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false
                    )
                      return false;
                    coordIndex++;
                  }
                  geometryIndex++;
                }
                multiFeatureIndex++;
              }
              break;
            case "GeometryCollection":
              for (j = 0; j < geometry.geometries.length; j++)
                if (
                  coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===
                  false
                )
                  return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }

    /**
     * Callback for coordReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback coordReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Array<number>} currentCoord The current coordinate being processed.
     * @param {number} coordIndex The current index of the coordinate being processed.
     * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     */

    /**
     * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
     *
     * @name coordReduce
     * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=previousValue
     *   //=currentCoord
     *   //=coordIndex
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     *   return currentCoord;
     * });
     */
    function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(
        geojson,
        function (
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        ) {
          if (coordIndex === 0 && initialValue === undefined)
            previousValue = currentCoord;
          else
            previousValue = callback(
              previousValue,
              currentCoord,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            );
        },
        excludeWrapCoord
      );
      return previousValue;
    }

    /**
     * Callback for propEach
     *
     * @callback propEachCallback
     * @param {Object} currentProperties The current Properties being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Iterate over properties in any GeoJSON object, similar to Array.forEach()
     *
     * @name propEach
     * @param {FeatureCollection|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentProperties, featureIndex)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.propEach(features, function (currentProperties, featureIndex) {
     *   //=currentProperties
     *   //=featureIndex
     * });
     */
    function propEach(geojson, callback) {
      var i;
      switch (geojson.type) {
        case "FeatureCollection":
          for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
          }
          break;
        case "Feature":
          callback(geojson.properties, 0);
          break;
      }
    }

    /**
     * Callback for propReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback propReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {*} currentProperties The current Properties being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Reduce properties in any GeoJSON object into a single value,
     * similar to how Array.reduce works. However, in this case we lazily run
     * the reduction, so an array of all properties is unnecessary.
     *
     * @name propReduce
     * @param {FeatureCollection|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
     *   //=previousValue
     *   //=currentProperties
     *   //=featureIndex
     *   return currentProperties
     * });
     */
    function propReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined)
          previousValue = currentProperties;
        else
          previousValue = callback(previousValue, currentProperties, featureIndex);
      });
      return previousValue;
    }

    /**
     * Callback for featureEach
     *
     * @callback featureEachCallback
     * @param {Feature<any>} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Iterate over features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name featureEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.featureEach(features, function (currentFeature, featureIndex) {
     *   //=currentFeature
     *   //=featureIndex
     * });
     */
    function featureEach$1(geojson, callback) {
      if (geojson.type === "Feature") {
        callback(geojson, 0);
      } else if (geojson.type === "FeatureCollection") {
        for (var i = 0; i < geojson.features.length; i++) {
          if (callback(geojson.features[i], i) === false) break;
        }
      }
    }

    /**
     * Callback for featureReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback featureReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name featureReduce
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=featureIndex
     *   return currentFeature
     * });
     */
    function featureReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      featureEach$1(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined)
          previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
      });
      return previousValue;
    }

    /**
     * Get all coordinates from any GeoJSON object.
     *
     * @name coordAll
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @returns {Array<Array<number>>} coordinate position array
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * var coords = turf.coordAll(features);
     * //= [[26, 37], [36, 53]]
     */
    function coordAll(geojson) {
      var coords = [];
      coordEach(geojson, function (coord) {
        coords.push(coord);
      });
      return coords;
    }

    /**
     * Callback for geomEach
     *
     * @callback geomEachCallback
     * @param {Geometry} currentGeometry The current Geometry being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {Object} featureProperties The current Feature Properties being processed.
     * @param {Array<number>} featureBBox The current Feature BBox being processed.
     * @param {number|string} featureId The current Feature Id being processed.
     */

    /**
     * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
     *
     * @name geomEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
     * @returns {void}
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
     *   //=currentGeometry
     *   //=featureIndex
     *   //=featureProperties
     *   //=featureBBox
     *   //=featureId
     * });
     */
    function geomEach(geojson, callback) {
      var i,
        j,
        g,
        geometry,
        stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === "FeatureCollection",
        isFeature = geojson.type === "Feature",
        stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (i = 0; i < stop; i++) {
        geometryMaybeCollection = isFeatureCollection
          ? geojson.features[i].geometry
          : isFeature
          ? geojson.geometry
          : geojson;
        featureProperties = isFeatureCollection
          ? geojson.features[i].properties
          : isFeature
          ? geojson.properties
          : {};
        featureBBox = isFeatureCollection
          ? geojson.features[i].bbox
          : isFeature
          ? geojson.bbox
          : undefined;
        featureId = isFeatureCollection
          ? geojson.features[i].id
          : isFeature
          ? geojson.id
          : undefined;
        isGeometryCollection = geometryMaybeCollection
          ? geometryMaybeCollection.type === "GeometryCollection"
          : false;
        stopG = isGeometryCollection
          ? geometryMaybeCollection.geometries.length
          : 1;

        for (g = 0; g < stopG; g++) {
          geometry = isGeometryCollection
            ? geometryMaybeCollection.geometries[g]
            : geometryMaybeCollection;

          // Handle null Geometry
          if (geometry === null) {
            if (
              callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false
            )
              return false;
            continue;
          }
          switch (geometry.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon": {
              if (
                callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false
              )
                return false;
              break;
            }
            case "GeometryCollection": {
              for (j = 0; j < geometry.geometries.length; j++) {
                if (
                  callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false
                )
                  return false;
              }
              break;
            }
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
      }
    }

    /**
     * Callback for geomReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback geomReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Geometry} currentGeometry The current Geometry being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {Object} featureProperties The current Feature Properties being processed.
     * @param {Array<number>} featureBBox The current Feature BBox being processed.
     * @param {number|string} featureId The current Feature Id being processed.
     */

    /**
     * Reduce geometry in any GeoJSON object, similar to Array.reduce().
     *
     * @name geomReduce
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
     *   //=previousValue
     *   //=currentGeometry
     *   //=featureIndex
     *   //=featureProperties
     *   //=featureBBox
     *   //=featureId
     *   return currentGeometry
     * });
     */
    function geomReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      geomEach(
        geojson,
        function (
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) {
          if (featureIndex === 0 && initialValue === undefined)
            previousValue = currentGeometry;
          else
            previousValue = callback(
              previousValue,
              currentGeometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            );
        }
      );
      return previousValue;
    }

    /**
     * Callback for flattenEach
     *
     * @callback flattenEachCallback
     * @param {Feature} currentFeature The current flattened feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     */

    /**
     * Iterate over flattened features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name flattenEach
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
     * ]);
     *
     * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
     *   //=currentFeature
     *   //=featureIndex
     *   //=multiFeatureIndex
     * });
     */
    function flattenEach(geojson, callback) {
      geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = geometry === null ? null : geometry.type;
        switch (type) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            if (
              callback(
                helpers.feature(geometry, properties, { bbox: bbox, id: id }),
                featureIndex,
                0
              ) === false
            )
              return false;
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
          case "MultiPoint":
            geomType = "Point";
            break;
          case "MultiLineString":
            geomType = "LineString";
            break;
          case "MultiPolygon":
            geomType = "Polygon";
            break;
        }

        for (
          var multiFeatureIndex = 0;
          multiFeatureIndex < geometry.coordinates.length;
          multiFeatureIndex++
        ) {
          var coordinate = geometry.coordinates[multiFeatureIndex];
          var geom = {
            type: geomType,
            coordinates: coordinate,
          };
          if (
            callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===
            false
          )
            return false;
        }
      });
    }

    /**
     * Callback for flattenReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback flattenReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature} currentFeature The current Feature being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     */

    /**
     * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
     *
     * @name flattenReduce
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
     * ]);
     *
     * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   return currentFeature
     * });
     */
    function flattenReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      flattenEach(
        geojson,
        function (currentFeature, featureIndex, multiFeatureIndex) {
          if (
            featureIndex === 0 &&
            multiFeatureIndex === 0 &&
            initialValue === undefined
          )
            previousValue = currentFeature;
          else
            previousValue = callback(
              previousValue,
              currentFeature,
              featureIndex,
              multiFeatureIndex
            );
        }
      );
      return previousValue;
    }

    /**
     * Callback for segmentEach
     *
     * @callback segmentEachCallback
     * @param {Feature<LineString>} currentSegment The current Segment being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     * @param {number} segmentIndex The current index of the Segment being processed.
     * @returns {void}
     */

    /**
     * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
     * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
     * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
     * @returns {void}
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     *
     * // Iterate over GeoJSON by 2-vertex segments
     * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
     *   //=currentSegment
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     *   //=segmentIndex
     * });
     *
     * // Calculate the total number of segments
     * var total = 0;
     * turf.segmentEach(polygon, function () {
     *     total++;
     * });
     */
    function segmentEach(geojson, callback) {
      flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;

        // Generate 2-vertex line segments
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (
          coordEach(
            feature,
            function (
              currentCoord,
              coordIndex,
              featureIndexCoord,
              multiPartIndexCoord,
              geometryIndex
            ) {
              // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
              if (
                previousCoords === undefined ||
                featureIndex > previousFeatureIndex ||
                multiPartIndexCoord > previousMultiIndex ||
                geometryIndex > prevGeomIndex
              ) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = helpers.lineString(
                [previousCoords, currentCoord],
                feature.properties
              );
              if (
                callback(
                  currentSegment,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex,
                  segmentIndex
                ) === false
              )
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false
        )
          return false;
      });
    }

    /**
     * Callback for segmentReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback segmentReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<LineString>} currentSegment The current Segment being processed.
     * @param {number} featureIndex The current index of the Feature being processed.
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
     * @param {number} geometryIndex The current index of the Geometry being processed.
     * @param {number} segmentIndex The current index of the Segment being processed.
     */

    /**
     * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
     * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
     * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {void}
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     *
     * // Iterate over GeoJSON by 2-vertex segments
     * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
     *   //= previousSegment
     *   //= currentSegment
     *   //= featureIndex
     *   //= multiFeatureIndex
     *   //= geometryIndex
     *   //= segmentIndex
     *   return currentSegment
     * });
     *
     * // Calculate the total number of segments
     * var initialValue = 0
     * var total = turf.segmentReduce(polygon, function (previousValue) {
     *     previousValue++;
     *     return previousValue;
     * }, initialValue);
     */
    function segmentReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      var started = false;
      segmentEach(
        geojson,
        function (
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) {
          if (started === false && initialValue === undefined)
            previousValue = currentSegment;
          else
            previousValue = callback(
              previousValue,
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            );
          started = true;
        }
      );
      return previousValue;
    }

    /**
     * Callback for lineEach
     *
     * @callback lineEachCallback
     * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
     * @param {number} featureIndex The current index of the Feature being processed
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
     * @param {number} geometryIndex The current index of the Geometry being processed
     */

    /**
     * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
     * similar to Array.forEach.
     *
     * @name lineEach
     * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
     * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
     * @example
     * var multiLine = turf.multiLineString([
     *   [[26, 37], [35, 45]],
     *   [[36, 53], [38, 50], [41, 55]]
     * ]);
     *
     * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=currentLine
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     * });
     */
    function lineEach(geojson, callback) {
      // validation
      if (!geojson) throw new Error("geojson is required");

      flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
          case "LineString":
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)
              return false;
            break;
          case "Polygon":
            for (
              var geometryIndex = 0;
              geometryIndex < coords.length;
              geometryIndex++
            ) {
              if (
                callback(
                  helpers.lineString(coords[geometryIndex], feature.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
            }
            break;
        }
      });
    }

    /**
     * Callback for lineReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback lineReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
     * @param {number} featureIndex The current index of the Feature being processed
     * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
     * @param {number} geometryIndex The current index of the Geometry being processed
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name lineReduce
     * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
     * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var multiPoly = turf.multiPolygon([
     *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
     *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
     * ]);
     *
     * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
     *   //=previousValue
     *   //=currentLine
     *   //=featureIndex
     *   //=multiFeatureIndex
     *   //=geometryIndex
     *   return currentLine
     * });
     */
    function lineReduce(geojson, callback, initialValue) {
      var previousValue = initialValue;
      lineEach(
        geojson,
        function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
          if (featureIndex === 0 && initialValue === undefined)
            previousValue = currentLine;
          else
            previousValue = callback(
              previousValue,
              currentLine,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            );
        }
      );
      return previousValue;
    }

    /**
     * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
     *
     * Negative indexes are permitted.
     * Point & MultiPoint will always return null.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.featureIndex=0] Feature Index
     * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
     * @param {number} [options.geometryIndex=0] Geometry Index
     * @param {number} [options.segmentIndex=0] Segment Index
     * @param {Object} [options.properties={}] Translate Properties to output LineString
     * @param {BBox} [options.bbox={}] Translate BBox to output LineString
     * @param {number|string} [options.id={}] Translate Id to output LineString
     * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
     * @example
     * var multiLine = turf.multiLineString([
     *     [[10, 10], [50, 30], [30, 40]],
     *     [[-10, -10], [-50, -30], [-30, -40]]
     * ]);
     *
     * // First Segment (defaults are 0)
     * turf.findSegment(multiLine);
     * // => Feature<LineString<[[10, 10], [50, 30]]>>
     *
     * // First Segment of 2nd Multi Feature
     * turf.findSegment(multiLine, {multiFeatureIndex: 1});
     * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
     *
     * // Last Segment of Last Multi Feature
     * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
     * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
     */
    function findSegment(geojson, options) {
      // Optional Parameters
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var segmentIndex = options.segmentIndex || 0;

      // Find FeatureIndex
      var properties = options.properties;
      var geometry;

      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }

      // Find SegmentIndex
      if (geometry === null) return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
          if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
          return helpers.lineString(
            [coords[segmentIndex], coords[segmentIndex + 1]],
            properties,
            options
          );
        case "Polygon":
          if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
          return helpers.lineString(
            [
              coords[geometryIndex][segmentIndex],
              coords[geometryIndex][segmentIndex + 1],
            ],
            properties,
            options
          );
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (segmentIndex < 0)
            segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
          return helpers.lineString(
            [
              coords[multiFeatureIndex][segmentIndex],
              coords[multiFeatureIndex][segmentIndex + 1],
            ],
            properties,
            options
          );
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (segmentIndex < 0)
            segmentIndex =
              coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
          return helpers.lineString(
            [
              coords[multiFeatureIndex][geometryIndex][segmentIndex],
              coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],
            ],
            properties,
            options
          );
      }
      throw new Error("geojson is invalid");
    }

    /**
     * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
     *
     * Negative indexes are permitted.
     *
     * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.featureIndex=0] Feature Index
     * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
     * @param {number} [options.geometryIndex=0] Geometry Index
     * @param {number} [options.coordIndex=0] Coord Index
     * @param {Object} [options.properties={}] Translate Properties to output Point
     * @param {BBox} [options.bbox={}] Translate BBox to output Point
     * @param {number|string} [options.id={}] Translate Id to output Point
     * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
     * @example
     * var multiLine = turf.multiLineString([
     *     [[10, 10], [50, 30], [30, 40]],
     *     [[-10, -10], [-50, -30], [-30, -40]]
     * ]);
     *
     * // First Segment (defaults are 0)
     * turf.findPoint(multiLine);
     * // => Feature<Point<[10, 10]>>
     *
     * // First Segment of the 2nd Multi-Feature
     * turf.findPoint(multiLine, {multiFeatureIndex: 1});
     * // => Feature<Point<[-10, -10]>>
     *
     * // Last Segment of last Multi-Feature
     * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
     * // => Feature<Point<[-30, -40]>>
     */
    function findPoint(geojson, options) {
      // Optional Parameters
      options = options || {};
      if (!helpers.isObject(options)) throw new Error("options is invalid");
      var featureIndex = options.featureIndex || 0;
      var multiFeatureIndex = options.multiFeatureIndex || 0;
      var geometryIndex = options.geometryIndex || 0;
      var coordIndex = options.coordIndex || 0;

      // Find FeatureIndex
      var properties = options.properties;
      var geometry;

      switch (geojson.type) {
        case "FeatureCollection":
          if (featureIndex < 0)
            featureIndex = geojson.features.length + featureIndex;
          properties = properties || geojson.features[featureIndex].properties;
          geometry = geojson.features[featureIndex].geometry;
          break;
        case "Feature":
          properties = properties || geojson.properties;
          geometry = geojson.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          geometry = geojson;
          break;
        default:
          throw new Error("geojson is invalid");
      }

      // Find Coord Index
      if (geometry === null) return null;
      var coords = geometry.coordinates;
      switch (geometry.type) {
        case "Point":
          return helpers.point(coords, properties, options);
        case "MultiPoint":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          return helpers.point(coords[multiFeatureIndex], properties, options);
        case "LineString":
          if (coordIndex < 0) coordIndex = coords.length + coordIndex;
          return helpers.point(coords[coordIndex], properties, options);
        case "Polygon":
          if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
          if (coordIndex < 0)
            coordIndex = coords[geometryIndex].length + coordIndex;
          return helpers.point(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (coordIndex < 0)
            coordIndex = coords[multiFeatureIndex].length + coordIndex;
          return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
          if (multiFeatureIndex < 0)
            multiFeatureIndex = coords.length + multiFeatureIndex;
          if (geometryIndex < 0)
            geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
          if (coordIndex < 0)
            coordIndex =
              coords[multiFeatureIndex][geometryIndex].length - coordIndex;
          return helpers.point(
            coords[multiFeatureIndex][geometryIndex][coordIndex],
            properties,
            options
          );
      }
      throw new Error("geojson is invalid");
    }

    var coordAll_1 = coordAll;
    var coordEach_1 = coordEach;
    var coordReduce_1 = coordReduce;
    var featureEach_1 = featureEach$1;
    var featureReduce_1 = featureReduce;
    var findPoint_1 = findPoint;
    var findSegment_1 = findSegment;
    var flattenEach_1 = flattenEach;
    var flattenReduce_1 = flattenReduce;
    var geomEach_1 = geomEach;
    var geomReduce_1 = geomReduce;
    var lineEach_1 = lineEach;
    var lineReduce_1 = lineReduce;
    var propEach_1 = propEach;
    var propReduce_1 = propReduce;
    var segmentEach_1 = segmentEach;
    var segmentReduce_1 = segmentReduce;

    var js$1 = /*#__PURE__*/Object.defineProperty({
    	coordAll: coordAll_1,
    	coordEach: coordEach_1,
    	coordReduce: coordReduce_1,
    	featureEach: featureEach_1,
    	featureReduce: featureReduce_1,
    	findPoint: findPoint_1,
    	findSegment: findSegment_1,
    	flattenEach: flattenEach_1,
    	flattenReduce: flattenReduce_1,
    	geomEach: geomEach_1,
    	geomReduce: geomReduce_1,
    	lineEach: lineEach_1,
    	lineReduce: lineReduce_1,
    	propEach: propEach_1,
    	propReduce: propReduce_1,
    	segmentEach: segmentEach_1,
    	segmentReduce: segmentReduce_1
    }, '__esModule', {value: true});

    var meta = js$1;

    /**
     * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
     *
     * @name bbox
     * @param {GeoJSON} geojson any GeoJSON object
     * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
     * var bbox = turf.bbox(line);
     * var bboxPolygon = turf.bboxPolygon(bbox);
     *
     * //addToMap
     * var addToMap = [line, bboxPolygon]
     */
    function bbox(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        meta.coordEach(geojson, function (coord) {
            if (result[0] > coord[0]) {
                result[0] = coord[0];
            }
            if (result[1] > coord[1]) {
                result[1] = coord[1];
            }
            if (result[2] < coord[0]) {
                result[2] = coord[0];
            }
            if (result[3] < coord[1]) {
                result[3] = coord[1];
            }
        });
        return result;
    }
    bbox["default"] = bbox;
    var _default$1 = bbox;

    var js = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var require$$0$1 = js;

    var turfBBox = require$$0$1.default;
    var featureEach = meta.featureEach;
    meta.coordEach;
    helpers.polygon;
    var featureCollection = helpers.featureCollection;

    /**
     * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
     *
     * @name rbush
     * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
     * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
     * @returns {RBush} GeoJSON RBush
     * @example
     * var geojsonRbush = require('geojson-rbush').default;
     * var tree = geojsonRbush();
     */
    function geojsonRbush(maxEntries) {
        var tree = new rbush_min(maxEntries);
        /**
         * [insert](https://github.com/mourner/rbush#data-format)
         *
         * @param {Feature} feature insert single GeoJSON Feature
         * @returns {RBush} GeoJSON RBush
         * @example
         * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
         * tree.insert(poly)
         */
        tree.insert = function (feature) {
            if (feature.type !== 'Feature') throw new Error('invalid feature');
            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
            return rbush_min.prototype.insert.call(this, feature);
        };

        /**
         * [load](https://github.com/mourner/rbush#bulk-inserting-data)
         *
         * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection
         * @returns {RBush} GeoJSON RBush
         * @example
         * var polys = turf.polygons([
         *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],
         *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
         * ]);
         * tree.load(polys);
         */
        tree.load = function (features) {
            var load = [];
            // Load an Array of Features
            if (Array.isArray(features)) {
                features.forEach(function (feature) {
                    if (feature.type !== 'Feature') throw new Error('invalid features');
                    feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                    load.push(feature);
                });
            } else {
                // Load a FeatureCollection
                featureEach(features, function (feature) {
                    if (feature.type !== 'Feature') throw new Error('invalid features');
                    feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                    load.push(feature);
                });
            }
            return rbush_min.prototype.load.call(this, load);
        };

        /**
         * [remove](https://github.com/mourner/rbush#removing-data)
         *
         * @param {Feature} feature remove single GeoJSON Feature
         * @param {Function} equals Pass a custom equals function to compare by value for removal.
         * @returns {RBush} GeoJSON RBush
         * @example
         * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
         *
         * tree.remove(poly);
         */
        tree.remove = function (feature, equals) {
            if (feature.type !== 'Feature') throw new Error('invalid feature');
            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
            return rbush_min.prototype.remove.call(this, feature, equals);
        };

        /**
         * [clear](https://github.com/mourner/rbush#removing-data)
         *
         * @returns {RBush} GeoJSON Rbush
         * @example
         * tree.clear()
         */
        tree.clear = function () {
            return rbush_min.prototype.clear.call(this);
        };

        /**
         * [search](https://github.com/mourner/rbush#search)
         *
         * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON
         * @returns {FeatureCollection} all features that intersects with the given GeoJSON.
         * @example
         * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
         *
         * tree.search(poly);
         */
        tree.search = function (geojson) {
            var features = rbush_min.prototype.search.call(this, this.toBBox(geojson));
            return featureCollection(features);
        };

        /**
         * [collides](https://github.com/mourner/rbush#collisions)
         *
         * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON
         * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
         * @example
         * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
         *
         * tree.collides(poly);
         */
        tree.collides = function (geojson) {
            return rbush_min.prototype.collides.call(this, this.toBBox(geojson));
        };

        /**
         * [all](https://github.com/mourner/rbush#search)
         *
         * @returns {FeatureCollection} all the features in RBush
         * @example
         * tree.all()
         */
        tree.all = function () {
            var features = rbush_min.prototype.all.call(this);
            return featureCollection(features);
        };

        /**
         * [toJSON](https://github.com/mourner/rbush#export-and-import)
         *
         * @returns {any} export data as JSON object
         * @example
         * var exported = tree.toJSON()
         */
        tree.toJSON = function () {
            return rbush_min.prototype.toJSON.call(this);
        };

        /**
         * [fromJSON](https://github.com/mourner/rbush#export-and-import)
         *
         * @param {any} json import previously exported data
         * @returns {RBush} GeoJSON RBush
         * @example
         * var exported = {
         *   "children": [
         *     {
         *       "type": "Feature",
         *       "geometry": {
         *         "type": "Point",
         *         "coordinates": [110, 50]
         *       },
         *       "properties": {},
         *       "bbox": [110, 50, 110, 50]
         *     }
         *   ],
         *   "height": 1,
         *   "leaf": true,
         *   "minX": 110,
         *   "minY": 50,
         *   "maxX": 110,
         *   "maxY": 50
         * }
         * tree.fromJSON(exported)
         */
        tree.fromJSON = function (json) {
            return rbush_min.prototype.fromJSON.call(this, json);
        };

        /**
         * Converts GeoJSON to {minX, minY, maxX, maxY} schema
         *
         * @private
         * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from
         * @returns {Object} converted to {minX, minY, maxX, maxY}
         */
        tree.toBBox = function (geojson) {
            var bbox;
            if (geojson.bbox) bbox = geojson.bbox;
            else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
            else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];
            else if (geojson.type === 'Feature') bbox = turfBBox(geojson);
            else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);
            else throw new Error('invalid geojson')

            return {
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3]
            };
        };
        return tree;
    }

    var geojsonRbush_1 = geojsonRbush;
    var _default = geojsonRbush;
    geojsonRbush_1.default = _default;

    /**
     * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
     *
     * @name lineIntersect
     * @param {GeoJSON} line1 any LineString or Polygon
     * @param {GeoJSON} line2 any LineString or Polygon
     * @returns {FeatureCollection<Point>} point(s) that intersect both
     * @example
     * var line1 = turf.lineString([[126, -11], [129, -21]]);
     * var line2 = turf.lineString([[123, -18], [131, -14]]);
     * var intersects = turf.lineIntersect(line1, line2);
     *
     * //addToMap
     * var addToMap = [line1, line2, intersects]
     */
    function lineIntersect(line1, line2) {
        var unique = {};
        var results = [];
        // First, normalize geometries to features
        // Then, handle simple 2-vertex segments
        if (line1.type === "LineString") {
            line1 = feature(line1);
        }
        if (line2.type === "LineString") {
            line2 = feature(line2);
        }
        if (line1.type === "Feature" &&
            line2.type === "Feature" &&
            line1.geometry !== null &&
            line2.geometry !== null &&
            line1.geometry.type === "LineString" &&
            line2.geometry.type === "LineString" &&
            line1.geometry.coordinates.length === 2 &&
            line2.geometry.coordinates.length === 2) {
            var intersect = intersects(line1, line2);
            if (intersect) {
                results.push(intersect);
            }
            return featureCollection$1(results);
        }
        // Handles complex GeoJSON Geometries
        var tree = geojsonRbush_1();
        tree.load(lineSegment(line2));
        featureEach$2(lineSegment(line1), function (segment) {
            featureEach$2(tree.search(segment), function (match) {
                var intersect = intersects(segment, match);
                if (intersect) {
                    // prevent duplicate points https://github.com/Turfjs/turf/issues/688
                    var key = getCoords(intersect).join(",");
                    if (!unique[key]) {
                        unique[key] = true;
                        results.push(intersect);
                    }
                }
            });
        });
        return featureCollection$1(results);
    }
    /**
     * Find a point that intersects LineStrings with two coordinates each
     *
     * @private
     * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
     * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
     * @returns {Feature<Point>} intersecting GeoJSON Point
     */
    function intersects(line1, line2) {
        var coords1 = getCoords(line1);
        var coords2 = getCoords(line2);
        if (coords1.length !== 2) {
            throw new Error("<intersects> line1 must only contain 2 coordinates");
        }
        if (coords2.length !== 2) {
            throw new Error("<intersects> line2 must only contain 2 coordinates");
        }
        var x1 = coords1[0][0];
        var y1 = coords1[0][1];
        var x2 = coords1[1][0];
        var y2 = coords1[1][1];
        var x3 = coords2[0][0];
        var y3 = coords2[0][1];
        var x4 = coords2[1][0];
        var y4 = coords2[1][1];
        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
        if (denom === 0) {
            if (numeA === 0 && numeB === 0) {
                return null;
            }
            return null;
        }
        var uA = numeA / denom;
        var uB = numeB / denom;
        if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
            var x = x1 + uA * (x2 - x1);
            var y = y1 + uA * (y2 - y1);
            return point([x, y]);
        }
        return null;
    }

    /**
     * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
     *
     * @name nearestPointOnLine
     * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
     * @param {Geometry|Feature<Point>|number[]} pt point to snap from
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
     * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
     * @example
     * var line = turf.lineString([
     *     [-77.031669, 38.878605],
     *     [-77.029609, 38.881946],
     *     [-77.020339, 38.884084],
     *     [-77.025661, 38.885821],
     *     [-77.021884, 38.889563],
     *     [-77.019824, 38.892368]
     * ]);
     * var pt = turf.point([-77.037076, 38.884017]);
     *
     * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});
     *
     * //addToMap
     * var addToMap = [line, pt, snapped];
     * snapped.properties['marker-color'] = '#00f';
     */
    function nearestPointOnLine(lines, pt, options) {
        if (options === void 0) { options = {}; }
        var closestPt = point([Infinity, Infinity], {
            dist: Infinity,
        });
        var length = 0.0;
        flattenEach$1(lines, function (line) {
            var coords = getCoords(line);
            for (var i = 0; i < coords.length - 1; i++) {
                //start
                var start = point(coords[i]);
                start.properties.dist = distance$1(pt, start, options);
                //stop
                var stop_1 = point(coords[i + 1]);
                stop_1.properties.dist = distance$1(pt, stop_1, options);
                // sectionLength
                var sectionLength = distance$1(start, stop_1, options);
                //perpendicular
                var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
                var direction = bearing(start, stop_1);
                var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);
                var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);
                var intersect = lineIntersect(lineString([
                    perpendicularPt1.geometry.coordinates,
                    perpendicularPt2.geometry.coordinates,
                ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
                var intersectPt = null;
                if (intersect.features.length > 0) {
                    intersectPt = intersect.features[0];
                    intersectPt.properties.dist = distance$1(pt, intersectPt, options);
                    intersectPt.properties.location =
                        length + distance$1(start, intersectPt, options);
                }
                if (start.properties.dist < closestPt.properties.dist) {
                    closestPt = start;
                    closestPt.properties.index = i;
                    closestPt.properties.location = length;
                }
                if (stop_1.properties.dist < closestPt.properties.dist) {
                    closestPt = stop_1;
                    closestPt.properties.index = i + 1;
                    closestPt.properties.location = length + sectionLength;
                }
                if (intersectPt &&
                    intersectPt.properties.dist < closestPt.properties.dist) {
                    closestPt = intersectPt;
                    closestPt.properties.index = i;
                }
                // update length
                length += sectionLength;
            }
        });
        return closestPt;
    }

    // https://en.wikipedia.org/wiki/Rhumb_line
    /**
     * Calculates the distance along a rhumb line between two {@link Point|points} in degrees, radians,
     * miles, or kilometers.
     *
     * @name rhumbDistance
     * @param {Coord} from origin point
     * @param {Coord} to destination point
     * @param {Object} [options] Optional parameters
     * @param {string} [options.units="kilometers"] can be degrees, radians, miles, or kilometers
     * @returns {number} distance between the two points
     * @example
     * var from = turf.point([-75.343, 39.984]);
     * var to = turf.point([-75.534, 39.123]);
     * var options = {units: 'miles'};
     *
     * var distance = turf.rhumbDistance(from, to, options);
     *
     * //addToMap
     * var addToMap = [from, to];
     * from.properties.distance = distance;
     * to.properties.distance = distance;
     */
    function rhumbDistance(from, to, options) {
        if (options === void 0) { options = {}; }
        var origin = getCoord(from);
        var destination = getCoord(to);
        // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)
        // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678
        destination[0] +=
            destination[0] - origin[0] > 180
                ? -360
                : origin[0] - destination[0] > 180
                    ? 360
                    : 0;
        var distanceInMeters = calculateRhumbDistance(origin, destination);
        var distance = convertLength(distanceInMeters, "meters", options.units);
        return distance;
    }
    /**
     * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.
     * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js
     *
     * @private
     * @param   {Array<number>} origin point.
     * @param   {Array<number>} destination point.
     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
     * @returns {number} Distance in km between this point and destination point (same units as radius).
     *
     * @example
     *     var p1 = new LatLon(51.127, 1.338);
     *     var p2 = new LatLon(50.964, 1.853);
     *     var d = p1.distanceTo(p2); // 40.31 km
     */
    function calculateRhumbDistance(origin, destination, radius) {
        // φ => phi
        // λ => lambda
        // ψ => psi
        // Δ => Delta
        // δ => delta
        // θ => theta
        radius = radius === undefined ? earthRadius : Number(radius);
        // see www.edwilliams.org/avform.htm#Rhumb
        var R = radius;
        var phi1 = (origin[1] * Math.PI) / 180;
        var phi2 = (destination[1] * Math.PI) / 180;
        var DeltaPhi = phi2 - phi1;
        var DeltaLambda = (Math.abs(destination[0] - origin[0]) * Math.PI) / 180;
        // if dLon over 180° take shorter rhumb line across the anti-meridian:
        if (DeltaLambda > Math.PI) {
            DeltaLambda -= 2 * Math.PI;
        }
        // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'
        // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it
        var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
        var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
        // distance is pythagoras on 'stretched' Mercator projection
        var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians
        var dist = delta * R;
        return dist;
    }

    // Taken from http://geomalgorithms.com/a02-_lines.html
    /**
     * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the
     * minimum distance between the point and any segment of the `LineString`.
     *
     * @name pointToLineDistance
     * @param {Feature<Point>|Array<number>} pt Feature or Geometry
     * @param {Feature<LineString>} line GeoJSON Feature or Geometry
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units="kilometers"] can be anything supported by turf/convertLength
     * (ex: degrees, radians, miles, or kilometers)
     * @param {string} [options.method="geodesic"] wether to calculate the distance based on geodesic (spheroid) or
     * planar (flat) method. Valid options are 'geodesic' or 'planar'.
     * @returns {number} distance between point and line
     * @example
     * var pt = turf.point([0, 0]);
     * var line = turf.lineString([[1, 1],[-1, 1]]);
     *
     * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});
     * //=69.11854715938406
     */
    function pointToLineDistance(pt, line, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        if (!options.method) {
            options.method = "geodesic";
        }
        if (!options.units) {
            options.units = "kilometers";
        }
        // validation
        if (!pt) {
            throw new Error("pt is required");
        }
        if (Array.isArray(pt)) {
            pt = point(pt);
        }
        else if (pt.type === "Point") {
            pt = feature(pt);
        }
        else {
            featureOf(pt, "Point", "point");
        }
        if (!line) {
            throw new Error("line is required");
        }
        if (Array.isArray(line)) {
            line = lineString(line);
        }
        else if (line.type === "LineString") {
            line = feature(line);
        }
        else {
            featureOf(line, "LineString", "line");
        }
        var distance = Infinity;
        var p = pt.geometry.coordinates;
        segmentEach$1(line, function (segment) {
            var a = segment.geometry.coordinates[0];
            var b = segment.geometry.coordinates[1];
            var d = distanceToSegment(p, a, b, options);
            if (d < distance) {
                distance = d;
            }
        });
        return convertLength(distance, "degrees", options.units);
    }
    /**
     * Returns the distance between a point P on a segment AB.
     *
     * @private
     * @param {Array<number>} p external point
     * @param {Array<number>} a first segment point
     * @param {Array<number>} b second segment point
     * @param {Object} [options={}] Optional parameters
     * @returns {number} distance
     */
    function distanceToSegment(p, a, b, options) {
        var v = [b[0] - a[0], b[1] - a[1]];
        var w = [p[0] - a[0], p[1] - a[1]];
        var c1 = dot(w, v);
        if (c1 <= 0) {
            return calcDistance(p, a, { method: options.method, units: "degrees" });
        }
        var c2 = dot(v, v);
        if (c2 <= c1) {
            return calcDistance(p, b, { method: options.method, units: "degrees" });
        }
        var b2 = c1 / c2;
        var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
        return calcDistance(p, Pb, { method: options.method, units: "degrees" });
    }
    function dot(u, v) {
        return u[0] * v[0] + u[1] * v[1];
    }
    function calcDistance(a, b, options) {
        return options.method === "planar"
            ? rhumbDistance(a, b, options)
            : distance$1(a, b, options);
    }

    /**
     * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,
     * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.
     *
     * @name nearestPointToLine
     * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection
     * @param {Feature|Geometry<LineString>} line Line Feature
     * @param {Object} [options] Optional parameters
     * @param {string} [options.units='kilometers'] unit of the output distance property
     * (eg: degrees, radians, miles, or kilometers)
     * @param {Object} [options.properties={}] Translate Properties to Point
     * @returns {Feature<Point>} the closest point
     * @example
     * var pt1 = turf.point([0, 0]);
     * var pt2 = turf.point([0.5, 0.5]);
     * var points = turf.featureCollection([pt1, pt2]);
     * var line = turf.lineString([[1,1], [-1,1]]);
     *
     * var nearest = turf.nearestPointToLine(points, line);
     *
     * //addToMap
     * var addToMap = [nearest, line];
     */
    function nearestPointToLine(points, line, options) {
        if (options === void 0) { options = {}; }
        var units = options.units;
        var properties = options.properties || {};
        // validation
        var pts = normalize$1(points);
        if (!pts.features.length) {
            throw new Error("points must contain features");
        }
        if (!line) {
            throw new Error("line is required");
        }
        if (getType$1(line) !== "LineString") {
            throw new Error("line must be a LineString");
        }
        var dist = Infinity;
        var pt = null;
        featureEach$2(pts, function (point) {
            var d = pointToLineDistance(point, line, { units: units });
            if (d < dist) {
                dist = d;
                pt = point;
            }
        });
        /**
         * Translate Properties to final Point, priorities:
         * 1. options.properties
         * 2. inherent Point properties
         * 3. dist custom properties created by NearestPointToLine
         */
        if (pt) {
            pt.properties = objectAssign({ dist: dist }, pt.properties, properties);
        }
        // if (pt) { pt.properties = objectAssign({dist}, pt.properties, properties); }
        return pt;
    }
    /**
     * Convert Collection to FeatureCollection
     *
     * @private
     * @param {FeatureCollection|GeometryCollection} points Points
     * @returns {FeatureCollection<Point>} points
     */
    function normalize$1(points) {
        var features = [];
        var type = points.geometry ? points.geometry.type : points.type;
        switch (type) {
            case "GeometryCollection":
                geomEach$1(points, function (geom) {
                    if (geom.type === "Point") {
                        features.push({ type: "Feature", properties: {}, geometry: geom });
                    }
                });
                return { type: "FeatureCollection", features: features };
            case "FeatureCollection":
                points.features = points.features.filter(function (feature) {
                    return feature.geometry.type === "Point";
                });
                return points;
            default:
                throw new Error("points must be a Point Collection");
        }
    }

    /**
     * Takes a triangular plane as a {@link Polygon}
     * and a {@link Point} within that triangle and returns the z-value
     * at that point. The Polygon should have properties `a`, `b`, and `c`
     * that define the values at its three corners. Alternatively, the z-values
     * of each triangle point can be provided by their respective 3rd coordinate
     * if their values are not provided as properties.
     *
     * @name planepoint
     * @param {Coord} point the Point for which a z-value will be calculated
     * @param {Feature<Polygon>} triangle a Polygon feature with three vertices
     * @returns {number} the z-value for `interpolatedPoint`
     * @example
     * var point = turf.point([-75.3221, 39.529]);
     * // "a", "b", and "c" values represent the values of the coordinates in order.
     * var triangle = turf.polygon([[
     *   [-75.1221, 39.57],
     *   [-75.58, 39.18],
     *   [-75.97, 39.86],
     *   [-75.1221, 39.57]
     * ]], {
     *   "a": 11,
     *   "b": 122,
     *   "c": 44
     * });
     *
     * var zValue = turf.planepoint(point, triangle);
     * point.properties.zValue = zValue;
     *
     * //addToMap
     * var addToMap = [triangle, point];
     */
    function planepoint(point, triangle) {
      // Normalize input
      var coord = getCoord(point);
      var geom = getGeom(triangle);
      var coords = geom.coordinates;
      var outer = coords[0];
      if (outer.length < 4)
        throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
      var properties = triangle.properties || {};
      var a = properties.a;
      var b = properties.b;
      var c = properties.c;

      // Planepoint
      var x = coord[0];
      var y = coord[1];
      var x1 = outer[0][0];
      var y1 = outer[0][1];
      var z1 = a !== undefined ? a : outer[0][2];
      var x2 = outer[1][0];
      var y2 = outer[1][1];
      var z2 = b !== undefined ? b : outer[1][2];
      var x3 = outer[2][0];
      var y3 = outer[2][1];
      var z3 = c !== undefined ? c : outer[2][2];
      var z =
        (z3 * (x - x1) * (y - y2) +
          z1 * (x - x2) * (y - y3) +
          z2 * (x - x3) * (y - y1) -
          z2 * (x - x1) * (y - y3) -
          z3 * (x - x2) * (y - y1) -
          z1 * (x - x3) * (y - y2)) /
        ((x - x1) * (y - y2) +
          (x - x2) * (y - y3) +
          (x - x3) * (y - y1) -
          (x - x1) * (y - y3) -
          (x - x2) * (y - y1) -
          (x - x3) * (y - y2));

      return z;
    }

    /**
     * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},
     * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and
     * returns {@link Point|points} at all self-intersections.
     *
     * @name kinks
     * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature
     * @returns {FeatureCollection<Point>} self-intersections
     * @example
     * var poly = turf.polygon([[
     *   [-12.034835, 8.901183],
     *   [-12.060413, 8.899826],
     *   [-12.03638, 8.873199],
     *   [-12.059383, 8.871418],
     *   [-12.034835, 8.901183]
     * ]]);
     *
     * var kinks = turf.kinks(poly);
     *
     * //addToMap
     * var addToMap = [poly, kinks]
     */
    function kinks(featureIn) {
        var coordinates;
        var feature;
        var results = {
            type: "FeatureCollection",
            features: [],
        };
        if (featureIn.type === "Feature") {
            feature = featureIn.geometry;
        }
        else {
            feature = featureIn;
        }
        if (feature.type === "LineString") {
            coordinates = [feature.coordinates];
        }
        else if (feature.type === "MultiLineString") {
            coordinates = feature.coordinates;
        }
        else if (feature.type === "MultiPolygon") {
            coordinates = [].concat.apply([], feature.coordinates);
        }
        else if (feature.type === "Polygon") {
            coordinates = feature.coordinates;
        }
        else {
            throw new Error("Input must be a LineString, MultiLineString, " +
                "Polygon, or MultiPolygon Feature or Geometry");
        }
        coordinates.forEach(function (line1) {
            coordinates.forEach(function (line2) {
                for (var i = 0; i < line1.length - 1; i++) {
                    // start iteration at i, intersections for k < i have already
                    // been checked in previous outer loop iterations
                    for (var k = i; k < line2.length - 1; k++) {
                        if (line1 === line2) {
                            // segments are adjacent and always share a vertex, not a kink
                            if (Math.abs(i - k) === 1) {
                                continue;
                            }
                            // first and last segment in a closed lineString or ring always share a vertex, not a kink
                            if (
                            // segments are first and last segment of lineString
                            i === 0 &&
                                k === line1.length - 2 &&
                                // lineString is closed
                                line1[i][0] === line1[line1.length - 1][0] &&
                                line1[i][1] === line1[line1.length - 1][1]) {
                                continue;
                            }
                        }
                        var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
                        if (intersection) {
                            results.features.push(point([intersection[0], intersection[1]]));
                        }
                    }
                }
            });
        });
        return results;
    }
    // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
    function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
        // if the lines intersect, the result contains the x and y of the
        // intersection (treating the lines as infinite) and booleans for whether
        // line segment 1 or line segment 2 contain the point
        var denominator;
        var a;
        var b;
        var numerator1;
        var numerator2;
        var result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false,
        };
        denominator =
            (line2EndY - line2StartY) * (line1EndX - line1StartX) -
                (line2EndX - line2StartX) * (line1EndY - line1StartY);
        if (denominator === 0) {
            if (result.x !== null && result.y !== null) {
                return result;
            }
            else {
                return false;
            }
        }
        a = line1StartY - line2StartY;
        b = line1StartX - line2StartX;
        numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
        numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
        a = numerator1 / denominator;
        b = numerator2 / denominator;
        // if we cast these lines infinitely in both directions, they intersect here:
        result.x = line1StartX + a * (line1EndX - line1StartX);
        result.y = line1StartY + a * (line1EndY - line1StartY);
        // if line1 is a segment and line2 is infinite, they intersect if:
        if (a >= 0 && a <= 1) {
            result.onLine1 = true;
        }
        // if line2 is a segment and line1 is infinite, they intersect if:
        if (b >= 0 && b <= 1) {
            result.onLine2 = true;
        }
        // if line1 and line2 are segments, they intersect if both of the above are true
        if (result.onLine1 && result.onLine2) {
            return [result.x, result.y];
        }
        else {
            return false;
        }
    }

    /**
     * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.
     *
     * * Given a {@link Polygon}, the point will be in the area of the polygon
     * * Given a {@link LineString}, the point will be along the string
     * * Given a {@link Point}, the point will the same as the input
     *
     * @name pointOnFeature
     * @param {GeoJSON} geojson any Feature or FeatureCollection
     * @returns {Feature<Point>} a point on the surface of `input`
     * @example
     * var polygon = turf.polygon([[
     *   [116, -36],
     *   [131, -32],
     *   [146, -43],
     *   [155, -25],
     *   [133, -9],
     *   [111, -22],
     *   [116, -36]
     * ]]);
     *
     * var pointOnPolygon = turf.pointOnFeature(polygon);
     *
     * //addToMap
     * var addToMap = [polygon, pointOnPolygon];
     */
    function pointOnFeature(geojson) {
      // normalize
      var fc = normalize(geojson);

      // get centroid
      var cent = center(fc);

      // check to see if centroid is on surface
      var onSurface = false;
      var i = 0;
      while (!onSurface && i < fc.features.length) {
        var geom = fc.features[i].geometry;
        var x, y, x1, y1, x2, y2, k;
        var onLine = false;
        if (geom.type === "Point") {
          if (
            cent.geometry.coordinates[0] === geom.coordinates[0] &&
            cent.geometry.coordinates[1] === geom.coordinates[1]
          ) {
            onSurface = true;
          }
        } else if (geom.type === "MultiPoint") {
          var onMultiPoint = false;
          k = 0;
          while (!onMultiPoint && k < geom.coordinates.length) {
            if (
              cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
              cent.geometry.coordinates[1] === geom.coordinates[k][1]
            ) {
              onSurface = true;
              onMultiPoint = true;
            }
            k++;
          }
        } else if (geom.type === "LineString") {
          k = 0;
          while (!onLine && k < geom.coordinates.length - 1) {
            x = cent.geometry.coordinates[0];
            y = cent.geometry.coordinates[1];
            x1 = geom.coordinates[k][0];
            y1 = geom.coordinates[k][1];
            x2 = geom.coordinates[k + 1][0];
            y2 = geom.coordinates[k + 1][1];
            if (pointOnSegment(x, y, x1, y1, x2, y2)) {
              onLine = true;
              onSurface = true;
            }
            k++;
          }
        } else if (geom.type === "MultiLineString") {
          var j = 0;
          while (j < geom.coordinates.length) {
            onLine = false;
            k = 0;
            var line = geom.coordinates[j];
            while (!onLine && k < line.length - 1) {
              x = cent.geometry.coordinates[0];
              y = cent.geometry.coordinates[1];
              x1 = line[k][0];
              y1 = line[k][1];
              x2 = line[k + 1][0];
              y2 = line[k + 1][1];
              if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                onLine = true;
                onSurface = true;
              }
              k++;
            }
            j++;
          }
        } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
          if (booleanPointInPolygon(cent, geom)) {
            onSurface = true;
          }
        }
        i++;
      }
      if (onSurface) {
        return cent;
      } else {
        var vertices = featureCollection$1([]);
        for (i = 0; i < fc.features.length; i++) {
          vertices.features = vertices.features.concat(
            explode$1(fc.features[i]).features
          );
        }
        // Remove distanceToPoint properties from nearestPoint()
        return point(nearestPoint(cent, vertices).geometry.coordinates);
      }
    }

    /**
     * Normalizes any GeoJSON to a FeatureCollection
     *
     * @private
     * @name normalize
     * @param {GeoJSON} geojson Any GeoJSON
     * @returns {FeatureCollection} FeatureCollection
     */
    function normalize(geojson) {
      if (geojson.type !== "FeatureCollection") {
        if (geojson.type !== "Feature") {
          return featureCollection$1([feature(geojson)]);
        }
        return featureCollection$1([geojson]);
      }
      return geojson;
    }

    function pointOnSegment(x, y, x1, y1, x2, y2) {
      var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
      return ab === ap + pb;
    }

    // Note: change RADIUS => earthRadius
    var RADIUS = 6378137;
    /**
     * Takes one or more features and returns their area in square meters.
     *
     * @name area
     * @param {GeoJSON} geojson input GeoJSON feature(s)
     * @returns {number} area in square meters
     * @example
     * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
     *
     * var area = turf.area(polygon);
     *
     * //addToMap
     * var addToMap = [polygon]
     * polygon.properties.area = area
     */
    function area(geojson) {
        return geomReduce$1(geojson, function (value, geom) {
            return value + calculateArea$1(geom);
        }, 0);
    }
    /**
     * Calculate Area
     *
     * @private
     * @param {Geometry} geom GeoJSON Geometries
     * @returns {number} area
     */
    function calculateArea$1(geom) {
        var total = 0;
        var i;
        switch (geom.type) {
            case "Polygon":
                return polygonArea(geom.coordinates);
            case "MultiPolygon":
                for (i = 0; i < geom.coordinates.length; i++) {
                    total += polygonArea(geom.coordinates[i]);
                }
                return total;
            case "Point":
            case "MultiPoint":
            case "LineString":
            case "MultiLineString":
                return 0;
        }
        return 0;
    }
    function polygonArea(coords) {
        var total = 0;
        if (coords && coords.length > 0) {
            total += Math.abs(ringArea(coords[0]));
            for (var i = 1; i < coords.length; i++) {
                total -= Math.abs(ringArea(coords[i]));
            }
        }
        return total;
    }
    /**
     * @private
     * Calculate the approximate area of the polygon were it projected onto the earth.
     * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
     *
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere",
     * JPL Publication 07-03, Jet Propulsion
     * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409
     *
     * @param {Array<Array<number>>} coords Ring Coordinates
     * @returns {number} The approximate signed geodesic area of the polygon in square meters.
     */
    function ringArea(coords) {
        var p1;
        var p2;
        var p3;
        var lowerIndex;
        var middleIndex;
        var upperIndex;
        var i;
        var total = 0;
        var coordsLength = coords.length;
        if (coordsLength > 2) {
            for (i = 0; i < coordsLength; i++) {
                if (i === coordsLength - 2) {
                    // i = N-2
                    lowerIndex = coordsLength - 2;
                    middleIndex = coordsLength - 1;
                    upperIndex = 0;
                }
                else if (i === coordsLength - 1) {
                    // i = N-1
                    lowerIndex = coordsLength - 1;
                    middleIndex = 0;
                    upperIndex = 1;
                }
                else {
                    // i = 0 to N-3
                    lowerIndex = i;
                    middleIndex = i + 1;
                    upperIndex = i + 2;
                }
                p1 = coords[lowerIndex];
                p2 = coords[middleIndex];
                p3 = coords[upperIndex];
                total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
            }
            total = (total * RADIUS * RADIUS) / 2;
        }
        return total;
    }
    function rad(num) {
        return (num * Math.PI) / 180;
    }

    /**
     * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.
     *
     * @name along
     * @param {Feature<LineString>} line input line
     * @param {number} distance distance along the line
     * @param {Object} [options] Optional parameters
     * @param {string} [options.units="kilometers"] can be degrees, radians, miles, or kilometers
     * @returns {Feature<Point>} Point `distance` `units` along the line
     * @example
     * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);
     * var options = {units: 'miles'};
     *
     * var along = turf.along(line, 200, options);
     *
     * //addToMap
     * var addToMap = [along, line]
     */
    function along(line, distance, options) {
        if (options === void 0) { options = {}; }
        // Get Coords
        var geom = getGeom(line);
        var coords = geom.coordinates;
        var travelled = 0;
        for (var i = 0; i < coords.length; i++) {
            if (distance >= travelled && i === coords.length - 1) {
                break;
            }
            else if (travelled >= distance) {
                var overshot = distance - travelled;
                if (!overshot) {
                    return point(coords[i]);
                }
                else {
                    var direction = bearing(coords[i], coords[i - 1]) - 180;
                    var interpolated = destination(coords[i], overshot, direction, options);
                    return interpolated;
                }
            }
            else {
                travelled += distance$1(coords[i], coords[i + 1], options);
            }
        }
        return point(coords[coords.length - 1]);
    }

    /**
     * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.
     *
     * @name length
     * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers
     * @returns {number} length of GeoJSON
     * @example
     * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);
     * var length = turf.length(line, {units: 'miles'});
     *
     * //addToMap
     * var addToMap = [line];
     * line.properties.distance = length;
     */
    function length(geojson, options) {
        if (options === void 0) { options = {}; }
        // Calculate distance from 2-vertex line segments
        return segmentReduce$1(geojson, function (previousValue, segment) {
            var coords = segment.geometry.coordinates;
            return previousValue + distance$1(coords[0], coords[1], options);
        }, 0);
    }

    /**
     * Takes a {@link LineString|line}, a start {@link Point}, and a stop point
     * and returns a subsection of the line in-between those points.
     * The start & stop points don't need to fall exactly on the line.
     *
     * This can be useful for extracting only the part of a route between waypoints.
     *
     * @name lineSlice
     * @param {Coord} startPt starting point
     * @param {Coord} stopPt stopping point
     * @param {Feature<LineString>|LineString} line line to slice
     * @returns {Feature<LineString>} sliced line
     * @example
     * var line = turf.lineString([
     *     [-77.031669, 38.878605],
     *     [-77.029609, 38.881946],
     *     [-77.020339, 38.884084],
     *     [-77.025661, 38.885821],
     *     [-77.021884, 38.889563],
     *     [-77.019824, 38.892368]
     * ]);
     * var start = turf.point([-77.029609, 38.881946]);
     * var stop = turf.point([-77.021884, 38.889563]);
     *
     * var sliced = turf.lineSlice(start, stop, line);
     *
     * //addToMap
     * var addToMap = [start, stop, line]
     */
    function lineSlice(startPt, stopPt, line) {
      // Validation
      var coords = getCoords(line);
      if (getType$1(line) !== "LineString")
        throw new Error("line must be a LineString");

      var startVertex = nearestPointOnLine(line, startPt);
      var stopVertex = nearestPointOnLine(line, stopPt);
      var ends;
      if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [startVertex, stopVertex];
      } else {
        ends = [stopVertex, startVertex];
      }
      var clipCoords = [ends[0].geometry.coordinates];
      for (
        var i = ends[0].properties.index + 1;
        i < ends[1].properties.index + 1;
        i++
      ) {
        clipCoords.push(coords[i]);
      }
      clipCoords.push(ends[1].geometry.coordinates);
      return lineString(clipCoords, line.properties);
    }

    /**
     * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},
     * and a specified  distance along the line to a stop point
     * and returns a subsection of the line in-between those points.
     *
     * This can be useful for extracting only the part of a route between two distances.
     *
     * @name lineSliceAlong
     * @param {Feature<LineString>|LineString} line input line
     * @param {number} startDist distance along the line to starting point
     * @param {number} stopDist distance along the line to ending point
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
     * @returns {Feature<LineString>} sliced line
     * @example
     * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);
     * var start = 12.5;
     * var stop = 25;
     * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});
     *
     * //addToMap
     * var addToMap = [line, start, stop, sliced]
     */
    function lineSliceAlong(line, startDist, stopDist, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");

      var coords;
      var slice = [];

      // Validation
      if (line.type === "Feature") coords = line.geometry.coordinates;
      else if (line.type === "LineString") coords = line.coordinates;
      else throw new Error("input must be a LineString Feature or Geometry");
      var origCoordsLength = coords.length;
      var travelled = 0;
      var overshot, direction, interpolated;
      for (var i = 0; i < coords.length; i++) {
        if (startDist >= travelled && i === coords.length - 1) break;
        else if (travelled > startDist && slice.length === 0) {
          overshot = startDist - travelled;
          if (!overshot) {
            slice.push(coords[i]);
            return lineString(slice);
          }
          direction = bearing(coords[i], coords[i - 1]) - 180;
          interpolated = destination(coords[i], overshot, direction, options);
          slice.push(interpolated.geometry.coordinates);
        }

        if (travelled >= stopDist) {
          overshot = stopDist - travelled;
          if (!overshot) {
            slice.push(coords[i]);
            return lineString(slice);
          }
          direction = bearing(coords[i], coords[i - 1]) - 180;
          interpolated = destination(coords[i], overshot, direction, options);
          slice.push(interpolated.geometry.coordinates);
          return lineString(slice);
        }

        if (travelled >= startDist) {
          slice.push(coords[i]);
        }

        if (i === coords.length - 1) {
          return lineString(slice);
        }

        travelled += distance$1(coords[i], coords[i + 1], options);
      }

      if (travelled < startDist && coords.length === origCoordsLength)
        throw new Error("Start position is beyond line");

      var last = coords[coords.length - 1];
      return lineString([last, last]);
    }

    /**
     * Returns true if a point is on a line. Accepts a optional parameter to ignore the
     * start and end vertices of the linestring.
     *
     * @name booleanPointOnLine
     * @param {Coord} pt GeoJSON Point
     * @param {Feature<LineString>} line GeoJSON LineString
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.
     * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points
     * @returns {boolean} true/false
     * @example
     * var pt = turf.point([0, 0]);
     * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
     * var isPointOnLine = turf.booleanPointOnLine(pt, line);
     * //=true
     */
    function booleanPointOnLine(pt, line, options) {
        if (options === void 0) { options = {}; }
        // Normalize inputs
        var ptCoords = getCoord(pt);
        var lineCoords = getCoords(line);
        // Main
        for (var i = 0; i < lineCoords.length - 1; i++) {
            var ignoreBoundary = false;
            if (options.ignoreEndVertices) {
                if (i === 0) {
                    ignoreBoundary = "start";
                }
                if (i === lineCoords.length - 2) {
                    ignoreBoundary = "end";
                }
                if (i === 0 && i + 1 === lineCoords.length - 1) {
                    ignoreBoundary = "both";
                }
            }
            if (isPointOnLineSegment$2(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
                return true;
            }
        }
        return false;
    }
    // See http://stackoverflow.com/a/4833823/1979085
    // See https://stackoverflow.com/a/328122/1048847
    /**
     * @private
     * @param {Position} lineSegmentStart coord pair of start of line
     * @param {Position} lineSegmentEnd coord pair of end of line
     * @param {Position} pt coord pair of point to check
     * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.
     * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points
     * If true which end to ignore.
     * @returns {boolean} true/false
     */
    function isPointOnLineSegment$2(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {
        var x = pt[0];
        var y = pt[1];
        var x1 = lineSegmentStart[0];
        var y1 = lineSegmentStart[1];
        var x2 = lineSegmentEnd[0];
        var y2 = lineSegmentEnd[1];
        var dxc = pt[0] - x1;
        var dyc = pt[1] - y1;
        var dxl = x2 - x1;
        var dyl = y2 - y1;
        var cross = dxc * dyl - dyc * dxl;
        if (epsilon !== null) {
            if (Math.abs(cross) > epsilon) {
                return false;
            }
        }
        else if (cross !== 0) {
            return false;
        }
        if (!excludeBoundary) {
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
            }
            return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
        }
        else if (excludeBoundary === "start") {
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
            }
            return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
        }
        else if (excludeBoundary === "end") {
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
            }
            return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
        }
        else if (excludeBoundary === "both") {
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
            }
            return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
        }
        return false;
    }

    /**
     * Boolean-within returns true if the first geometry is completely within the second geometry.
     * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)
     * must not intersect the exterior of the secondary (geometry b).
     * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.
     *
     * @name booleanWithin
     * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
     * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
     * @returns {boolean} true/false
     * @example
     * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
     * var point = turf.point([1, 2]);
     *
     * turf.booleanWithin(point, line);
     * //=true
     */
    function booleanWithin(feature1, feature2) {
        var geom1 = getGeom(feature1);
        var geom2 = getGeom(feature2);
        var type1 = geom1.type;
        var type2 = geom2.type;
        switch (type1) {
            case "Point":
                switch (type2) {
                    case "MultiPoint":
                        return isPointInMultiPoint$1(geom1, geom2);
                    case "LineString":
                        return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });
                    case "Polygon":
                    case "MultiPolygon":
                        return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "MultiPoint":
                switch (type2) {
                    case "MultiPoint":
                        return isMultiPointInMultiPoint$1(geom1, geom2);
                    case "LineString":
                        return isMultiPointOnLine$1(geom1, geom2);
                    case "Polygon":
                    case "MultiPolygon":
                        return isMultiPointInPoly$1(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "LineString":
                switch (type2) {
                    case "LineString":
                        return isLineOnLine$2(geom1, geom2);
                    case "Polygon":
                    case "MultiPolygon":
                        return isLineInPoly$2(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "Polygon":
                switch (type2) {
                    case "Polygon":
                    case "MultiPolygon":
                        return isPolyInPoly$2(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            default:
                throw new Error("feature1 " + type1 + " geometry not supported");
        }
    }
    function isPointInMultiPoint$1(point, multiPoint) {
        var i;
        var output = false;
        for (i = 0; i < multiPoint.coordinates.length; i++) {
            if (compareCoords$2(multiPoint.coordinates[i], point.coordinates)) {
                output = true;
                break;
            }
        }
        return output;
    }
    function isMultiPointInMultiPoint$1(multiPoint1, multiPoint2) {
        for (var i = 0; i < multiPoint1.coordinates.length; i++) {
            var anyMatch = false;
            for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
                if (compareCoords$2(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
                    anyMatch = true;
                }
            }
            if (!anyMatch) {
                return false;
            }
        }
        return true;
    }
    function isMultiPointOnLine$1(multiPoint, lineString) {
        var foundInsidePoint = false;
        for (var i = 0; i < multiPoint.coordinates.length; i++) {
            if (!booleanPointOnLine(multiPoint.coordinates[i], lineString)) {
                return false;
            }
            if (!foundInsidePoint) {
                foundInsidePoint = booleanPointOnLine(multiPoint.coordinates[i], lineString, { ignoreEndVertices: true });
            }
        }
        return foundInsidePoint;
    }
    function isMultiPointInPoly$1(multiPoint, polygon) {
        var output = true;
        var isInside = false;
        for (var i = 0; i < multiPoint.coordinates.length; i++) {
            isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon);
            if (!isInside) {
                output = false;
                break;
            }
            {
                isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon, {
                    ignoreBoundary: true,
                });
            }
        }
        return output && isInside;
    }
    function isLineOnLine$2(lineString1, lineString2) {
        for (var i = 0; i < lineString1.coordinates.length; i++) {
            if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {
                return false;
            }
        }
        return true;
    }
    function isLineInPoly$2(linestring, polygon) {
        var polyBbox = bbox$2(polygon);
        var lineBbox = bbox$2(linestring);
        if (!doBBoxOverlap$1(polyBbox, lineBbox)) {
            return false;
        }
        var foundInsidePoint = false;
        for (var i = 0; i < linestring.coordinates.length - 1; i++) {
            if (!booleanPointInPolygon(linestring.coordinates[i], polygon)) {
                return false;
            }
            if (!foundInsidePoint) {
                foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon, { ignoreBoundary: true });
            }
            if (!foundInsidePoint) {
                var midpoint = getMidpoint$1(linestring.coordinates[i], linestring.coordinates[i + 1]);
                foundInsidePoint = booleanPointInPolygon(midpoint, polygon, {
                    ignoreBoundary: true,
                });
            }
        }
        return foundInsidePoint;
    }
    /**
     * Is Polygon2 in Polygon1
     * Only takes into account outer rings
     *
     * @private
     * @param {Polygon} geometry1
     * @param {Polygon|MultiPolygon} geometry2
     * @returns {boolean} true/false
     */
    function isPolyInPoly$2(geometry1, geometry2) {
        var poly1Bbox = bbox$2(geometry1);
        var poly2Bbox = bbox$2(geometry2);
        if (!doBBoxOverlap$1(poly2Bbox, poly1Bbox)) {
            return false;
        }
        for (var i = 0; i < geometry1.coordinates[0].length; i++) {
            if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
                return false;
            }
        }
        return true;
    }
    function doBBoxOverlap$1(bbox1, bbox2) {
        if (bbox1[0] > bbox2[0])
            return false;
        if (bbox1[2] < bbox2[2])
            return false;
        if (bbox1[1] > bbox2[1])
            return false;
        if (bbox1[3] < bbox2[3])
            return false;
        return true;
    }
    /**
     * compareCoords
     *
     * @private
     * @param {Position} pair1 point [x,y]
     * @param {Position} pair2 point [x,y]
     * @returns {boolean} true/false if coord pairs match
     */
    function compareCoords$2(pair1, pair2) {
        return pair1[0] === pair2[0] && pair1[1] === pair2[1];
    }
    /**
     * getMidpoint
     *
     * @private
     * @param {Position} pair1 point [x,y]
     * @param {Position} pair2 point [x,y]
     * @returns {Position} midpoint of pair1 and pair2
     */
    function getMidpoint$1(pair1, pair2) {
        return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
    }

    /**
     * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.
     *
     * @name pointGrid
     * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @param {number} cellSide the distance between points, in units
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers
     * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
     * @param {Object} [options.properties={}] passed to each point of the grid
     * @returns {FeatureCollection<Point>} grid of points
     * @example
     * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
     * var cellSide = 3;
     * var options = {units: 'miles'};
     *
     * var grid = turf.pointGrid(extent, cellSide, options);
     *
     * //addToMap
     * var addToMap = [grid];
     */
    function pointGrid(bbox, cellSide, options) {
        if (options === void 0) { options = {}; }
        // Default parameters
        if (options.mask && !options.units)
            options.units = "kilometers";
        // Containers
        var results = [];
        // Typescript handles the Type Validation
        // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');
        // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');
        // if (!bbox) throw new Error('bbox is required');
        // if (!Array.isArray(bbox)) throw new Error('bbox must be array');
        // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');
        // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');
        var west = bbox[0];
        var south = bbox[1];
        var east = bbox[2];
        var north = bbox[3];
        var xFraction = cellSide / distance$1([west, south], [east, south], options);
        var cellWidth = xFraction * (east - west);
        var yFraction = cellSide / distance$1([west, south], [west, north], options);
        var cellHeight = yFraction * (north - south);
        var bboxWidth = east - west;
        var bboxHeight = north - south;
        var columns = Math.floor(bboxWidth / cellWidth);
        var rows = Math.floor(bboxHeight / cellHeight);
        // adjust origin of the grid
        var deltaX = (bboxWidth - columns * cellWidth) / 2;
        var deltaY = (bboxHeight - rows * cellHeight) / 2;
        var currentX = west + deltaX;
        while (currentX <= east) {
            var currentY = south + deltaY;
            while (currentY <= north) {
                var cellPt = point([currentX, currentY], options.properties);
                if (options.mask) {
                    if (booleanWithin(cellPt, options.mask))
                        results.push(cellPt);
                }
                else {
                    results.push(cellPt);
                }
                currentY += cellHeight;
            }
            currentX += cellWidth;
        }
        return featureCollection$1(results);
    }

    /**
     * Takes a GeoJSON Feature or FeatureCollection and truncates the precision of the geometry.
     *
     * @name truncate
     * @param {GeoJSON} geojson any GeoJSON Feature, FeatureCollection, Geometry or GeometryCollection.
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.precision=6] coordinate decimal precision
     * @param {number} [options.coordinates=3] maximum number of coordinates (primarly used to remove z coordinates)
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} layer with truncated geometry
     * @example
     * var point = turf.point([
     *     70.46923055566859,
     *     58.11088890802906,
     *     1508
     * ]);
     * var options = {precision: 3, coordinates: 2};
     * var truncated = turf.truncate(point, options);
     * //=truncated.geometry.coordinates => [70.469, 58.111]
     *
     * //addToMap
     * var addToMap = [truncated];
     */
    function truncate(geojson, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        var precision = options.precision;
        var coordinates = options.coordinates;
        var mutate = options.mutate;
        // default params
        precision =
            precision === undefined || precision === null || isNaN(precision)
                ? 6
                : precision;
        coordinates =
            coordinates === undefined || coordinates === null || isNaN(coordinates)
                ? 3
                : coordinates;
        // validation
        if (!geojson)
            throw new Error("<geojson> is required");
        if (typeof precision !== "number")
            throw new Error("<precision> must be a number");
        if (typeof coordinates !== "number")
            throw new Error("<coordinates> must be a number");
        // prevent input mutation
        if (mutate === false || mutate === undefined)
            geojson = JSON.parse(JSON.stringify(geojson));
        var factor = Math.pow(10, precision);
        // Truncate Coordinates
        coordEach$1(geojson, function (coords) {
            truncateCoords(coords, factor, coordinates);
        });
        return geojson;
    }
    /**
     * Truncate Coordinates - Mutates coordinates in place
     *
     * @private
     * @param {Array<any>} coords Geometry Coordinates
     * @param {number} factor rounding factor for coordinate decimal precision
     * @param {number} coordinates maximum number of coordinates (primarly used to remove z coordinates)
     * @returns {Array<any>} mutated coordinates
     */
    function truncateCoords(coords, factor, coordinates) {
        // Remove extra coordinates (usually elevation coordinates and more)
        if (coords.length > coordinates)
            coords.splice(coordinates, coords.length);
        // Truncate coordinate decimals
        for (var i = 0; i < coords.length; i++) {
            coords[i] = Math.round(coords[i] * factor) / factor;
        }
        return coords;
    }

    /**
     * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).
     *
     * @name flatten
     * @param {GeoJSON} geojson any valid GeoJSON Object
     * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features
     * @example
     * var multiGeometry = turf.multiPolygon([
     *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
     *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
     *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
     * ]);
     *
     * var flatten = turf.flatten(multiGeometry);
     *
     * //addToMap
     * var addToMap = [flatten]
     */
    function flatten(geojson) {
      if (!geojson) throw new Error("geojson is required");

      var results = [];
      flattenEach$1(geojson, function (feature) {
        results.push(feature);
      });
      return featureCollection$1(results);
    }

    /**
     * Divides a {@link LineString} into chunks of a specified length.
     * If the line is shorter than the segment length then the original line is returned.
     *
     * @name lineChunk
     * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split
     * @param {number} segmentLength how long to make each segment
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers
     * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end
     * @returns {FeatureCollection<LineString>} collection of line segments
     * @example
     * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);
     *
     * var chunk = turf.lineChunk(line, 15, {units: 'miles'});
     *
     * //addToMap
     * var addToMap = [chunk];
     */
    function lineChunk(geojson, segmentLength, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var units = options.units;
      var reverse = options.reverse;

      // Validation
      if (!geojson) throw new Error("geojson is required");
      if (segmentLength <= 0)
        throw new Error("segmentLength must be greater than 0");

      // Container
      var results = [];

      // Flatten each feature to simple LineString
      flattenEach$1(geojson, function (feature) {
        // reverses coordinates to start the first chunked segment at the end
        if (reverse)
          feature.geometry.coordinates = feature.geometry.coordinates.reverse();

        sliceLineSegments(feature, segmentLength, units, function (segment) {
          results.push(segment);
        });
      });
      return featureCollection$1(results);
    }

    /**
     * Slice Line Segments
     *
     * @private
     * @param {Feature<LineString>} line GeoJSON LineString
     * @param {number} segmentLength how long to make each segment
     * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers
     * @param {Function} callback iterate over sliced line segments
     * @returns {void}
     */
    function sliceLineSegments(line, segmentLength, units, callback) {
      var lineLength = length(line, { units: units });

      // If the line is shorter than the segment length then the orginal line is returned.
      if (lineLength <= segmentLength) return callback(line);

      var numberOfSegments = lineLength / segmentLength;

      // If numberOfSegments is integer, no need to plus 1
      if (!Number.isInteger(numberOfSegments)) {
        numberOfSegments = Math.floor(numberOfSegments) + 1;
      }

      for (var i = 0; i < numberOfSegments; i++) {
        var outline = lineSliceAlong(
          line,
          segmentLength * i,
          segmentLength * (i + 1),
          { units: units }
        );
        callback(outline, i);
      }
    }

    // Find self-intersections in geojson polygon (possibly with interior rings)

    function isects (feature, filterFn, useSpatialIndex) {
      if (feature.geometry.type !== "Polygon")
        throw new Error("The input feature must be a Polygon");
      if (useSpatialIndex === undefined) useSpatialIndex = 1;

      var coord = feature.geometry.coordinates;

      var output = [];
      var seen = {};

      if (useSpatialIndex) {
        var allEdgesAsRbushTreeItems = [];
        for (var ring0 = 0; ring0 < coord.length; ring0++) {
          for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
            allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
          }
        }
        var tree = rbush_1();
        tree.load(allEdgesAsRbushTreeItems);
      }

      for (var ringA = 0; ringA < coord.length; ringA++) {
        for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {
          if (useSpatialIndex) {
            var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
            bboxOverlaps.forEach(function (bboxIsect) {
              var ring1 = bboxIsect.ring;
              var edge1 = bboxIsect.edge;
              ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
            });
          } else {
            for (var ring1 = 0; ring1 < coord.length; ring1++) {
              for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
                // TODO: speedup possible if only interested in unique: start last two loops at ringA and edgeA+1
                ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
              }
            }
          }
        }
      }

      if (!filterFn)
        output = {
          type: "Feature",
          geometry: { type: "MultiPoint", coordinates: output },
        };
      return output;

      // Function to check if two edges intersect and add the intersection to the output
      function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {
        var start0 = coord[ring0][edge0];
        var end0 = coord[ring0][edge0 + 1];
        var start1 = coord[ring1][edge1];
        var end1 = coord[ring1][edge1 + 1];

        var isect = intersect$2(start0, end0, start1, end1);

        if (isect === null) return; // discard parallels and coincidence
        var frac0;
        var frac1;
        if (end0[0] !== start0[0]) {
          frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
        } else {
          frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
        }
        if (end1[0] !== start1[0]) {
          frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
        } else {
          frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
        }
        if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection

        var key = isect;
        var unique = !seen[key];
        if (unique) {
          seen[key] = true;
        }

        if (filterFn) {
          output.push(
            filterFn(
              isect,
              ring0,
              edge0,
              start0,
              end0,
              frac0,
              ring1,
              edge1,
              start1,
              end1,
              frac1,
              unique
            )
          );
        } else {
          output.push(isect);
        }
      }

      // Function to return a rbush tree item given an ring and edge number
      function rbushTreeItem(ring, edge) {
        var start = coord[ring][edge];
        var end = coord[ring][edge + 1];
        var minX;
        var maxX;
        var minY;
        var maxY;
        if (start[0] < end[0]) {
          minX = start[0];
          maxX = end[0];
        } else {
          minX = end[0];
          maxX = start[0];
        }
        if (start[1] < end[1]) {
          minY = start[1];
          maxY = end[1];
        } else {
          minY = end[1];
          maxY = start[1];
        }
        return {
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY,
          ring: ring,
          edge: edge,
        };
      }
    }

    // Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
    function intersect$2(start0, end0, start1, end1) {
      if (
        equalArrays(start0, start1) ||
        equalArrays(start0, end1) ||
        equalArrays(end0, start1) ||
        equalArrays(end1, start1)
      )
        return null;
      var x0 = start0[0],
        y0 = start0[1],
        x1 = end0[0],
        y1 = end0[1],
        x2 = start1[0],
        y2 = start1[1],
        x3 = end1[0],
        y3 = end1[1];
      var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
      if (denom === 0) return null;
      var x4 =
        ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
      var y4 =
        ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
      return [x4, y4];
    }

    // Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
    function equalArrays(array1, array2) {
      // if the other array is a falsy value, return
      if (!array1 || !array2) return false;

      // compare lengths - can save a lot of time
      if (array1.length !== array2.length) return false;

      for (var i = 0, l = array1.length; i < l; i++) {
        // Check if we have nested arrays
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
          // recurse into the nested arrays
          if (!equalArrays(array1[i], array2[i])) return false;
        } else if (array1[i] !== array2[i]) {
          // Warning - two different object instances will never be equal: {x:20} !== {x:20}
          return false;
        }
      }
      return true;
    }

    /**
     * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.
     *
     * @module simplepolygon
     * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.
     * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.
     *
     * @example
     * var poly = {
     *   "type": "Feature",
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]
     *   }
     * };
     *
     * var result = simplepolygon(poly);
     *
     * // =result
     * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1
     */
    function simplepolygon (feature) {
      // Check input
      if (feature.type != "Feature")
        throw new Error("The input must a geojson object of type Feature");
      if (feature.geometry === undefined || feature.geometry == null)
        throw new Error(
          "The input must a geojson object with a non-empty geometry"
        );
      if (feature.geometry.type != "Polygon")
        throw new Error("The input must be a geojson Polygon");

      // Process input
      var numRings = feature.geometry.coordinates.length;
      var vertices = [];
      for (var i = 0; i < numRings; i++) {
        var ring = feature.geometry.coordinates[i];
        if (!equalArrays$1(ring[0], ring[ring.length - 1])) {
          ring.push(ring[0]); // Close input ring if it is not
        }
        vertices.push.apply(vertices, ring.slice(0, ring.length - 1));
      }
      if (!isUnique(vertices))
        throw new Error(
          "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
        );
      var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted

      // Compute self-intersections
      var selfIsectsData = isects(
        feature,
        function filterFn(
          isect,
          ring0,
          edge0,
          start0,
          end0,
          frac0,
          ring1,
          edge1,
          start1,
          end1,
          frac1,
          unique
        ) {
          return [
            isect,
            ring0,
            edge0,
            start0,
            end0,
            frac0,
            ring1,
            edge1,
            start1,
            end1,
            frac1,
            unique,
          ];
        }
      );
      var numSelfIsect = selfIsectsData.length;

      // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.
      if (numSelfIsect == 0) {
        var outputFeatureArray = [];
        for (var i = 0; i < numRings; i++) {
          outputFeatureArray.push(
            polygon([feature.geometry.coordinates[i]], {
              parent: -1,
              winding: windingOfRing(feature.geometry.coordinates[i]),
            })
          );
        }
        var output = featureCollection$1(outputFeatureArray);
        determineParents();
        setNetWinding();

        return output;
      }

      // If self-intersections are found, we will compute the output rings with the help of two intermediate variables
      // First, we build the pseudo vertex list and intersection list
      // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.
      var pseudoVtxListByRingAndEdge = [];
      // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.
      var isectList = [];
      // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList
      for (var i = 0; i < numRings; i++) {
        pseudoVtxListByRingAndEdge.push([]);
        for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {
          // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.
          pseudoVtxListByRingAndEdge[i].push([
            new PseudoVtx(
              feature.geometry.coordinates[i][
                modulo(j + 1, feature.geometry.coordinates[i].length - 1)
              ],
              1,
              [i, j],
              [i, modulo(j + 1, feature.geometry.coordinates[i].length - 1)],
              undefined
            ),
          ]);
          // The first numvertices elements in isectList correspond to the ring-vertex-intersections
          isectList.push(
            new Isect(
              feature.geometry.coordinates[i][j],
              [i, modulo(j - 1, feature.geometry.coordinates[i].length - 1)],
              [i, j],
              undefined,
              undefined,
              false,
              true
            )
          );
        }
      }
      // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList
      for (var i = 0; i < numSelfIsect; i++) {
        // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge
        pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(
          new PseudoVtx(
            selfIsectsData[i][0],
            selfIsectsData[i][5],
            [selfIsectsData[i][1], selfIsectsData[i][2]],
            [selfIsectsData[i][6], selfIsectsData[i][7]],
            undefined
          )
        );
        // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList
        if (selfIsectsData[i][11])
          isectList.push(
            new Isect(
              selfIsectsData[i][0],
              [selfIsectsData[i][1], selfIsectsData[i][2]],
              [selfIsectsData[i][6], selfIsectsData[i][7]],
              undefined,
              undefined,
              true,
              true
            )
          );
      }
      var numIsect = isectList.length;
      // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'
      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
          pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {
            return a.param < b.param ? -1 : 1;
          });
        }
      }

      // Make a spatial index of intersections, in preperation for the following two steps
      var allIsectsAsIsectRbushTreeItem = [];
      for (var i = 0; i < numIsect; i++) {
        allIsectsAsIsectRbushTreeItem.push({
          minX: isectList[i].coord[0],
          minY: isectList[i].coord[1],
          maxX: isectList[i].coord[0],
          maxY: isectList[i].coord[1],
          index: i,
        }); // could pass isect: isectList[i], but not necessary
      }
      var isectRbushTree = rbush_1();
      isectRbushTree.load(allIsectsAsIsectRbushTreeItem);

      // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.
      // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:
      // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates
      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
          for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
            var coordToFind;
            if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
              // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.
              coordToFind =
                pseudoVtxListByRingAndEdge[i][
                  modulo(j + 1, feature.geometry.coordinates[i].length - 1)
                ][0].coord;
            } else {
              coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
            }
            var IsectRbushTreeItemFound = isectRbushTree.search({
              minX: coordToFind[0],
              minY: coordToFind[1],
              maxX: coordToFind[0],
              maxY: coordToFind[1],
            })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
            pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn =
              IsectRbushTreeItemFound.index;
          }
        }
      }

      // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection
      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
          for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
            var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
            var IsectRbushTreeItemFound = isectRbushTree.search({
              minX: coordToFind[0],
              minY: coordToFind[1],
              maxX: coordToFind[0],
              maxY: coordToFind[1],
            })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
            var l = IsectRbushTreeItemFound.index;
            if (l < numvertices) {
              // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.
              isectList[l].nxtIsectAlongRingAndEdge2 =
                pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
            } else {
              // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.
              if (
                equalArrays$1(
                  isectList[l].ringAndEdge1,
                  pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn
                )
              ) {
                isectList[l].nxtIsectAlongRingAndEdge1 =
                  pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
              } else {
                isectList[l].nxtIsectAlongRingAndEdge2 =
                  pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
              }
            }
          }
        }
      }
      // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!

      // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.
      // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).
      var queue = [];
      // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.
      var i = 0;
      for (var j = 0; j < numRings; j++) {
        var leftIsect = i;
        for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {
          if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
            leftIsect = i;
          }
          i++;
        }
        // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.
        // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong
        var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
        for (var k = 0; k < isectList.length; k++) {
          if (
            isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect ||
            isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect
          ) {
            var isectBeforeLeftIsect = k;
            break;
          }
        }
        var windingAtIsect = isConvex(
          [
            isectList[isectBeforeLeftIsect].coord,
            isectList[leftIsect].coord,
            isectList[isectAfterLeftIsect].coord,
          ],
          true
        )
          ? 1
          : -1;

        queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
      }
      // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.
      queue.sort(function (a, b) {
        return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
      });

      // Initialise output
      var outputFeatureArray = [];

      // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.
      while (queue.length > 0) {
        // Get the last object out of the queue
        var popped = queue.pop();
        var startIsect = popped.isect;
        var currentOutputRingParent = popped.parent;
        var currentOutputRingWinding = popped.winding;
        // Make new output ring and add vertex from starting intersection
        var currentOutputRing = outputFeatureArray.length;
        var currentOutputRingCoords = [isectList[startIsect].coord];
        // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'
        var currentIsect = startIsect;
        if (isectList[startIsect].ringAndEdge1Walkable) {
          var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
          var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
        } else {
          var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
          var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
        }
        // While we have not arrived back at the same intersection, keep walking
        while (
          !equalArrays$1(isectList[startIsect].coord, isectList[nxtIsect].coord)
        ) {
          currentOutputRingCoords.push(isectList[nxtIsect].coord);
          // If the next intersection is queued, we can remove it, because we will go there now.
          var nxtIsectInQueue = undefined;
          for (var i = 0; i < queue.length; i++) {
            if (queue[i].isect == nxtIsect) {
              nxtIsectInQueue = i;
              break;
            }
          }
          if (nxtIsectInQueue != undefined) {
            queue.splice(nxtIsectInQueue, 1);
          }
          // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),
          // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it
          // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue
          // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)
          // We then update the other two walking variables.
          if (equalArrays$1(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
            walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
            isectList[nxtIsect].ringAndEdge2Walkable = false;
            if (isectList[nxtIsect].ringAndEdge1Walkable) {
              var pushing = { isect: nxtIsect };
              if (
                isConvex(
                  [
                    isectList[currentIsect].coord,
                    isectList[nxtIsect].coord,
                    isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord,
                  ],
                  currentOutputRingWinding == 1
                )
              ) {
                pushing.parent = currentOutputRingParent;
                pushing.winding = -currentOutputRingWinding;
              } else {
                pushing.parent = currentOutputRing;
                pushing.winding = currentOutputRingWinding;
              }
              queue.push(pushing);
            }
            currentIsect = nxtIsect;
            nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
          } else {
            walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
            isectList[nxtIsect].ringAndEdge1Walkable = false;
            if (isectList[nxtIsect].ringAndEdge2Walkable) {
              var pushing = { isect: nxtIsect };
              if (
                isConvex(
                  [
                    isectList[currentIsect].coord,
                    isectList[nxtIsect].coord,
                    isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord,
                  ],
                  currentOutputRingWinding == 1
                )
              ) {
                pushing.parent = currentOutputRingParent;
                pushing.winding = -currentOutputRingWinding;
              } else {
                pushing.parent = currentOutputRing;
                pushing.winding = currentOutputRingWinding;
              }
              queue.push(pushing);
            }
            currentIsect = nxtIsect;
            nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
          }
        }
        // Close output ring
        currentOutputRingCoords.push(isectList[nxtIsect].coord);
        // Push output ring to output
        outputFeatureArray.push(
          polygon([currentOutputRingCoords], {
            index: currentOutputRing,
            parent: currentOutputRingParent,
            winding: currentOutputRingWinding,
            netWinding: undefined,
          })
        );
      }

      var output = featureCollection$1(outputFeatureArray);

      determineParents();

      setNetWinding();

      // These functions are also used if no intersections are found
      function determineParents() {
        var featuresWithoutParent = [];
        for (var i = 0; i < output.features.length; i++) {
          if (output.features[i].properties.parent == -1)
            featuresWithoutParent.push(i);
        }
        if (featuresWithoutParent.length > 1) {
          for (var i = 0; i < featuresWithoutParent.length; i++) {
            var parent = -1;
            var parentArea = Infinity;
            for (var j = 0; j < output.features.length; j++) {
              if (featuresWithoutParent[i] == j) continue;
              if (
                booleanPointInPolygon(
                  output.features[featuresWithoutParent[i]].geometry
                    .coordinates[0][0],
                  output.features[j],
                  { ignoreBoundary: true }
                )
              ) {
                if (area(output.features[j]) < parentArea) {
                  parent = j;
                }
              }
            }
            output.features[featuresWithoutParent[i]].properties.parent = parent;
          }
        }
      }

      function setNetWinding() {
        for (var i = 0; i < output.features.length; i++) {
          if (output.features[i].properties.parent == -1) {
            var netWinding = output.features[i].properties.winding;
            output.features[i].properties.netWinding = netWinding;
            setNetWindingOfChildren(i, netWinding);
          }
        }
      }

      function setNetWindingOfChildren(parent, ParentNetWinding) {
        for (var i = 0; i < output.features.length; i++) {
          if (output.features[i].properties.parent == parent) {
            var netWinding =
              ParentNetWinding + output.features[i].properties.winding;
            output.features[i].properties.netWinding = netWinding;
            setNetWindingOfChildren(i, netWinding);
          }
        }
      }

      return output;
    }

    // Constructor for (ring- or intersection-) pseudo-vertices.
    var PseudoVtx = function (
      coord,
      param,
      ringAndEdgeIn,
      ringAndEdgeOut,
      nxtIsectAlongEdgeIn
    ) {
      this.coord = coord; // [x,y] of this pseudo-vertex
      this.param = param; // fractional distance of this intersection on incomming edge
      this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge
      this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge
      this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)
    };

    // Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.
    var Isect = function (
      coord,
      ringAndEdge1,
      ringAndEdge2,
      nxtIsectAlongRingAndEdge1,
      nxtIsectAlongRingAndEdge2,
      ringAndEdge1Walkable,
      ringAndEdge2Walkable
    ) {
      this.coord = coord; // [x,y] of this intersection
      this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection
      this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection
      this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1
      this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2
      this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?
      this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?
    };

    // Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded
    function isConvex(pts, righthanded) {
      // 'pts' is an [x,y] pair
      // 'righthanded' is a boolean
      if (typeof righthanded === "undefined") righthanded = true;
      if (pts.length != 3)
        throw new Error("This function requires an array of three points [x,y]");
      var d =
        (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) -
        (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
      return d >= 0 == righthanded;
    }

    // Function to compute winding of simple, non-self-intersecting ring
    function windingOfRing(ring) {
      // 'ring' is an array of [x,y] pairs with the last equal to the first
      // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong
      var leftVtx = 0;
      for (var i = 0; i < ring.length - 1; i++) {
        if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
      }
      if (
        isConvex(
          [
            ring[modulo(leftVtx - 1, ring.length - 1)],
            ring[leftVtx],
            ring[modulo(leftVtx + 1, ring.length - 1)],
          ],
          true
        )
      ) {
        var winding = 1;
      } else {
        var winding = -1;
      }
      return winding;
    }

    // Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
    function equalArrays$1(array1, array2) {
      // if the other array is a falsy value, return
      if (!array1 || !array2) return false;

      // compare lengths - can save a lot of time
      if (array1.length != array2.length) return false;

      for (var i = 0, l = array1.length; i < l; i++) {
        // Check if we have nested arrays
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
          // recurse into the nested arrays
          if (!equalArrays$1(array1[i], array2[i])) return false;
        } else if (array1[i] != array2[i]) {
          // Warning - two different object instances will never be equal: {x:20} != {x:20}
          return false;
        }
      }
      return true;
    }

    // Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving
    function modulo(n, m) {
      return ((n % m) + m) % m;
    }

    // Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)
    function isUnique(array) {
      var u = {};
      var isUnique = 1;
      for (var i = 0, l = array.length; i < l; ++i) {
        if (Object.prototype.hasOwnProperty.call(u, array[i])) {
          isUnique = 0;
          break;
        }
        u[array[i]] = 1;
      }
      return isUnique;
    }

    /**
     * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.
     * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.
     *
     * @name unkinkPolygon
     * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon
     * @returns {FeatureCollection<Polygon>} Unkinked polygons
     * @example
     * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);
     *
     * var result = turf.unkinkPolygon(poly);
     *
     * //addToMap
     * var addToMap = [poly, result]
     */
    function unkinkPolygon(geojson) {
      var features = [];
      flattenEach$1(geojson, function (feature) {
        if (feature.geometry.type !== "Polygon") return;
        featureEach$2(simplepolygon(feature), function (poly) {
          features.push(polygon(poly.geometry.coordinates, feature.properties));
        });
      });
      return featureCollection$1(features);
    }

    var D2R = Math.PI / 180;
    var R2D = 180 / Math.PI;

    var Coord = function (lon, lat) {
      this.lon = lon;
      this.lat = lat;
      this.x = D2R * lon;
      this.y = D2R * lat;
    };

    Coord.prototype.view = function () {
      return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
    };

    Coord.prototype.antipode = function () {
      var anti_lat = -1 * this.lat;
      var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
      return new Coord(anti_lon, anti_lat);
    };

    var LineString = function () {
      this.coords = [];
      this.length = 0;
    };

    LineString.prototype.move_to = function (coord) {
      this.length++;
      this.coords.push(coord);
    };

    var Arc = function (properties) {
      this.properties = properties || {};
      this.geometries = [];
    };

    Arc.prototype.json = function () {
      if (this.geometries.length <= 0) {
        return {
          geometry: { type: "LineString", coordinates: null },
          type: "Feature",
          properties: this.properties,
        };
      } else if (this.geometries.length === 1) {
        return {
          geometry: { type: "LineString", coordinates: this.geometries[0].coords },
          type: "Feature",
          properties: this.properties,
        };
      } else {
        var multiline = [];
        for (var i = 0; i < this.geometries.length; i++) {
          multiline.push(this.geometries[i].coords);
        }
        return {
          geometry: { type: "MultiLineString", coordinates: multiline },
          type: "Feature",
          properties: this.properties,
        };
      }
    };

    // TODO - output proper multilinestring
    Arc.prototype.wkt = function () {
      var wkt_string = "";
      var wkt = "LINESTRING(";
      var collect = function (c) {
        wkt += c[0] + " " + c[1] + ",";
      };
      for (var i = 0; i < this.geometries.length; i++) {
        if (this.geometries[i].coords.length === 0) {
          return "LINESTRING(empty)";
        } else {
          var coords = this.geometries[i].coords;
          coords.forEach(collect);
          wkt_string += wkt.substring(0, wkt.length - 1) + ")";
        }
      }
      return wkt_string;
    };

    /*
     * http://en.wikipedia.org/wiki/Great-circle_distance
     *
     */
    var GreatCircle = function (start, end, properties) {
      if (!start || start.x === undefined || start.y === undefined) {
        throw new Error(
          "GreatCircle constructor expects two args: start and end objects with x and y properties"
        );
      }
      if (!end || end.x === undefined || end.y === undefined) {
        throw new Error(
          "GreatCircle constructor expects two args: start and end objects with x and y properties"
        );
      }
      this.start = new Coord(start.x, start.y);
      this.end = new Coord(end.x, end.y);
      this.properties = properties || {};

      var w = this.start.x - this.end.x;
      var h = this.start.y - this.end.y;
      var z =
        Math.pow(Math.sin(h / 2.0), 2) +
        Math.cos(this.start.y) *
          Math.cos(this.end.y) *
          Math.pow(Math.sin(w / 2.0), 2);
      this.g = 2.0 * Math.asin(Math.sqrt(z));

      if (this.g === Math.PI) {
        throw new Error(
          "it appears " +
            start.view() +
            " and " +
            end.view() +
            " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
        );
      } else if (isNaN(this.g)) {
        throw new Error(
          "could not calculate great circle between " + start + " and " + end
        );
      }
    };

    /*
     * http://williams.best.vwh.net/avform.htm#Intermediate
     */
    GreatCircle.prototype.interpolate = function (f) {
      var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
      var B = Math.sin(f * this.g) / Math.sin(this.g);
      var x =
        A * Math.cos(this.start.y) * Math.cos(this.start.x) +
        B * Math.cos(this.end.y) * Math.cos(this.end.x);
      var y =
        A * Math.cos(this.start.y) * Math.sin(this.start.x) +
        B * Math.cos(this.end.y) * Math.sin(this.end.x);
      var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
      var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
      var lon = R2D * Math.atan2(y, x);
      return [lon, lat];
    };

    /*
     * Generate points along the great circle
     */
    GreatCircle.prototype.Arc = function (npoints, options) {
      var first_pass = [];
      if (!npoints || npoints <= 2) {
        first_pass.push([this.start.lon, this.start.lat]);
        first_pass.push([this.end.lon, this.end.lat]);
      } else {
        var delta = 1.0 / (npoints - 1);
        for (var i = 0; i < npoints; ++i) {
          var step = delta * i;
          var pair = this.interpolate(step);
          first_pass.push(pair);
        }
      }
      /* partial port of dateline handling from:
          gdal/ogr/ogrgeometryfactory.cpp

          TODO - does not handle all wrapping scenarios yet
        */
      var bHasBigDiff = false;
      var dfMaxSmallDiffLong = 0;
      // from http://www.gdal.org/ogr2ogr.html
      // -datelineoffset:
      // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)
      var dfDateLineOffset = options && options.offset ? options.offset : 10;
      var dfLeftBorderX = 180 - dfDateLineOffset;
      var dfRightBorderX = -180 + dfDateLineOffset;
      var dfDiffSpace = 360 - dfDateLineOffset;

      // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342
      for (var j = 1; j < first_pass.length; ++j) {
        var dfPrevX = first_pass[j - 1][0];
        var dfX = first_pass[j][0];
        var dfDiffLong = Math.abs(dfX - dfPrevX);
        if (
          dfDiffLong > dfDiffSpace &&
          ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) ||
            (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))
        ) {
          bHasBigDiff = true;
        } else if (dfDiffLong > dfMaxSmallDiffLong) {
          dfMaxSmallDiffLong = dfDiffLong;
        }
      }

      var poMulti = [];
      if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
        var poNewLS = [];
        poMulti.push(poNewLS);
        for (var k = 0; k < first_pass.length; ++k) {
          var dfX0 = parseFloat(first_pass[k][0]);
          if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
            var dfX1 = parseFloat(first_pass[k - 1][0]);
            var dfY1 = parseFloat(first_pass[k - 1][1]);
            var dfX2 = parseFloat(first_pass[k][0]);
            var dfY2 = parseFloat(first_pass[k][1]);
            if (
              dfX1 > -180 &&
              dfX1 < dfRightBorderX &&
              dfX2 === 180 &&
              k + 1 < first_pass.length &&
              first_pass[k - 1][0] > -180 &&
              first_pass[k - 1][0] < dfRightBorderX
            ) {
              poNewLS.push([-180, first_pass[k][1]]);
              k++;
              poNewLS.push([first_pass[k][0], first_pass[k][1]]);
              continue;
            } else if (
              dfX1 > dfLeftBorderX &&
              dfX1 < 180 &&
              dfX2 === -180 &&
              k + 1 < first_pass.length &&
              first_pass[k - 1][0] > dfLeftBorderX &&
              first_pass[k - 1][0] < 180
            ) {
              poNewLS.push([180, first_pass[k][1]]);
              k++;
              poNewLS.push([first_pass[k][0], first_pass[k][1]]);
              continue;
            }

            if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
              // swap dfX1, dfX2
              var tmpX = dfX1;
              dfX1 = dfX2;
              dfX2 = tmpX;
              // swap dfY1, dfY2
              var tmpY = dfY1;
              dfY1 = dfY2;
              dfY2 = tmpY;
            }
            if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
              dfX2 += 360;
            }

            if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
              var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
              var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
              poNewLS.push([
                first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
                dfY,
              ]);
              poNewLS = [];
              poNewLS.push([
                first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
                dfY,
              ]);
              poMulti.push(poNewLS);
            } else {
              poNewLS = [];
              poMulti.push(poNewLS);
            }
            poNewLS.push([dfX0, first_pass[k][1]]);
          } else {
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
          }
        }
      } else {
        // add normally
        var poNewLS0 = [];
        poMulti.push(poNewLS0);
        for (var l = 0; l < first_pass.length; ++l) {
          poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
        }
      }

      var arc = new Arc(this.properties);
      for (var m = 0; m < poMulti.length; ++m) {
        var line = new LineString();
        arc.geometries.push(line);
        var points = poMulti[m];
        for (var j0 = 0; j0 < points.length; ++j0) {
          line.move_to(points[j0]);
        }
      }
      return arc;
    };

    /**
     * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.
     * If the `start` and `end` points span the antimeridian, the resulting feature will
     * be split into a `MultiLineString`.
     *
     * @name greatCircle
     * @param {Coord} start source point feature
     * @param {Coord} end destination point feature
     * @param {Object} [options={}] Optional parameters
     * @param {Object} [options.properties={}] line feature properties
     * @param {number} [options.npoints=100] number of points
     * @param {number} [options.offset=10] offset controls the likelyhood that lines will
     * be split which cross the dateline. The higher the number the more likely.
     * @returns {Feature<LineString | MultiLineString>} great circle line feature
     * @example
     * var start = turf.point([-122, 48]);
     * var end = turf.point([-77, 39]);
     *
     * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});
     *
     * //addToMap
     * var addToMap = [start, end, greatCircle]
     */
    function greatCircle(start, end, options) {
      // Optional parameters
      options = options || {};
      if (typeof options !== "object") throw new Error("options is invalid");
      var properties = options.properties;
      var npoints = options.npoints;
      var offset = options.offset;

      start = getCoord(start);
      end = getCoord(end);
      properties = properties || {};
      npoints = npoints || 100;
      offset = offset || 10;

      var generator = new GreatCircle(
        { x: start[0], y: start[1] },
        { x: end[0], y: end[1] },
        properties
      );

      var line = generator.Arc(npoints, { offset: offset });

      return line.json();
    }

    /**
     * Split a LineString by another GeoJSON Feature.
     *
     * @name lineSplit
     * @param {Feature<LineString>} line LineString Feature to split
     * @param {Feature<any>} splitter Feature used to split line
     * @returns {FeatureCollection<LineString>} Split LineStrings
     * @example
     * var line = turf.lineString([[120, -25], [145, -25]]);
     * var splitter = turf.lineString([[130, -15], [130, -35]]);
     *
     * var split = turf.lineSplit(line, splitter);
     *
     * //addToMap
     * var addToMap = [line, splitter]
     */
    function lineSplit(line, splitter) {
      if (!line) throw new Error("line is required");
      if (!splitter) throw new Error("splitter is required");

      var lineType = getType$1(line);
      var splitterType = getType$1(splitter);

      if (lineType !== "LineString") throw new Error("line must be LineString");
      if (splitterType === "FeatureCollection")
        throw new Error("splitter cannot be a FeatureCollection");
      if (splitterType === "GeometryCollection")
        throw new Error("splitter cannot be a GeometryCollection");

      // remove excessive decimals from splitter
      // to avoid possible approximation issues in rbush
      var truncatedSplitter = truncate(splitter, { precision: 7 });

      switch (splitterType) {
        case "Point":
          return splitLineWithPoint(line, truncatedSplitter);
        case "MultiPoint":
          return splitLineWithPoints(line, truncatedSplitter);
        case "LineString":
        case "MultiLineString":
        case "Polygon":
        case "MultiPolygon":
          return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));
      }
    }

    /**
     * Split LineString with MultiPoint
     *
     * @private
     * @param {Feature<LineString>} line LineString
     * @param {FeatureCollection<Point>} splitter Point
     * @returns {FeatureCollection<LineString>} split LineStrings
     */
    function splitLineWithPoints(line, splitter) {
      var results = [];
      var tree = geojsonRbush_1();

      flattenEach$1(splitter, function (point) {
        // Add index/id to features (needed for filter)
        results.forEach(function (feature, index) {
          feature.id = index;
        });
        // First Point - doesn't need to handle any previous line results
        if (!results.length) {
          results = splitLineWithPoint(line, point).features;

          // Add Square BBox to each feature for GeoJSON-RBush
          results.forEach(function (feature) {
            if (!feature.bbox) feature.bbox = square(bbox$2(feature));
          });
          tree.load(featureCollection$1(results));
          // Split with remaining points - lines might needed to be split multiple times
        } else {
          // Find all lines that are within the splitter's bbox
          var search = tree.search(point);

          if (search.features.length) {
            // RBush might return multiple lines - only process the closest line to splitter
            var closestLine = findClosestFeature(point, search);

            // Remove closest line from results since this will be split into two lines
            // This removes any duplicates inside the results & index
            results = results.filter(function (feature) {
              return feature.id !== closestLine.id;
            });
            tree.remove(closestLine);

            // Append the two newly split lines into the results
            featureEach$2(splitLineWithPoint(closestLine, point), function (line) {
              results.push(line);
              tree.insert(line);
            });
          }
        }
      });
      return featureCollection$1(results);
    }

    /**
     * Split LineString with Point
     *
     * @private
     * @param {Feature<LineString>} line LineString
     * @param {Feature<Point>} splitter Point
     * @returns {FeatureCollection<LineString>} split LineStrings
     */
    function splitLineWithPoint(line, splitter) {
      var results = [];

      // handle endpoints
      var startPoint = getCoords(line)[0];
      var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];
      if (
        pointsEquals(startPoint, getCoord(splitter)) ||
        pointsEquals(endPoint, getCoord(splitter))
      )
        return featureCollection$1([line]);

      // Create spatial index
      var tree = geojsonRbush_1();
      var segments = lineSegment(line);
      tree.load(segments);

      // Find all segments that are within bbox of splitter
      var search = tree.search(splitter);

      // Return itself if point is not within spatial index
      if (!search.features.length) return featureCollection$1([line]);

      // RBush might return multiple lines - only process the closest line to splitter
      var closestSegment = findClosestFeature(splitter, search);

      // Initial value is the first point of the first segments (beginning of line)
      var initialValue = [startPoint];
      var lastCoords = featureReduce$1(
        segments,
        function (previous, current, index) {
          var currentCoords = getCoords(current)[1];
          var splitterCoords = getCoord(splitter);

          // Location where segment intersects with line
          if (index === closestSegment.id) {
            previous.push(splitterCoords);
            results.push(lineString(previous));
            // Don't duplicate splitter coordinate (Issue #688)
            if (pointsEquals(splitterCoords, currentCoords))
              return [splitterCoords];
            return [splitterCoords, currentCoords];

            // Keep iterating over coords until finished or intersection is found
          } else {
            previous.push(currentCoords);
            return previous;
          }
        },
        initialValue
      );
      // Append last line to final split results
      if (lastCoords.length > 1) {
        results.push(lineString(lastCoords));
      }
      return featureCollection$1(results);
    }

    /**
     * Find Closest Feature
     *
     * @private
     * @param {Feature<Point>} point Feature must be closest to this point
     * @param {FeatureCollection<LineString>} lines Collection of Features
     * @returns {Feature<LineString>} closest LineString
     */
    function findClosestFeature(point, lines) {
      if (!lines.features.length) throw new Error("lines must contain features");
      // Filter to one segment that is the closest to the line
      if (lines.features.length === 1) return lines.features[0];

      var closestFeature;
      var closestDistance = Infinity;
      featureEach$2(lines, function (segment) {
        var pt = nearestPointOnLine(segment, point);
        var dist = pt.properties.dist;
        if (dist < closestDistance) {
          closestFeature = segment;
          closestDistance = dist;
        }
      });
      return closestFeature;
    }

    /**
     * Compares two points and returns if they are equals
     *
     * @private
     * @param {Array<number>} pt1 point
     * @param {Array<number>} pt2 point
     * @returns {boolean} true if they are equals
     */
    function pointsEquals(pt1, pt2) {
      return pt1[0] === pt2[0] && pt1[1] === pt2[1];
    }

    /**
     * Creates a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2;
     * 0 bearing is North of center point, positive clockwise.
     *
     * @name lineArc
     * @param {Coord} center center point
     * @param {number} radius radius of the circle
     * @param {number} bearing1 angle, in decimal degrees, of the first radius of the arc
     * @param {number} bearing2 angle, in decimal degrees, of the second radius of the arc
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.steps=64] number of steps
     * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
     * @returns {Feature<LineString>} line arc
     * @example
     * var center = turf.point([-75, 40]);
     * var radius = 5;
     * var bearing1 = 25;
     * var bearing2 = 47;
     *
     * var arc = turf.lineArc(center, radius, bearing1, bearing2);
     *
     * //addToMap
     * var addToMap = [center, arc]
     */
    function lineArc(center, radius, bearing1, bearing2, options) {
        if (options === void 0) { options = {}; }
        // default params
        var steps = options.steps || 64;
        var angle1 = convertAngleTo360$1(bearing1);
        var angle2 = convertAngleTo360$1(bearing2);
        var properties = !Array.isArray(center) && center.type === "Feature"
            ? center.properties
            : {};
        // handle angle parameters
        if (angle1 === angle2) {
            return lineString(circle(center, radius, options).geometry.coordinates[0], properties);
        }
        var arcStartDegree = angle1;
        var arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;
        var alfa = arcStartDegree;
        var coordinates = [];
        var i = 0;
        while (alfa < arcEndDegree) {
            coordinates.push(destination(center, radius, alfa, options).geometry.coordinates);
            i++;
            alfa = arcStartDegree + (i * 360) / steps;
        }
        if (alfa > arcEndDegree) {
            coordinates.push(destination(center, radius, arcEndDegree, options).geometry.coordinates);
        }
        return lineString(coordinates, properties);
    }
    /**
     * Takes any angle in  degrees
     * and returns a valid angle between 0-360 degrees
     *
     * @private
     * @param {number} alfa angle between -180-180 degrees
     * @returns {number} angle between 0-360 degrees
     */
    function convertAngleTo360$1(alfa) {
        var beta = alfa % 360;
        if (beta < 0) {
            beta += 360;
        }
        return beta;
    }

    /**
     * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a
     * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.
     *
     * @name polygonToLine
     * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert
     * @param {Object} [options={}] Optional parameters
     * @param {Object} [options.properties={}] translates GeoJSON properties to Feature
     * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString
     * @example
     * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);
     *
     * var line = turf.polygonToLine(poly);
     *
     * //addToMap
     * var addToMap = [line];
     */
    function polygonToLine (poly, options) {
        if (options === void 0) { options = {}; }
        var geom = getGeom(poly);
        if (!options.properties && poly.type === "Feature") {
            options.properties = poly.properties;
        }
        switch (geom.type) {
            case "Polygon":
                return polygonToLine$1(geom, options);
            case "MultiPolygon":
                return multiPolygonToLine(geom, options);
            default:
                throw new Error("invalid poly");
        }
    }
    /**
     * @private
     */
    function polygonToLine$1(poly, options) {
        if (options === void 0) { options = {}; }
        var geom = getGeom(poly);
        var coords = geom.coordinates;
        var properties = options.properties
            ? options.properties
            : poly.type === "Feature"
                ? poly.properties
                : {};
        return coordsToLine(coords, properties);
    }
    /**
     * @private
     */
    function multiPolygonToLine(multiPoly, options) {
        if (options === void 0) { options = {}; }
        var geom = getGeom(multiPoly);
        var coords = geom.coordinates;
        var properties = options.properties
            ? options.properties
            : multiPoly.type === "Feature"
                ? multiPoly.properties
                : {};
        var lines = [];
        coords.forEach(function (coord) {
            lines.push(coordsToLine(coord, properties));
        });
        return featureCollection$1(lines);
    }
    /**
     * @private
     */
    function coordsToLine(coords, properties) {
        if (coords.length > 1) {
            return multiLineString(coords, properties);
        }
        return lineString(coords[0], properties);
    }

    /**
     * Converts (Multi)LineString(s) to Polygon(s).
     *
     * @name lineToPolygon
     * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert
     * @param {Object} [options={}] Optional parameters
     * @param {Object} [options.properties={}] translates GeoJSON properties to Feature
     * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)
     * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates
     * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)
     * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons
     * @example
     * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);
     *
     * var polygon = turf.lineToPolygon(line);
     *
     * //addToMap
     * var addToMap = [polygon];
     */
    function lineToPolygon(lines, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c;
        // Optional parameters
        var properties = options.properties;
        var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;
        var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;
        var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;
        if (!mutate) {
            lines = clone(lines);
        }
        switch (lines.type) {
            case "FeatureCollection":
                var coords = [];
                lines.features.forEach(function (line) {
                    coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
                });
                return multiPolygon(coords, properties);
            default:
                return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
        }
    }
    /**
     * LineString to Polygon
     *
     * @private
     * @param {Feature<LineString|MultiLineString>} line line
     * @param {Object} [properties] translates GeoJSON properties to Feature
     * @param {boolean} [autoComplete=true] auto complete linestrings
     * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates
     * @returns {Feature<Polygon>} line converted to Polygon
     */
    function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
        properties = properties
            ? properties
            : line.type === "Feature"
                ? line.properties
                : {};
        var geom = getGeom(line);
        var coords = geom.coordinates;
        var type = geom.type;
        if (!coords.length)
            throw new Error("line must contain coordinates");
        switch (type) {
            case "LineString":
                if (autoComplete)
                    coords = autoCompleteCoords(coords);
                return polygon([coords], properties);
            case "MultiLineString":
                var multiCoords = [];
                var largestArea = 0;
                coords.forEach(function (coord) {
                    if (autoComplete)
                        coord = autoCompleteCoords(coord);
                    // Largest LineString to be placed in the first position of the coordinates array
                    if (orderCoords) {
                        var area = calculateArea(bbox$2(lineString(coord)));
                        if (area > largestArea) {
                            multiCoords.unshift(coord);
                            largestArea = area;
                        }
                        else
                            multiCoords.push(coord);
                    }
                    else {
                        multiCoords.push(coord);
                    }
                });
                return polygon(multiCoords, properties);
            default:
                throw new Error("geometry type " + type + " is not supported");
        }
    }
    /**
     * Auto Complete Coords - matches first & last coordinates
     *
     * @private
     * @param {Array<Array<number>>} coords Coordinates
     * @returns {Array<Array<number>>} auto completed coordinates
     */
    function autoCompleteCoords(coords) {
        var first = coords[0];
        var x1 = first[0];
        var y1 = first[1];
        var last = coords[coords.length - 1];
        var x2 = last[0];
        var y2 = last[1];
        if (x1 !== x2 || y1 !== y2) {
            coords.push(first);
        }
        return coords;
    }
    /**
     * area - quick approximate area calculation (used to sort)
     *
     * @private
     * @param {Array<number>} bbox BBox [west, south, east, north]
     * @returns {number} very quick area calculation
     */
    function calculateArea(bbox) {
        var west = bbox[0];
        var south = bbox[1];
        var east = bbox[2];
        var north = bbox[3];
        return Math.abs(west - east) * Math.abs(south - north);
    }

    // Cohen-Sutherland line clipping algorithm, adapted to efficiently
    // handle polylines rather than just segments
    function lineclip(points, bbox, result) {
        var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;
        var a;
        var b;
        if (!result)
            result = [];
        for (i = 1; i < len; i++) {
            a = points[i - 1];
            b = points[i];
            codeB = lastCode = bitCode(b, bbox);
            while (true) {
                if (!(codeA | codeB)) {
                    // accept
                    part.push(a);
                    if (codeB !== lastCode) {
                        // segment went outside
                        part.push(b);
                        if (i < len - 1) {
                            // start a new line
                            result.push(part);
                            part = [];
                        }
                    }
                    else if (i === len - 1) {
                        part.push(b);
                    }
                    break;
                }
                else if (codeA & codeB) {
                    // trivial reject
                    break;
                }
                else if (codeA) {
                    // a outside, intersect with clip edge
                    a = intersect$1(a, b, codeA, bbox);
                    codeA = bitCode(a, bbox);
                }
                else {
                    // b outside
                    b = intersect$1(a, b, codeB, bbox);
                    codeB = bitCode(b, bbox);
                }
            }
            codeA = lastCode;
        }
        if (part.length)
            result.push(part);
        return result;
    }
    // Sutherland-Hodgeman polygon clipping algorithm
    function polygonclip(points, bbox) {
        var result, edge, prev, prevInside, i, p, inside;
        // clip against each side of the clip rectangle
        for (edge = 1; edge <= 8; edge *= 2) {
            result = [];
            prev = points[points.length - 1];
            prevInside = !(bitCode(prev, bbox) & edge);
            for (i = 0; i < points.length; i++) {
                p = points[i];
                inside = !(bitCode(p, bbox) & edge);
                // if segment goes through the clip window, add an intersection
                if (inside !== prevInside)
                    result.push(intersect$1(prev, p, edge, bbox));
                if (inside)
                    result.push(p); // add a point if it's inside
                prev = p;
                prevInside = inside;
            }
            points = result;
            if (!points.length)
                break;
        }
        return result;
    }
    // intersect a segment against one of the 4 lines that make up the bbox
    function intersect$1(a, b, edge, bbox) {
        return edge & 8
            ? [a[0] + ((b[0] - a[0]) * (bbox[3] - a[1])) / (b[1] - a[1]), bbox[3]] // top
            : edge & 4
                ? [a[0] + ((b[0] - a[0]) * (bbox[1] - a[1])) / (b[1] - a[1]), bbox[1]] // bottom
                : edge & 2
                    ? [bbox[2], a[1] + ((b[1] - a[1]) * (bbox[2] - a[0])) / (b[0] - a[0])] // right
                    : edge & 1
                        ? [bbox[0], a[1] + ((b[1] - a[1]) * (bbox[0] - a[0])) / (b[0] - a[0])] // left
                        : null;
    }
    // bit code reflects the point position relative to the bbox:
    //         left  mid  right
    //    top  1001  1000  1010
    //    mid  0001  0000  0010
    // bottom  0101  0100  0110
    function bitCode(p, bbox) {
        var code = 0;
        if (p[0] < bbox[0])
            code |= 1;
        // left
        else if (p[0] > bbox[2])
            code |= 2; // right
        if (p[1] < bbox[1])
            code |= 4;
        // bottom
        else if (p[1] > bbox[3])
            code |= 8; // top
        return code;
    }

    /**
     * Takes a {@link Feature} and a bbox and clips the feature to the bbox using
     * [lineclip](https://github.com/mapbox/lineclip).
     * May result in degenerate edges when clipping Polygons.
     *
     * @name bboxClip
     * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature feature to clip to the bbox
     * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
     * @returns {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} clipped Feature
     * @example
     * var bbox = [0, 0, 10, 10];
     * var poly = turf.polygon([[[2, 2], [8, 4], [12, 8], [3, 7], [2, 2]]]);
     *
     * var clipped = turf.bboxClip(poly, bbox);
     *
     * //addToMap
     * var addToMap = [bbox, poly, clipped]
     */
    function bboxClip(feature, bbox) {
        var geom = getGeom(feature);
        var type = geom.type;
        var properties = feature.type === "Feature" ? feature.properties : {};
        var coords = geom.coordinates;
        switch (type) {
            case "LineString":
            case "MultiLineString": {
                var lines_1 = [];
                if (type === "LineString") {
                    coords = [coords];
                }
                coords.forEach(function (line) {
                    lineclip(line, bbox, lines_1);
                });
                if (lines_1.length === 1) {
                    return lineString(lines_1[0], properties);
                }
                return multiLineString(lines_1, properties);
            }
            case "Polygon":
                return polygon(clipPolygon$1(coords, bbox), properties);
            case "MultiPolygon":
                return multiPolygon(coords.map(function (poly) {
                    return clipPolygon$1(poly, bbox);
                }), properties);
            default:
                throw new Error("geometry " + type + " not supported");
        }
    }
    function clipPolygon$1(rings, bbox) {
        var outRings = [];
        for (var _i = 0, rings_1 = rings; _i < rings_1.length; _i++) {
            var ring = rings_1[_i];
            var clipped = polygonclip(ring, bbox);
            if (clipped.length > 0) {
                if (clipped[0][0] !== clipped[clipped.length - 1][0] ||
                    clipped[0][1] !== clipped[clipped.length - 1][1]) {
                    clipped.push(clipped[0]);
                }
                if (clipped.length >= 4) {
                    outRings.push(clipped);
                }
            }
        }
        return outRings;
    }

    var toStr$4 = Object.prototype.toString;

    var isArguments$1 = function isArguments(value) {
    	var str = toStr$4.call(value);
    	var isArgs = str === '[object Arguments]';
    	if (!isArgs) {
    		isArgs = str !== '[object Array]' &&
    			value !== null &&
    			typeof value === 'object' &&
    			typeof value.length === 'number' &&
    			value.length >= 0 &&
    			toStr$4.call(value.callee) === '[object Function]';
    	}
    	return isArgs;
    };

    var keysShim$1;
    if (!Object.keys) {
    	// modified from https://github.com/es-shims/es5-shim
    	var has$1 = Object.prototype.hasOwnProperty;
    	var toStr$3 = Object.prototype.toString;
    	var isArgs = isArguments$1; // eslint-disable-line global-require
    	var isEnumerable = Object.prototype.propertyIsEnumerable;
    	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
    	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
    	var dontEnums = [
    		'toString',
    		'toLocaleString',
    		'valueOf',
    		'hasOwnProperty',
    		'isPrototypeOf',
    		'propertyIsEnumerable',
    		'constructor'
    	];
    	var equalsConstructorPrototype = function (o) {
    		var ctor = o.constructor;
    		return ctor && ctor.prototype === o;
    	};
    	var excludedKeys = {
    		$applicationCache: true,
    		$console: true,
    		$external: true,
    		$frame: true,
    		$frameElement: true,
    		$frames: true,
    		$innerHeight: true,
    		$innerWidth: true,
    		$onmozfullscreenchange: true,
    		$onmozfullscreenerror: true,
    		$outerHeight: true,
    		$outerWidth: true,
    		$pageXOffset: true,
    		$pageYOffset: true,
    		$parent: true,
    		$scrollLeft: true,
    		$scrollTop: true,
    		$scrollX: true,
    		$scrollY: true,
    		$self: true,
    		$webkitIndexedDB: true,
    		$webkitStorageInfo: true,
    		$window: true
    	};
    	var hasAutomationEqualityBug = (function () {
    		/* global window */
    		if (typeof window === 'undefined') { return false; }
    		for (var k in window) {
    			try {
    				if (!excludedKeys['$' + k] && has$1.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
    					try {
    						equalsConstructorPrototype(window[k]);
    					} catch (e) {
    						return true;
    					}
    				}
    			} catch (e) {
    				return true;
    			}
    		}
    		return false;
    	}());
    	var equalsConstructorPrototypeIfNotBuggy = function (o) {
    		/* global window */
    		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
    			return equalsConstructorPrototype(o);
    		}
    		try {
    			return equalsConstructorPrototype(o);
    		} catch (e) {
    			return false;
    		}
    	};

    	keysShim$1 = function keys(object) {
    		var isObject = object !== null && typeof object === 'object';
    		var isFunction = toStr$3.call(object) === '[object Function]';
    		var isArguments = isArgs(object);
    		var isString = isObject && toStr$3.call(object) === '[object String]';
    		var theKeys = [];

    		if (!isObject && !isFunction && !isArguments) {
    			throw new TypeError('Object.keys called on a non-object');
    		}

    		var skipProto = hasProtoEnumBug && isFunction;
    		if (isString && object.length > 0 && !has$1.call(object, 0)) {
    			for (var i = 0; i < object.length; ++i) {
    				theKeys.push(String(i));
    			}
    		}

    		if (isArguments && object.length > 0) {
    			for (var j = 0; j < object.length; ++j) {
    				theKeys.push(String(j));
    			}
    		} else {
    			for (var name in object) {
    				if (!(skipProto && name === 'prototype') && has$1.call(object, name)) {
    					theKeys.push(String(name));
    				}
    			}
    		}

    		if (hasDontEnumBug) {
    			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

    			for (var k = 0; k < dontEnums.length; ++k) {
    				if (!(skipConstructor && dontEnums[k] === 'constructor') && has$1.call(object, dontEnums[k])) {
    					theKeys.push(dontEnums[k]);
    				}
    			}
    		}
    		return theKeys;
    	};
    }
    var implementation$3 = keysShim$1;

    var slice = Array.prototype.slice;


    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) { return origKeys(o); } : implementation$3;

    var originalKeys = Object.keys;

    keysShim.shim = function shimObjectKeys() {
    	if (Object.keys) {
    		var keysWorksWithArguments = (function () {
    			// Safari 5.0 bug
    			var args = Object.keys(arguments);
    			return args && args.length === arguments.length;
    		}(1, 2));
    		if (!keysWorksWithArguments) {
    			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
    				if (isArguments$1(object)) {
    					return originalKeys(slice.call(object));
    				}
    				return originalKeys(object);
    			};
    		}
    	} else {
    		Object.keys = keysShim;
    	}
    	return Object.keys || keysShim;
    };

    var objectKeys = keysShim;

    /* eslint complexity: [2, 18], max-statements: [2, 33] */
    var shams$1 = function hasSymbols() {
    	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
    	if (typeof Symbol.iterator === 'symbol') { return true; }

    	var obj = {};
    	var sym = Symbol('test');
    	var symObj = Object(sym);
    	if (typeof sym === 'string') { return false; }

    	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
    	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

    	// temp disabled per https://github.com/ljharb/object.assign/issues/17
    	// if (sym instanceof Symbol) { return false; }
    	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    	// if (!(symObj instanceof Symbol)) { return false; }

    	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
    	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    	var symVal = 42;
    	obj[sym] = symVal;
    	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

    	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

    	var syms = Object.getOwnPropertySymbols(obj);
    	if (syms.length !== 1 || syms[0] !== sym) { return false; }

    	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

    	if (typeof Object.getOwnPropertyDescriptor === 'function') {
    		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
    	}

    	return true;
    };

    /** @type {import('.')} */
    var shams = function hasToStringTagShams() {
    	return shams$1() && !!Symbol.toStringTag;
    };

    /** @type {import('.')} */
    var esErrors = Error;

    /** @type {import('./eval')} */
    var _eval = EvalError;

    /** @type {import('./range')} */
    var range = RangeError;

    /** @type {import('./ref')} */
    var ref = ReferenceError;

    /** @type {import('./syntax')} */
    var syntax = SyntaxError;

    /** @type {import('./type')} */
    var type = TypeError;

    /** @type {import('./uri')} */
    var uri = URIError;

    var origSymbol = typeof Symbol !== 'undefined' && Symbol;


    var hasSymbols$2 = function hasNativeSymbols() {
    	if (typeof origSymbol !== 'function') { return false; }
    	if (typeof Symbol !== 'function') { return false; }
    	if (typeof origSymbol('foo') !== 'symbol') { return false; }
    	if (typeof Symbol('bar') !== 'symbol') { return false; }

    	return shams$1();
    };

    var test = {
    	__proto__: null,
    	foo: {}
    };

    var $Object$1 = Object;

    /** @type {import('.')} */
    var hasProto$1 = function hasProto() {
    	// @ts-expect-error: TS errors on an inherited property for some reason
    	return { __proto__: test }.foo === test.foo
    		&& !(test instanceof $Object$1);
    };

    /* eslint no-invalid-this: 1 */

    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var toStr$2 = Object.prototype.toString;
    var max$1 = Math.max;
    var funcType = '[object Function]';

    var concatty = function concatty(a, b) {
        var arr = [];

        for (var i = 0; i < a.length; i += 1) {
            arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
            arr[j + a.length] = b[j];
        }

        return arr;
    };

    var slicy = function slicy(arrLike, offset) {
        var arr = [];
        for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
            arr[j] = arrLike[i];
        }
        return arr;
    };

    var joiny = function (arr, joiner) {
        var str = '';
        for (var i = 0; i < arr.length; i += 1) {
            str += arr[i];
            if (i + 1 < arr.length) {
                str += joiner;
            }
        }
        return str;
    };

    var implementation$2 = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr$2.apply(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);

        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    concatty(args, arguments)
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            }
            return target.apply(
                that,
                concatty(args, arguments)
            );

        };

        var boundLength = max$1(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs[i] = '$' + i;
        }

        bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }

        return bound;
    };

    var functionBind = Function.prototype.bind || implementation$2;

    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;


    /** @type {import('.')} */
    var hasown = functionBind.call(call, $hasOwn);

    var $Error = esErrors;

    var $EvalError = _eval;

    var $RangeError = range;

    var $ReferenceError = ref;

    var $SyntaxError = syntax;

    var $TypeError = type;

    var $URIError = uri;

    var require$$1 = hasProto$1;

    var hasOwn = hasown;

    var undefined$1;









    var $Function = Function;

    // eslint-disable-next-line consistent-return
    var getEvalledConstructor = function (expressionSyntax) {
    	try {
    		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    	} catch (e) {}
    };

    var $gOPD$2 = Object.getOwnPropertyDescriptor;
    if ($gOPD$2) {
    	try {
    		$gOPD$2({}, '');
    	} catch (e) {
    		$gOPD$2 = null; // this is IE 8, which has a broken gOPD
    	}
    }

    var throwTypeError = function () {
    	throw new $TypeError();
    };
    var ThrowTypeError = $gOPD$2
    	? (function () {
    		try {
    			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    			arguments.callee; // IE 8 does not throw here
    			return throwTypeError;
    		} catch (calleeThrows) {
    			try {
    				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
    				return $gOPD$2(arguments, 'callee').get;
    			} catch (gOPDthrows) {
    				return throwTypeError;
    			}
    		}
    	}())
    	: throwTypeError;

    var hasSymbols$1 = hasSymbols$2();
    var hasProto = require$$1();

    var getProto$1 = Object.getPrototypeOf || (
    	hasProto
    		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
    		: null
    );

    var needsEval = {};

    var TypedArray = typeof Uint8Array === 'undefined' || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);

    var INTRINSICS = {
    	__proto__: null,
    	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
    	'%Array%': Array,
    	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    	'%ArrayIteratorPrototype%': hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
    	'%AsyncFromSyncIteratorPrototype%': undefined$1,
    	'%AsyncFunction%': needsEval,
    	'%AsyncGenerator%': needsEval,
    	'%AsyncGeneratorFunction%': needsEval,
    	'%AsyncIteratorPrototype%': needsEval,
    	'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    	'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
    	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
    	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
    	'%Boolean%': Boolean,
    	'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    	'%Date%': Date,
    	'%decodeURI%': decodeURI,
    	'%decodeURIComponent%': decodeURIComponent,
    	'%encodeURI%': encodeURI,
    	'%encodeURIComponent%': encodeURIComponent,
    	'%Error%': $Error,
    	'%eval%': eval, // eslint-disable-line no-eval
    	'%EvalError%': $EvalError,
    	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
    	'%Function%': $Function,
    	'%GeneratorFunction%': needsEval,
    	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    	'%isFinite%': isFinite,
    	'%isNaN%': isNaN,
    	'%IteratorPrototype%': hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
    	'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
    	'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
    	'%Math%': Math,
    	'%Number%': Number,
    	'%Object%': Object,
    	'%parseFloat%': parseFloat,
    	'%parseInt%': parseInt,
    	'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    	'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    	'%RangeError%': $RangeError,
    	'%ReferenceError%': $ReferenceError,
    	'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    	'%RegExp%': RegExp,
    	'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
    	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    	'%String%': String,
    	'%StringIteratorPrototype%': hasSymbols$1 && getProto$1 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
    	'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
    	'%SyntaxError%': $SyntaxError,
    	'%ThrowTypeError%': ThrowTypeError,
    	'%TypedArray%': TypedArray,
    	'%TypeError%': $TypeError,
    	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    	'%URIError%': $URIError,
    	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
    	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
    };

    if (getProto$1) {
    	try {
    		null.error; // eslint-disable-line no-unused-expressions
    	} catch (e) {
    		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    		var errorProto = getProto$1(getProto$1(e));
    		INTRINSICS['%Error.prototype%'] = errorProto;
    	}
    }

    var doEval = function doEval(name) {
    	var value;
    	if (name === '%AsyncFunction%') {
    		value = getEvalledConstructor('async function () {}');
    	} else if (name === '%GeneratorFunction%') {
    		value = getEvalledConstructor('function* () {}');
    	} else if (name === '%AsyncGeneratorFunction%') {
    		value = getEvalledConstructor('async function* () {}');
    	} else if (name === '%AsyncGenerator%') {
    		var fn = doEval('%AsyncGeneratorFunction%');
    		if (fn) {
    			value = fn.prototype;
    		}
    	} else if (name === '%AsyncIteratorPrototype%') {
    		var gen = doEval('%AsyncGenerator%');
    		if (gen && getProto$1) {
    			value = getProto$1(gen.prototype);
    		}
    	}

    	INTRINSICS[name] = value;

    	return value;
    };

    var LEGACY_ALIASES = {
    	__proto__: null,
    	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    	'%ArrayPrototype%': ['Array', 'prototype'],
    	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
    	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    	'%BooleanPrototype%': ['Boolean', 'prototype'],
    	'%DataViewPrototype%': ['DataView', 'prototype'],
    	'%DatePrototype%': ['Date', 'prototype'],
    	'%ErrorPrototype%': ['Error', 'prototype'],
    	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
    	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    	'%FunctionPrototype%': ['Function', 'prototype'],
    	'%Generator%': ['GeneratorFunction', 'prototype'],
    	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    	'%JSONParse%': ['JSON', 'parse'],
    	'%JSONStringify%': ['JSON', 'stringify'],
    	'%MapPrototype%': ['Map', 'prototype'],
    	'%NumberPrototype%': ['Number', 'prototype'],
    	'%ObjectPrototype%': ['Object', 'prototype'],
    	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    	'%PromisePrototype%': ['Promise', 'prototype'],
    	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    	'%Promise_all%': ['Promise', 'all'],
    	'%Promise_reject%': ['Promise', 'reject'],
    	'%Promise_resolve%': ['Promise', 'resolve'],
    	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
    	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    	'%RegExpPrototype%': ['RegExp', 'prototype'],
    	'%SetPrototype%': ['Set', 'prototype'],
    	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    	'%StringPrototype%': ['String', 'prototype'],
    	'%SymbolPrototype%': ['Symbol', 'prototype'],
    	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
    	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    	'%URIErrorPrototype%': ['URIError', 'prototype'],
    	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
    	'%WeakSetPrototype%': ['WeakSet', 'prototype']
    };



    var $concat = functionBind.call(Function.call, Array.prototype.concat);
    var $spliceApply = functionBind.call(Function.apply, Array.prototype.splice);
    var $replace = functionBind.call(Function.call, String.prototype.replace);
    var $strSlice = functionBind.call(Function.call, String.prototype.slice);
    var $exec$1 = functionBind.call(Function.call, RegExp.prototype.exec);

    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
    var stringToPath = function stringToPath(string) {
    	var first = $strSlice(string, 0, 1);
    	var last = $strSlice(string, -1);
    	if (first === '%' && last !== '%') {
    		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    	} else if (last === '%' && first !== '%') {
    		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    	}
    	var result = [];
    	$replace(string, rePropName, function (match, number, quote, subString) {
    		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    	});
    	return result;
    };
    /* end adaptation */

    var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    	var intrinsicName = name;
    	var alias;
    	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    		alias = LEGACY_ALIASES[intrinsicName];
    		intrinsicName = '%' + alias[0] + '%';
    	}

    	if (hasOwn(INTRINSICS, intrinsicName)) {
    		var value = INTRINSICS[intrinsicName];
    		if (value === needsEval) {
    			value = doEval(intrinsicName);
    		}
    		if (typeof value === 'undefined' && !allowMissing) {
    			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    		}

    		return {
    			alias: alias,
    			name: intrinsicName,
    			value: value
    		};
    	}

    	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
    };

    var getIntrinsic = function GetIntrinsic(name, allowMissing) {
    	if (typeof name !== 'string' || name.length === 0) {
    		throw new $TypeError('intrinsic name must be a non-empty string');
    	}
    	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    		throw new $TypeError('"allowMissing" argument must be a boolean');
    	}

    	if ($exec$1(/^%?[^%]*%?$/, name) === null) {
    		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    	}
    	var parts = stringToPath(name);
    	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

    	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    	var intrinsicRealName = intrinsic.name;
    	var value = intrinsic.value;
    	var skipFurtherCaching = false;

    	var alias = intrinsic.alias;
    	if (alias) {
    		intrinsicBaseName = alias[0];
    		$spliceApply(parts, $concat([0, 1], alias));
    	}

    	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    		var part = parts[i];
    		var first = $strSlice(part, 0, 1);
    		var last = $strSlice(part, -1);
    		if (
    			(
    				(first === '"' || first === "'" || first === '`')
    				|| (last === '"' || last === "'" || last === '`')
    			)
    			&& first !== last
    		) {
    			throw new $SyntaxError('property names with quotes must have matching quotes');
    		}
    		if (part === 'constructor' || !isOwn) {
    			skipFurtherCaching = true;
    		}

    		intrinsicBaseName += '.' + part;
    		intrinsicRealName = '%' + intrinsicBaseName + '%';

    		if (hasOwn(INTRINSICS, intrinsicRealName)) {
    			value = INTRINSICS[intrinsicRealName];
    		} else if (value != null) {
    			if (!(part in value)) {
    				if (!allowMissing) {
    					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
    				}
    				return void undefined$1;
    			}
    			if ($gOPD$2 && (i + 1) >= parts.length) {
    				var desc = $gOPD$2(value, part);
    				isOwn = !!desc;

    				// By convention, when a data property is converted to an accessor
    				// property to emulate a data property that does not suffer from
    				// the override mistake, that accessor's getter is marked with
    				// an `originalValue` property. Here, when we detect this, we
    				// uphold the illusion by pretending to see that original data
    				// property, i.e., returning the value rather than the getter
    				// itself.
    				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
    					value = desc.get;
    				} else {
    					value = value[part];
    				}
    			} else {
    				isOwn = hasOwn(value, part);
    				value = value[part];
    			}

    			if (isOwn && !skipFurtherCaching) {
    				INTRINSICS[intrinsicRealName] = value;
    			}
    		}
    	}
    	return value;
    };

    var GetIntrinsic = getIntrinsic;

    /** @type {import('.')} */
    var $defineProperty$1 = GetIntrinsic('%Object.defineProperty%', true) || false;
    if ($defineProperty$1) {
    	try {
    		$defineProperty$1({}, 'a', { value: 1 });
    	} catch (e) {
    		// IE 8 has a broken defineProperty
    		$defineProperty$1 = false;
    	}
    }

    var esDefineProperty = $defineProperty$1;

    var $gOPD$1 = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

    if ($gOPD$1) {
    	try {
    		$gOPD$1([], 'length');
    	} catch (e) {
    		// IE 8 has a broken gOPD
    		$gOPD$1 = null;
    	}
    }

    var gopd = $gOPD$1;

    var $defineProperty = esDefineProperty;

    var gOPD$3 = gopd;

    /** @type {import('.')} */
    var defineDataProperty = function defineDataProperty(
    	obj,
    	property,
    	value
    ) {
    	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    		throw new $TypeError('`obj` must be an object or a function`');
    	}
    	if (typeof property !== 'string' && typeof property !== 'symbol') {
    		throw new $TypeError('`property` must be a string or a symbol`');
    	}
    	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
    		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
    	}
    	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
    		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
    	}
    	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
    		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
    	}
    	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
    		throw new $TypeError('`loose`, if provided, must be a boolean');
    	}

    	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    	var nonWritable = arguments.length > 4 ? arguments[4] : null;
    	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    	var loose = arguments.length > 6 ? arguments[6] : false;

    	/* @type {false | TypedPropertyDescriptor<unknown>} */
    	var desc = !!gOPD$3 && gOPD$3(obj, property);

    	if ($defineProperty) {
    		$defineProperty(obj, property, {
    			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
    			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
    			value: value,
    			writable: nonWritable === null && desc ? desc.writable : !nonWritable
    		});
    	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
    		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    		obj[property] = value; // eslint-disable-line no-param-reassign
    	} else {
    		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
    	}
    };

    var hasPropertyDescriptors = function hasPropertyDescriptors() {
    	return !!$defineProperty;
    };

    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    	// node v0.6 has a bug where array lengths can be Set but not Defined
    	if (!$defineProperty) {
    		return null;
    	}
    	try {
    		return $defineProperty([], 'length', { value: 1 }).length !== 1;
    	} catch (e) {
    		// In Firefox 4-22, defining length on an array throws an exception.
    		return true;
    	}
    };

    var hasPropertyDescriptors_1 = hasPropertyDescriptors;

    var define = defineDataProperty;

    var require$$0 = hasPropertyDescriptors_1;

    var hasDescriptors$1 = require$$0();



    var $floor = GetIntrinsic('%Math.floor%');

    /** @type {import('.')} */
    var setFunctionLength$1 = function setFunctionLength(fn, length) {
    	if (typeof fn !== 'function') {
    		throw new $TypeError('`fn` is not a function');
    	}
    	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
    		throw new $TypeError('`length` must be a positive 32-bit integer');
    	}

    	var loose = arguments.length > 2 && !!arguments[2];

    	var functionLengthIsConfigurable = true;
    	var functionLengthIsWritable = true;
    	if ('length' in fn && gOPD$3) {
    		var desc = gOPD$3(fn, 'length');
    		if (desc && !desc.configurable) {
    			functionLengthIsConfigurable = false;
    		}
    		if (desc && !desc.writable) {
    			functionLengthIsWritable = false;
    		}
    	}

    	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    		if (hasDescriptors$1) {
    			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
    		} else {
    			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
    		}
    	}
    	return fn;
    };

    var setFunctionLength = setFunctionLength$1;

    var callBind = createCommonjsModule(function (module) {






    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);


    var $max = GetIntrinsic('%Math.max%');

    module.exports = function callBind(originalFunction) {
    	if (typeof originalFunction !== 'function') {
    		throw new $TypeError('a function is required');
    	}
    	var func = $reflectApply(functionBind, $call, arguments);
    	return setFunctionLength(
    		func,
    		1 + $max(0, originalFunction.length - (arguments.length - 1)),
    		true
    	);
    };

    var applyBind = function applyBind() {
    	return $reflectApply(functionBind, $apply, arguments);
    };

    if ($defineProperty) {
    	$defineProperty(module.exports, 'apply', { value: applyBind });
    } else {
    	module.exports.apply = applyBind;
    }
    });

    var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

    var callBound = function callBoundIntrinsic(name, allowMissing) {
    	var intrinsic = GetIntrinsic(name, !!allowMissing);
    	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    		return callBind(intrinsic);
    	}
    	return intrinsic;
    };

    var hasToStringTag$2 = shams();


    var $toString$1 = callBound('Object.prototype.toString');

    var isStandardArguments = function isArguments(value) {
    	if (hasToStringTag$2 && value && typeof value === 'object' && Symbol.toStringTag in value) {
    		return false;
    	}
    	return $toString$1(value) === '[object Arguments]';
    };

    var isLegacyArguments = function isArguments(value) {
    	if (isStandardArguments(value)) {
    		return true;
    	}
    	return value !== null &&
    		typeof value === 'object' &&
    		typeof value.length === 'number' &&
    		value.length >= 0 &&
    		$toString$1(value) !== '[object Array]' &&
    		$toString$1(value.callee) === '[object Function]';
    };

    var supportsStandardArguments = (function () {
    	return isStandardArguments(arguments);
    }());

    isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

    var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

    var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

    var toStr$1 = Object.prototype.toString;
    var concat = Array.prototype.concat;


    var isFunction = function (fn) {
    	return typeof fn === 'function' && toStr$1.call(fn) === '[object Function]';
    };

    var supportsDescriptors$2 = require$$0();

    var defineProperty$1 = function (object, name, value, predicate) {
    	if (name in object) {
    		if (predicate === true) {
    			if (object[name] === value) {
    				return;
    			}
    		} else if (!isFunction(predicate) || !predicate()) {
    			return;
    		}
    	}

    	if (supportsDescriptors$2) {
    		define(object, name, value, true);
    	} else {
    		define(object, name, value);
    	}
    };

    var defineProperties = function (object, map) {
    	var predicates = arguments.length > 2 ? arguments[2] : {};
    	var props = objectKeys(map);
    	if (hasSymbols) {
    		props = concat.call(props, Object.getOwnPropertySymbols(map));
    	}
    	for (var i = 0; i < props.length; i += 1) {
    		defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
    	}
    };

    defineProperties.supportsDescriptors = !!supportsDescriptors$2;

    var defineProperties_1 = defineProperties;

    var numberIsNaN = function (value) {
    	return value !== value;
    };

    var implementation$1 = function is(a, b) {
    	if (a === 0 && b === 0) {
    		return 1 / a === 1 / b;
    	}
    	if (a === b) {
    		return true;
    	}
    	if (numberIsNaN(a) && numberIsNaN(b)) {
    		return true;
    	}
    	return false;
    };

    var polyfill$2 = function getPolyfill() {
    	return typeof Object.is === 'function' ? Object.is : implementation$1;
    };

    var shim$1 = function shimObjectIs() {
    	var polyfill = polyfill$2();
    	defineProperties_1(Object, { is: polyfill }, {
    		is: function testObjectIs() {
    			return Object.is !== polyfill;
    		}
    	});
    	return polyfill;
    };

    var polyfill$1 = callBind(polyfill$2(), Object);

    defineProperties_1(polyfill$1, {
    	getPolyfill: polyfill$2,
    	implementation: implementation$1,
    	shim: shim$1
    });

    var objectIs = polyfill$1;

    var hasToStringTag$1 = shams();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;

    if (hasToStringTag$1) {
    	has = callBound('Object.prototype.hasOwnProperty');
    	$exec = callBound('RegExp.prototype.exec');
    	isRegexMarker = {};

    	var throwRegexMarker = function () {
    		throw isRegexMarker;
    	};
    	badStringifier = {
    		toString: throwRegexMarker,
    		valueOf: throwRegexMarker
    	};

    	if (typeof Symbol.toPrimitive === 'symbol') {
    		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    	}
    }

    var $toString = callBound('Object.prototype.toString');
    var gOPD$2 = Object.getOwnPropertyDescriptor;
    var regexClass = '[object RegExp]';

    var isRegex = hasToStringTag$1
    	// eslint-disable-next-line consistent-return
    	? function isRegex(value) {
    		if (!value || typeof value !== 'object') {
    			return false;
    		}

    		var descriptor = gOPD$2(value, 'lastIndex');
    		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
    		if (!hasLastIndexDataProperty) {
    			return false;
    		}

    		try {
    			$exec(value, badStringifier);
    		} catch (e) {
    			return e === isRegexMarker;
    		}
    	}
    	: function isRegex(value) {
    		// In older browsers, typeof regex incorrectly returns 'function'
    		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
    			return false;
    		}

    		return $toString(value) === regexClass;
    	};

    var functionsHaveNames = function functionsHaveNames() {
    	return typeof function f() {}.name === 'string';
    };

    var gOPD$1 = Object.getOwnPropertyDescriptor;
    if (gOPD$1) {
    	try {
    		gOPD$1([], 'length');
    	} catch (e) {
    		// IE 8 has a broken gOPD
    		gOPD$1 = null;
    	}
    }

    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
    	if (!functionsHaveNames() || !gOPD$1) {
    		return false;
    	}
    	var desc = gOPD$1(function () {}, 'name');
    	return !!desc && !!desc.configurable;
    };

    var $bind = Function.prototype.bind;

    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
    	return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
    };

    var functionsHaveNames_1 = functionsHaveNames;

    var hasDescriptors = require$$0();
    var functionsHaveConfigurableNames = functionsHaveNames_1.functionsHaveConfigurableNames();



    /** @type {import('.')} */
    var setFunctionName = function setFunctionName(fn, name) {
    	if (typeof fn !== 'function') {
    		throw new $TypeError('`fn` is not a function');
    	}
    	var loose = arguments.length > 2 && !!arguments[2];
    	if (!loose || functionsHaveConfigurableNames) {
    		if (hasDescriptors) {
    			define(/** @type {Parameters<define>[0]} */ (fn), 'name', name, true, true);
    		} else {
    			define(/** @type {Parameters<define>[0]} */ (fn), 'name', name);
    		}
    	}
    	return fn;
    };

    var $Object = Object;

    var implementation = setFunctionName(function flags() {
    	if (this == null || this !== $Object(this)) {
    		throw new $TypeError('RegExp.prototype.flags getter called on non-object');
    	}
    	var result = '';
    	if (this.hasIndices) {
    		result += 'd';
    	}
    	if (this.global) {
    		result += 'g';
    	}
    	if (this.ignoreCase) {
    		result += 'i';
    	}
    	if (this.multiline) {
    		result += 'm';
    	}
    	if (this.dotAll) {
    		result += 's';
    	}
    	if (this.unicode) {
    		result += 'u';
    	}
    	if (this.unicodeSets) {
    		result += 'v';
    	}
    	if (this.sticky) {
    		result += 'y';
    	}
    	return result;
    }, 'get flags', true);

    var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;

    var polyfill = function getPolyfill() {
    	if (supportsDescriptors$1 && (/a/mig).flags === 'gim') {
    		var descriptor = $gOPD(RegExp.prototype, 'flags');
    		if (
    			descriptor
    			&& typeof descriptor.get === 'function'
    			&& typeof RegExp.prototype.dotAll === 'boolean'
    			&& typeof RegExp.prototype.hasIndices === 'boolean'
    		) {
    			/* eslint getter-return: 0 */
    			var calls = '';
    			var o = {};
    			Object.defineProperty(o, 'hasIndices', {
    				get: function () {
    					calls += 'd';
    				}
    			});
    			Object.defineProperty(o, 'sticky', {
    				get: function () {
    					calls += 'y';
    				}
    			});
    			if (calls === 'dy') {
    				return descriptor.get;
    			}
    		}
    	}
    	return implementation;
    };

    var supportsDescriptors = defineProperties_1.supportsDescriptors;

    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;

    var shim = function shimFlags() {
    	if (!supportsDescriptors || !getProto) {
    		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
    	}
    	var polyfill$1 = polyfill();
    	var proto = getProto(regex);
    	var descriptor = gOPD(proto, 'flags');
    	if (!descriptor || descriptor.get !== polyfill$1) {
    		defineProperty(proto, 'flags', {
    			configurable: true,
    			enumerable: false,
    			get: polyfill$1
    		});
    	}
    	return polyfill$1;
    };

    var flagsBound = callBind(polyfill());

    defineProperties_1(flagsBound, {
    	getPolyfill: polyfill,
    	implementation: implementation,
    	shim: shim
    });

    var regexp_prototype_flags = flagsBound;

    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
    	try {
    		getDay.call(value);
    		return true;
    	} catch (e) {
    		return false;
    	}
    };

    var toStr = Object.prototype.toString;
    var dateClass = '[object Date]';
    var hasToStringTag = shams();

    var isDateObject = function isDateObject(value) {
    	if (typeof value !== 'object' || value === null) {
    		return false;
    	}
    	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };

    var getTime = Date.prototype.getTime;

    function deepEqual(actual, expected, options) {
      var opts = options || {};

      // 7.1. All identical values are equivalent, as determined by ===.
      if (opts.strict ? objectIs(actual, expected) : actual === expected) {
        return true;
      }

      // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
      if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
        return opts.strict ? objectIs(actual, expected) : actual == expected;
      }

      /*
       * 7.4. For all other Object pairs, including Array objects, equivalence is
       * determined by having the same number of owned properties (as verified
       * with Object.prototype.hasOwnProperty.call), the same set of keys
       * (although not necessarily the same order), equivalent values for every
       * corresponding key, and an identical 'prototype' property. Note: this
       * accounts for both named and indexed properties on Arrays.
       */
      // eslint-disable-next-line no-use-before-define
      return objEquiv(actual, expected, opts);
    }

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isBuffer(x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
        return false;
      }
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') {
        return false;
      }
      return true;
    }

    function objEquiv(a, b, opts) {
      /* eslint max-statements: [2, 50] */
      var i, key;
      if (typeof a !== typeof b) { return false; }
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) { return false; }

      if (isArguments(a) !== isArguments(b)) { return false; }

      var aIsRegex = isRegex(a);
      var bIsRegex = isRegex(b);
      if (aIsRegex !== bIsRegex) { return false; }
      if (aIsRegex || bIsRegex) {
        return a.source === b.source && regexp_prototype_flags(a) === regexp_prototype_flags(b);
      }

      if (isDateObject(a) && isDateObject(b)) {
        return getTime.call(a) === getTime.call(b);
      }

      var aIsBuffer = isBuffer(a);
      var bIsBuffer = isBuffer(b);
      if (aIsBuffer !== bIsBuffer) { return false; }
      if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
        if (a.length !== b.length) { return false; }
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) { return false; }
        }
        return true;
      }

      if (typeof a !== typeof b) { return false; }

      try {
        var ka = objectKeys(a);
        var kb = objectKeys(b);
      } catch (e) { // happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates hasOwnProperty)
      if (ka.length !== kb.length) { return false; }

      // the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      // ~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i]) { return false; }
      }
      // equivalent values for every corresponding key, and ~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) { return false; }
      }

      return true;
    }

    var deepEqual_1 = deepEqual;

    /**
     * Takes any LineString or Polygon and returns the overlapping lines between both features.
     *
     * @name lineOverlap
     * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
     * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)
     * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features
     * @example
     * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);
     * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);
     *
     * var overlapping = turf.lineOverlap(line1, line2);
     *
     * //addToMap
     * var addToMap = [line1, line2, overlapping]
     */
    function lineOverlap(line1, line2, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        options = options || {};
        if (!isObject(options))
            throw new Error("options is invalid");
        var tolerance = options.tolerance || 0;
        // Containers
        var features = [];
        // Create Spatial Index
        var tree = geojsonRbush_1();
        // To-Do -- HACK way to support typescript
        var line = lineSegment(line1);
        tree.load(line);
        var overlapSegment;
        // Line Intersection
        // Iterate over line segments
        segmentEach$1(line2, function (segment) {
            var doesOverlaps = false;
            if (!segment) {
                return;
            }
            // Iterate over each segments which falls within the same bounds
            featureEach$2(tree.search(segment), function (match) {
                if (doesOverlaps === false) {
                    var coordsSegment = getCoords(segment).sort();
                    var coordsMatch = getCoords(match).sort();
                    // Segment overlaps feature
                    if (deepEqual_1(coordsSegment, coordsMatch)) {
                        doesOverlaps = true;
                        // Overlaps already exists - only append last coordinate of segment
                        if (overlapSegment)
                            overlapSegment = concatSegment(overlapSegment, segment);
                        else
                            overlapSegment = segment;
                        // Match segments which don't share nodes (Issue #901)
                    }
                    else if (tolerance === 0
                        ? booleanPointOnLine(coordsSegment[0], match) &&
                            booleanPointOnLine(coordsSegment[1], match)
                        : nearestPointOnLine(match, coordsSegment[0]).properties.dist <=
                            tolerance &&
                            nearestPointOnLine(match, coordsSegment[1]).properties.dist <=
                                tolerance) {
                        doesOverlaps = true;
                        if (overlapSegment)
                            overlapSegment = concatSegment(overlapSegment, segment);
                        else
                            overlapSegment = segment;
                    }
                    else if (tolerance === 0
                        ? booleanPointOnLine(coordsMatch[0], segment) &&
                            booleanPointOnLine(coordsMatch[1], segment)
                        : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <=
                            tolerance &&
                            nearestPointOnLine(segment, coordsMatch[1]).properties.dist <=
                                tolerance) {
                        // Do not define (doesOverlap = true) since more matches can occur within the same segment
                        // doesOverlaps = true;
                        if (overlapSegment)
                            overlapSegment = concatSegment(overlapSegment, match);
                        else
                            overlapSegment = match;
                    }
                }
            });
            // Segment doesn't overlap - add overlaps to results & reset
            if (doesOverlaps === false && overlapSegment) {
                features.push(overlapSegment);
                overlapSegment = undefined;
            }
        });
        // Add last segment if exists
        if (overlapSegment)
            features.push(overlapSegment);
        return featureCollection$1(features);
    }
    /**
     * Concat Segment
     *
     * @private
     * @param {Feature<LineString>} line LineString
     * @param {Feature<LineString>} segment 2-vertex LineString
     * @returns {Feature<LineString>} concat linestring
     */
    function concatSegment(line, segment) {
        var coords = getCoords(segment);
        var lineCoords = getCoords(line);
        var start = lineCoords[0];
        var end = lineCoords[lineCoords.length - 1];
        var geom = line.geometry.coordinates;
        if (deepEqual_1(coords[0], start))
            geom.unshift(coords[1]);
        else if (deepEqual_1(coords[0], end))
            geom.push(coords[1]);
        else if (deepEqual_1(coords[1], start))
            geom.unshift(coords[0]);
        else if (deepEqual_1(coords[1], end))
            geom.push(coords[0]);
        return line;
    }

    /**
     * Creates a circular sector of a circle of given radius and center {@link Point},
     * between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.
     *
     * @name sector
     * @param {Coord} center center point
     * @param {number} radius radius of the circle
     * @param {number} bearing1 angle, in decimal degrees, of the first radius of the sector
     * @param {number} bearing2 angle, in decimal degrees, of the second radius of the sector
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
     * @param {number} [options.steps=64] number of steps
     * @param {Properties} [options.properties={}] Translate properties to Feature Polygon
     * @returns {Feature<Polygon>} sector polygon
     * @example
     * var center = turf.point([-75, 40]);
     * var radius = 5;
     * var bearing1 = 25;
     * var bearing2 = 45;
     *
     * var sector = turf.sector(center, radius, bearing1, bearing2);
     *
     * //addToMap
     * var addToMap = [center, sector];
     */
    function sector(center, radius, bearing1, bearing2, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var properties = options.properties;

      // validation
      if (!center) throw new Error("center is required");
      if (bearing1 === undefined || bearing1 === null)
        throw new Error("bearing1 is required");
      if (bearing2 === undefined || bearing2 === null)
        throw new Error("bearing2 is required");
      if (!radius) throw new Error("radius is required");
      if (typeof options !== "object") throw new Error("options must be an object");

      if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {
        return circle(center, radius, options);
      }
      var coords = getCoords(center);
      var arc = lineArc(center, radius, bearing1, bearing2, options);
      var sliceCoords = [[coords]];
      coordEach$1(arc, function (currentCoords) {
        sliceCoords[0].push(currentCoords);
      });
      sliceCoords[0].push(coords);

      return polygon(sliceCoords, properties);
    }

    /**
     * Takes any angle in degrees
     * and returns a valid angle between 0-360 degrees
     *
     * @private
     * @param {number} alfa angle between -180-180 degrees
     * @returns {number} angle between 0-360 degrees
     */
    function convertAngleTo360(alfa) {
      var beta = alfa % 360;
      if (beta < 0) beta += 360;
      return beta;
    }

    // https://en.wikipedia.org/wiki/Rhumb_line
    /**
     * Takes two {@link Point|points} and finds the bearing angle between them along a Rhumb line
     * i.e. the angle measured in degrees start the north line (0 degrees)
     *
     * @name rhumbBearing
     * @param {Coord} start starting Point
     * @param {Coord} end ending Point
     * @param {Object} [options] Optional parameters
     * @param {boolean} [options.final=false] calculates the final bearing if true
     * @returns {number} bearing from north in decimal degrees, between -180 and 180 degrees (positive clockwise)
     * @example
     * var point1 = turf.point([-75.343, 39.984], {"marker-color": "#F00"});
     * var point2 = turf.point([-75.534, 39.123], {"marker-color": "#00F"});
     *
     * var bearing = turf.rhumbBearing(point1, point2);
     *
     * //addToMap
     * var addToMap = [point1, point2];
     * point1.properties.bearing = bearing;
     * point2.properties.bearing = bearing;
     */
    function rhumbBearing(start, end, options) {
        if (options === void 0) { options = {}; }
        var bear360;
        if (options.final) {
            bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));
        }
        else {
            bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));
        }
        var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
        return bear180;
    }
    /**
     * Returns the bearing from ‘this’ point to destination point along a rhumb line.
     * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js
     *
     * @private
     * @param   {Array<number>} from - origin point.
     * @param   {Array<number>} to - destination point.
     * @returns {number} Bearing in degrees from north.
     * @example
     * var p1 = new LatLon(51.127, 1.338);
     * var p2 = new LatLon(50.964, 1.853);
     * var d = p1.rhumbBearingTo(p2); // 116.7 m
     */
    function calculateRhumbBearing(from, to) {
        // φ => phi
        // Δλ => deltaLambda
        // Δψ => deltaPsi
        // θ => theta
        var phi1 = degreesToRadians(from[1]);
        var phi2 = degreesToRadians(to[1]);
        var deltaLambda = degreesToRadians(to[0] - from[0]);
        // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:
        if (deltaLambda > Math.PI) {
            deltaLambda -= 2 * Math.PI;
        }
        if (deltaLambda < -Math.PI) {
            deltaLambda += 2 * Math.PI;
        }
        var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
        var theta = Math.atan2(deltaLambda, deltaPsi);
        return (radiansToDegrees(theta) + 360) % 360;
    }

    // https://en.wikipedia.org/wiki/Rhumb_line
    /**
     * Returns the destination {@link Point} having travelled the given distance along a Rhumb line from the
     * origin Point with the (varant) given bearing.
     *
     * @name rhumbDestination
     * @param {Coord} origin starting point
     * @param {number} distance distance from the starting point
     * @param {number} bearing varant bearing angle ranging from -180 to 180 degrees from north
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
     * @param {Object} [options.properties={}] translate properties to destination point
     * @returns {Feature<Point>} Destination point.
     * @example
     * var pt = turf.point([-75.343, 39.984], {"marker-color": "F00"});
     * var distance = 50;
     * var bearing = 90;
     * var options = {units: 'miles'};
     *
     * var destination = turf.rhumbDestination(pt, distance, bearing, options);
     *
     * //addToMap
     * var addToMap = [pt, destination]
     * destination.properties['marker-color'] = '#00F';
     */
    function rhumbDestination(origin, distance, bearing, options) {
        if (options === void 0) { options = {}; }
        var wasNegativeDistance = distance < 0;
        var distanceInMeters = convertLength(Math.abs(distance), options.units, "meters");
        if (wasNegativeDistance)
            distanceInMeters = -Math.abs(distanceInMeters);
        var coords = getCoord(origin);
        var destination = calculateRhumbDestination(coords, distanceInMeters, bearing);
        // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)
        // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678
        destination[0] +=
            destination[0] - coords[0] > 180
                ? -360
                : coords[0] - destination[0] > 180
                    ? 360
                    : 0;
        return point(destination, options.properties);
    }
    /**
     * Returns the destination point having travelled along a rhumb line from origin point the given
     * distance on the  given bearing.
     * Adapted from Geodesy: http://www.movable-type.co.uk/scripts/latlong.html#rhumblines
     *
     * @private
     * @param   {Array<number>} origin - point
     * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).
     * @param   {number} bearing - Bearing in degrees from north.
     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
     * @returns {Array<number>} Destination point.
     */
    function calculateRhumbDestination(origin, distance, bearing, radius) {
        // φ => phi
        // λ => lambda
        // ψ => psi
        // Δ => Delta
        // δ => delta
        // θ => theta
        radius = radius === undefined ? earthRadius : Number(radius);
        var delta = distance / radius; // angular distance in radians
        var lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 𝜋
        var phi1 = degreesToRadians(origin[1]);
        var theta = degreesToRadians(bearing);
        var DeltaPhi = delta * Math.cos(theta);
        var phi2 = phi1 + DeltaPhi;
        // check for some daft bugger going past the pole, normalise latitude if so
        if (Math.abs(phi2) > Math.PI / 2) {
            phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
        }
        var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
        // E-W course becomes ill-conditioned with 0/0
        var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
        var DeltaLambda = (delta * Math.sin(theta)) / q;
        var lambda2 = lambda1 + DeltaLambda;
        return [
            (((lambda2 * 180) / Math.PI + 540) % 360) - 180,
            (phi2 * 180) / Math.PI,
        ]; // normalise to −180..+180°
    }

    /**
     * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.
     *
     * @name polygonTangents
     * @param {Coord} pt to calculate the tangent points from
     * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from
     * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points
     * @example
     * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);
     * var point = turf.point([61, 5]);
     *
     * var tangents = turf.polygonTangents(point, polygon)
     *
     * //addToMap
     * var addToMap = [tangents, point, polygon];
     */
    function polygonTangents(pt, polygon) {
      var pointCoords = getCoords(pt);
      var polyCoords = getCoords(polygon);

      var rtan;
      var ltan;
      var enext;
      var eprev;
      var bbox = bbox$2(polygon);
      var nearestPtIndex = 0;
      var nearest = null;

      // If the point lies inside the polygon bbox then we need to be a bit trickier
      // otherwise points lying inside reflex angles on concave polys can have issues
      if (
        pointCoords[0] > bbox[0] &&
        pointCoords[0] < bbox[2] &&
        pointCoords[1] > bbox[1] &&
        pointCoords[1] < bbox[3]
      ) {
        nearest = nearestPoint(pt, explode$1(polygon));
        nearestPtIndex = nearest.properties.featureIndex;
      }
      var type = getType$1(polygon);
      switch (type) {
        case "Polygon":
          rtan = polyCoords[0][nearestPtIndex];
          ltan = polyCoords[0][0];
          if (nearest !== null) {
            if (nearest.geometry.coordinates[1] < pointCoords[1])
              ltan = polyCoords[0][nearestPtIndex];
          }
          eprev = isLeft(
            polyCoords[0][0],
            polyCoords[0][polyCoords[0].length - 1],
            pointCoords
          );
          var out = processPolygon$1(
            polyCoords[0],
            pointCoords,
            eprev,
            enext,
            rtan,
            ltan);
          rtan = out[0];
          ltan = out[1];
          break;
        case "MultiPolygon":
          var closestFeature = 0;
          var closestVertex = 0;
          var verticesCounted = 0;
          for (var i = 0; i < polyCoords[0].length; i++) {
            closestFeature = i;
            var verticeFound = false;
            for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {
              closestVertex = i2;
              if (verticesCounted === nearestPtIndex) {
                verticeFound = true;
                break;
              }
              verticesCounted++;
            }
            if (verticeFound) break;
          }
          rtan = polyCoords[0][closestFeature][closestVertex];
          ltan = polyCoords[0][closestFeature][closestVertex];
          eprev = isLeft(
            polyCoords[0][0][0],
            polyCoords[0][0][polyCoords[0][0].length - 1],
            pointCoords
          );
          polyCoords.forEach(function (ring) {
            var out = processPolygon$1(
              ring[0],
              pointCoords,
              eprev,
              enext,
              rtan,
              ltan);
            rtan = out[0];
            ltan = out[1];
          });
          break;
      }
      return featureCollection$1([point(rtan), point(ltan)]);
    }

    function processPolygon$1(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {
      for (var i = 0; i < polygonCoords.length; i++) {
        var currentCoords = polygonCoords[i];
        var nextCoordPair = polygonCoords[i + 1];
        if (i === polygonCoords.length - 1) {
          nextCoordPair = polygonCoords[0];
        }
        enext = isLeft(currentCoords, nextCoordPair, ptCoords);
        if (eprev <= 0 && enext > 0) {
          if (!isBelow(ptCoords, currentCoords, rtan)) {
            rtan = currentCoords;
          }
        } else if (eprev > 0 && enext <= 0) {
          if (!isAbove(ptCoords, currentCoords, ltan)) {
            ltan = currentCoords;
          }
        }
        eprev = enext;
      }
      return [rtan, ltan];
    }

    function isAbove(point1, point2, point3) {
      return isLeft(point1, point2, point3) > 0;
    }

    function isBelow(point1, point2, point3) {
      return isLeft(point1, point2, point3) < 0;
    }

    function isLeft(point1, point2, point3) {
      return (
        (point2[0] - point1[0]) * (point3[1] - point1[1]) -
        (point3[0] - point1[0]) * (point2[1] - point1[1])
      );
    }

    /**
     * Takes a ring and return true or false whether or not the ring is clockwise or counter-clockwise.
     *
     * @name booleanClockwise
     * @param {Feature<LineString>|LineString|Array<Array<number>>} line to be evaluated
     * @returns {boolean} true/false
     * @example
     * var clockwiseRing = turf.lineString([[0,0],[1,1],[1,0],[0,0]]);
     * var counterClockwiseRing = turf.lineString([[0,0],[1,0],[1,1],[0,0]]);
     *
     * turf.booleanClockwise(clockwiseRing)
     * //=true
     * turf.booleanClockwise(counterClockwiseRing)
     * //=false
     */
    function booleanClockwise(line) {
        var ring = getCoords(line);
        var sum = 0;
        var i = 1;
        var prev;
        var cur;
        while (i < ring.length) {
            prev = cur || ring[0];
            cur = ring[i];
            sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
            i++;
        }
        return sum > 0;
    }

    /**
     * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).
     *
     * @name rewind
     * @param {GeoJSON} geojson input GeoJSON Polygon
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.reverse=false] enable reverse winding
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} rewind Polygon
     * @example
     * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);
     *
     * var rewind = turf.rewind(polygon);
     *
     * //addToMap
     * var addToMap = [rewind];
     */
    function rewind(geojson, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var reverse = options.reverse || false;
      var mutate = options.mutate || false;

      // validation
      if (!geojson) throw new Error("<geojson> is required");
      if (typeof reverse !== "boolean")
        throw new Error("<reverse> must be a boolean");
      if (typeof mutate !== "boolean")
        throw new Error("<mutate> must be a boolean");

      // prevent input mutation
      if (mutate === false) geojson = clone(geojson);

      // Support Feature Collection or Geometry Collection
      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          geomEach$1(geojson, function (geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "FeatureCollection":
          featureEach$2(geojson, function (feature) {
            featureEach$2(rewindFeature(feature, reverse), function (result) {
              results.push(result);
            });
          });
          return featureCollection$1(results);
      }
      // Support Feature or Geometry Objects
      return rewindFeature(geojson, reverse);
    }

    /**
     * Rewind
     *
     * @private
     * @param {Geometry|Feature<any>} geojson Geometry or Feature
     * @param {Boolean} [reverse=false] enable reverse winding
     * @returns {Geometry|Feature<any>} rewind Geometry or Feature
     */
    function rewindFeature(geojson, reverse) {
      var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;

      // Support all GeoJSON Geometry Objects
      switch (type) {
        case "GeometryCollection":
          geomEach$1(geojson, function (geometry) {
            rewindFeature(geometry, reverse);
          });
          return geojson;
        case "LineString":
          rewindLineString(getCoords(geojson), reverse);
          return geojson;
        case "Polygon":
          rewindPolygon(getCoords(geojson), reverse);
          return geojson;
        case "MultiLineString":
          getCoords(geojson).forEach(function (lineCoords) {
            rewindLineString(lineCoords, reverse);
          });
          return geojson;
        case "MultiPolygon":
          getCoords(geojson).forEach(function (lineCoords) {
            rewindPolygon(lineCoords, reverse);
          });
          return geojson;
        case "Point":
        case "MultiPoint":
          return geojson;
      }
    }

    /**
     * Rewind LineString - outer ring clockwise
     *
     * @private
     * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates
     * @param {Boolean} [reverse=false] enable reverse winding
     * @returns {void} mutates coordinates
     */
    function rewindLineString(coords, reverse) {
      if (booleanClockwise(coords) === reverse) coords.reverse();
    }

    /**
     * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.
     *
     * @private
     * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates
     * @param {Boolean} [reverse=false] enable reverse winding
     * @returns {void} mutates coordinates
     */
    function rewindPolygon(coords, reverse) {
      // outer ring
      if (booleanClockwise(coords[0]) !== reverse) {
        coords[0].reverse();
      }
      // inner rings
      for (var i = 1; i < coords.length; i++) {
        if (booleanClockwise(coords[i]) === reverse) {
          coords[i].reverse();
        }
      }
    }

    /**
     * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}
     * of the 'property' values
     *
     * @name gridToMatrix
     * @param {FeatureCollection<Point>} grid of points
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
     * @param {boolean} [options.flip=false] returns the matrix upside-down
     * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,
     * the grid points with coordinates on the matrix
     * @returns {Array<Array<number>>} matrix of property values
     * @example
     *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
     *   var cellSize = 3;
     *   var grid = turf.pointGrid(extent, cellSize);
     *   // add a random property to each point between 0 and 60
     *   for (var i = 0; i < grid.features.length; i++) {
     *     grid.features[i].properties.elevation = (Math.random() * 60);
     *   }
     *   gridToMatrix(grid);
     *   //= [
     *     [ 1, 13, 10,  9, 10, 13, 18],
     *     [34,  8,  5,  4,  5,  8, 13],
     *     [10,  5,  2,  1,  2,  5,  4],
     *     [ 0,  4, 56, 19,  1,  4,  9],
     *     [10,  5,  2,  1,  2,  5, 10],
     *     [57,  8,  5,  4,  5,  0, 57],
     *     [ 3, 13, 10,  9,  5, 13, 18],
     *     [18, 13, 10,  9, 78, 13, 18]
     *   ]
     */
    function gridToMatrix(grid, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var flip = options.flip;
      var flags = options.flags;

      // validation
      collectionOf(grid, "Point", "input must contain Points");

      var pointsMatrix = sortPointsByLatLng(grid, flip);

      var matrix = [];
      // create property matrix from sorted points
      // looping order matters here
      for (var r = 0; r < pointsMatrix.length; r++) {
        var pointRow = pointsMatrix[r];
        var row = [];
        for (var c = 0; c < pointRow.length; c++) {
          var point = pointRow[c];
          // Check if zProperty exist
          if (point.properties[zProperty]) row.push(point.properties[zProperty]);
          else row.push(0);
          // add flags
          if (flags === true) point.properties.matrixPosition = [r, c];
        }
        matrix.push(row);
      }

      return matrix;
    }

    /**
     * Sorts points by latitude and longitude, creating a 2-dimensional array of points
     *
     * @private
     * @param {FeatureCollection<Point>} points GeoJSON Point features
     * @param {boolean} [flip=false] returns the matrix upside-down
     * @returns {Array<Array<Point>>} points ordered by latitude and longitude
     */
    function sortPointsByLatLng(points, flip) {
      var pointsByLatitude = {};

      // divide points by rows with the same latitude
      featureEach$2(points, function (point) {
        var lat = getCoords(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
      });

      // sort points (with the same latitude) by longitude
      var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function (a, b) {
          return getCoords(a)[0] - getCoords(b)[0];
        });
        return rowOrderedByLongitude;
      });

      // sort rows (of points with the same latitude) by latitude
      var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {
        if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];
        else return getCoords(b[0])[1] - getCoords(a[0])[1];
      });

      return pointMatrix;
    }

    /*!
     * @license GNU Affero General Public License.
     * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
     * v. 1.2.0
     * https://github.com/RaumZeit/MarchingSquares.js
     *
     * MarchingSquaresJS is free software: you can redistribute it and/or modify
     * it under the terms of the GNU Affero General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * MarchingSquaresJS is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU Affero General Public License for more details.
     *
     * As additional permission under GNU Affero General Public License version 3
     * section 7, third-party projects (personal or commercial) may distribute,
     * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
     * requirement that said third-party project for that reason alone becomes
     * subject to any requirement of the GNU Affero General Public License version 3.
     * Any modifications to MarchingSquaresJS, however, must be shared with the public
     * and made available.
     *
     * In summary this:
     * - allows you to use MarchingSquaresJS at no cost
     * - allows you to use MarchingSquaresJS for both personal and commercial purposes
     * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
     *   license as long as this license notice is included
     * - enables you to keep the source code of your program that uses MarchingSquaresJS
     *   undisclosed
     * - forces you to share any modifications you have made to MarchingSquaresJS,
     *   e.g. bug-fixes
     *
     * You should have received a copy of the GNU Affero General Public License
     * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
     */
    var defaultSettings = {
      successCallback: null,
      verbose: false,
      polygons: false,
    };

    var settings = {};

    /*
      Compute isobands(s) of a scalar 2D field given a certain
      threshold and a bandwidth by applying the Marching Squares
      Algorithm. The function returns a list of path coordinates
      either for individual polygons within each grid cell, or the
      outline of connected polygons.
    */
    function isoBands(data, minV, bandwidth, options) {
      /* process options */
      options = options ? options : {};

      var optionKeys = Object.keys(defaultSettings);

      for (var i = 0; i < optionKeys.length; i++) {
        var key = optionKeys[i];
        var val = options[key];
        val =
          typeof val !== "undefined" && val !== null ? val : defaultSettings[key];

        settings[key] = val;
      }

      if (settings.verbose)
        console.log(
          "MarchingSquaresJS-isoBands: computing isobands for [" +
            minV +
            ":" +
            (minV + bandwidth) +
            "]"
        );

      var grid = computeBandGrid(data, minV, bandwidth);

      var ret;
      if (settings.polygons) {
        if (settings.verbose)
          console.log(
            "MarchingSquaresJS-isoBands: returning single polygons for each grid cell"
          );
        ret = BandGrid2Areas(grid);
      } else {
        if (settings.verbose)
          console.log(
            "MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"
          );
        ret = BandGrid2AreaPaths(grid);
      }

      if (typeof settings.successCallback === "function")
        settings.successCallback(ret);

      return ret;
    }

    /*
      Thats all for the public interface, below follows the actual
      implementation
    */

    /* Some private variables */
    var Node0 = 64,
      Node1 = 16,
      Node2 = 4,
      Node3 = 1;

    /*
      The look-up tables for tracing back the contour path
      of isoBands
    */

    var isoBandNextXTL = [];
    var isoBandNextYTL = [];
    var isoBandNextOTL = [];

    var isoBandNextXTR = [];
    var isoBandNextYTR = [];
    var isoBandNextOTR = [];

    var isoBandNextXRT = [];
    var isoBandNextYRT = [];
    var isoBandNextORT = [];

    var isoBandNextXRB = [];
    var isoBandNextYRB = [];
    var isoBandNextORB = [];

    var isoBandNextXBL = [];
    var isoBandNextYBL = [];
    var isoBandNextOBL = [];

    var isoBandNextXBR = [];
    var isoBandNextYBR = [];
    var isoBandNextOBR = [];

    var isoBandNextXLT = [];
    var isoBandNextYLT = [];
    var isoBandNextOLT = [];

    var isoBandNextXLB = [];
    var isoBandNextYLB = [];
    var isoBandNextOLB = [];

    isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
    isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
    isoBandNextORT[85] = isoBandNextORB[85] = 1;
    isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
    isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
    isoBandNextOLT[85] = isoBandNextOLB[85] = 1;

    isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
    isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
    isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
    isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
    isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
    isoBandNextOTR[85] = isoBandNextOBR[85] = 1;

    /* triangle cases */
    isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
    isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
    isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
    isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
    isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
    isoBandNextOBL[1] = isoBandNextOBL[169] = 0;

    isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
    isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
    isoBandNextORB[4] = isoBandNextORB[166] = 1;
    isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
    isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
    isoBandNextOBR[4] = isoBandNextOBR[166] = 0;

    isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
    isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
    isoBandNextORT[16] = isoBandNextORT[154] = 1;
    isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
    isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
    isoBandNextOTR[16] = isoBandNextOTR[154] = 1;

    isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
    isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
    isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
    isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
    isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
    isoBandNextOTL[64] = isoBandNextOTL[106] = 1;

    /* single trapezoid cases */
    isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
    isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
    isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
    isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
    isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
    isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
    isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
    isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
    isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
    isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
    isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
    isoBandNextOBR[2] = isoBandNextOBR[168] = 1;

    isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
    isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
    isoBandNextORT[8] = isoBandNextORT[162] = 0;
    isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
    isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
    isoBandNextORB[8] = isoBandNextORB[162] = 1;
    isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
    isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
    isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
    isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
    isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
    isoBandNextOBR[8] = isoBandNextOBR[162] = 0;

    isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
    isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
    isoBandNextORT[32] = isoBandNextORT[138] = 1;
    isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
    isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
    isoBandNextORB[32] = isoBandNextORB[138] = 0;
    isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
    isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
    isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
    isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
    isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
    isoBandNextOTR[32] = isoBandNextOTR[138] = 1;

    isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
    isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
    isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
    isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
    isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
    isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
    isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
    isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
    isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
    isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
    isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
    isoBandNextOTR[128] = isoBandNextOTR[42] = 0;

    /* single rectangle cases */
    isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
    isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
    isoBandNextORB[5] = isoBandNextORB[165] = 0;
    isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
    isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
    isoBandNextOLB[5] = isoBandNextOLB[165] = 0;

    isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
    isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
    isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
    isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
    isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
    isoBandNextOTR[20] = isoBandNextOTR[150] = 1;

    isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
    isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
    isoBandNextORT[80] = isoBandNextORT[90] = 1;
    isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
    isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
    isoBandNextOLT[80] = isoBandNextOLT[90] = 1;

    isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
    isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
    isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
    isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
    isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
    isoBandNextOTL[65] = isoBandNextOTL[105] = 0;

    isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
    isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
    isoBandNextORT[160] = isoBandNextORT[10] = 1;
    isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
    isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
    isoBandNextORB[160] = isoBandNextORB[10] = 0;
    isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
    isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
    isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
    isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
    isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
    isoBandNextOLT[160] = isoBandNextOLT[10] = 1;

    isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
    isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
    isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
    isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
    isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
    isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
    isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
    isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
    isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
    isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
    isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
    isoBandNextOTR[130] = isoBandNextOTR[40] = 1;

    /* single hexagon cases */
    isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
    isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
    isoBandNextORB[37] = isoBandNextORB[133] = 1;
    isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
    isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
    isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
    isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
    isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
    isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
    isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
    isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
    isoBandNextOTR[37] = isoBandNextOTR[133] = 0;

    isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
    isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
    isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
    isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
    isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
    isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
    isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
    isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
    isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
    isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
    isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
    isoBandNextOTR[148] = isoBandNextOTR[22] = 1;

    isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
    isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
    isoBandNextORT[82] = isoBandNextORT[88] = 1;
    isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
    isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
    isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
    isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
    isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
    isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
    isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
    isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
    isoBandNextOLT[82] = isoBandNextOLT[88] = 0;

    isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
    isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
    isoBandNextORT[73] = isoBandNextORT[97] = 0;
    isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
    isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
    isoBandNextORB[73] = isoBandNextORB[97] = 0;
    isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
    isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
    isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
    isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
    isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
    isoBandNextOTL[73] = isoBandNextOTL[97] = 1;

    isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
    isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
    isoBandNextORT[145] = isoBandNextORT[25] = 0;
    isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
    isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
    isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
    isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
    isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
    isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
    isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
    isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
    isoBandNextOTR[145] = isoBandNextOTR[25] = 0;

    isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
    isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
    isoBandNextORB[70] = isoBandNextORB[100] = 0;
    isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
    isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
    isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
    isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
    isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
    isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
    isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
    isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
    isoBandNextOTL[70] = isoBandNextOTL[100] = 0;

    /* single pentagon cases */
    isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
    isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
    isoBandNextORB[101] = isoBandNextORB[69] = 0;
    isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
    isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
    isoBandNextOTL[101] = isoBandNextOTL[69] = 0;

    isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
    isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
    isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
    isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
    isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
    isoBandNextOTR[149] = isoBandNextOTR[21] = 0;

    isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
    isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
    isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
    isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
    isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
    isoBandNextOLT[86] = isoBandNextOLT[84] = 1;

    isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
    isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
    isoBandNextORT[89] = isoBandNextORT[81] = 0;
    isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
    isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
    isoBandNextOBL[89] = isoBandNextOBL[81] = 1;

    isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
    isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
    isoBandNextORT[96] = isoBandNextORT[74] = 0;
    isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
    isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
    isoBandNextORB[96] = isoBandNextORB[74] = 1;
    isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
    isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
    isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
    isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
    isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
    isoBandNextOTL[96] = isoBandNextOTL[74] = 1;

    isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
    isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
    isoBandNextORT[24] = isoBandNextORT[146] = 1;
    isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
    isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
    isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
    isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
    isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
    isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
    isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
    isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
    isoBandNextOTR[24] = isoBandNextOTR[146] = 0;

    isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
    isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
    isoBandNextORB[6] = isoBandNextORB[164] = 1;
    isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
    isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
    isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
    isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
    isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
    isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
    isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
    isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
    isoBandNextOLT[6] = isoBandNextOLT[164] = 0;

    isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
    isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
    isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
    isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
    isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
    isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
    isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
    isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
    isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
    isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
    isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
    isoBandNextOTR[129] = isoBandNextOTR[41] = 0;

    isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
    isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
    isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
    isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
    isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
    isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
    isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
    isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
    isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
    isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
    isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
    isoBandNextOTL[66] = isoBandNextOTL[104] = 1;

    isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
    isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
    isoBandNextORT[144] = isoBandNextORT[26] = 0;
    isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
    isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
    isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
    isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
    isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
    isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
    isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
    isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
    isoBandNextOTR[144] = isoBandNextOTR[26] = 1;

    isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
    isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
    isoBandNextORB[36] = isoBandNextORB[134] = 1;
    isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
    isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
    isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
    isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
    isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
    isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
    isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
    isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
    isoBandNextOTR[36] = isoBandNextOTR[134] = 0;

    isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
    isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
    isoBandNextORT[9] = isoBandNextORT[161] = 0;
    isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
    isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
    isoBandNextORB[9] = isoBandNextORB[161] = 0;
    isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
    isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
    isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
    isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
    isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
    isoBandNextOLB[9] = isoBandNextOLB[161] = 1;

    /* 8-sided cases */
    isoBandNextXRT[136] = 0;
    isoBandNextYRT[136] = 1;
    isoBandNextORT[136] = 1;
    isoBandNextXRB[136] = 0;
    isoBandNextYRB[136] = 1;
    isoBandNextORB[136] = 0;
    isoBandNextXBR[136] = -1;
    isoBandNextYBR[136] = 0;
    isoBandNextOBR[136] = 1;
    isoBandNextXBL[136] = -1;
    isoBandNextYBL[136] = 0;
    isoBandNextOBL[136] = 0;
    isoBandNextXLB[136] = 0;
    isoBandNextYLB[136] = -1;
    isoBandNextOLB[136] = 0;
    isoBandNextXLT[136] = 0;
    isoBandNextYLT[136] = -1;
    isoBandNextOLT[136] = 1;
    isoBandNextXTL[136] = 1;
    isoBandNextYTL[136] = 0;
    isoBandNextOTL[136] = 0;
    isoBandNextXTR[136] = 1;
    isoBandNextYTR[136] = 0;
    isoBandNextOTR[136] = 1;

    isoBandNextXRT[34] = 0;
    isoBandNextYRT[34] = -1;
    isoBandNextORT[34] = 0;
    isoBandNextXRB[34] = 0;
    isoBandNextYRB[34] = -1;
    isoBandNextORB[34] = 1;
    isoBandNextXBR[34] = 1;
    isoBandNextYBR[34] = 0;
    isoBandNextOBR[34] = 0;
    isoBandNextXBL[34] = 1;
    isoBandNextYBL[34] = 0;
    isoBandNextOBL[34] = 1;
    isoBandNextXLB[34] = 0;
    isoBandNextYLB[34] = 1;
    isoBandNextOLB[34] = 1;
    isoBandNextXLT[34] = 0;
    isoBandNextYLT[34] = 1;
    isoBandNextOLT[34] = 0;
    isoBandNextXTL[34] = -1;
    isoBandNextYTL[34] = 0;
    isoBandNextOTL[34] = 1;
    isoBandNextXTR[34] = -1;
    isoBandNextYTR[34] = 0;
    isoBandNextOTR[34] = 0;

    isoBandNextXRT[35] = 0;
    isoBandNextYRT[35] = 1;
    isoBandNextORT[35] = 1;
    isoBandNextXRB[35] = 0;
    isoBandNextYRB[35] = -1;
    isoBandNextORB[35] = 1;
    isoBandNextXBR[35] = 1;
    isoBandNextYBR[35] = 0;
    isoBandNextOBR[35] = 0;
    isoBandNextXBL[35] = -1;
    isoBandNextYBL[35] = 0;
    isoBandNextOBL[35] = 0;
    isoBandNextXLB[35] = 0;
    isoBandNextYLB[35] = -1;
    isoBandNextOLB[35] = 0;
    isoBandNextXLT[35] = 0;
    isoBandNextYLT[35] = 1;
    isoBandNextOLT[35] = 0;
    isoBandNextXTL[35] = -1;
    isoBandNextYTL[35] = 0;
    isoBandNextOTL[35] = 1;
    isoBandNextXTR[35] = 1;
    isoBandNextYTR[35] = 0;
    isoBandNextOTR[35] = 1;

    /* 6-sided cases */
    isoBandNextXRT[153] = 0;
    isoBandNextYRT[153] = 1;
    isoBandNextORT[153] = 1;
    isoBandNextXBL[153] = -1;
    isoBandNextYBL[153] = 0;
    isoBandNextOBL[153] = 0;
    isoBandNextXLB[153] = 0;
    isoBandNextYLB[153] = -1;
    isoBandNextOLB[153] = 0;
    isoBandNextXTR[153] = 1;
    isoBandNextYTR[153] = 0;
    isoBandNextOTR[153] = 1;

    isoBandNextXRB[102] = 0;
    isoBandNextYRB[102] = -1;
    isoBandNextORB[102] = 1;
    isoBandNextXBR[102] = 1;
    isoBandNextYBR[102] = 0;
    isoBandNextOBR[102] = 0;
    isoBandNextXLT[102] = 0;
    isoBandNextYLT[102] = 1;
    isoBandNextOLT[102] = 0;
    isoBandNextXTL[102] = -1;
    isoBandNextYTL[102] = 0;
    isoBandNextOTL[102] = 1;

    isoBandNextXRT[155] = 0;
    isoBandNextYRT[155] = -1;
    isoBandNextORT[155] = 0;
    isoBandNextXBL[155] = 1;
    isoBandNextYBL[155] = 0;
    isoBandNextOBL[155] = 1;
    isoBandNextXLB[155] = 0;
    isoBandNextYLB[155] = 1;
    isoBandNextOLB[155] = 1;
    isoBandNextXTR[155] = -1;
    isoBandNextYTR[155] = 0;
    isoBandNextOTR[155] = 0;

    isoBandNextXRB[103] = 0;
    isoBandNextYRB[103] = 1;
    isoBandNextORB[103] = 0;
    isoBandNextXBR[103] = -1;
    isoBandNextYBR[103] = 0;
    isoBandNextOBR[103] = 1;
    isoBandNextXLT[103] = 0;
    isoBandNextYLT[103] = -1;
    isoBandNextOLT[103] = 1;
    isoBandNextXTL[103] = 1;
    isoBandNextYTL[103] = 0;
    isoBandNextOTL[103] = 0;

    /* 7-sided cases */
    isoBandNextXRT[152] = 0;
    isoBandNextYRT[152] = 1;
    isoBandNextORT[152] = 1;
    isoBandNextXBR[152] = -1;
    isoBandNextYBR[152] = 0;
    isoBandNextOBR[152] = 1;
    isoBandNextXBL[152] = -1;
    isoBandNextYBL[152] = 0;
    isoBandNextOBL[152] = 0;
    isoBandNextXLB[152] = 0;
    isoBandNextYLB[152] = -1;
    isoBandNextOLB[152] = 0;
    isoBandNextXLT[152] = 0;
    isoBandNextYLT[152] = -1;
    isoBandNextOLT[152] = 1;
    isoBandNextXTR[152] = 1;
    isoBandNextYTR[152] = 0;
    isoBandNextOTR[152] = 1;

    isoBandNextXRT[156] = 0;
    isoBandNextYRT[156] = -1;
    isoBandNextORT[156] = 1;
    isoBandNextXBR[156] = 1;
    isoBandNextYBR[156] = 0;
    isoBandNextOBR[156] = 1;
    isoBandNextXBL[156] = -1;
    isoBandNextYBL[156] = 0;
    isoBandNextOBL[156] = 0;
    isoBandNextXLB[156] = 0;
    isoBandNextYLB[156] = -1;
    isoBandNextOLB[156] = 0;
    isoBandNextXLT[156] = 0;
    isoBandNextYLT[156] = 1;
    isoBandNextOLT[156] = 1;
    isoBandNextXTR[156] = -1;
    isoBandNextYTR[156] = 0;
    isoBandNextOTR[156] = 1;

    isoBandNextXRT[137] = 0;
    isoBandNextYRT[137] = 1;
    isoBandNextORT[137] = 1;
    isoBandNextXRB[137] = 0;
    isoBandNextYRB[137] = 1;
    isoBandNextORB[137] = 0;
    isoBandNextXBL[137] = -1;
    isoBandNextYBL[137] = 0;
    isoBandNextOBL[137] = 0;
    isoBandNextXLB[137] = 0;
    isoBandNextYLB[137] = -1;
    isoBandNextOLB[137] = 0;
    isoBandNextXTL[137] = 1;
    isoBandNextYTL[137] = 0;
    isoBandNextOTL[137] = 0;
    isoBandNextXTR[137] = 1;
    isoBandNextYTR[137] = 0;
    isoBandNextOTR[137] = 1;

    isoBandNextXRT[139] = 0;
    isoBandNextYRT[139] = 1;
    isoBandNextORT[139] = 1;
    isoBandNextXRB[139] = 0;
    isoBandNextYRB[139] = -1;
    isoBandNextORB[139] = 0;
    isoBandNextXBL[139] = 1;
    isoBandNextYBL[139] = 0;
    isoBandNextOBL[139] = 0;
    isoBandNextXLB[139] = 0;
    isoBandNextYLB[139] = 1;
    isoBandNextOLB[139] = 0;
    isoBandNextXTL[139] = -1;
    isoBandNextYTL[139] = 0;
    isoBandNextOTL[139] = 0;
    isoBandNextXTR[139] = 1;
    isoBandNextYTR[139] = 0;
    isoBandNextOTR[139] = 1;

    isoBandNextXRT[98] = 0;
    isoBandNextYRT[98] = -1;
    isoBandNextORT[98] = 0;
    isoBandNextXRB[98] = 0;
    isoBandNextYRB[98] = -1;
    isoBandNextORB[98] = 1;
    isoBandNextXBR[98] = 1;
    isoBandNextYBR[98] = 0;
    isoBandNextOBR[98] = 0;
    isoBandNextXBL[98] = 1;
    isoBandNextYBL[98] = 0;
    isoBandNextOBL[98] = 1;
    isoBandNextXLT[98] = 0;
    isoBandNextYLT[98] = 1;
    isoBandNextOLT[98] = 0;
    isoBandNextXTL[98] = -1;
    isoBandNextYTL[98] = 0;
    isoBandNextOTL[98] = 1;

    isoBandNextXRT[99] = 0;
    isoBandNextYRT[99] = 1;
    isoBandNextORT[99] = 0;
    isoBandNextXRB[99] = 0;
    isoBandNextYRB[99] = -1;
    isoBandNextORB[99] = 1;
    isoBandNextXBR[99] = 1;
    isoBandNextYBR[99] = 0;
    isoBandNextOBR[99] = 0;
    isoBandNextXBL[99] = -1;
    isoBandNextYBL[99] = 0;
    isoBandNextOBL[99] = 1;
    isoBandNextXLT[99] = 0;
    isoBandNextYLT[99] = -1;
    isoBandNextOLT[99] = 0;
    isoBandNextXTL[99] = 1;
    isoBandNextYTL[99] = 0;
    isoBandNextOTL[99] = 1;

    isoBandNextXRB[38] = 0;
    isoBandNextYRB[38] = -1;
    isoBandNextORB[38] = 1;
    isoBandNextXBR[38] = 1;
    isoBandNextYBR[38] = 0;
    isoBandNextOBR[38] = 0;
    isoBandNextXLB[38] = 0;
    isoBandNextYLB[38] = 1;
    isoBandNextOLB[38] = 1;
    isoBandNextXLT[38] = 0;
    isoBandNextYLT[38] = 1;
    isoBandNextOLT[38] = 0;
    isoBandNextXTL[38] = -1;
    isoBandNextYTL[38] = 0;
    isoBandNextOTL[38] = 1;
    isoBandNextXTR[38] = -1;
    isoBandNextYTR[38] = 0;
    isoBandNextOTR[38] = 0;

    isoBandNextXRB[39] = 0;
    isoBandNextYRB[39] = 1;
    isoBandNextORB[39] = 1;
    isoBandNextXBR[39] = -1;
    isoBandNextYBR[39] = 0;
    isoBandNextOBR[39] = 0;
    isoBandNextXLB[39] = 0;
    isoBandNextYLB[39] = -1;
    isoBandNextOLB[39] = 1;
    isoBandNextXLT[39] = 0;
    isoBandNextYLT[39] = 1;
    isoBandNextOLT[39] = 0;
    isoBandNextXTL[39] = -1;
    isoBandNextYTL[39] = 0;
    isoBandNextOTL[39] = 1;
    isoBandNextXTR[39] = 1;
    isoBandNextYTR[39] = 0;
    isoBandNextOTR[39] = 0;

    /*
      Define helper functions for the polygon_table
      */

    /* triangle cases */
    var p00 = function (cell) {
      return [
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
      ];
    };
    var p01 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
      ];
    };
    var p02 = function (cell) {
      return [
        [cell.topright, 1],
        [1, 1],
        [1, cell.righttop],
      ];
    };
    var p03 = function (cell) {
      return [
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* trapezoid cases */
    var p04 = function (cell) {
      return [
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
      ];
    };
    var p05 = function (cell) {
      return [
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [1, cell.righttop],
        [1, cell.rightbottom],
      ];
    };
    var p06 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    var p07 = function (cell) {
      return [
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    /* rectangle cases */
    var p08 = function (cell) {
      return [
        [0, 0],
        [0, cell.leftbottom],
        [1, cell.rightbottom],
        [1, 0],
      ];
    };
    var p09 = function (cell) {
      return [
        [1, 0],
        [cell.bottomright, 0],
        [cell.topright, 1],
        [1, 1],
      ];
    };
    var p10 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [0, cell.lefttop],
        [0, 1],
      ];
    };
    var p11 = function (cell) {
      return [
        [cell.bottomleft, 0],
        [0, 0],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    var p12 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [0, cell.leftbottom],
        [0, cell.lefttop],
      ];
    };
    var p13 = function (cell) {
      return [
        [cell.topleft, 1],
        [cell.topright, 1],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
      ];
    };
    /* square case */
    var p14 = function () {
      return [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0],
      ];
    };
    /* pentagon cases */
    var p15 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [0, 0],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1211 || 1011 */
    var p16 = function (cell) {
      return [
        [cell.topright, 1],
        [1, 1],
        [1, 0],
        [0, 0],
        [0, cell.leftbottom],
      ];
    };
    /* 2111 || 0111 */
    var p17 = function (cell) {
      return [
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.lefttop],
        [0, 1],
        [1, 1],
      ];
    };
    /* 1112 || 1110 */
    var p18 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomleft, 0],
        [0, 0],
        [0, 1],
      ];
    };
    /* 1121 || 1101 */
    var p19 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1200 || 1022 */
    var p20 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [cell.topright, 1],
      ];
    };
    /* 0120 || 2102 */
    var p21 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
      ];
    };
    /* 0012 || 2210 */
    var p22 = function (cell) {
      return [
        [cell.topright, 1],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topleft, 1],
      ];
    };
    /* 2001 || 0221 */
    var p23 = function (cell) {
      return [
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1002 || 1220 */
    var p24 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topright, 1],
      ];
    };
    /* 2100 || 0122 */
    var p25 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    /* 0210 || 2012 */
    var p26 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
      ];
    };
    /* 0021 || 2201 */
    /*hexagon cases */
    var p27 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    /* 0211 || 2011 */
    var p28 = function (cell) {
      return [
        [1, 1],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topright, 1],
      ];
    };
    /* 2110 || 0112 */
    var p29 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.lefttop],
        [0, 1],
      ];
    };
    /* 1102 || 1120 */
    var p30 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomleft, 0],
        [0, 0],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1021 || 1201 */
    var p31 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topright, 1],
      ];
    };
    /* 2101 || 0121 */
    var p32 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1012 || 1210 */
    /* 8-sided cases */
    var p33 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    /* flipped == 1 state for 0202 and 2020 */
    /* 6-sided cases */
    var p34 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topright, 1],
      ];
    };
    /* 0101 with flipped == 1 || 2121 with flipped == 1 */
    var p35 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1010 with flipped == 1 || 1212 with flipped == 1 */
    /* 7-sided cases */
    var p36 = function (cell) {
      return [
        [1, 1],
        [1, cell.righttop],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topright, 1],
      ];
    };
    /* 2120 with flipped == 1 || 0102 with flipped == 1 */
    var p37 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomleft, 0],
        [0, 0],
        [0, cell.leftbottom],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    /* 2021 with flipped == 1 || 0201 with flipped == 1 */
    var p38 = function (cell) {
      return [
        [1, cell.righttop],
        [1, cell.rightbottom],
        [cell.bottomright, 0],
        [cell.bottomleft, 0],
        [0, cell.lefttop],
        [0, 1],
        [cell.topleft, 1],
      ];
    };
    /* 1202 with flipped == 1 || 1020 with flipped == 1 */
    var p39 = function (cell) {
      return [
        [1, cell.rightbottom],
        [1, 0],
        [cell.bottomright, 0],
        [0, cell.leftbottom],
        [0, cell.lefttop],
        [cell.topleft, 1],
        [cell.topright, 1],
      ];
    };
    /* 0212 with flipped == 1 || 2010 with flipped == 1 */

    /*
      The lookup tables for edge number given the polygon
      is entered at a specific location
    */

    var isoBandEdgeRT = [];
    var isoBandEdgeRB = [];
    var isoBandEdgeBR = [];
    var isoBandEdgeBL = [];
    var isoBandEdgeLB = [];
    var isoBandEdgeLT = [];
    var isoBandEdgeTL = [];
    var isoBandEdgeTR = [];

    /* triangle cases */
    isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
    isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
    isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
    isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
    isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
    isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
    isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
    isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;

    /* trapezoid cases */
    isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
    isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
    isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
    isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
    isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
    isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
    isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
    isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
    isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
    isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
    isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
    isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
    isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
    isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
    isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
    isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;

    /* rectangle cases */
    isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
    isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
    isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
    isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
    isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
    isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
    isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
    isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
    isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
    isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
    isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
    isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
    isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
    isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
    isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
    isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;

    /* pentagon cases */
    isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
    isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
    isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
    isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
    isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
    isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
    isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
    isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
    isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
    isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
    isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
    isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
    isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
    isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
    isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
    isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
    isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
    isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
    isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
    isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
    isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
    isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
    isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
    isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
    isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
    isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
    isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
    isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
    isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
    isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
    isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
    isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
    isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
    isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
    isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
    isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
    isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
    isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
    isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
    isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;

    /* hexagon cases */
    isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
    isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
    isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
    isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
    isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
    isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
    isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
    isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
    isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
    isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
    isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
    isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
    isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
    isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
    isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
    isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
    isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
    isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
    isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
    isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
    isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
    isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
    isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
    isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;

    /* 8-sided cases */
    isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
    isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
    isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
    isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
    isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
    isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
    isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
    isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
    isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
    isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
    isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
    isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;

    /* 6-sided cases */
    isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
    isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
    isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
    isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
    isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
    isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
    isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
    isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;

    /* 7-sided cases */
    isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
    isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
    isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
    isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
    isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
    isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
    isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
    isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
    isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
    isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
    isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
    isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
    isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
    isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
    isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
    isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
    isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
    isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
    isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
    isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
    isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
    isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
    isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
    isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;

    /*
      The lookup tables for all different polygons that
      may appear within a grid cell
    */

    var polygon_table = [];

    /* triangle cases */
    polygon_table[1] = polygon_table[169] = p00; /* 2221 || 0001 */
    polygon_table[4] = polygon_table[166] = p01; /* 2212 || 0010 */
    polygon_table[16] = polygon_table[154] = p02; /* 2122 || 0100 */
    polygon_table[64] = polygon_table[106] = p03; /* 1222 || 1000 */

    /* trapezoid cases */
    polygon_table[168] = polygon_table[2] = p04; /* 2220 || 0002 */
    polygon_table[162] = polygon_table[8] = p05; /* 2202 || 0020 */
    polygon_table[138] = polygon_table[32] = p06; /* 2022 || 0200 */
    polygon_table[42] = polygon_table[128] = p07; /* 0222 || 2000 */

    /* rectangle cases */
    polygon_table[5] = polygon_table[165] = p08; /* 0011 || 2211 */
    polygon_table[20] = polygon_table[150] = p09; /* 0110 || 2112 */
    polygon_table[80] = polygon_table[90] = p10; /* 1100 || 1122 */
    polygon_table[65] = polygon_table[105] = p11; /* 1001 || 1221 */
    polygon_table[160] = polygon_table[10] = p12; /* 2200 || 0022 */
    polygon_table[130] = polygon_table[40] = p13; /* 2002 || 0220 */

    /* square case */
    polygon_table[85] = p14; /* 1111 */

    /* pentagon cases */
    polygon_table[101] = polygon_table[69] = p15; /* 1211 || 1011 */
    polygon_table[149] = polygon_table[21] = p16; /* 2111 || 0111 */
    polygon_table[86] = polygon_table[84] = p17; /* 1112 || 1110 */
    polygon_table[89] = polygon_table[81] = p18; /* 1121 || 1101 */
    polygon_table[96] = polygon_table[74] = p19; /* 1200 || 1022 */
    polygon_table[24] = polygon_table[146] = p20; /* 0120 || 2102 */
    polygon_table[6] = polygon_table[164] = p21; /* 0012 || 2210 */
    polygon_table[129] = polygon_table[41] = p22; /* 2001 || 0221 */
    polygon_table[66] = polygon_table[104] = p23; /* 1002 || 1220 */
    polygon_table[144] = polygon_table[26] = p24; /* 2100 || 0122 */
    polygon_table[36] = polygon_table[134] = p25; /* 0210 || 2012 */
    polygon_table[9] = polygon_table[161] = p26; /* 0021 || 2201 */

    /* hexagon cases */
    polygon_table[37] = polygon_table[133] = p27; /* 0211 || 2011 */
    polygon_table[148] = polygon_table[22] = p28; /* 2110 || 0112 */
    polygon_table[82] = polygon_table[88] = p29; /* 1102 || 1120 */
    polygon_table[73] = polygon_table[97] = p30; /* 1021 || 1201 */
    polygon_table[145] = polygon_table[25] = p31; /* 2101 || 0121 */
    polygon_table[70] = polygon_table[100] = p32; /* 1012 || 1210 */

    /* 8-sided cases */
    polygon_table[34] = function (c) {
      return [p07(c), p05(c)];
    }; /* 0202 || 2020 with flipped == 0 */
    polygon_table[35] = p33; /* flipped == 1 state for 0202 and 2020 */
    polygon_table[136] = function (c) {
      return [p06(c), p04(c)];
    }; /* 2020 || 0202 with flipped == 0 */

    /* 6-sided cases */
    polygon_table[153] = function (c) {
      return [p02(c), p00(c)];
    }; /* 0101 with flipped == 0 || 2121 with flipped == 2 */
    polygon_table[102] = function (c) {
      return [p01(c), p03(c)];
    }; /* 1010 with flipped == 0 || 1212 with flipped == 2 */
    polygon_table[155] = p34; /* 0101 with flipped == 1 || 2121 with flipped == 1 */
    polygon_table[103] = p35; /* 1010 with flipped == 1 || 1212 with flipped == 1 */

    /* 7-sided cases */
    polygon_table[152] = function (c) {
      return [p02(c), p04(c)];
    }; /* 2120 with flipped == 2 || 0102 with flipped == 0 */
    polygon_table[156] = p36; /* 2120 with flipped == 1 || 0102 with flipped == 1 */
    polygon_table[137] = function (c) {
      return [p06(c), p00(c)];
    }; /* 2021 with flipped == 2 || 0201 with flipped == 0 */
    polygon_table[139] = p37; /* 2021 with flipped == 1 || 0201 with flipped == 1 */
    polygon_table[98] = function (c) {
      return [p05(c), p03(c)];
    }; /* 1202 with flipped == 2 || 1020 with flipped == 0 */
    polygon_table[99] = p38; /* 1202 with flipped == 1 || 1020 with flipped == 1 */
    polygon_table[38] = function (c) {
      return [p01(c), p07(c)];
    }; /* 0212 with flipped == 2 || 2010 with flipped == 0 */
    polygon_table[39] = p39; /* 0212 with flipped == 1 || 2010 with flipped == 1 */

    /*
    ####################################
    Some small helper functions
    ####################################
    */

    /* assume that x1 == 1 &&  x0 == 0 */
    function interpolateX(y, y0, y1) {
      return (y - y0) / (y1 - y0);
    }

    function isArray(myArray) {
      return myArray.constructor.toString().indexOf("Array") > -1;
    }

    /*
    ####################################
    Below is the actual Marching Squares implementation
    ####################################
    */

    function computeBandGrid(data, minV, bandwidth) {
      var rows = data.length - 1;
      var cols = data[0].length - 1;
      var BandGrid = { rows: rows, cols: cols, cells: [] };

      var maxV = minV + Math.abs(bandwidth);

      for (var j = 0; j < rows; ++j) {
        BandGrid.cells[j] = [];
        for (var i = 0; i < cols; ++i) {
          /*  compose the 4-trit corner representation */
          var cval = 0;

          var tl = data[j + 1][i];
          var tr = data[j + 1][i + 1];
          var br = data[j][i + 1];
          var bl = data[j][i];

          if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
            continue;
          }

          cval |= tl < minV ? 0 : tl > maxV ? 128 : 64;
          cval |= tr < minV ? 0 : tr > maxV ? 32 : 16;
          cval |= br < minV ? 0 : br > maxV ? 8 : 4;
          cval |= bl < minV ? 0 : bl > maxV ? 2 : 1;

          var cval_real = +cval;

          /* resolve ambiguity via averaging */
          var flipped = 0;
          if (
            cval === 17 /* 0101 */ ||
            cval === 18 /* 0102 */ ||
            cval === 33 /* 0201 */ ||
            cval === 34 /* 0202 */ ||
            cval === 38 /* 0212 */ ||
            cval === 68 /* 1010 */ ||
            cval === 72 /* 1020 */ ||
            cval === 98 /* 1202 */ ||
            cval === 102 /* 1212 */ ||
            cval === 132 /* 2010 */ ||
            cval === 136 /* 2020 */ ||
            cval === 137 /* 2021 */ ||
            cval === 152 /* 2120 */ ||
            cval === 153 /* 2121 */
          ) {
            var average = (tl + tr + br + bl) / 4;
            /* set flipped state */
            flipped = average > maxV ? 2 : average < minV ? 0 : 1;

            /* adjust cval for flipped cases */

            /* 8-sided cases */
            if (cval === 34) {
              if (flipped === 1) {
                cval = 35;
              } else if (flipped === 0) {
                cval = 136;
              }
            } else if (cval === 136) {
              if (flipped === 1) {
                cval = 35;
                flipped = 4;
              } else if (flipped === 0) {
                cval = 34;
              }
            } else if (cval === 17) {
              /* 6-sided polygon cases */
              if (flipped === 1) {
                cval = 155;
                flipped = 4;
              } else if (flipped === 0) {
                cval = 153;
              }
            } else if (cval === 68) {
              if (flipped === 1) {
                cval = 103;
                flipped = 4;
              } else if (flipped === 0) {
                cval = 102;
              }
            } else if (cval === 153) {
              if (flipped === 1) cval = 155;
            } else if (cval === 102) {
              if (flipped === 1) cval = 103;
            } else if (cval === 152) {
              /* 7-sided polygon cases */
              if (flipped < 2) {
                cval = 156;
                flipped = 1;
              }
            } else if (cval === 137) {
              if (flipped < 2) {
                cval = 139;
                flipped = 1;
              }
            } else if (cval === 98) {
              if (flipped < 2) {
                cval = 99;
                flipped = 1;
              }
            } else if (cval === 38) {
              if (flipped < 2) {
                cval = 39;
                flipped = 1;
              }
            } else if (cval === 18) {
              if (flipped > 0) {
                cval = 156;
                flipped = 4;
              } else {
                cval = 152;
              }
            } else if (cval === 33) {
              if (flipped > 0) {
                cval = 139;
                flipped = 4;
              } else {
                cval = 137;
              }
            } else if (cval === 72) {
              if (flipped > 0) {
                cval = 99;
                flipped = 4;
              } else {
                cval = 98;
              }
            } else if (cval === 132) {
              if (flipped > 0) {
                cval = 39;
                flipped = 4;
              } else {
                cval = 38;
              }
            }
          }

          /* add cell to BandGrid if it contains at least one polygon-side */
          if (cval != 0 && cval != 170) {
            var topleft,
              topright,
              bottomleft,
              bottomright,
              righttop,
              rightbottom,
              lefttop,
              leftbottom;

            topleft = topright = bottomleft = bottomright = righttop = rightbottom = lefttop = leftbottom = 0.5;

            var edges = [];

            /* do interpolation here */
            /* 1st Triangles */
            if (cval === 1) {
              /* 0001 */
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 169) {
              /* 2221 */
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 4) {
              /* 0010 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = interpolateX(minV, bl, br);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 166) {
              /* 2212 */
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = 1 - interpolateX(maxV, br, bl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 16) {
              /* 0100 */
              righttop = interpolateX(minV, br, tr);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 154) {
              /* 2122 */
              righttop = 1 - interpolateX(maxV, tr, br);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 64) {
              /* 1000 */
              lefttop = interpolateX(minV, bl, tl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 106) {
              /* 1222 */
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 168) {
              /* 2nd Trapezoids */
              /* 2220 */
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 2) {
              /* 0002 */
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 162) {
              /* 2202 */
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 8) {
              /* 0020 */
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 138) {
              /* 2022 */
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 32) {
              /* 0200 */
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 42) {
              /* 0222 */
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 128) {
              /* 2000 */
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            }

            /* 3rd rectangle cases */
            if (cval === 5) {
              /* 0011 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 165) {
              /* 2211 */
              rightbottom = interpolateX(maxV, br, tr);
              leftbottom = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 20) {
              /* 0110 */
              bottomright = interpolateX(minV, bl, br);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 150) {
              /* 2112 */
              bottomright = 1 - interpolateX(maxV, br, bl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 80) {
              /* 1100 */
              righttop = interpolateX(minV, br, tr);
              lefttop = interpolateX(minV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 90) {
              /* 1122 */
              righttop = 1 - interpolateX(maxV, tr, br);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
            } else if (cval === 65) {
              /* 1001 */
              bottomleft = 1 - interpolateX(minV, br, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 105) {
              /* 1221 */
              bottomleft = interpolateX(maxV, bl, br);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 160) {
              /* 2200 */
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 10) {
              /* 0022 */
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 130) {
              /* 2002 */
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 40) {
              /* 0220 */
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 101) {
              /* 4th single pentagon cases */
              /* 1211 */
              rightbottom = interpolateX(maxV, br, tr);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 69) {
              /* 1011 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 149) {
              /* 2111 */
              leftbottom = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 21) {
              /* 0111 */
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 86) {
              /* 1112 */
              bottomright = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 84) {
              /* 1110 */
              bottomright = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 89) {
              /* 1121 */
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 81) {
              /* 1101 */
              righttop = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 96) {
              /* 1200 */
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              lefttop = interpolateX(minV, bl, tl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 74) {
              /* 1022 */
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 24) {
              /* 0120 */
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 146) {
              /* 2102 */
              righttop = interpolateX(minV, br, tr);
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 6) {
              /* 0012 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = 1 - interpolateX(maxV, br, bl);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 164) {
              /* 2210 */
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = interpolateX(minV, bl, br);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 129) {
              /* 2001 */
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = interpolateX(maxV, bl, tl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 41) {
              /* 0221 */
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 66) {
              /* 1002 */
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 104) {
              /* 1220 */
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeTL[cval]);
            } else if (cval === 144) {
              /* 2100 */
              righttop = interpolateX(minV, br, tr);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 26) {
              /* 0122 */
              righttop = 1 - interpolateX(maxV, tr, br);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 36) {
              /* 0210 */
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = interpolateX(minV, bl, br);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 134) {
              /* 2012 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = 1 - interpolateX(maxV, br, bl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 9) {
              /* 0021 */
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 161) {
              /* 2201 */
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = interpolateX(maxV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 37) {
              /* 5th single hexagon cases */
              /* 0211 */
              rightbottom = interpolateX(maxV, br, tr);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topleft = interpolateX(minV, tl, tr);
              topright = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 133) {
              /* 2011 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              leftbottom = interpolateX(maxV, bl, tl);
              topleft = 1 - interpolateX(maxV, tr, tl);
              topright = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 148) {
              /* 2110 */
              bottomright = interpolateX(minV, bl, br);
              leftbottom = interpolateX(minV, bl, tl);
              lefttop = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 22) {
              /* 0112 */
              bottomright = 1 - interpolateX(maxV, br, bl);
              leftbottom = 1 - interpolateX(maxV, tl, bl);
              lefttop = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 82) {
              /* 1102 */
              righttop = interpolateX(minV, br, tr);
              bottomright = 1 - interpolateX(minV, br, bl);
              bottomleft = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 88) {
              /* 1120 */
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomright = interpolateX(maxV, bl, br);
              bottomleft = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 73) {
              /* 1021 */
              righttop = 1 - interpolateX(minV, tr, br);
              rightbottom = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 97) {
              /* 1201 */
              righttop = interpolateX(maxV, br, tr);
              rightbottom = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
            } else if (cval === 145) {
              /* 2101 */
              righttop = interpolateX(minV, br, tr);
              bottomleft = 1 - interpolateX(minV, br, bl);
              leftbottom = interpolateX(maxV, bl, tl);
              topright = 1 - interpolateX(maxV, tr, tl);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 25) {
              /* 0121 */
              righttop = 1 - interpolateX(maxV, tr, br);
              bottomleft = interpolateX(maxV, bl, br);
              leftbottom = 1 - interpolateX(minV, tl, bl);
              topright = interpolateX(minV, tl, tr);
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 70) {
              /* 1012 */
              rightbottom = 1 - interpolateX(minV, tr, br);
              bottomright = 1 - interpolateX(maxV, br, bl);
              lefttop = 1 - interpolateX(maxV, tl, bl);
              topleft = 1 - interpolateX(minV, tr, tl);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 100) {
              /* 1210 */
              rightbottom = interpolateX(maxV, br, tr);
              bottomright = interpolateX(minV, bl, br);
              lefttop = interpolateX(minV, bl, tl);
              topleft = interpolateX(maxV, tl, tr);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 34) {
              /* 8-sided cases */
              /* 0202 || 2020 with flipped == 0 */
              if (flipped === 0) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 35) {
              /* flipped == 1 state for 0202, and 2020 with flipped == 4*/
              if (flipped === 4) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 136) {
              /* 2020 || 0202 with flipped == 0 */
              if (flipped === 0) {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              } else {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 153) {
              /* 6-sided polygon cases */
              /* 0101 with flipped == 0 || 2121 with flipped == 2 */
              if (flipped === 0) {
                righttop = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 102) {
              /* 1010 with flipped == 0 || 1212 with flipped == 2 */
              if (flipped === 0) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 155) {
              /* 0101 with flipped == 4 || 2121 with flipped == 1 */
              if (flipped === 4) {
                righttop = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 103) {
              /* 1010 with flipped == 4 || 1212 with flipped == 1 */
              if (flipped === 4) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
            } else if (cval === 152) {
              /* 7-sided polygon cases */
              /* 2120 with flipped == 2 || 0102 with flipped == 0 */
              if (flipped === 0) {
                righttop = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 156) {
              /* 2120 with flipped == 1 || 0102 with flipped == 4 */
              if (flipped === 4) {
                righttop = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topright = interpolateX(minV, tl, tr);
              } else {
                righttop = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topright = 1 - interpolateX(maxV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeBL[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 137) {
              /* 2021 with flipped == 2 || 0201 with flipped == 0 */
              if (flipped === 0) {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              } else {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 139) {
              /* 2021 with flipped == 1 || 0201 with flipped == 4 */
              if (flipped === 4) {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomleft = 1 - interpolateX(minV, br, bl);
                leftbottom = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              } else {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomleft = interpolateX(maxV, bl, br);
                leftbottom = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
            } else if (cval === 98) {
              /* 1202 with flipped == 2 || 1020 with flipped == 0 */
              if (flipped === 0) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 99) {
              /* 1202 with flipped == 1 || 1020 with flipped == 4 */
              if (flipped === 4) {
                righttop = 1 - interpolateX(minV, tr, br);
                rightbottom = 1 - interpolateX(maxV, tr, br);
                bottomright = interpolateX(maxV, bl, br);
                bottomleft = interpolateX(minV, bl, br);
                lefttop = interpolateX(minV, bl, tl);
                topleft = 1 - interpolateX(minV, tr, tl);
              } else {
                righttop = interpolateX(maxV, br, tr);
                rightbottom = interpolateX(minV, br, tr);
                bottomright = 1 - interpolateX(minV, br, bl);
                bottomleft = 1 - interpolateX(maxV, br, bl);
                lefttop = 1 - interpolateX(maxV, tl, bl);
                topleft = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRT[cval]);
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBL[cval]);
            } else if (cval === 38) {
              /* 0212 with flipped == 2 || 2010 with flipped == 0 */
              if (flipped === 0) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeLB[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 39) {
              /* 0212 with flipped == 1 || 2010 with flipped == 4 */
              if (flipped === 4) {
                rightbottom = 1 - interpolateX(minV, tr, br);
                bottomright = interpolateX(minV, bl, br);
                leftbottom = interpolateX(minV, bl, tl);
                lefttop = interpolateX(maxV, bl, tl);
                topleft = 1 - interpolateX(maxV, tr, tl);
                topright = 1 - interpolateX(minV, tr, tl);
              } else {
                rightbottom = interpolateX(maxV, br, tr);
                bottomright = 1 - interpolateX(maxV, br, bl);
                leftbottom = 1 - interpolateX(maxV, tl, bl);
                lefttop = 1 - interpolateX(minV, tl, bl);
                topleft = interpolateX(minV, tl, tr);
                topright = interpolateX(maxV, tl, tr);
              }
              edges.push(isoBandEdgeRB[cval]);
              edges.push(isoBandEdgeBR[cval]);
              edges.push(isoBandEdgeLT[cval]);
            } else if (cval === 85) {
              righttop = 1;
              rightbottom = 0;
              bottomright = 1;
              bottomleft = 0;
              leftbottom = 0;
              lefttop = 1;
              topleft = 0;
              topright = 1;
            }

            if (
              topleft < 0 ||
              topleft > 1 ||
              topright < 0 ||
              topright > 1 ||
              righttop < 0 ||
              righttop > 1 ||
              bottomright < 0 ||
              bottomright > 1 ||
              leftbottom < 0 ||
              leftbottom > 1 ||
              lefttop < 0 ||
              lefttop > 1
            ) {
              console.log(
                "MarchingSquaresJS-isoBands: " +
                  cval +
                  " " +
                  cval_real +
                  " " +
                  tl +
                  "," +
                  tr +
                  "," +
                  br +
                  "," +
                  bl +
                  " " +
                  flipped +
                  " " +
                  topleft +
                  " " +
                  topright +
                  " " +
                  righttop +
                  " " +
                  rightbottom +
                  " " +
                  bottomright +
                  " " +
                  bottomleft +
                  " " +
                  leftbottom +
                  " " +
                  lefttop
              );
            }

            BandGrid.cells[j][i] = {
              cval: cval,
              cval_real: cval_real,
              flipped: flipped,
              topleft: topleft,
              topright: topright,
              righttop: righttop,
              rightbottom: rightbottom,
              bottomright: bottomright,
              bottomleft: bottomleft,
              leftbottom: leftbottom,
              lefttop: lefttop,
              edges: edges,
            };
          }
        }
      }

      return BandGrid;
    }

    function BandGrid2AreaPaths(grid) {
      var areas = [];
      var rows = grid.rows;
      var cols = grid.cols;
      var currentPolygon = [];

      for (var j = 0; j < rows; j++) {
        for (var i = 0; i < cols; i++) {
          if (
            typeof grid.cells[j][i] !== "undefined" &&
            grid.cells[j][i].edges.length > 0
          ) {
            /* trace back polygon path starting from this cell */

            var cell = grid.cells[j][i];

            /* get start coordinates */

            var prev = getStartXY(cell),
              next = null,
              p = i,
              q = j;

            if (prev !== null) {
              currentPolygon.push([prev.p[0] + p, prev.p[1] + q]);
              //console.log(cell);
              //console.log("coords: " + (prev.p[0] + p) + " " + (prev.p[1] + q));
            }

            do {
              //console.log(p + "," + q);
              //console.log(grid.cells[q][p]);
              //console.log(grid.cells[q][p].edges);
              //console.log("from : " + prev.x + " " + prev.y + " " + prev.o);

              next = getExitXY(grid.cells[q][p], prev.x, prev.y, prev.o);
              if (next !== null) {
                //console.log("coords: " + (next.p[0] + p) + " " + (next.p[1] + q));
                currentPolygon.push([next.p[0] + p, next.p[1] + q]);
                p += next.x;
                q += next.y;
                prev = next;
              } else {
                //console.log("getExitXY() returned null!");
                break;
              }
              //console.log("to : " + next.x + " " + next.y + " " + next.o);
              /* special case, where we've reached the grid boundaries */
              if (
                q < 0 ||
                q >= rows ||
                p < 0 ||
                p >= cols ||
                typeof grid.cells[q][p] === "undefined"
              ) {
                /* to create a closed path, we need to trace our way
                    arround the missing data, until we find an entry
                    point again
                */

                /* set back coordinates of current cell */
                p -= next.x;
                q -= next.y;

                //console.log("reached boundary at " + p + " " + q);

                var missing = traceOutOfGridPath(
                  grid,
                  p,
                  q,
                  next.x,
                  next.y,
                  next.o
                );
                if (missing !== null) {
                  missing.path.forEach(function (pp) {
                    //console.log("coords: " + (pp[0]) + " " + (pp[1]));
                    currentPolygon.push(pp);
                  });
                  p = missing.i;
                  q = missing.j;
                  prev = missing;
                } else {
                  break;
                }
                //console.log(grid.cells[q][p]);
              }
            } while (
              typeof grid.cells[q][p] !== "undefined" &&
              grid.cells[q][p].edges.length > 0
            );

            areas.push(currentPolygon);
            //console.log("next polygon");
            //console.log(currentPolygon);
            currentPolygon = [];
            if (grid.cells[j][i].edges.length > 0) i--;
          }
        }
      }
      return areas;
    }

    function traceOutOfGridPath(grid, i, j, d_x, d_y, d_o) {
      var cell = grid.cells[j][i];
      var cval = cell.cval_real;
      var p = i + d_x,
        q = j + d_y;
      var path = [];
      var closed = false;

      while (!closed) {
        //console.log("processing cell " + p + "," + q + " " + d_x + " " + d_y + " " + d_o);
        if (
          typeof grid.cells[q] === "undefined" ||
          typeof grid.cells[q][p] === "undefined"
        ) {
          //console.log("which is undefined");
          /* we can't move on, so we have to change direction to proceed further */

          /* go back to previous cell */
          q -= d_y;
          p -= d_x;
          cell = grid.cells[q][p];
          cval = cell.cval_real;

          /* check where we've left defined cells of the grid... */
          if (d_y === -1) {
            /* we came from top */
            if (d_o === 0) {
              /* exit left */
              if (cval & Node3) {
                /* lower left node is within range, so we move left */
                path.push([p, q]);
                d_x = -1;
                d_y = 0;
                d_o = 0;
              } else if (cval & Node2) {
                /* lower right node is within range, so we move right */
                path.push([p + 1, q]);
                d_x = 1;
                d_y = 0;
                d_o = 0;
              } else {
                /* close the path */
                path.push([p + cell.bottomright, q]);
                d_x = 0;
                d_y = 1;
                d_o = 1;
                closed = true;
                break;
              }
            } else if (cval & Node3) {
              path.push([p, q]);
              d_x = -1;
              d_y = 0;
              d_o = 0;
            } else if (cval & Node2) {
              path.push([p + cell.bottomright, q]);
              d_x = 0;
              d_y = 1;
              d_o = 1;
              closed = true;
              break;
            } else {
              path.push([p + cell.bottomleft, q]);
              d_x = 0;
              d_y = 1;
              d_o = 0;
              closed = true;
              break;
            }
          } else if (d_y === 1) {
            /* we came from bottom */
            //console.log("we came from bottom and hit a non-existing cell " + (p + d_x) + "," + (q + d_y) + "!");
            if (d_o === 0) {
              /* exit left */
              if (cval & Node1) {
                /* top right node is within range, so we move right */
                path.push([p + 1, q + 1]);
                d_x = 1;
                d_y = 0;
                d_o = 1;
              } else if (!(cval & Node0)) {
                /* found entry within same cell */
                path.push([p + cell.topright, q + 1]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
                closed = true;
                //console.log("found entry from bottom at " + p + "," + q);
                break;
              } else {
                path.push([p + cell.topleft, q + 1]);
                d_x = 0;
                d_y = -1;
                d_o = 0;
                closed = true;
                break;
              }
            } else if (cval & Node1) {
              path.push([p + 1, q + 1]);
              d_x = 1;
              d_y = 0;
              d_o = 1;
            } else {
              /* move right */
              path.push([p + 1, q + 1]);
              d_x = 1;
              d_y = 0;
              d_o = 1;
              //console.log("wtf");
              //break;
            }
          } else if (d_x === -1) {
            /* we came from right */
            //console.log("we came from right and hit a non-existing cell at " + (p + d_x) + "," + (q + d_y) + "!");
            if (d_o === 0) {
              //console.log("continue at bottom");
              if (cval & Node0) {
                path.push([p, q + 1]);
                d_x = 0;
                d_y = 1;
                d_o = 0;
                //console.log("moving upwards to " + (p + d_x) + "," + (q + d_y) + "!");
              } else if (!(cval & Node3)) {
                /* there has to be an entry into the regular grid again! */
                //console.log("exiting top");
                path.push([p, q + cell.lefttop]);
                d_x = 1;
                d_y = 0;
                d_o = 1;
                closed = true;
                break;
              } else {
                //console.log("exiting bottom");
                path.push([p, q + cell.leftbottom]);
                d_x = 1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              }
            } else {
              //console.log("continue at top");
              if (cval & Node0) {
                path.push([p, q + 1]);
                d_x = 0;
                d_y = 1;
                d_o = 0;
                //console.log("moving upwards to " + (p + d_x) + "," + (q + d_y) + "!");
              } else {
                /* */
                console.log("MarchingSquaresJS-isoBands: wtf");
                break;
              }
            }
          } else if (d_x === 1) {
            /* we came from left */
            //console.log("we came from left and hit a non-existing cell " + (p + d_x) + "," + (q + d_y) + "!");
            if (d_o === 0) {
              /* exit bottom */
              if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else {
                path.push([p + 1, q + cell.rightbottom]);
                d_x = -1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              }
            } else {
              /* exit top */
              if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else if (!(cval & Node1)) {
                path.push([p + 1, q + cell.rightbottom]);
                d_x = -1;
                d_y = 0;
                d_o = 0;
                closed = true;
                break;
              } else {
                path.push([p + 1, q + cell.righttop]);
                d_x = -1;
                d_y = 0;
                d_o = 1;
                break;
              }
            }
          } else {
            /* we came from the same cell */
            console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
            break;
          }
        } else {
          /* try to find an entry into the regular grid again! */
          cell = grid.cells[q][p];
          cval = cell.cval_real;
          //console.log("which is defined");

          if (d_x === -1) {
            if (d_o === 0) {
              /* try to go downwards */
              if (
                typeof grid.cells[q - 1] !== "undefined" &&
                typeof grid.cells[q - 1][p] !== "undefined"
              ) {
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else if (cval & Node3) {
                /* proceed searching in x-direction */
                //console.log("proceeding in x-direction!");
                path.push([p, q]);
              } else {
                /* we must have found an entry into the regular grid */
                path.push([p + cell.bottomright, q]);
                d_x = 0;
                d_y = 1;
                d_o = 1;
                closed = true;
                //console.log("found entry from bottom at " + p + "," + q);
                break;
              }
            } else if (cval & Node0) {
              /* proceed searchin in x-direction */
              console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!");
            } else {
              /* we must have found an entry into the regular grid */
              console.log(
                "MarchingSquaresJS-isoBands: found entry from top at " + p + "," + q
              );
              break;
            }
          } else if (d_x === 1) {
            if (d_o === 0) {
              console.log("MarchingSquaresJS-isoBands: wtf");
              break;
            } else {
              /* try to go upwards */
              if (
                typeof grid.cells[q + 1] !== "undefined" &&
                typeof grid.cells[q + 1][p] !== "undefined"
              ) {
                d_x = 0;
                d_y = 1;
                d_o = 0;
              } else if (cval & Node1) {
                path.push([p + 1, q + 1]);
                d_x = 1;
                d_y = 0;
                d_o = 1;
              } else {
                /* found an entry point into regular grid! */
                path.push([p + cell.topleft, q + 1]);
                d_x = 0;
                d_y = -1;
                d_o = 0;
                closed = true;
                //console.log("found entry from bottom at " + p + "," + q);
                break;
              }
            }
          } else if (d_y === -1) {
            if (d_o === 1) {
              /* try to go right */
              if (typeof grid.cells[q][p + 1] !== "undefined") {
                d_x = 1;
                d_y = 0;
                d_o = 1;
              } else if (cval & Node2) {
                path.push([p + 1, q]);
                d_x = 0;
                d_y = -1;
                d_o = 1;
              } else {
                /* found entry into regular grid! */
                path.push([p + 1, q + cell.righttop]);
                d_x = -1;
                d_y = 0;
                d_o = 1;
                closed = true;
                //console.log("found entry from top at " + p + "," + q);
                break;
              }
            } else {
              console.log("MarchingSquaresJS-isoBands: wtf");
              break;
            }
          } else if (d_y === 1) {
            if (d_o === 0) {
              //console.log("we came from bottom left and proceed to the left");
              /* try to go left */
              if (typeof grid.cells[q][p - 1] !== "undefined") {
                d_x = -1;
                d_y = 0;
                d_o = 0;
              } else if (cval & Node0) {
                path.push([p, q + 1]);
                d_x = 0;
                d_y = 1;
                d_o = 0;
              } else {
                /* found an entry point into regular grid! */
                path.push([p, q + cell.leftbottom]);
                d_x = 1;
                d_y = 0;
                d_o = 0;
                closed = true;
                //console.log("found entry from bottom at " + p + "," + q);
                break;
              }
            } else {
              //console.log("we came from bottom right and proceed to the right");
              console.log("MarchingSquaresJS-isoBands: wtf");
              break;
            }
          } else {
            console.log("MarchingSquaresJS-isoBands: where did we came from???");
            break;
          }
        }

        p += d_x;
        q += d_y;
        //console.log("going on to  " + p + "," + q + " via " + d_x + " " + d_y + " " + d_o);

        if (p === i && q === j) {
          /* bail out, once we've closed a circle path */
          break;
        }
      }

      //console.log("exit with " + p + "," + q + " " + d_x + " " + d_y + " " + d_o);
      return { path: path, i: p, j: q, x: d_x, y: d_y, o: d_o };
    }

    function deleteEdge(cell, edgeIdx) {
      delete cell.edges[edgeIdx];
      for (var k = edgeIdx + 1; k < cell.edges.length; k++) {
        cell.edges[k - 1] = cell.edges[k];
      }
      cell.edges.pop();
    }

    function getStartXY(cell) {
      if (cell.edges.length > 0) {
        var e = cell.edges[cell.edges.length - 1];
        //console.log("starting with edge " + e);
        var cval = cell.cval_real;
        switch (e) {
          case 0:
            if (cval & Node1) {
              /* node 1 within range */
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              /* node 1 below or above threshold */
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            }
          case 1:
            if (cval & Node2) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 2:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            }
          case 3:
            if (cval & Node3) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 4:
            if (cval & Node1) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          case 5:
            if (cval & Node2) {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 6:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          case 7:
            if (cval & Node3) {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 8:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            }
          case 9:
            if (cval & Node3) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 10:
            if (cval & Node3) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            }
          case 11:
            if (cval & Node0) {
              return { p: [1, cell.righttop], x: -1, y: 0, o: 1 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 12:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 13:
            if (cval & Node3) {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 14:
            if (cval & Node3) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            }
          case 15:
            if (cval & Node0) {
              return { p: [1, cell.rightbottom], x: -1, y: 0, o: 0 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 16:
            if (cval & Node2) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            }
          case 17:
            if (cval & Node0) {
              return { p: [cell.bottomright, 0], x: 0, y: 1, o: 1 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 18:
            if (cval & Node3) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            }
          case 19:
            if (cval & Node0) {
              return { p: [cell.bottomleft, 0], x: 0, y: 1, o: 0 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 20:
            if (cval & Node0) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            }
          case 21:
            if (cval & Node1) {
              return { p: [0, cell.leftbottom], x: 1, y: 0, o: 0 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          case 22:
            if (cval & Node0) {
              return { p: [cell.topleft, 1], x: 0, y: -1, o: 0 };
            } else {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            }
          case 23:
            if (cval & Node1) {
              return { p: [0, cell.lefttop], x: 1, y: 0, o: 1 };
            } else {
              return { p: [cell.topright, 1], x: 0, y: -1, o: 1 };
            }
          default:
            console.log("MarchingSquaresJS-isoBands: edge index out of range!");
            console.log(cell);
            break;
        }
      }

      return null;
    }

    function getExitXY(cell, x, y, o) {
      var e,
        id_x,
        d_x,
        d_y,
        cval = cell.cval;
      var d_o;

      switch (x) {
        case -1:
          switch (o) {
            case 0:
              e = isoBandEdgeRB[cval];
              d_x = isoBandNextXRB[cval];
              d_y = isoBandNextYRB[cval];
              d_o = isoBandNextORB[cval];
              break;
            default:
              e = isoBandEdgeRT[cval];
              d_x = isoBandNextXRT[cval];
              d_y = isoBandNextYRT[cval];
              d_o = isoBandNextORT[cval];
              break;
          }
          break;
        case 1:
          switch (o) {
            case 0:
              e = isoBandEdgeLB[cval];
              d_x = isoBandNextXLB[cval];
              d_y = isoBandNextYLB[cval];
              d_o = isoBandNextOLB[cval];
              break;
            default:
              e = isoBandEdgeLT[cval];
              d_x = isoBandNextXLT[cval];
              d_y = isoBandNextYLT[cval];
              d_o = isoBandNextOLT[cval];
              break;
          }
          break;
        default:
          switch (y) {
            case -1:
              switch (o) {
                case 0:
                  e = isoBandEdgeTL[cval];
                  d_x = isoBandNextXTL[cval];
                  d_y = isoBandNextYTL[cval];
                  d_o = isoBandNextOTL[cval];
                  break;
                default:
                  e = isoBandEdgeTR[cval];
                  d_x = isoBandNextXTR[cval];
                  d_y = isoBandNextYTR[cval];
                  d_o = isoBandNextOTR[cval];
                  break;
              }
              break;
            case 1:
              switch (o) {
                case 0:
                  e = isoBandEdgeBL[cval];
                  d_x = isoBandNextXBL[cval];
                  d_y = isoBandNextYBL[cval];
                  d_o = isoBandNextOBL[cval];
                  break;
                default:
                  e = isoBandEdgeBR[cval];
                  d_x = isoBandNextXBR[cval];
                  d_y = isoBandNextYBR[cval];
                  d_o = isoBandNextOBR[cval];
                  break;
              }
              break;
          }
          break;
      }

      id_x = cell.edges.indexOf(e);
      if (typeof cell.edges[id_x] !== "undefined") {
        deleteEdge(cell, id_x);
      } else {
        //console.log("wrong edges...");
        //console.log(x + " " + y + " " + o);
        //console.log(cell);
        return null;
      }

      cval = cell.cval_real;

      switch (e) {
        case 0:
          if (cval & Node1) {
            /* node 1 within range */
            x = cell.topleft;
            y = 1;
          } else {
            /* node 1 below or above threshold */
            x = 1;
            y = cell.righttop;
          }
          break;
        case 1:
          if (cval & Node2) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 2:
          if (cval & Node2) {
            x = cell.topleft;
            y = 1;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 3:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 4:
          if (cval & Node1) {
            x = cell.topright;
            y = 1;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 5:
          if (cval & Node2) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = cell.topright;
            y = 1;
          }
          break;
        case 6:
          if (cval & Node2) {
            x = cell.topright;
            y = 1;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 7:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = cell.topright;
            y = 1;
          }
          break;
        case 8:
          if (cval & Node2) {
            x = 1;
            y = cell.righttop;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 9:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 10:
          if (cval & Node3) {
            x = 1;
            y = cell.righttop;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 11:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = 1;
            y = cell.righttop;
          }
          break;
        case 12:
          if (cval & Node2) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 13:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = 1;
            y = cell.rightbottom;
          }
          break;
        case 14:
          if (cval & Node3) {
            x = 1;
            y = cell.rightbottom;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 15:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = 1;
            y = cell.rightbottom;
          }
          break;
        case 16:
          if (cval & Node2) {
            x = 0;
            y = cell.leftbottom;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 17:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = cell.bottomright;
            y = 0;
          }
          break;
        case 18:
          if (cval & Node3) {
            x = cell.bottomleft;
            y = 0;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 19:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = cell.bottomleft;
            y = 0;
          }
          break;
        case 20:
          if (cval & Node0) {
            x = 0;
            y = cell.leftbottom;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 21:
          if (cval & Node1) {
            x = cell.topright;
            y = 1;
          } else {
            x = 0;
            y = cell.leftbottom;
          }
          break;
        case 22:
          if (cval & Node0) {
            x = 0;
            y = cell.lefttop;
          } else {
            x = cell.topleft;
            y = 1;
          }
          break;
        case 23:
          if (cval & Node1) {
            x = cell.topright;
            y = 1;
          } else {
            x = 0;
            y = cell.lefttop;
          }
          break;
        default:
          console.log("MarchingSquaresJS-isoBands: edge index out of range!");
          console.log(cell);
          return null;
      }

      if (
        typeof x === "undefined" ||
        typeof y === "undefined" ||
        typeof d_x === "undefined" ||
        typeof d_y === "undefined" ||
        typeof d_o === "undefined"
      ) {
        console.log("MarchingSquaresJS-isoBands: undefined value!");
        console.log(cell);
        console.log(x + " " + y + " " + d_x + " " + d_y + " " + d_o);
      }
      return { p: [x, y], x: d_x, y: d_y, o: d_o };
    }

    function BandGrid2Areas(grid) {
      var areas = [];
      var area_idx = 0;

      grid.cells.forEach(function (g, j) {
        g.forEach(function (gg, i) {
          if (typeof gg !== "undefined") {
            var a = polygon_table[gg.cval](gg);
            if (typeof a === "object" && isArray(a)) {
              if (typeof a[0] === "object" && isArray(a[0])) {
                if (typeof a[0][0] === "object" && isArray(a[0][0])) {
                  a.forEach(function (aa) {
                    aa.forEach(function (aaa) {
                      aaa[0] += i;
                      aaa[1] += j;
                    });
                    areas[area_idx++] = aa;
                  });
                } else {
                  a.forEach(function (aa) {
                    aa[0] += i;
                    aa[1] += j;
                  });
                  areas[area_idx++] = a;
                }
              } else {
                console.log(
                  "MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates"
                );
              }
            } else {
              console.log(
                "MarchingSquaresJS-isoBands: bandcell polygon with null coordinates"
              );
            }
          }
        });
      });

      return areas;
    }

    /**
     * Takes a square or rectangular grid {@link FeatureCollection} of {@link Point} features with z-values and an array of
     * value breaks and generates filled contour isobands.
     *
     * @name isobands
     * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular
     * @param {Array<number>} breaks where to draw contours
     * @param {Object} [options={}] options on output
     * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
     * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands
     * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)
     * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands
     */
    function isobands(pointGrid, breaks, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var zProperty = options.zProperty || "elevation";
      var commonProperties = options.commonProperties || {};
      var breaksProperties = options.breaksProperties || [];

      // Validation
      collectionOf(pointGrid, "Point", "Input must contain Points");
      if (!breaks) throw new Error("breaks is required");
      if (!Array.isArray(breaks)) throw new Error("breaks is not an Array");
      if (!isObject(commonProperties))
        throw new Error("commonProperties is not an Object");
      if (!Array.isArray(breaksProperties))
        throw new Error("breaksProperties is not an Array");

      // Isoband methods
      var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });
      var contours = createContourLines(matrix, breaks, zProperty);
      contours = rescaleContours(contours, matrix, pointGrid);

      var multipolygons = contours.map(function (contour, index) {
        if (breaksProperties[index] && !isObject(breaksProperties[index])) {
          throw new Error("Each mappedProperty is required to be an Object");
        }
        // collect all properties
        var contourProperties = objectAssign(
          {},
          commonProperties,
          breaksProperties[index]
        );
        contourProperties[zProperty] = contour[zProperty];
        var multiP = multiPolygon(contour.groupedRings, contourProperties);
        return multiP;
      });

      return featureCollection$1(multipolygons);
    }

    /**
     * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid
     *
     * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it
     * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be
     * rescaled, with turfjs, to the original area and proportions on the map
     *
     * @private
     * @param {Array<Array<number>>} matrix Grid Data
     * @param {Array<number>} breaks Breaks
     * @param {string} [property='elevation'] Property
     * @returns {Array<any>} contours
     */
    function createContourLines(matrix, breaks, property) {
      var contours = [];
      for (var i = 1; i < breaks.length; i++) {
        var lowerBand = +breaks[i - 1]; // make sure the breaks value is a number
        var upperBand = +breaks[i];

        var isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
        // as per GeoJson rules for creating a Polygon, make sure the first element
        // in the array of LinearRings represents the exterior ring (i.e. biggest area),
        // and any subsequent elements represent interior rings (i.e. smaller area);
        // this avoids rendering issues of the MultiPolygons on the map
        var nestedRings = orderByArea(isobandsCoords);
        var groupedRings = groupNestedRings(nestedRings);
        var obj = {};
        obj["groupedRings"] = groupedRings;
        obj[property] = lowerBand + "-" + upperBand;
        contours.push(obj);
      }
      return contours;
    }

    /**
     * Transform isobands of 2D grid to polygons for the map
     *
     * @private
     * @param {Array<any>} contours Contours
     * @param {Array<Array<number>>} matrix Grid Data
     * @param {Object} points Points by Latitude
     * @returns {Array<any>} contours
     */
    function rescaleContours(contours, matrix, points) {
      // get dimensions (on the map) of the original grid
      var gridBbox = bbox$2(points); // [ minX, minY, maxX, maxY ]
      var originalWidth = gridBbox[2] - gridBbox[0];
      var originalHeigth = gridBbox[3] - gridBbox[1];

      // get origin, which is the first point of the last row on the rectangular data on the map
      var x0 = gridBbox[0];
      var y0 = gridBbox[1];
      // get number of cells per side
      var matrixWidth = matrix[0].length - 1;
      var matrixHeight = matrix.length - 1;
      // calculate the scaling factor between matrix and rectangular grid on the map
      var scaleX = originalWidth / matrixWidth;
      var scaleY = originalHeigth / matrixHeight;

      var resize = function (point) {
        point[0] = point[0] * scaleX + x0;
        point[1] = point[1] * scaleY + y0;
      };

      // resize and shift each point/line of the isobands
      contours.forEach(function (contour) {
        contour.groupedRings.forEach(function (lineRingSet) {
          lineRingSet.forEach(function (lineRing) {
            lineRing.forEach(resize);
          });
        });
      });
      return contours;
    }

    /*  utility functions */

    /**
     * Returns an array of coordinates (of LinearRings) in descending order by area
     *
     * @private
     * @param {Array<LineString>} ringsCoords array of closed LineString
     * @returns {Array} array of the input LineString ordered by area
     */
    function orderByArea(ringsCoords) {
      var ringsWithArea = [];
      var areas = [];
      ringsCoords.forEach(function (coords) {
        // var poly = polygon([points]);
        var ringArea = area(polygon([coords]));
        // create an array of areas value
        areas.push(ringArea);
        // associate each lineRing with its area
        ringsWithArea.push({ ring: coords, area: ringArea });
      });
      areas.sort(function (a, b) {
        // bigger --> smaller
        return b - a;
      });
      // create a new array of linearRings coordinates ordered by their area
      var orderedByArea = [];
      areas.forEach(function (area) {
        for (var lr = 0; lr < ringsWithArea.length; lr++) {
          if (ringsWithArea[lr].area === area) {
            orderedByArea.push(ringsWithArea[lr].ring);
            ringsWithArea.splice(lr, 1);
            break;
          }
        }
      });
      return orderedByArea;
    }

    /**
     * Returns an array of arrays of coordinates, each representing
     * a set of (coordinates of) nested LinearRings,
     * i.e. the first ring contains all the others
     *
     * @private
     * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area
     * @returns {Array<Array>} Array of coordinates of nested LinearRings
     */
    function groupNestedRings(orderedLinearRings) {
      // create a list of the (coordinates of) LinearRings
      var lrList = orderedLinearRings.map(function (lr) {
        return { lrCoordinates: lr, grouped: false };
      });
      var groupedLinearRingsCoords = [];
      while (!allGrouped(lrList)) {
        for (var i = 0; i < lrList.length; i++) {
          if (!lrList[i].grouped) {
            // create new group starting with the larger not already grouped ring
            var group = [];
            group.push(lrList[i].lrCoordinates);
            lrList[i].grouped = true;
            var outerMostPoly = polygon([lrList[i].lrCoordinates]);
            // group all the rings contained by the outermost ring
            for (var j = i + 1; j < lrList.length; j++) {
              if (!lrList[j].grouped) {
                var lrPoly = polygon([lrList[j].lrCoordinates]);
                if (isInside$1(lrPoly, outerMostPoly)) {
                  group.push(lrList[j].lrCoordinates);
                  lrList[j].grouped = true;
                }
              }
            }
            // insert the new group
            groupedLinearRingsCoords.push(group);
          }
        }
      }
      return groupedLinearRingsCoords;
    }

    /**
     * @private
     * @param {Polygon} testPolygon polygon of interest
     * @param {Polygon} targetPolygon polygon you want to compare with
     * @returns {boolean} true if test-Polygon is inside target-Polygon
     */
    function isInside$1(testPolygon, targetPolygon) {
      var points = explode$1(testPolygon);
      for (var i = 0; i < points.features.length; i++) {
        if (!booleanPointInPolygon(points.features[i], targetPolygon)) {
          return false;
        }
      }
      return true;
    }

    /**
     * @private
     * @param {Array<Object>} list list of objects which might contain the 'group' attribute
     * @returns {boolean} true if all the objects in the list are marked as grouped
     */
    function allGrouped(list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].grouped === false) {
          return false;
        }
      }
      return true;
    }

    /**
     * Rotates any geojson Feature or Geometry of a specified angle, around its `centroid` or a given `pivot` point.
     *
     * @name transformRotate
     * @param {GeoJSON} geojson object to be rotated
     * @param {number} angle of rotation in decimal degrees, positive clockwise
     * @param {Object} [options={}] Optional parameters
     * @param {Coord} [options.pivot='centroid'] point around which the rotation will be performed
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} the rotated GeoJSON feature
     * @example
     * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);
     * var options = {pivot: [0, 25]};
     * var rotatedPoly = turf.transformRotate(poly, 10, options);
     *
     * //addToMap
     * var addToMap = [poly, rotatedPoly];
     * rotatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};
     */
    function transformRotate(geojson, angle, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var pivot = options.pivot;
      var mutate = options.mutate;

      // Input validation
      if (!geojson) throw new Error("geojson is required");
      if (angle === undefined || angle === null || isNaN(angle))
        throw new Error("angle is required");

      // Shortcut no-rotation
      if (angle === 0) return geojson;

      // Use centroid of GeoJSON if pivot is not provided
      if (!pivot) pivot = centroid(geojson);

      // Clone geojson to avoid side effects
      if (mutate === false || mutate === undefined) geojson = clone(geojson);

      // Rotate each coordinate
      coordEach$1(geojson, function (pointCoords) {
        var initialAngle = rhumbBearing(pivot, pointCoords);
        var finalAngle = initialAngle + angle;
        var distance = rhumbDistance(pivot, pointCoords);
        var newCoords = getCoords(rhumbDestination(pivot, distance, finalAngle));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
      });
      return geojson;
    }

    /**
     * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).
     * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.
     *
     * @name transformScale
     * @param {GeoJSON} geojson GeoJSON to be scaled
     * @param {number} factor of scaling, positive or negative values greater than 0
     * @param {Object} [options={}] Optional parameters
     * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} scaled GeoJSON
     * @example
     * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);
     * var scaledPoly = turf.transformScale(poly, 3);
     *
     * //addToMap
     * var addToMap = [poly, scaledPoly];
     * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};
     */
    function transformScale(geojson, factor, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var origin = options.origin;
      var mutate = options.mutate;

      // Input validation
      if (!geojson) throw new Error("geojson required");
      if (typeof factor !== "number" || factor === 0)
        throw new Error("invalid factor");
      var originIsPoint = Array.isArray(origin) || typeof origin === "object";

      // Clone geojson to avoid side effects
      if (mutate !== true) geojson = clone(geojson);

      // Scale each Feature separately
      if (geojson.type === "FeatureCollection" && !originIsPoint) {
        featureEach$2(geojson, function (feature, index) {
          geojson.features[index] = scale(feature, factor, origin);
        });
        return geojson;
      }
      // Scale Feature/Geometry
      return scale(geojson, factor, origin);
    }

    /**
     * Scale Feature/Geometry
     *
     * @private
     * @param {Feature|Geometry} feature GeoJSON Feature/Geometry
     * @param {number} factor of scaling, positive or negative values greater than 0
     * @param {string|Coord} [origin="centroid"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)
     * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry
     */
    function scale(feature, factor, origin) {
      // Default params
      var isPoint = getType$1(feature) === "Point";
      origin = defineOrigin(feature, origin);

      // Shortcut no-scaling
      if (factor === 1 || isPoint) return feature;

      // Scale each coordinate
      coordEach$1(feature, function (coord) {
        var originalDistance = rhumbDistance(origin, coord);
        var bearing = rhumbBearing(origin, coord);
        var newDistance = originalDistance * factor;
        var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));
        coord[0] = newCoord[0];
        coord[1] = newCoord[1];
        if (coord.length === 3) coord[2] *= factor;
      });

      return feature;
    }

    /**
     * Define Origin
     *
     * @private
     * @param {GeoJSON} geojson GeoJSON
     * @param {string|Coord} origin sw/se/nw/ne/center/centroid
     * @returns {Feature<Point>} Point origin
     */
    function defineOrigin(geojson, origin) {
      // Default params
      if (origin === undefined || origin === null) origin = "centroid";

      // Input Coord
      if (Array.isArray(origin) || typeof origin === "object")
        return getCoord(origin);

      // Define BBox
      var bbox = geojson.bbox ? geojson.bbox : bbox$2(geojson);
      var west = bbox[0];
      var south = bbox[1];
      var east = bbox[2];
      var north = bbox[3];

      switch (origin) {
        case "sw":
        case "southwest":
        case "westsouth":
        case "bottomleft":
          return point([west, south]);
        case "se":
        case "southeast":
        case "eastsouth":
        case "bottomright":
          return point([east, south]);
        case "nw":
        case "northwest":
        case "westnorth":
        case "topleft":
          return point([west, north]);
        case "ne":
        case "northeast":
        case "eastnorth":
        case "topright":
          return point([east, north]);
        case "center":
          return center(geojson);
        case undefined:
        case null:
        case "centroid":
          return centroid(geojson);
        default:
          throw new Error("invalid origin");
      }
    }

    /**
     * Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line
     * on the provided direction angle.
     *
     * @name transformTranslate
     * @param {GeoJSON} geojson object to be translated
     * @param {number} distance length of the motion; negative values determine motion in opposite direction
     * @param {number} direction of the motion; angle from North in decimal degrees, positive clockwise
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] in which `distance` will be express; miles, kilometers, degrees, or radians
     * @param {number} [options.zTranslation=0] length of the vertical motion, same unit of distance
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} the translated GeoJSON object
     * @example
     * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);
     * var translatedPoly = turf.transformTranslate(poly, 100, 35);
     *
     * //addToMap
     * var addToMap = [poly, translatedPoly];
     * translatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};
     */
    function transformTranslate(geojson, distance, direction, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var units = options.units;
      var zTranslation = options.zTranslation;
      var mutate = options.mutate;

      // Input validation
      if (!geojson) throw new Error("geojson is required");
      if (distance === undefined || distance === null || isNaN(distance))
        throw new Error("distance is required");
      if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
        throw new Error("zTranslation is not a number");

      // Shortcut no-motion
      zTranslation = zTranslation !== undefined ? zTranslation : 0;
      if (distance === 0 && zTranslation === 0) return geojson;

      if (direction === undefined || direction === null || isNaN(direction))
        throw new Error("direction is required");

      // Invert with negative distances
      if (distance < 0) {
        distance = -distance;
        direction = direction + 180;
      }

      // Clone geojson to avoid side effects
      if (mutate === false || mutate === undefined) geojson = clone(geojson);

      // Translate each coordinate
      coordEach$1(geojson, function (pointCoords) {
        var newCoords = getCoords(
          rhumbDestination(pointCoords, distance, direction, { units: units })
        );
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
        if (zTranslation && pointCoords.length === 3)
          pointCoords[2] += zTranslation;
      });
      return geojson;
    }

    /**
     * https://github.com/rook2pawn/node-intersection
     *
     * Author @rook2pawn
     */

    /**
     * AB
     *
     * @private
     * @param {Array<Array<number>>} segment - 2 vertex line segment
     * @returns {Array<number>} coordinates [x, y]
     */
    function ab(segment) {
      var start = segment[0];
      var end = segment[1];
      return [end[0] - start[0], end[1] - start[1]];
    }

    /**
     * Cross Product
     *
     * @private
     * @param {Array<number>} v1 coordinates [x, y]
     * @param {Array<number>} v2 coordinates [x, y]
     * @returns {Array<number>} Cross Product
     */
    function crossProduct(v1, v2) {
      return v1[0] * v2[1] - v2[0] * v1[1];
    }

    /**
     * Add
     *
     * @private
     * @param {Array<number>} v1 coordinates [x, y]
     * @param {Array<number>} v2 coordinates [x, y]
     * @returns {Array<number>} Add
     */
    function add$1(v1, v2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    }

    /**
     * Sub
     *
     * @private
     * @param {Array<number>} v1 coordinates [x, y]
     * @param {Array<number>} v2 coordinates [x, y]
     * @returns {Array<number>} Sub
     */
    function sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    }

    /**
     * scalarMult
     *
     * @private
     * @param {number} s scalar
     * @param {Array<number>} v coordinates [x, y]
     * @returns {Array<number>} scalarMult
     */
    function scalarMult(s, v) {
      return [s * v[0], s * v[1]];
    }

    /**
     * Intersect Segments
     *
     * @private
     * @param {Array<number>} a coordinates [x, y]
     * @param {Array<number>} b coordinates [x, y]
     * @returns {Array<number>} intersection
     */
    function intersectSegments(a, b) {
      var p = a[0];
      var r = ab(a);
      var q = b[0];
      var s = ab(b);

      var cross = crossProduct(r, s);
      var qmp = sub(q, p);
      var numerator = crossProduct(qmp, s);
      var t = numerator / cross;
      var intersection = add$1(p, scalarMult(t, r));
      return intersection;
    }

    /**
     * Is Parallel
     *
     * @private
     * @param {Array<number>} a coordinates [x, y]
     * @param {Array<number>} b coordinates [x, y]
     * @returns {boolean} true if a and b are parallel (or co-linear)
     */
    function isParallel$1(a, b) {
      var r = ab(a);
      var s = ab(b);
      return crossProduct(r, s) === 0;
    }

    /**
     * Intersection
     *
     * @private
     * @param {Array<number>} a coordinates [x, y]
     * @param {Array<number>} b coordinates [x, y]
     * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)
     */
    function intersection(a, b) {
      if (isParallel$1(a, b)) return false;
      return intersectSegments(a, b);
    }

    /**
     * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.
     *
     * @name lineOffset
     * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON
     * @param {number} distance distance to offset the line (can be of negative value)
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters
     * @returns {Feature<LineString|MultiLineString>} Line offset from the input line
     * @example
     * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { "stroke": "#F00" });
     *
     * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});
     *
     * //addToMap
     * var addToMap = [offsetLine, line]
     * offsetLine.properties.stroke = "#00F"
     */
    function lineOffset(geojson, distance, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var units = options.units;

      // Valdiation
      if (!geojson) throw new Error("geojson is required");
      if (distance === undefined || distance === null || isNaN(distance))
        throw new Error("distance is required");

      var type = getType$1(geojson);
      var properties = geojson.properties;

      switch (type) {
        case "LineString":
          return lineOffsetFeature(geojson, distance, units);
        case "MultiLineString":
          var coords = [];
          flattenEach$1(geojson, function (feature) {
            coords.push(
              lineOffsetFeature(feature, distance, units).geometry.coordinates
            );
          });
          return multiLineString(coords, properties);
        default:
          throw new Error("geometry " + type + " is not supported");
      }
    }

    /**
     * Line Offset
     *
     * @private
     * @param {Geometry|Feature<LineString>} line input line
     * @param {number} distance distance to offset the line (can be of negative value)
     * @param {string} [units=kilometers] units
     * @returns {Feature<LineString>} Line offset from the input line
     */
    function lineOffsetFeature(line, distance, units) {
      var segments = [];
      var offsetDegrees = lengthToDegrees(distance, units);
      var coords = getCoords(line);
      var finalCoords = [];
      coords.forEach(function (currentCoords, index) {
        if (index !== coords.length - 1) {
          var segment = processSegment(
            currentCoords,
            coords[index + 1],
            offsetDegrees
          );
          segments.push(segment);
          if (index > 0) {
            var seg2Coords = segments[index - 1];
            var intersects = intersection(segment, seg2Coords);

            // Handling for line segments that aren't straight
            if (intersects !== false) {
              seg2Coords[1] = intersects;
              segment[0] = intersects;
            }

            finalCoords.push(seg2Coords[0]);
            if (index === coords.length - 2) {
              finalCoords.push(segment[0]);
              finalCoords.push(segment[1]);
            }
          }
          // Handling for lines that only have 1 segment
          if (coords.length === 2) {
            finalCoords.push(segment[0]);
            finalCoords.push(segment[1]);
          }
        }
      });
      return lineString(finalCoords, line.properties);
    }

    /**
     * Process Segment
     * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line
     *
     * @private
     * @param {Array<number>} point1 Point coordinates
     * @param {Array<number>} point2 Point coordinates
     * @param {number} offset Offset
     * @returns {Array<Array<number>>} offset points
     */
    function processSegment(point1, point2, offset) {
      var L = Math.sqrt(
        (point1[0] - point2[0]) * (point1[0] - point2[0]) +
          (point1[1] - point2[1]) * (point1[1] - point2[1])
      );

      var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;
      var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;
      var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;
      var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;
      return [
        [out1x, out1y],
        [out2x, out2y],
      ];
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
    function mathSign(x) {
        return ((x > 0) - (x < 0) || +x);
    }
    /**
     * Returns the direction of the point q relative to the vector p1 -> p2.
     *
     * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()
     * (same as geos::algorithm::CGAlgorithm::computeOrientation())
     *
     * @param {number[]} p1 - the origin point of the vector
     * @param {number[]} p2 - the final point of the vector
     * @param {number[]} q - the point to compute the direction to
     *
     * @returns {number} - 1 if q is ccw (left) from p1->p2,
     *    -1 if q is cw (right) from p1->p2,
     *     0 if q is colinear with p1->p2
     */
    function orientationIndex(p1, p2, q) {
        var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
        return mathSign(dx1 * dy2 - dx2 * dy1);
    }
    /**
     * Checks if two envelopes are equal.
     *
     * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon
     *
     * @param {Feature<Polygon>} env1 - Envelope
     * @param {Feature<Polygon>} env2 - Envelope
     * @returns {boolean} - True if the envelopes are equal
     */
    function envelopeIsEqual(env1, env2) {
        var envX1 = env1.geometry.coordinates[0].map(function (c) { return c[0]; }), envY1 = env1.geometry.coordinates[0].map(function (c) { return c[1]; }), envX2 = env2.geometry.coordinates[0].map(function (c) { return c[0]; }), envY2 = env2.geometry.coordinates[0].map(function (c) { return c[1]; });
        return (Math.max.apply(null, envX1) === Math.max.apply(null, envX2) &&
            Math.max.apply(null, envY1) === Math.max.apply(null, envY2) &&
            Math.min.apply(null, envX1) === Math.min.apply(null, envX2) &&
            Math.min.apply(null, envY1) === Math.min.apply(null, envY2));
    }
    /**
     * Check if a envelope is contained in other one.
     *
     * The function assumes that the arguments are envelopes, i.e.: Convex polygon
     * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,
     * this could be further improved.
     *
     * @param {Feature<Polygon>} self - Envelope
     * @param {Feature<Polygon>} env - Envelope
     * @returns {boolean} - True if env is contained in self
     */
    function envelopeContains(self, env) {
        return env.geometry.coordinates[0].every(function (c) {
            return booleanPointInPolygon(point(c), self);
        });
    }
    /**
     * Checks if two coordinates are equal.
     *
     * @param {number[]} coord1 - First coordinate
     * @param {number[]} coord2 - Second coordinate
     * @returns {boolean} - True if coordinates are equal
     */
    function coordinatesEqual(coord1, coord2) {
        return coord1[0] === coord2[0] && coord1[1] === coord2[1];
    }

    /**
     * Node
     */
    var Node$1 = /** @class */ (function () {
        function Node(coordinates) {
            this.id = Node.buildId(coordinates);
            this.coordinates = coordinates; //< {Number[]}
            this.innerEdges = []; //< {Edge[]}
            // We wil store to (out) edges in an CCW order as geos::planargraph::DirectedEdgeStar does
            this.outerEdges = []; //< {Edge[]}
            this.outerEdgesSorted = false; //< {Boolean} flag that stores if the outer Edges had been sorted
        }
        Node.buildId = function (coordinates) {
            return coordinates.join(",");
        };
        Node.prototype.removeInnerEdge = function (edge) {
            this.innerEdges = this.innerEdges.filter(function (e) { return e.from.id !== edge.from.id; });
        };
        Node.prototype.removeOuterEdge = function (edge) {
            this.outerEdges = this.outerEdges.filter(function (e) { return e.to.id !== edge.to.id; });
        };
        /**
         * Outer edges are stored CCW order.
         *
         * @memberof Node
         * @param {Edge} edge - Edge to add as an outerEdge.
         */
        Node.prototype.addOuterEdge = function (edge) {
            this.outerEdges.push(edge);
            this.outerEdgesSorted = false;
        };
        /**
         * Sorts outer edges in CCW way.
         *
         * @memberof Node
         * @private
         */
        Node.prototype.sortOuterEdges = function () {
            var _this = this;
            if (!this.outerEdgesSorted) {
                //this.outerEdges.sort((a, b) => a.compareTo(b));
                // Using this comparator in order to be deterministic
                this.outerEdges.sort(function (a, b) {
                    var aNode = a.to, bNode = b.to;
                    if (aNode.coordinates[0] - _this.coordinates[0] >= 0 &&
                        bNode.coordinates[0] - _this.coordinates[0] < 0)
                        return 1;
                    if (aNode.coordinates[0] - _this.coordinates[0] < 0 &&
                        bNode.coordinates[0] - _this.coordinates[0] >= 0)
                        return -1;
                    if (aNode.coordinates[0] - _this.coordinates[0] === 0 &&
                        bNode.coordinates[0] - _this.coordinates[0] === 0) {
                        if (aNode.coordinates[1] - _this.coordinates[1] >= 0 ||
                            bNode.coordinates[1] - _this.coordinates[1] >= 0)
                            return aNode.coordinates[1] - bNode.coordinates[1];
                        return bNode.coordinates[1] - aNode.coordinates[1];
                    }
                    var det = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
                    if (det < 0)
                        return 1;
                    if (det > 0)
                        return -1;
                    var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) +
                        Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) +
                        Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
                    return d1 - d2;
                });
                this.outerEdgesSorted = true;
            }
        };
        /**
         * Retrieves outer edges.
         *
         * They are sorted if they aren't in the CCW order.
         *
         * @memberof Node
         * @returns {Edge[]} - List of outer edges sorted in a CCW order.
         */
        Node.prototype.getOuterEdges = function () {
            this.sortOuterEdges();
            return this.outerEdges;
        };
        Node.prototype.getOuterEdge = function (i) {
            this.sortOuterEdges();
            return this.outerEdges[i];
        };
        Node.prototype.addInnerEdge = function (edge) {
            this.innerEdges.push(edge);
        };
        return Node;
    }());

    /**
     * This class is inspired by GEOS's geos::operation::polygonize::PolygonizeDirectedEdge
     */
    var Edge = /** @class */ (function () {
        /**
         * @param {Node} from - start node of the Edge
         * @param {Node} to - end node of the edge
         */
        function Edge(from, to) {
            this.from = from; //< start
            this.to = to; //< End
            this.next = undefined; //< The edge to be computed after
            this.label = undefined; //< Used in order to detect Cut Edges (Bridges)
            this.symetric = undefined; //< The symetric edge of this
            this.ring = undefined; //< EdgeRing in which the Edge is
            this.from.addOuterEdge(this);
            this.to.addInnerEdge(this);
        }
        /**
         * Creates or get the symetric Edge.
         *
         * @returns {Edge} - Symetric Edge.
         */
        Edge.prototype.getSymetric = function () {
            if (!this.symetric) {
                this.symetric = new Edge(this.to, this.from);
                this.symetric.symetric = this;
            }
            return this.symetric;
        };
        /**
         * Removes edge from from and to nodes.
         */
        Edge.prototype.deleteEdge = function () {
            this.from.removeOuterEdge(this);
            this.to.removeInnerEdge(this);
        };
        /**
         * Compares Edge equallity.
         *
         * An edge is equal to another, if the from and to nodes are the same.
         *
         * @param {Edge} edge - Another Edge
         * @returns {boolean} - True if Edges are equal, False otherwise
         */
        Edge.prototype.isEqual = function (edge) {
            return this.from.id === edge.from.id && this.to.id === edge.to.id;
        };
        Edge.prototype.toString = function () {
            return "Edge { " + this.from.id + " -> " + this.to.id + " }";
        };
        /**
         * Returns a LineString representation of the Edge
         *
         * @returns {Feature<LineString>} - LineString representation of the Edge
         */
        Edge.prototype.toLineString = function () {
            return lineString([this.from.coordinates, this.to.coordinates]);
        };
        /**
         * Comparator of two edges.
         *
         * Implementation of geos::planargraph::DirectedEdge::compareTo.
         *
         * @param {Edge} edge - Another edge to compare with this one
         * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,
         *          0 if the Edges are colinear,
         *          1 otherwise
         */
        Edge.prototype.compareTo = function (edge) {
            return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
        };
        return Edge;
    }());

    /**
     * Ring of edges which form a polygon.
     *
     * The ring may be either an outer shell or a hole.
     *
     * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing
     */
    var EdgeRing = /** @class */ (function () {
        function EdgeRing() {
            this.edges = [];
            this.polygon = undefined; //< Caches Polygon representation
            this.envelope = undefined; //< Caches Envelope representation
        }
        /**
         * Add an edge to the ring, inserting it in the last position.
         *
         * @memberof EdgeRing
         * @param {Edge} edge - Edge to be inserted
         */
        EdgeRing.prototype.push = function (edge) {
            this.edges.push(edge);
            this.polygon = this.envelope = undefined;
        };
        /**
         * Get Edge.
         *
         * @memberof EdgeRing
         * @param {number} i - Index
         * @returns {Edge} - Edge in the i position
         */
        EdgeRing.prototype.get = function (i) {
            return this.edges[i];
        };
        Object.defineProperty(EdgeRing.prototype, "length", {
            /**
             * Getter of length property.
             *
             * @memberof EdgeRing
             * @returns {number} - Length of the edge ring.
             */
            get: function () {
                return this.edges.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.
         *
         * @memberof EdgeRing
         * @param {Function} f - The same function to be passed to Array.prototype.forEach
         */
        EdgeRing.prototype.forEach = function (f) {
            this.edges.forEach(f);
        };
        /**
         * Similar to Array.prototype.map for the list of Edges in the EdgeRing.
         *
         * @memberof EdgeRing
         * @param {Function} f - The same function to be passed to Array.prototype.map
         * @returns {Array} - The mapped values in the function
         */
        EdgeRing.prototype.map = function (f) {
            return this.edges.map(f);
        };
        /**
         * Similar to Array.prototype.some for the list of Edges in the EdgeRing.
         *
         * @memberof EdgeRing
         * @param {Function} f - The same function to be passed to Array.prototype.some
         * @returns {boolean} - True if an Edge check the condition
         */
        EdgeRing.prototype.some = function (f) {
            return this.edges.some(f);
        };
        /**
         * Check if the ring is valid in geomtry terms.
         *
         * A ring must have either 0 or 4 or more points. The first and the last must be
         * equal (in 2D)
         * geos::geom::LinearRing::validateConstruction
         *
         * @memberof EdgeRing
         * @returns {boolean} - Validity of the EdgeRing
         */
        EdgeRing.prototype.isValid = function () {
            // TODO: stub
            return true;
        };
        /**
         * Tests whether this ring is a hole.
         *
         * A ring is a hole if it is oriented counter-clockwise.
         * Similar implementation of geos::algorithm::CGAlgorithms::isCCW
         *
         * @memberof EdgeRing
         * @returns {boolean} - true: if it is a hole
         */
        EdgeRing.prototype.isHole = function () {
            var _this = this;
            // XXX: Assuming Ring is valid
            // Find highest point
            var hiIndex = this.edges.reduce(function (high, edge, i) {
                if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
                    high = i;
                return high;
            }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
            if (disc === 0)
                return (this.edges[iPrev].from.coordinates[0] >
                    this.edges[iNext].from.coordinates[0]);
            return disc > 0;
        };
        /**
         * Creates a MultiPoint representing the EdgeRing (discarts edges directions).
         *
         * @memberof EdgeRing
         * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing
         */
        EdgeRing.prototype.toMultiPoint = function () {
            return multiPoint(this.edges.map(function (edge) { return edge.from.coordinates; }));
        };
        /**
         * Creates a Polygon representing the EdgeRing.
         *
         * @memberof EdgeRing
         * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring
         */
        EdgeRing.prototype.toPolygon = function () {
            if (this.polygon)
                return this.polygon;
            var coordinates = this.edges.map(function (edge) { return edge.from.coordinates; });
            coordinates.push(this.edges[0].from.coordinates);
            return (this.polygon = polygon([coordinates]));
        };
        /**
         * Calculates the envelope of the EdgeRing.
         *
         * @memberof EdgeRing
         * @returns {Feature<Polygon>} - envelope
         */
        EdgeRing.prototype.getEnvelope = function () {
            if (this.envelope)
                return this.envelope;
            return (this.envelope = envelope(this.toPolygon()));
        };
        /**
         * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`
         *
         * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list
         * @param {EdgeRing[]} shellList - List of EdgeRing in which to search
         *
         * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing
         */
        EdgeRing.findEdgeRingContaining = function (testEdgeRing, shellList) {
            var testEnvelope = testEdgeRing.getEnvelope();
            var minEnvelope, minShell;
            shellList.forEach(function (shell) {
                var tryEnvelope = shell.getEnvelope();
                if (minShell)
                    minEnvelope = minShell.getEnvelope();
                // the hole envelope cannot equal the shell envelope
                if (envelopeIsEqual(tryEnvelope, testEnvelope))
                    return;
                if (envelopeContains(tryEnvelope, testEnvelope)) {
                    var testEdgeRingCoordinates = testEdgeRing.map(function (edge) { return edge.from.coordinates; });
                    var testPoint = void 0;
                    var _loop_1 = function (pt) {
                        if (!shell.some(function (edge) { return coordinatesEqual(pt, edge.from.coordinates); })) {
                            testPoint = pt;
                        }
                    };
                    for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
                        var pt = testEdgeRingCoordinates_1[_i];
                        _loop_1(pt);
                    }
                    if (testPoint && shell.inside(point(testPoint))) {
                        if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
                            minShell = shell;
                    }
                }
            });
            return minShell;
        };
        /**
         * Checks if the point is inside the edgeRing
         *
         * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing
         * @returns {boolean} - True if it is inside, False otherwise
         */
        EdgeRing.prototype.inside = function (pt) {
            return booleanPointInPolygon(pt, this.toPolygon());
        };
        return EdgeRing;
    }());
    var EdgeRing$1 = EdgeRing;

    /**
     * Validates the geoJson.
     *
     * @param {GeoJSON} geoJson - input geoJson.
     * @throws {Error} if geoJson is invalid.
     */
    function validateGeoJson(geoJson) {
        if (!geoJson)
            throw new Error("No geojson passed");
        if (geoJson.type !== "FeatureCollection" &&
            geoJson.type !== "GeometryCollection" &&
            geoJson.type !== "MultiLineString" &&
            geoJson.type !== "LineString" &&
            geoJson.type !== "Feature")
            throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
    }
    /**
     * Represents a planar graph of edges and nodes that can be used to compute a polygonization.
     *
     * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,
     * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it
     * isn't a javascript transcription of the C++ source.
     *
     * This graph is directed (both directions are created)
     */
    var Graph$1 = /** @class */ (function () {
        function Graph() {
            this.edges = []; //< {Edge[]} dirEdges
            // The key is the `id` of the Node (ie: coordinates.join(','))
            this.nodes = {};
        }
        /**
         * Creates a graph from a GeoJSON.
         *
         * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index
         * @returns {Graph} - The newly created graph
         * @throws {Error} if geoJson is invalid.
         */
        Graph.fromGeoJson = function (geoJson) {
            validateGeoJson(geoJson);
            var graph = new Graph();
            flattenEach$1(geoJson, function (feature) {
                featureOf(feature, "LineString", "Graph::fromGeoJson");
                // When a LineString if formed by many segments, split them
                coordReduce$1(feature, function (prev, cur) {
                    if (prev) {
                        var start = graph.getNode(prev), end = graph.getNode(cur);
                        graph.addEdge(start, end);
                    }
                    return cur;
                });
            });
            return graph;
        };
        /**
         * Creates or get a Node.
         *
         * @param {number[]} coordinates - Coordinates of the node
         * @returns {Node} - The created or stored node
         */
        Graph.prototype.getNode = function (coordinates) {
            var id = Node$1.buildId(coordinates);
            var node = this.nodes[id];
            if (!node)
                node = this.nodes[id] = new Node$1(coordinates);
            return node;
        };
        /**
         * Adds an Edge and its symetricall.
         *
         * Edges are added symetrically, i.e.: we also add its symetric
         *
         * @param {Node} from - Node which starts the Edge
         * @param {Node} to - Node which ends the Edge
         */
        Graph.prototype.addEdge = function (from, to) {
            var edge = new Edge(from, to), symetricEdge = edge.getSymetric();
            this.edges.push(edge);
            this.edges.push(symetricEdge);
        };
        /**
         * Removes Dangle Nodes (nodes with grade 1).
         */
        Graph.prototype.deleteDangles = function () {
            var _this = this;
            Object.keys(this.nodes)
                .map(function (id) { return _this.nodes[id]; })
                .forEach(function (node) { return _this._removeIfDangle(node); });
        };
        /**
         * Check if node is dangle, if so, remove it.
         *
         * It calls itself recursively, removing a dangling node might cause another dangling node
         *
         * @param {Node} node - Node to check if it's a dangle
         */
        Graph.prototype._removeIfDangle = function (node) {
            var _this = this;
            // As edges are directed and symetrical, we count only innerEdges
            if (node.innerEdges.length <= 1) {
                var outerNodes = node.getOuterEdges().map(function (e) { return e.to; });
                this.removeNode(node);
                outerNodes.forEach(function (n) { return _this._removeIfDangle(n); });
            }
        };
        /**
         * Delete cut-edges (bridge edges).
         *
         * The graph will be traversed, all the edges will be labeled according the ring
         * in which they are. (The label is a number incremented by 1). Edges with the same
         * label are cut-edges.
         */
        Graph.prototype.deleteCutEdges = function () {
            var _this = this;
            this._computeNextCWEdges();
            this._findLabeledEdgeRings();
            // Cut-edges (bridges) are edges where both edges have the same label
            this.edges.forEach(function (edge) {
                if (edge.label === edge.symetric.label) {
                    _this.removeEdge(edge.symetric);
                    _this.removeEdge(edge);
                }
            });
        };
        /**
         * Set the `next` property of each Edge.
         *
         * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.
         * OuterEdges are sorted CCW.
         *
         * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph
         */
        Graph.prototype._computeNextCWEdges = function (node) {
            var _this = this;
            if (typeof node === "undefined") {
                Object.keys(this.nodes).forEach(function (id) {
                    return _this._computeNextCWEdges(_this.nodes[id]);
                });
            }
            else {
                node.getOuterEdges().forEach(function (edge, i) {
                    node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
                });
            }
        };
        /**
         * Computes the next edge pointers going CCW around the given node, for the given edgering label.
         *
         * This algorithm has the effect of converting maximal edgerings into minimal edgerings
         *
         * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,
         * could be written in a more javascript way.
         *
         * @param {Node} node - Node
         * @param {number} label - Ring's label
         */
        Graph.prototype._computeNextCCWEdges = function (node, label) {
            var edges = node.getOuterEdges();
            var firstOutDE, prevInDE;
            for (var i = edges.length - 1; i >= 0; --i) {
                var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;
                if (de.label === label)
                    outDE = de;
                if (sym.label === label)
                    inDE = sym;
                if (!outDE || !inDE)
                    // This edge is not in edgering
                    continue;
                if (inDE)
                    prevInDE = inDE;
                if (outDE) {
                    if (prevInDE) {
                        prevInDE.next = outDE;
                        prevInDE = undefined;
                    }
                    if (!firstOutDE)
                        firstOutDE = outDE;
                }
            }
            if (prevInDE)
                prevInDE.next = firstOutDE;
        };
        /**
         * Finds rings and labels edges according to which rings are.
         *
         * The label is a number which is increased for each ring.
         *
         * @returns {Edge[]} edges that start rings
         */
        Graph.prototype._findLabeledEdgeRings = function () {
            var edgeRingStarts = [];
            var label = 0;
            this.edges.forEach(function (edge) {
                if (edge.label >= 0)
                    return;
                edgeRingStarts.push(edge);
                var e = edge;
                do {
                    e.label = label;
                    e = e.next;
                } while (!edge.isEqual(e));
                label++;
            });
            return edgeRingStarts;
        };
        /**
         * Computes the EdgeRings formed by the edges in this graph.
         *
         * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.
         */
        Graph.prototype.getEdgeRings = function () {
            var _this = this;
            this._computeNextCWEdges();
            // Clear labels
            this.edges.forEach(function (edge) {
                edge.label = undefined;
            });
            this._findLabeledEdgeRings().forEach(function (edge) {
                // convertMaximalToMinimalEdgeRings
                _this._findIntersectionNodes(edge).forEach(function (node) {
                    _this._computeNextCCWEdges(node, edge.label);
                });
            });
            var edgeRingList = [];
            // find all edgerings
            this.edges.forEach(function (edge) {
                if (edge.ring)
                    return;
                edgeRingList.push(_this._findEdgeRing(edge));
            });
            return edgeRingList;
        };
        /**
         * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.
         *
         * @param {Node} startEdge - Start Edge of the Ring
         * @returns {Node[]} - intersection nodes
         */
        Graph.prototype._findIntersectionNodes = function (startEdge) {
            var intersectionNodes = [];
            var edge = startEdge;
            var _loop_1 = function () {
                // getDegree
                var degree = 0;
                edge.from.getOuterEdges().forEach(function (e) {
                    if (e.label === startEdge.label)
                        ++degree;
                });
                if (degree > 1)
                    intersectionNodes.push(edge.from);
                edge = edge.next;
            };
            do {
                _loop_1();
            } while (!startEdge.isEqual(edge));
            return intersectionNodes;
        };
        /**
         * Get the edge-ring which starts from the provided Edge.
         *
         * @param {Edge} startEdge - starting edge of the edge ring
         * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.
         */
        Graph.prototype._findEdgeRing = function (startEdge) {
            var edge = startEdge;
            var edgeRing = new EdgeRing$1();
            do {
                edgeRing.push(edge);
                edge.ring = edgeRing;
                edge = edge.next;
            } while (!startEdge.isEqual(edge));
            return edgeRing;
        };
        /**
         * Removes a node from the Graph.
         *
         * It also removes edges asociated to that node
         * @param {Node} node - Node to be removed
         */
        Graph.prototype.removeNode = function (node) {
            var _this = this;
            node.getOuterEdges().forEach(function (edge) { return _this.removeEdge(edge); });
            node.innerEdges.forEach(function (edge) { return _this.removeEdge(edge); });
            delete this.nodes[node.id];
        };
        /**
         * Remove edge from the graph and deletes the edge.
         *
         * @param {Edge} edge - Edge to be removed
         */
        Graph.prototype.removeEdge = function (edge) {
            this.edges = this.edges.filter(function (e) { return !e.isEqual(edge); });
            edge.deleteEdge();
        };
        return Graph;
    }());
    var Graph$2 = Graph$1;

    /**
     * Polygonizes {@link LineString|(Multi)LineString(s)} into {@link Polygons}.
     *
     * Implementation of GEOSPolygonize function (`geos::operation::polygonize::Polygonizer`).
     *
     * Polygonizes a set of lines that represents edges in a planar graph. Edges must be correctly
     * noded, i.e., they must only meet at their endpoints.
     *
     * The implementation correctly handles:
     *
     * - Dangles: edges which have one or both ends which are not incident on another edge endpoint.
     * - Cut Edges (bridges): edges that are connected at both ends but which do not form part of a polygon.
     *
     * @name polygonize
     * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geoJson Lines in order to polygonize
     * @returns {FeatureCollection<Polygon>} Polygons created
     * @throws {Error} if geoJson is invalid.
     */
    function polygonize(geoJson) {
        var graph = Graph$2.fromGeoJson(geoJson);
        // 1. Remove dangle node
        graph.deleteDangles();
        // 2. Remove cut-edges (bridge edges)
        graph.deleteCutEdges();
        // 3. Get all holes and shells
        var holes = [], shells = [];
        graph
            .getEdgeRings()
            .filter(function (edgeRing) { return edgeRing.isValid(); })
            .forEach(function (edgeRing) {
            if (edgeRing.isHole())
                holes.push(edgeRing);
            else
                shells.push(edgeRing);
        });
        // 4. Assign Holes to Shells
        holes.forEach(function (hole) {
            if (EdgeRing$1.findEdgeRingContaining(hole, shells))
                shells.push(hole);
        });
        // 5. EdgeRings to Polygons
        return featureCollection$1(shells.map(function (shell) { return shell.toPolygon(); }));
    }

    /**
     * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.
     *
     * @name booleanDisjoint
     * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
     * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
     * @returns {boolean} true/false
     * @example
     * var point = turf.point([2, 2]);
     * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
     *
     * turf.booleanDisjoint(line, point);
     * //=true
     */
    function booleanDisjoint(feature1, feature2) {
        var bool = true;
        flattenEach$1(feature1, function (flatten1) {
            flattenEach$1(feature2, function (flatten2) {
                if (bool === false) {
                    return false;
                }
                bool = disjoint(flatten1.geometry, flatten2.geometry);
            });
        });
        return bool;
    }
    /**
     * Disjoint operation for simple Geometries (Point/LineString/Polygon)
     *
     * @private
     * @param {Geometry<any>} geom1 GeoJSON Geometry
     * @param {Geometry<any>} geom2 GeoJSON Geometry
     * @returns {boolean} true/false
     */
    function disjoint(geom1, geom2) {
        switch (geom1.type) {
            case "Point":
                switch (geom2.type) {
                    case "Point":
                        return !compareCoords$1(geom1.coordinates, geom2.coordinates);
                    case "LineString":
                        return !isPointOnLine(geom2, geom1);
                    case "Polygon":
                        return !booleanPointInPolygon(geom1, geom2);
                }
                /* istanbul ignore next */
                break;
            case "LineString":
                switch (geom2.type) {
                    case "Point":
                        return !isPointOnLine(geom1, geom2);
                    case "LineString":
                        return !isLineOnLine$1(geom1, geom2);
                    case "Polygon":
                        return !isLineInPoly$1(geom2, geom1);
                }
                /* istanbul ignore next */
                break;
            case "Polygon":
                switch (geom2.type) {
                    case "Point":
                        return !booleanPointInPolygon(geom2, geom1);
                    case "LineString":
                        return !isLineInPoly$1(geom1, geom2);
                    case "Polygon":
                        return !isPolyInPoly$1(geom2, geom1);
                }
        }
        return false;
    }
    // http://stackoverflow.com/a/11908158/1979085
    function isPointOnLine(lineString, pt) {
        for (var i = 0; i < lineString.coordinates.length - 1; i++) {
            if (isPointOnLineSegment$1(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {
                return true;
            }
        }
        return false;
    }
    function isLineOnLine$1(lineString1, lineString2) {
        var doLinesIntersect = lineIntersect(lineString1, lineString2);
        if (doLinesIntersect.features.length > 0) {
            return true;
        }
        return false;
    }
    function isLineInPoly$1(polygon, lineString) {
        for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {
            var coord = _a[_i];
            if (booleanPointInPolygon(coord, polygon)) {
                return true;
            }
        }
        var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));
        if (doLinesIntersect.features.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Is Polygon (geom1) in Polygon (geom2)
     * Only takes into account outer rings
     * See http://stackoverflow.com/a/4833823/1979085
     *
     * @private
     * @param {Geometry|Feature<Polygon>} feature1 Polygon1
     * @param {Geometry|Feature<Polygon>} feature2 Polygon2
     * @returns {boolean} true/false
     */
    function isPolyInPoly$1(feature1, feature2) {
        for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {
            var coord1 = _a[_i];
            if (booleanPointInPolygon(coord1, feature2)) {
                return true;
            }
        }
        for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {
            var coord2 = _c[_b];
            if (booleanPointInPolygon(coord2, feature1)) {
                return true;
            }
        }
        var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));
        if (doLinesIntersect.features.length > 0) {
            return true;
        }
        return false;
    }
    function isPointOnLineSegment$1(lineSegmentStart, lineSegmentEnd, pt) {
        var dxc = pt[0] - lineSegmentStart[0];
        var dyc = pt[1] - lineSegmentStart[1];
        var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
        var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
        var cross = dxc * dyl - dyc * dxl;
        if (cross !== 0) {
            return false;
        }
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            if (dxl > 0) {
                return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
            }
            else {
                return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
            }
        }
        else if (dyl > 0) {
            return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
        }
        else {
            return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
        }
    }
    /**
     * compareCoords
     *
     * @private
     * @param {Position} pair1 point [x,y]
     * @param {Position} pair2 point [x,y]
     * @returns {boolean} true/false if coord pairs match
     */
    function compareCoords$1(pair1, pair2) {
        return pair1[0] === pair2[0] && pair1[1] === pair2[1];
    }

    /**
     * Boolean-contains returns True if the second geometry is completely contained by the first geometry.
     * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)
     * must not intersect the exterior of the primary (geometry a).
     * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.
     *
     * @name booleanContains
     * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
     * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
     * @returns {boolean} true/false
     * @example
     * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
     * var point = turf.point([1, 2]);
     *
     * turf.booleanContains(line, point);
     * //=true
     */
    function booleanContains(feature1, feature2) {
        var geom1 = getGeom(feature1);
        var geom2 = getGeom(feature2);
        var type1 = geom1.type;
        var type2 = geom2.type;
        var coords1 = geom1.coordinates;
        var coords2 = geom2.coordinates;
        switch (type1) {
            case "Point":
                switch (type2) {
                    case "Point":
                        return compareCoords(coords1, coords2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "MultiPoint":
                switch (type2) {
                    case "Point":
                        return isPointInMultiPoint(geom1, geom2);
                    case "MultiPoint":
                        return isMultiPointInMultiPoint(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "LineString":
                switch (type2) {
                    case "Point":
                        return booleanPointOnLine(geom2, geom1, { ignoreEndVertices: true });
                    case "LineString":
                        return isLineOnLine(geom1, geom2);
                    case "MultiPoint":
                        return isMultiPointOnLine(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "Polygon":
                switch (type2) {
                    case "Point":
                        return booleanPointInPolygon(geom2, geom1, { ignoreBoundary: true });
                    case "LineString":
                        return isLineInPoly(geom1, geom2);
                    case "Polygon":
                        return isPolyInPoly(geom1, geom2);
                    case "MultiPoint":
                        return isMultiPointInPoly(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            default:
                throw new Error("feature1 " + type1 + " geometry not supported");
        }
    }
    function isPointInMultiPoint(multiPoint, pt) {
        var i;
        var output = false;
        for (i = 0; i < multiPoint.coordinates.length; i++) {
            if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
                output = true;
                break;
            }
        }
        return output;
    }
    function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
        for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
            var coord2 = _a[_i];
            var matchFound = false;
            for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
                var coord1 = _c[_b];
                if (compareCoords(coord2, coord1)) {
                    matchFound = true;
                    break;
                }
            }
            if (!matchFound) {
                return false;
            }
        }
        return true;
    }
    function isMultiPointOnLine(lineString, multiPoint) {
        var haveFoundInteriorPoint = false;
        for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
            var coord = _a[_i];
            if (booleanPointOnLine(coord, lineString, { ignoreEndVertices: true })) {
                haveFoundInteriorPoint = true;
            }
            if (!booleanPointOnLine(coord, lineString)) {
                return false;
            }
        }
        if (haveFoundInteriorPoint) {
            return true;
        }
        return false;
    }
    function isMultiPointInPoly(polygon, multiPoint) {
        for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
            var coord = _a[_i];
            if (!booleanPointInPolygon(coord, polygon, { ignoreBoundary: true })) {
                return false;
            }
        }
        return true;
    }
    function isLineOnLine(lineString1, lineString2) {
        var haveFoundInteriorPoint = false;
        for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
            var coords = _a[_i];
            if (booleanPointOnLine({ type: "Point", coordinates: coords }, lineString1, {
                ignoreEndVertices: true,
            })) {
                haveFoundInteriorPoint = true;
            }
            if (!booleanPointOnLine({ type: "Point", coordinates: coords }, lineString1, {
                ignoreEndVertices: false,
            })) {
                return false;
            }
        }
        return haveFoundInteriorPoint;
    }
    function isLineInPoly(polygon, linestring) {
        var output = false;
        var i = 0;
        var polyBbox = bbox$2(polygon);
        var lineBbox = bbox$2(linestring);
        if (!doBBoxOverlap(polyBbox, lineBbox)) {
            return false;
        }
        for (i; i < linestring.coordinates.length - 1; i++) {
            var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
            if (booleanPointInPolygon({ type: "Point", coordinates: midPoint }, polygon, {
                ignoreBoundary: true,
            })) {
                output = true;
                break;
            }
        }
        return output;
    }
    /**
     * Is Polygon2 in Polygon1
     * Only takes into account outer rings
     *
     * @private
     * @param {Geometry|Feature<Polygon>} feature1 Polygon1
     * @param {Geometry|Feature<Polygon>} feature2 Polygon2
     * @returns {boolean} true/false
     */
    function isPolyInPoly(feature1, feature2) {
        // Handle Nulls
        if (feature1.type === "Feature" && feature1.geometry === null) {
            return false;
        }
        if (feature2.type === "Feature" && feature2.geometry === null) {
            return false;
        }
        var poly1Bbox = bbox$2(feature1);
        var poly2Bbox = bbox$2(feature2);
        if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
            return false;
        }
        var coords = getGeom(feature2).coordinates;
        for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
            var ring = coords_1[_i];
            for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
                var coord = ring_1[_a];
                if (!booleanPointInPolygon(coord, feature1)) {
                    return false;
                }
            }
        }
        return true;
    }
    function doBBoxOverlap(bbox1, bbox2) {
        if (bbox1[0] > bbox2[0]) {
            return false;
        }
        if (bbox1[2] < bbox2[2]) {
            return false;
        }
        if (bbox1[1] > bbox2[1]) {
            return false;
        }
        if (bbox1[3] < bbox2[3]) {
            return false;
        }
        return true;
    }
    /**
     * compareCoords
     *
     * @private
     * @param {Position} pair1 point [x,y]
     * @param {Position} pair2 point [x,y]
     * @returns {boolean} true/false if coord pairs match
     */
    function compareCoords(pair1, pair2) {
        return pair1[0] === pair2[0] && pair1[1] === pair2[1];
    }
    function getMidpoint(pair1, pair2) {
        return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
    }

    /**
     * Boolean-Crosses returns True if the intersection results in a geometry whose dimension is one less than
     * the maximum dimension of the two source geometries and the intersection set is interior to
     * both source geometries.
     *
     * Boolean-Crosses returns t (TRUE) for only multipoint/polygon, multipoint/linestring, linestring/linestring, linestring/polygon, and linestring/multipolygon comparisons.
     *
     * @name booleanCrosses
     * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
     * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
     * @returns {boolean} true/false
     * @example
     * var line1 = turf.lineString([[-2, 2], [4, 2]]);
     * var line2 = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
     *
     * var cross = turf.booleanCrosses(line1, line2);
     * //=true
     */
    function booleanCrosses(feature1, feature2) {
        var geom1 = getGeom(feature1);
        var geom2 = getGeom(feature2);
        var type1 = geom1.type;
        var type2 = geom2.type;
        switch (type1) {
            case "MultiPoint":
                switch (type2) {
                    case "LineString":
                        return doMultiPointAndLineStringCross(geom1, geom2);
                    case "Polygon":
                        return doesMultiPointCrossPoly(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "LineString":
                switch (type2) {
                    case "MultiPoint": // An inverse operation
                        return doMultiPointAndLineStringCross(geom2, geom1);
                    case "LineString":
                        return doLineStringsCross(geom1, geom2);
                    case "Polygon":
                        return doLineStringAndPolygonCross(geom1, geom2);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            case "Polygon":
                switch (type2) {
                    case "MultiPoint": // An inverse operation
                        return doesMultiPointCrossPoly(geom2, geom1);
                    case "LineString": // An inverse operation
                        return doLineStringAndPolygonCross(geom2, geom1);
                    default:
                        throw new Error("feature2 " + type2 + " geometry not supported");
                }
            default:
                throw new Error("feature1 " + type1 + " geometry not supported");
        }
    }
    function doMultiPointAndLineStringCross(multiPoint, lineString) {
        var foundIntPoint = false;
        var foundExtPoint = false;
        var pointLength = multiPoint.coordinates.length;
        var i = 0;
        while (i < pointLength && !foundIntPoint && !foundExtPoint) {
            for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {
                var incEndVertices = true;
                if (i2 === 0 || i2 === lineString.coordinates.length - 2) {
                    incEndVertices = false;
                }
                if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {
                    foundIntPoint = true;
                }
                else {
                    foundExtPoint = true;
                }
            }
            i++;
        }
        return foundIntPoint && foundExtPoint;
    }
    function doLineStringsCross(lineString1, lineString2) {
        var doLinesIntersect = lineIntersect(lineString1, lineString2);
        if (doLinesIntersect.features.length > 0) {
            for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
                for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
                    var incEndVertices = true;
                    if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
                        incEndVertices = false;
                    }
                    if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function doLineStringAndPolygonCross(lineString, polygon) {
        var line = polygonToLine$1(polygon);
        var doLinesIntersect = lineIntersect(lineString, line);
        if (doLinesIntersect.features.length > 0) {
            return true;
        }
        return false;
    }
    function doesMultiPointCrossPoly(multiPoint, polygon) {
        var foundIntPoint = false;
        var foundExtPoint = false;
        var pointLength = multiPoint.coordinates.length;
        for (var i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
            if (booleanPointInPolygon(point(multiPoint.coordinates[i]), polygon)) {
                foundIntPoint = true;
            }
            else {
                foundExtPoint = true;
            }
        }
        return foundExtPoint && foundIntPoint;
    }
    /**
     * Is a point on a line segment
     * Only takes into account outer rings
     * See http://stackoverflow.com/a/4833823/1979085
     *
     * @private
     * @param {number[]} lineSegmentStart coord pair of start of line
     * @param {number[]} lineSegmentEnd coord pair of end of line
     * @param {number[]} pt coord pair of point to check
     * @param {boolean} incEnd whether the point is allowed to fall on the line ends
     * @returns {boolean} true/false
     */
    function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
        var dxc = pt[0] - lineSegmentStart[0];
        var dyc = pt[1] - lineSegmentStart[1];
        var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
        var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
        var cross = dxc * dyl - dyc * dxl;
        if (cross !== 0) {
            return false;
        }
        if (incEnd) {
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                return dxl > 0
                    ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0]
                    : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
            }
            return dyl > 0
                ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1]
                : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
        }
        else {
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                return dxl > 0
                    ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0]
                    : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
            }
            return dyl > 0
                ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1]
                : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
        }
    }

    //index.js


    var Equality = function(opt) {
      this.precision = opt && opt.precision ? opt.precision : 17;
      this.direction = opt && opt.direction ? opt.direction : false;
      this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
      this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
    };

    Equality.prototype.compare = function(g1,g2) {
      if (g1.type !== g2.type || !sameLength(g1,g2)) return false;

      switch(g1.type) {
      case 'Point':
        return this.compareCoord(g1.coordinates, g2.coordinates);
      case 'LineString':
        return this.compareLine(g1.coordinates, g2.coordinates,0,false);
      case 'Polygon':
        return this.comparePolygon(g1,g2);
      case 'Feature':
        return this.compareFeature(g1, g2);
      default:
        if (g1.type.indexOf('Multi') === 0) {
          var context = this;
          var g1s = explode(g1);
          var g2s = explode(g2);
          return g1s.every(function(g1part) {
            return this.some(function(g2part) {
              return context.compare(g1part,g2part);
            });
          },g2s);
        }
      }
      return false;
    };

    function explode(g) {
      return g.coordinates.map(function(part) {
        return {
          type: g.type.replace('Multi', ''),
          coordinates: part}
      });
    }
    //compare length of coordinates/array
    function sameLength(g1,g2) {
       return g1.hasOwnProperty('coordinates') ?
        g1.coordinates.length === g2.coordinates.length
        : g1.length === g2.length;
    }

    // compare the two coordinates [x,y]
    Equality.prototype.compareCoord = function(c1,c2) {
      if (c1.length !== c2.length) {
        return false;
      }

      for (var i=0; i < c1.length; i++) {
        if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
          return false;
        }
      }
      return true;
    };

    Equality.prototype.compareLine = function(path1,path2,ind,isPoly) {
      if (!sameLength(path1,path2)) return false;
      var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
      var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
      if (isPoly && !this.compareCoord(p1[0],p2[0])) {
        // fix start index of both to same point
        p2 = this.fixStartIndex(p2,p1);
        if(!p2) return;
      }
      // for linestring ind =0 and for polygon ind =1
      var sameDirection = this.compareCoord(p1[ind],p2[ind]);
      if (this.direction || sameDirection
      ) {
        return this.comparePath(p1, p2);
      } else {
        if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])
        ) {
          return this.comparePath(p1.slice().reverse(), p2);
        }
        return false;
      }
    };
    Equality.prototype.fixStartIndex = function(sourcePath,targetPath) {
      //make sourcePath first point same as of targetPath
      var correctPath,ind = -1;
      for (var i=0; i< sourcePath.length; i++) {
        if(this.compareCoord(sourcePath[i],targetPath[0])) {
          ind = i;
          break;
        }
      }
      if (ind >= 0) {
        correctPath = [].concat(
          sourcePath.slice(ind,sourcePath.length),
          sourcePath.slice(1,ind+1));
      }
      return correctPath;
    };
    Equality.prototype.comparePath = function (p1,p2) {
      var cont = this;
      return p1.every(function(c,i) {
        return cont.compareCoord(c,this[i]);
      },p2);
    };

    Equality.prototype.comparePolygon = function(g1,g2) {
      if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {
        var holes1 = g1.coordinates.slice(1,g1.coordinates.length);
        var holes2 = g2.coordinates.slice(1,g2.coordinates.length);
        var cont = this;
        return holes1.every(function(h1) {
          return this.some(function(h2) {
            return cont.compareLine(h1,h2,1,true);
          });
        },holes2);
      } else {
        return false;
      }
    };

    Equality.prototype.compareFeature = function(g1,g2) {
      if (
        g1.id !== g2.id ||
        !this.objectComparator(g1.properties, g2.properties) ||
        !this.compareBBox(g1,g2)
      ) {
        return false;
      }
      return this.compare(g1.geometry, g2.geometry);
    };

    Equality.prototype.compareBBox = function(g1,g2) {
      if (
        (!g1.bbox && !g2.bbox) || 
        (
          g1.bbox && g2.bbox &&
          this.compareCoord(g1.bbox, g2.bbox)
        )
      )  {
        return true;
      }
      return false;
    };
    Equality.prototype.removePseudo = function(path) {
      //TODO to be implement
      return path;
    };

    function objectComparator(obj1, obj2) {
      return deepEqual_1(obj1, obj2, {strict: true});
    }

    var geojsonEquality = Equality;

    var GeojsonEquality = geojsonEquality;

    /**
     * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry
     * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,
     * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.
     *
     * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.
     *
     * @name booleanOverlap
     * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input
     * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input
     * @returns {boolean} true/false
     * @example
     * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);
     * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);
     * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);
     *
     * turf.booleanOverlap(poly1, poly2)
     * //=true
     * turf.booleanOverlap(poly2, poly3)
     * //=false
     */
    function booleanOverlap(feature1, feature2) {
        var geom1 = getGeom(feature1);
        var geom2 = getGeom(feature2);
        var type1 = geom1.type;
        var type2 = geom2.type;
        if ((type1 === "MultiPoint" && type2 !== "MultiPoint") ||
            ((type1 === "LineString" || type1 === "MultiLineString") &&
                type2 !== "LineString" &&
                type2 !== "MultiLineString") ||
            ((type1 === "Polygon" || type1 === "MultiPolygon") &&
                type2 !== "Polygon" &&
                type2 !== "MultiPolygon")) {
            throw new Error("features must be of the same type");
        }
        if (type1 === "Point")
            throw new Error("Point geometry not supported");
        // features must be not equal
        var equality = new GeojsonEquality({ precision: 6 });
        if (equality.compare(feature1, feature2))
            return false;
        var overlap = 0;
        switch (type1) {
            case "MultiPoint":
                for (var i = 0; i < geom1.coordinates.length; i++) {
                    for (var j = 0; j < geom2.coordinates.length; j++) {
                        var coord1 = geom1.coordinates[i];
                        var coord2 = geom2.coordinates[j];
                        if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
                            return true;
                        }
                    }
                }
                return false;
            case "LineString":
            case "MultiLineString":
                segmentEach$1(feature1, function (segment1) {
                    segmentEach$1(feature2, function (segment2) {
                        if (lineOverlap(segment1, segment2).features.length)
                            overlap++;
                    });
                });
                break;
            case "Polygon":
            case "MultiPolygon":
                segmentEach$1(feature1, function (segment1) {
                    segmentEach$1(feature2, function (segment2) {
                        if (lineIntersect(segment1, segment2).features.length)
                            overlap++;
                    });
                });
                break;
        }
        return overlap > 0;
    }

    /**
     * Determine whether two geometries of the same type have identical X,Y coordinate values.
     * See http://edndoc.esri.com/arcsde/9.0/general_topics/understand_spatial_relations.htm
     *
     * @name booleanEqual
     * @param {Geometry|Feature} feature1 GeoJSON input
     * @param {Geometry|Feature} feature2 GeoJSON input
     * @returns {boolean} true if the objects are equal, false otherwise
     * @example
     * var pt1 = turf.point([0, 0]);
     * var pt2 = turf.point([0, 0]);
     * var pt3 = turf.point([1, 1]);
     *
     * turf.booleanEqual(pt1, pt2);
     * //= true
     * turf.booleanEqual(pt2, pt3);
     * //= false
     */
    function booleanEqual(feature1, feature2) {
        var type1 = getGeom(feature1).type;
        var type2 = getGeom(feature2).type;
        if (type1 !== type2)
            return false;
        var equality = new GeojsonEquality({ precision: 6 });
        return equality.compare(cleanCoords(feature1), cleanCoords(feature2));
    }

    /**
     * Boolean-intersects returns (TRUE) two geometries intersect.
     *
     * @name booleanIntersects
     * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
     * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
     * @returns {boolean} true/false
     * @example
     * var point = turf.point([2, 2]);
     * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
     *
     * turf.booleanIntersects(line, point);
     * //=true
     */
    function booleanIntersects(feature1, feature2) {
        var bool = false;
        flattenEach$1(feature1, function (flatten1) {
            flattenEach$1(feature2, function (flatten2) {
                if (bool === true) {
                    return true;
                }
                bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);
            });
        });
        return bool;
    }

    /**
     * DBSCAN - Density based clustering
     *
     * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
     * @copyright MIT
     */

    var DBSCAN_1 = createCommonjsModule(function (module) {
    /**
     * DBSCAN class construcotr
     * @constructor
     *
     * @param {Array} dataset
     * @param {number} epsilon
     * @param {number} minPts
     * @param {function} distanceFunction
     * @returns {DBSCAN}
     */
    function DBSCAN(dataset, epsilon, minPts, distanceFunction) {
      /** @type {Array} */
      this.dataset = [];
      /** @type {number} */
      this.epsilon = 1;
      /** @type {number} */
      this.minPts = 2;
      /** @type {function} */
      this.distance = this._euclideanDistance;
      /** @type {Array} */
      this.clusters = [];
      /** @type {Array} */
      this.noise = [];

      // temporary variables used during computation

      /** @type {Array} */
      this._visited = [];
      /** @type {Array} */
      this._assigned = [];
      /** @type {number} */
      this._datasetLength = 0;

      this._init(dataset, epsilon, minPts, distanceFunction);
    }
    /******************************************************************************/
    // public functions

    /**
     * Start clustering
     *
     * @param {Array} dataset
     * @param {number} epsilon
     * @param {number} minPts
     * @param {function} distanceFunction
     * @returns {undefined}
     * @access public
     */
    DBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
      this._init(dataset, epsilon, minPts, distanceFunction);

      for (var pointId = 0; pointId < this._datasetLength; pointId++) {
        // if point is not visited, check if it forms a cluster
        if (this._visited[pointId] !== 1) {
          this._visited[pointId] = 1;

          // if closest neighborhood is too small to form a cluster, mark as noise
          var neighbors = this._regionQuery(pointId);

          if (neighbors.length < this.minPts) {
            this.noise.push(pointId);
          } else {
            // create new cluster and add point
            var clusterId = this.clusters.length;
            this.clusters.push([]);
            this._addToCluster(pointId, clusterId);

            this._expandCluster(clusterId, neighbors);
          }
        }
      }

      return this.clusters;
    };

    /******************************************************************************/
    // protected functions

    /**
     * Set object properties
     *
     * @param {Array} dataset
     * @param {number} epsilon
     * @param {number} minPts
     * @param {function} distance
     * @returns {undefined}
     * @access protected
     */
    DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {

      if (dataset) {

        if (!(dataset instanceof Array)) {
          throw Error('Dataset must be of type array, ' +
            typeof dataset + ' given');
        }

        this.dataset = dataset;
        this.clusters = [];
        this.noise = [];

        this._datasetLength = dataset.length;
        this._visited = new Array(this._datasetLength);
        this._assigned = new Array(this._datasetLength);
      }

      if (epsilon) {
        this.epsilon = epsilon;
      }

      if (minPts) {
        this.minPts = minPts;
      }

      if (distance) {
        this.distance = distance;
      }
    };

    /**
     * Expand cluster to closest points of given neighborhood
     *
     * @param {number} clusterId
     * @param {Array} neighbors
     * @returns {undefined}
     * @access protected
     */
    DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {

      /**
       * It's very important to calculate length of neighbors array each time,
       * as the number of elements changes over time
       */
      for (var i = 0; i < neighbors.length; i++) {
        var pointId2 = neighbors[i];

        if (this._visited[pointId2] !== 1) {
          this._visited[pointId2] = 1;
          var neighbors2 = this._regionQuery(pointId2);

          if (neighbors2.length >= this.minPts) {
            neighbors = this._mergeArrays(neighbors, neighbors2);
          }
        }

        // add to cluster
        if (this._assigned[pointId2] !== 1) {
          this._addToCluster(pointId2, clusterId);
        }
      }
    };

    /**
     * Add new point to cluster
     *
     * @param {number} pointId
     * @param {number} clusterId
     */
    DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
      this.clusters[clusterId].push(pointId);
      this._assigned[pointId] = 1;
    };

    /**
     * Find all neighbors around given point
     *
     * @param {number} pointId,
     * @param {number} epsilon
     * @returns {Array}
     * @access protected
     */
    DBSCAN.prototype._regionQuery = function(pointId) {
      var neighbors = [];

      for (var id = 0; id < this._datasetLength; id++) {
        var dist = this.distance(this.dataset[pointId], this.dataset[id]);
        if (dist < this.epsilon) {
          neighbors.push(id);
        }
      }

      return neighbors;
    };

    /******************************************************************************/
    // helpers

    /**
     * @param {Array} a
     * @param {Array} b
     * @returns {Array}
     * @access protected
     */
    DBSCAN.prototype._mergeArrays = function(a, b) {
      var len = b.length;

      for (var i = 0; i < len; i++) {
        var P = b[i];
        if (a.indexOf(P) < 0) {
          a.push(P);
        }
      }

      return a;
    };

    /**
     * Calculate euclidean distance in multidimensional space
     *
     * @param {Array} p
     * @param {Array} q
     * @returns {number}
     * @access protected
     */
    DBSCAN.prototype._euclideanDistance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);

      while (i--) {
        sum += (p[i] - q[i]) * (p[i] - q[i]);
      }

      return Math.sqrt(sum);
    };

    if (module.exports) {
      module.exports = DBSCAN;
    }
    });

    var KMEANS_1 = createCommonjsModule(function (module) {
    /**
     * KMEANS clustering
     *
     * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
     * @copyright MIT
     */

    /**
     * KMEANS class constructor
     * @constructor
     *
     * @param {Array} dataset
     * @param {number} k - number of clusters
     * @param {function} distance - distance function
     * @returns {KMEANS}
     */
     function KMEANS(dataset, k, distance) {
      this.k = 3; // number of clusters
      this.dataset = []; // set of feature vectors
      this.assignments = []; // set of associated clusters for each feature vector
      this.centroids = []; // vectors for our clusters

      this.init(dataset, k, distance);
    }

    /**
     * @returns {undefined}
     */
    KMEANS.prototype.init = function(dataset, k, distance) {
      this.assignments = [];
      this.centroids = [];

      if (typeof dataset !== 'undefined') {
        this.dataset = dataset;
      }

      if (typeof k !== 'undefined') {
        this.k = k;
      }

      if (typeof distance !== 'undefined') {
        this.distance = distance;
      }
    };

    /**
     * @returns {undefined}
     */
    KMEANS.prototype.run = function(dataset, k) {
      this.init(dataset, k);

      var len = this.dataset.length;

      // initialize centroids
      for (var i = 0; i < this.k; i++) {
        this.centroids[i] = this.randomCentroid();
    	}

      var change = true;
      while(change) {

        // assign feature vectors to clusters
        change = this.assign();

        // adjust location of centroids
        for (var centroidId = 0; centroidId < this.k; centroidId++) {
          var mean = new Array(maxDim);
          var count = 0;

          // init mean vector
          for (var dim = 0; dim < maxDim; dim++) {
            mean[dim] = 0;
          }

          for (var j = 0; j < len; j++) {
            var maxDim = this.dataset[j].length;

            // if current cluster id is assigned to point
            if (centroidId === this.assignments[j]) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] += this.dataset[j][dim];
              }
              count++;
            }
          }

          if (count > 0) {
            // if cluster contain points, adjust centroid position
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] /= count;
            }
            this.centroids[centroidId] = mean;
          } else {
            // if cluster is empty, generate new random centroid
            this.centroids[centroidId] = this.randomCentroid();
            change = true;
          }
        }
      }

      return this.getClusters();
    };

    /**
     * Generate random centroid
     *
     * @returns {Array}
     */
    KMEANS.prototype.randomCentroid = function() {
      var maxId = this.dataset.length -1;
      var centroid;
      var id;

      do {
        id = Math.round(Math.random() * maxId);
        centroid = this.dataset[id];
      } while (this.centroids.indexOf(centroid) >= 0);

      return centroid;
    };

    /**
     * Assign points to clusters
     *
     * @returns {boolean}
     */
    KMEANS.prototype.assign = function() {
      var change = false;
      var len = this.dataset.length;
      var closestCentroid;

      for (var i = 0; i < len; i++) {
        closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);

        if (closestCentroid != this.assignments[i]) {
          this.assignments[i] = closestCentroid;
          change = true;
        }
      }

      return change;
    };

    /**
     * Extract information about clusters
     *
     * @returns {undefined}
     */
    KMEANS.prototype.getClusters = function() {
      var clusters = new Array(this.k);
      var centroidId;

      for (var pointId = 0; pointId < this.assignments.length; pointId++) {
        centroidId = this.assignments[pointId];

        // init empty cluster
        if (typeof clusters[centroidId] === 'undefined') {
          clusters[centroidId] = [];
        }

        clusters[centroidId].push(pointId);
      }

      return clusters;
    };

    // utils

    /**
     * @params {Array} point
     * @params {Array.<Array>} set
     * @params {Function} f
     * @returns {number}
     */
    KMEANS.prototype.argmin = function(point, set, f) {
      var min = Number.MAX_VALUE;
      var arg = 0;
      var len = set.length;
      var d;

      for (var i = 0; i < len; i++) {
        d = f(point, set[i]);
        if (d < min) {
          min = d;
          arg = i;
        }
      }

      return arg;
    };

    /**
     * Euclidean distance
     *
     * @params {number} p
     * @params {number} q
     * @returns {number}
     */
    KMEANS.prototype.distance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);

      while (i--) {
        var diff = p[i] - q[i];
        sum += diff * diff;
      }

      return Math.sqrt(sum);
    };

    if (module.exports) {
      module.exports = KMEANS;
    }
    });

    /**
     * PriorityQueue
     * Elements in this queue are sorted according to their value
     *
     * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
     * @copyright MIT
     */

    var PriorityQueue_1 = createCommonjsModule(function (module) {
    /**
     * PriorityQueue class construcotr
     * @constructor
     *
     * @example
     * queue: [1,2,3,4]
     * priorities: [4,1,2,3]
     * > result = [1,4,2,3]
     *
     * @param {Array} elements
     * @param {Array} priorities
     * @param {string} sorting - asc / desc
     * @returns {PriorityQueue}
     */
    function PriorityQueue(elements, priorities, sorting) {
      /** @type {Array} */
      this._queue = [];
      /** @type {Array} */
      this._priorities = [];
      /** @type {string} */
      this._sorting = 'desc';

      this._init(elements, priorities, sorting);
    }
    /**
     * Insert element
     *
     * @param {Object} ele
     * @param {Object} priority
     * @returns {undefined}
     * @access public
     */
    PriorityQueue.prototype.insert = function(ele, priority) {
      var indexToInsert = this._queue.length;
      var index = indexToInsert;

      while (index--) {
        var priority2 = this._priorities[index];
        if (this._sorting === 'desc') {
          if (priority > priority2) {
            indexToInsert = index;
          }
        } else {
          if (priority < priority2) {
            indexToInsert = index;
          }
        }
      }

      this._insertAt(ele, priority, indexToInsert);
    };

    /**
     * Remove element
     *
     * @param {Object} ele
     * @returns {undefined}
     * @access public
     */
    PriorityQueue.prototype.remove = function(ele) {
      var index = this._queue.length;

      while (index--) {
        var ele2 = this._queue[index];
        if (ele === ele2) {
          this._queue.splice(index, 1);
          this._priorities.splice(index, 1);
          break;
        }
      }
    };

    /**
     * For each loop wrapper
     *
     * @param {function} func
     * @returs {undefined}
     * @access public
     */
    PriorityQueue.prototype.forEach = function(func) {
      this._queue.forEach(func);
    };

    /**
     * @returns {Array}
     * @access public
     */
    PriorityQueue.prototype.getElements = function() {
      return this._queue;
    };

    /**
     * @param {number} index
     * @returns {Object}
     * @access public
     */
    PriorityQueue.prototype.getElementPriority = function(index) {
      return this._priorities[index];
    };

    /**
     * @returns {Array}
     * @access public
     */
    PriorityQueue.prototype.getPriorities = function() {
      return this._priorities;
    };

    /**
     * @returns {Array}
     * @access public
     */
    PriorityQueue.prototype.getElementsWithPriorities = function() {
      var result = [];

      for (var i = 0, l = this._queue.length; i < l; i++) {
        result.push([this._queue[i], this._priorities[i]]);
      }

      return result;
    };

    /**
     * Set object properties
     *
     * @param {Array} elements
     * @param {Array} priorities
     * @returns {undefined}
     * @access protected
     */
    PriorityQueue.prototype._init = function(elements, priorities, sorting) {

      if (elements && priorities) {
        this._queue = [];
        this._priorities = [];

        if (elements.length !== priorities.length) {
          throw new Error('Arrays must have the same length');
        }

        for (var i = 0; i < elements.length; i++) {
          this.insert(elements[i], priorities[i]);
        }
      }

      if (sorting) {
        this._sorting = sorting;
      }
    };

    /**
     * Insert element at given position
     *
     * @param {Object} ele
     * @param {number} index
     * @returns {undefined}
     * @access protected
     */
    PriorityQueue.prototype._insertAt = function(ele, priority, index) {
      if (this._queue.length === index) {
        this._queue.push(ele);
        this._priorities.push(priority);
      } else {
        this._queue.splice(index, 0, ele);
        this._priorities.splice(index, 0, priority);
      }
    };

    if (module.exports) {
      module.exports = PriorityQueue;
    }
    });

    var OPTICS_1 = createCommonjsModule(function (module) {
    /**
     * @requires ./PriorityQueue.js
     */

    if (module.exports) {
          var PriorityQueue = PriorityQueue_1;
    }

    /**
     * OPTICS - Ordering points to identify the clustering structure
     *
     * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
     * @copyright MIT
     */

    /**
     * OPTICS class constructor
     * @constructor
     *
     * @param {Array} dataset
     * @param {number} epsilon
     * @param {number} minPts
     * @param {function} distanceFunction
     * @returns {OPTICS}
     */
    function OPTICS(dataset, epsilon, minPts, distanceFunction) {
      /** @type {number} */
      this.epsilon = 1;
      /** @type {number} */
      this.minPts = 1;
      /** @type {function} */
      this.distance = this._euclideanDistance;

      // temporary variables used during computation

      /** @type {Array} */
      this._reachability = [];
      /** @type {Array} */
      this._processed = [];
      /** @type {number} */
      this._coreDistance = 0;
      /** @type {Array} */
      this._orderedList = [];

      this._init(dataset, epsilon, minPts, distanceFunction);
    }

    /******************************************************************************/
    // pulic functions

    /**
     * Start clustering
     *
     * @param {Array} dataset
     * @returns {undefined}
     * @access public
     */
    OPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {
      this._init(dataset, epsilon, minPts, distanceFunction);

      for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
        if (this._processed[pointId] !== 1) {
          this._processed[pointId] = 1;
          this.clusters.push([pointId]);
          var clusterId = this.clusters.length - 1;

          this._orderedList.push(pointId);
          var priorityQueue = new PriorityQueue(null, null, 'asc');
          var neighbors = this._regionQuery(pointId);

          // using priority queue assign elements to new cluster
          if (this._distanceToCore(pointId) !== undefined) {
            this._updateQueue(pointId, neighbors, priorityQueue);
            this._expandCluster(clusterId, priorityQueue);
          }
        }
      }

      return this.clusters;
    };

    /**
     * Generate reachability plot for all points
     *
     * @returns {array}
     * @access public
     */
    OPTICS.prototype.getReachabilityPlot = function() {
      var reachabilityPlot = [];

      for (var i = 0, l = this._orderedList.length; i < l; i++) {
        var pointId = this._orderedList[i];
        var distance = this._reachability[pointId];

        reachabilityPlot.push([pointId, distance]);
      }

      return reachabilityPlot;
    };

    /******************************************************************************/
    // protected functions

    /**
     * Set object properties
     *
     * @param {Array} dataset
     * @param {number} epsilon
     * @param {number} minPts
     * @param {function} distance
     * @returns {undefined}
     * @access protected
     */
    OPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {

      if (dataset) {

        if (!(dataset instanceof Array)) {
          throw Error('Dataset must be of type array, ' +
            typeof dataset + ' given');
        }

        this.dataset = dataset;
        this.clusters = [];
        this._reachability = new Array(this.dataset.length);
        this._processed = new Array(this.dataset.length);
        this._coreDistance = 0;
        this._orderedList = [];
      }

      if (epsilon) {
        this.epsilon = epsilon;
      }

      if (minPts) {
        this.minPts = minPts;
      }

      if (distance) {
        this.distance = distance;
      }
    };

    /**
     * Update information in queue
     *
     * @param {number} pointId
     * @param {Array} neighbors
     * @param {PriorityQueue} queue
     * @returns {undefined}
     * @access protected
     */
    OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
      var self = this;

      this._coreDistance = this._distanceToCore(pointId);
      neighbors.forEach(function(pointId2) {
        if (self._processed[pointId2] === undefined) {
          var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);
          var newReachableDistance = Math.max(self._coreDistance, dist);

          if (self._reachability[pointId2] === undefined) {
            self._reachability[pointId2] = newReachableDistance;
            queue.insert(pointId2, newReachableDistance);
          } else {
            if (newReachableDistance < self._reachability[pointId2]) {
              self._reachability[pointId2] = newReachableDistance;
              queue.remove(pointId2);
              queue.insert(pointId2, newReachableDistance);
            }
          }
        }
      });
    };

    /**
     * Expand cluster
     *
     * @param {number} clusterId
     * @param {PriorityQueue} queue
     * @returns {undefined}
     * @access protected
     */
    OPTICS.prototype._expandCluster = function(clusterId, queue) {
      var queueElements = queue.getElements();

      for (var p = 0, l = queueElements.length; p < l; p++) {
        var pointId = queueElements[p];
        if (this._processed[pointId] === undefined) {
          var neighbors = this._regionQuery(pointId);
          this._processed[pointId] = 1;

          this.clusters[clusterId].push(pointId);
          this._orderedList.push(pointId);

          if (this._distanceToCore(pointId) !== undefined) {
            this._updateQueue(pointId, neighbors, queue);
            this._expandCluster(clusterId, queue);
          }
        }
      }
    };

    /**
     * Calculating distance to cluster core
     *
     * @param {number} pointId
     * @returns {number}
     * @access protected
     */
    OPTICS.prototype._distanceToCore = function(pointId) {
      var l = this.epsilon;
      for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
        var neighbors = this._regionQuery(pointId, coreDistCand);
        if (neighbors.length >= this.minPts) {
          return coreDistCand;
        }
      }

      return;
    };

    /**
     * Find all neighbors around given point
     *
     * @param {number} pointId
     * @param {number} epsilon
     * @returns {Array}
     * @access protected
     */
    OPTICS.prototype._regionQuery = function(pointId, epsilon) {
      epsilon = epsilon || this.epsilon;
      var neighbors = [];

      for (var id = 0, l = this.dataset.length; id < l; id++) {
        if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {
          neighbors.push(id);
        }
      }

      return neighbors;
    };

    /******************************************************************************/
    // helpers

    /**
     * Calculate euclidean distance in multidimensional space
     *
     * @param {Array} p
     * @param {Array} q
     * @returns {number}
     * @access protected
     */
    OPTICS.prototype._euclideanDistance = function(p, q) {
      var sum = 0;
      var i = Math.min(p.length, q.length);

      while (i--) {
        sum += (p[i] - q[i]) * (p[i] - q[i]);
      }

      return Math.sqrt(sum);
    };

    if (module.exports) {
      module.exports = OPTICS;
    }
    });

    var lib = createCommonjsModule(function (module) {
    if (module.exports) {
        module.exports = {
          DBSCAN: DBSCAN_1,
          KMEANS: KMEANS_1,
          OPTICS: OPTICS_1,
          PriorityQueue: PriorityQueue_1
        };
    }
    });

    /**
     * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.
     *
     * @name clustersDbscan
     * @param {FeatureCollection<Point>} points to be clustered
     * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units="kilometers"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers
     * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated
     * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,
     * points which do not meet this requirement will be classified as an 'edge' or 'noise'.
     * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:
     * - {number} cluster - the associated clusterId
     * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')
     * @example
     * // create random points with random z-values in their properties
     * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});
     * var maxDistance = 100;
     * var clustered = turf.clustersDbscan(points, maxDistance);
     *
     * //addToMap
     * var addToMap = [clustered];
     */
    function clustersDbscan(points, maxDistance, options) {
        // Input validation being handled by Typescript
        // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');
        // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');
        // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');
        // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');
        if (options === void 0) { options = {}; }
        // Clone points to prevent any mutations
        if (options.mutate !== true)
            points = clone(points);
        // Defaults
        options.minPoints = options.minPoints || 3;
        // create clustered ids
        var dbscan = new lib.DBSCAN();
        var clusteredIds = dbscan.run(coordAll$1(points), convertLength(maxDistance, options.units), options.minPoints, distance$1);
        // Tag points to Clusters ID
        var clusterId = -1;
        clusteredIds.forEach(function (clusterIds) {
            clusterId++;
            // assign cluster ids to input points
            clusterIds.forEach(function (idx) {
                var clusterPoint = points.features[idx];
                if (!clusterPoint.properties)
                    clusterPoint.properties = {};
                clusterPoint.properties.cluster = clusterId;
                clusterPoint.properties.dbscan = "core";
            });
        });
        // handle noise points, if any
        // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can "reach" less than 'minPoints' number of points
        dbscan.noise.forEach(function (noiseId) {
            var noisePoint = points.features[noiseId];
            if (!noisePoint.properties)
                noisePoint.properties = {};
            if (noisePoint.properties.cluster)
                noisePoint.properties.dbscan = "edge";
            else
                noisePoint.properties.dbscan = "noise";
        });
        return points;
    }

    var distance = {
    	/**
      * Euclidean distance
      */
    	eudist: function eudist(v1, v2, sqrt) {
    		var len = v1.length;
    		var sum = 0;

    		for (var i = 0; i < len; i++) {
    			var d = (v1[i] || 0) - (v2[i] || 0);
    			sum += d * d;
    		}
    		// Square root not really needed
    		return sqrt ? Math.sqrt(sum) : sum;
    	},
    	mandist: function mandist(v1, v2, sqrt) {
    		var len = v1.length;
    		var sum = 0;

    		for (var i = 0; i < len; i++) {
    			sum += Math.abs((v1[i] || 0) - (v2[i] || 0));
    		}

    		// Square root not really needed
    		return sqrt ? Math.sqrt(sum) : sum;
    	},


    	/**
      * Unidimensional distance
      */
    	dist: function dist(v1, v2, sqrt) {
    		var d = Math.abs(v1 - v2);
    		return sqrt ? d : d * d;
    	}
    };

    var eudist$1 = distance.eudist,
        dist = distance.dist;

    var kinit = {
    	kmrand: function kmrand(data, k) {
    		var map = {},
    		    ks = [],
    		    t = k << 2;
    		var len = data.length;
    		var multi = data[0].length > 0;

    		while (ks.length < k && t-- > 0) {
    			var d = data[Math.floor(Math.random() * len)];
    			var key = multi ? d.join("_") : "" + d;
    			if (!map[key]) {
    				map[key] = true;
    				ks.push(d);
    			}
    		}

    		if (ks.length < k) throw new Error("Error initializating clusters");else return ks;
    	},


    	/**
      * K-means++ initial centroid selection
      */
    	kmpp: function kmpp(data, k) {
    		var distance = data[0].length ? eudist$1 : dist;
    		var ks = [],
    		    len = data.length;
    		var multi = data[0].length > 0;
    		var map = {};

    		// First random centroid
    		var c = data[Math.floor(Math.random() * len)];
    		var key = multi ? c.join("_") : "" + c;
    		ks.push(c);
    		map[key] = true;

    		// Retrieve next centroids
    		while (ks.length < k) {
    			// Min Distances between current centroids and data points
    			var dists = [],
    			    lk = ks.length;
    			var dsum = 0,
    			    prs = [];

    			for (var i = 0; i < len; i++) {
    				var min = Infinity;
    				for (var j = 0; j < lk; j++) {
    					var _dist = distance(data[i], ks[j]);
    					if (_dist <= min) min = _dist;
    				}
    				dists[i] = min;
    			}

    			// Sum all min distances
    			for (var _i = 0; _i < len; _i++) {
    				dsum += dists[_i];
    			}

    			// Probabilities and cummulative prob (cumsum)
    			for (var _i2 = 0; _i2 < len; _i2++) {
    				prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
    			}

    			// Sort Probabilities
    			prs.sort(function (a, b) {
    				return a.pr - b.pr;
    			});

    			// Cummulative Probabilities
    			prs[0].cs = prs[0].pr;
    			for (var _i3 = 1; _i3 < len; _i3++) {
    				prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
    			}

    			// Randomize
    			var rnd = Math.random();

    			// Gets only the items whose cumsum >= rnd
    			var idx = 0;
    			while (idx < len - 1 && prs[idx++].cs < rnd) {}
    			ks.push(prs[idx - 1].v);
    			/*
       let done = false;
       while(!done) {
       	// this is our new centroid
       	c = prs[idx-1].v
       	key = multi? c.join("_") : `${c}`;
       	if(!map[key]) {
       		map[key] = true;
       		ks.push(c);
       		done = true;
       	}
       	else {
       		idx++;
       	}
       }
       */
    		}

    		return ks;
    	}
    };

    /*jshint esversion: 6 */

    var eudist = distance.eudist,
        kmrand = kinit.kmrand,
        kmpp = kinit.kmpp;

    var MAX = 10000;

    /**
     * Inits an array with values
     */
    function init(len, val, v) {
    	v = v || [];
    	for (var i = 0; i < len; i++) {
    		v[i] = val;
    	}return v;
    }

    function skmeans(data, k, initial, maxit) {
    	var ks = [],
    	    old = [],
    	    idxs = [],
    	    dist = [];
    	var conv = false,
    	    it = maxit || MAX;
    	var len = data.length,
    	    vlen = data[0].length,
    	    multi = vlen > 0;
    	var count = [];

    	if (!initial) {
    		var _idxs = {};
    		while (ks.length < k) {
    			var idx = Math.floor(Math.random() * len);
    			if (!_idxs[idx]) {
    				_idxs[idx] = true;
    				ks.push(data[idx]);
    			}
    		}
    	} else if (initial == "kmrand") {
    		ks = kmrand(data, k);
    	} else if (initial == "kmpp") {
    		ks = kmpp(data, k);
    	} else {
    		ks = initial;
    	}

    	do {
    		// Reset k count
    		init(k, 0, count);

    		// For each value in data, find the nearest centroid
    		for (var i = 0; i < len; i++) {
    			var min = Infinity,
    			    _idx = 0;
    			for (var j = 0; j < k; j++) {
    				// Multidimensional or unidimensional
    				var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
    				if (dist <= min) {
    					min = dist;
    					_idx = j;
    				}
    			}
    			idxs[i] = _idx; // Index of the selected centroid for that value
    			count[_idx]++; // Number of values for this centroid
    		}

    		// Recalculate centroids
    		var sum = [],
    		    old = [];
    		for (var _j = 0; _j < k; _j++) {
    			// Multidimensional or unidimensional
    			sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;
    			old[_j] = ks[_j];
    		}

    		// If multidimensional
    		if (multi) {
    			for (var _j2 = 0; _j2 < k; _j2++) {
    				ks[_j2] = [];
    			} // Sum values and count for each centroid
    			for (var _i = 0; _i < len; _i++) {
    				var _idx2 = idxs[_i],
    				    // Centroid for that item
    				vsum = sum[_idx2],
    				    // Sum values for this centroid
    				vect = data[_i]; // Current vector

    				// Accumulate value on the centroid for current vector
    				for (var h = 0; h < vlen; h++) {
    					vsum[h] += vect[h];
    				}
    			}
    			// Calculate the average for each centroid
    			conv = true;
    			for (var _j3 = 0; _j3 < k; _j3++) {
    				var ksj = ks[_j3],
    				    // Current centroid
    				sumj = sum[_j3],
    				    // Accumulated centroid values
    				oldj = old[_j3],
    				    // Old centroid value
    				cj = count[_j3]; // Number of elements for this centroid

    				// New average
    				for (var _h = 0; _h < vlen; _h++) {
    					ksj[_h] = sumj[_h] / cj || 0; // New centroid
    				}

    				// Find if centroids have moved
    				if (conv) {
    					for (var _h2 = 0; _h2 < vlen; _h2++) {
    						if (oldj[_h2] != ksj[_h2]) {
    							conv = false;
    							break;
    						}
    					}
    				}
    			}
    		}
    		// If unidimensional
    		else {
    				// Sum values and count for each centroid
    				for (var _i2 = 0; _i2 < len; _i2++) {
    					var _idx3 = idxs[_i2];
    					sum[_idx3] += data[_i2];
    				}
    				// Calculate the average for each centroid
    				for (var _j4 = 0; _j4 < k; _j4++) {
    					ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid
    				}
    				// Find if centroids have moved
    				conv = true;
    				for (var _j5 = 0; _j5 < k; _j5++) {
    					if (old[_j5] != ks[_j5]) {
    						conv = false;
    						break;
    					}
    				}
    			}

    		conv = conv || --it <= 0;
    	} while (!conv);

    	return {
    		it: MAX - it,
    		k: k,
    		idxs: idxs,
    		centroids: ks
    	};
    }

    var main = skmeans;

    /**
     * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .
     * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)
     *
     * @name clustersKmeans
     * @param {FeatureCollection<Point>} points to be clustered
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:
     * - {number} cluster - the associated clusterId
     * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]
     * @example
     * // create random points with random z-values in their properties
     * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});
     * var options = {numberOfClusters: 7};
     * var clustered = turf.clustersKmeans(points, options);
     *
     * //addToMap
     * var addToMap = [clustered];
     */
    function clustersKmeans(points, options) {
        if (options === void 0) { options = {}; }
        // Default Params
        var count = points.features.length;
        options.numberOfClusters =
            options.numberOfClusters || Math.round(Math.sqrt(count / 2));
        // numberOfClusters can't be greater than the number of points
        // fallbacks to count
        if (options.numberOfClusters > count)
            options.numberOfClusters = count;
        // Clone points to prevent any mutations (enabled by default)
        if (options.mutate !== true)
            points = clone(points);
        // collect points coordinates
        var data = coordAll$1(points);
        // create seed to avoid skmeans to drift
        var initialCentroids = data.slice(0, options.numberOfClusters);
        // create skmeans clusters
        var skmeansResult = main(data, options.numberOfClusters, initialCentroids);
        // store centroids {clusterId: [number, number]}
        var centroids = {};
        skmeansResult.centroids.forEach(function (coord, idx) {
            centroids[idx] = coord;
        });
        // add associated cluster number
        featureEach$2(points, function (point, index) {
            var clusterId = skmeansResult.idxs[index];
            point.properties.cluster = clusterId;
            point.properties.centroid = centroids[clusterId];
        });
        return points;
    }

    /**
     * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`
     *
     * @name booleanParallel
     * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry
     * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry
     * @returns {boolean} true/false if the lines are parallel
     * @example
     * var line1 = turf.lineString([[0, 0], [0, 1]]);
     * var line2 = turf.lineString([[1, 0], [1, 1]]);
     *
     * turf.booleanParallel(line1, line2);
     * //=true
     */
    function booleanParallel(line1, line2) {
        // validation
        if (!line1)
            throw new Error("line1 is required");
        if (!line2)
            throw new Error("line2 is required");
        var type1 = getType(line1, "line1");
        if (type1 !== "LineString")
            throw new Error("line1 must be a LineString");
        var type2 = getType(line2, "line2");
        if (type2 !== "LineString")
            throw new Error("line2 must be a LineString");
        var segments1 = lineSegment(cleanCoords(line1)).features;
        var segments2 = lineSegment(cleanCoords(line2)).features;
        for (var i = 0; i < segments1.length; i++) {
            var segment1 = segments1[i].geometry.coordinates;
            if (!segments2[i])
                break;
            var segment2 = segments2[i].geometry.coordinates;
            if (!isParallel(segment1, segment2))
                return false;
        }
        return true;
    }
    /**
     * Compares slopes and return result
     *
     * @private
     * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature
     * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature
     * @returns {boolean} if slopes are equal
     */
    function isParallel(segment1, segment2) {
        var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));
        var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));
        return slope1 === slope2;
    }
    /**
     * Returns Feature's type
     *
     * @private
     * @param {Geometry|Feature<any>} geojson Geometry or Feature
     * @param {string} name of the variable
     * @returns {string} Feature's type
     */
    function getType(geojson, name) {
        if (geojson.geometry && geojson.geometry.type)
            return geojson.geometry.type;
        if (geojson.type)
            return geojson.type; // if GeoJSON geometry
        throw new Error("Invalid GeoJSON object for " + name);
    }

    // javascript-astar 0.4.1
    // http://github.com/bgrins/javascript-astar
    // Freely distributable under the MIT License.
    // Implements the astar search algorithm in javascript using a Binary Heap.
    // Includes Binary Heap (with modifications) from Marijn Haverbeke.
    // http://eloquentjavascript.net/appendix2.html

    function pathTo(node) {
      var curr = node,
        path = [];
      while (curr.parent) {
        path.unshift(curr);
        curr = curr.parent;
      }
      return path;
    }

    function getHeap() {
      return new BinaryHeap(function (node) {
        return node.f;
      });
    }

    /**
     * Astar
     * @private
     */
    var astar = {
      /**
       * Perform an A* Search on a graph given a start and end node.
       *
       * @private
       * @memberof astar
       * @param {Graph} graph Graph
       * @param {GridNode} start Start
       * @param {GridNode} end End
       * @param {Object} [options] Options
       * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
       * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
       * @returns {Object} Search
       */
      search: function (graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan,
          closest = options.closest || false;

        var openHeap = getHeap(),
          closestNode = start; // set the start node to be the closest if required

        start.h = heuristic(start, end);

        openHeap.push(start);

        while (openHeap.size() > 0) {
          // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
          var currentNode = openHeap.pop();

          // End case -- result has been found, return the traced path.
          if (currentNode === end) {
            return pathTo(currentNode);
          }

          // Normal case -- move currentNode from open to closed, process each of its neighbors.
          currentNode.closed = true;

          // Find all neighbors for the current node.
          var neighbors = graph.neighbors(currentNode);

          for (var i = 0, il = neighbors.length; i < il; ++i) {
            var neighbor = neighbors[i];

            if (neighbor.closed || neighbor.isWall()) {
              // Not a valid node to process, skip to next neighbor.
              continue;
            }

            // The g score is the shortest distance from start to current node.
            // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
            var gScore = currentNode.g + neighbor.getCost(currentNode),
              beenVisited = neighbor.visited;

            if (!beenVisited || gScore < neighbor.g) {
              // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
              neighbor.visited = true;
              neighbor.parent = currentNode;
              neighbor.h = neighbor.h || heuristic(neighbor, end);
              neighbor.g = gScore;
              neighbor.f = neighbor.g + neighbor.h;
              graph.markDirty(neighbor);
              if (closest) {
                // If the neighbour is closer than the current closestNode or if it's equally close but has
                // a cheaper path than the current closest node then it becomes the closest node
                if (
                  neighbor.h < closestNode.h ||
                  (neighbor.h === closestNode.h && neighbor.g < closestNode.g)
                ) {
                  closestNode = neighbor;
                }
              }

              if (!beenVisited) {
                // Pushing to heap will put it in proper place based on the 'f' value.
                openHeap.push(neighbor);
              } else {
                // Already seen the node, but since it has been rescored we need to reorder it in the heap
                openHeap.rescoreElement(neighbor);
              }
            }
          }
        }

        if (closest) {
          return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
      },
      // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
      heuristics: {
        manhattan: function (pos0, pos1) {
          var d1 = Math.abs(pos1.x - pos0.x);
          var d2 = Math.abs(pos1.y - pos0.y);
          return d1 + d2;
        },
        diagonal: function (pos0, pos1) {
          var D = 1;
          var D2 = Math.sqrt(2);
          var d1 = Math.abs(pos1.x - pos0.x);
          var d2 = Math.abs(pos1.y - pos0.y);
          return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
        },
      },
      cleanNode: function (node) {
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
      },
    };

    /**
     * A graph memory structure
     *
     * @private
     * @param {Array} gridIn 2D array of input weights
     * @param {Object} [options] Options
     * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed
     * @returns {void} Graph
     */
    function Graph(gridIn, options) {
      options = options || {};
      this.nodes = [];
      this.diagonal = !!options.diagonal;
      this.grid = [];
      for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];

        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
          var node = new GridNode(x, y, row[y]);
          this.grid[x][y] = node;
          this.nodes.push(node);
        }
      }
      this.init();
    }

    Graph.prototype.init = function () {
      this.dirtyNodes = [];
      for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
      }
    };

    Graph.prototype.cleanDirty = function () {
      for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
      }
      this.dirtyNodes = [];
    };

    Graph.prototype.markDirty = function (node) {
      this.dirtyNodes.push(node);
    };

    Graph.prototype.neighbors = function (node) {
      var ret = [],
        x = node.x,
        y = node.y,
        grid = this.grid;

      // West
      if (grid[x - 1] && grid[x - 1][y]) {
        ret.push(grid[x - 1][y]);
      }

      // East
      if (grid[x + 1] && grid[x + 1][y]) {
        ret.push(grid[x + 1][y]);
      }

      // South
      if (grid[x] && grid[x][y - 1]) {
        ret.push(grid[x][y - 1]);
      }

      // North
      if (grid[x] && grid[x][y + 1]) {
        ret.push(grid[x][y + 1]);
      }

      if (this.diagonal) {
        // Southwest
        if (grid[x - 1] && grid[x - 1][y - 1]) {
          ret.push(grid[x - 1][y - 1]);
        }

        // Southeast
        if (grid[x + 1] && grid[x + 1][y - 1]) {
          ret.push(grid[x + 1][y - 1]);
        }

        // Northwest
        if (grid[x - 1] && grid[x - 1][y + 1]) {
          ret.push(grid[x - 1][y + 1]);
        }

        // Northeast
        if (grid[x + 1] && grid[x + 1][y + 1]) {
          ret.push(grid[x + 1][y + 1]);
        }
      }

      return ret;
    };

    Graph.prototype.toString = function () {
      var graphString = [],
        nodes = this.grid, // when using grid
        rowDebug,
        row,
        y,
        l;
      for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = [];
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
          rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(" "));
      }
      return graphString.join("\n");
    };

    function GridNode(x, y, weight) {
      this.x = x;
      this.y = y;
      this.weight = weight;
    }

    GridNode.prototype.toString = function () {
      return "[" + this.x + " " + this.y + "]";
    };

    GridNode.prototype.getCost = function (fromNeighbor) {
      // Take diagonal weight into consideration.
      if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
      }
      return this.weight;
    };

    GridNode.prototype.isWall = function () {
      return this.weight === 0;
    };

    function BinaryHeap(scoreFunction) {
      this.content = [];
      this.scoreFunction = scoreFunction;
    }

    BinaryHeap.prototype = {
      push: function (element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
      },
      pop: function () {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
          this.content[0] = end;
          this.bubbleUp(0);
        }
        return result;
      },
      remove: function (node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
          this.content[i] = end;

          if (this.scoreFunction(end) < this.scoreFunction(node)) {
            this.sinkDown(i);
          } else {
            this.bubbleUp(i);
          }
        }
      },
      size: function () {
        return this.content.length;
      },
      rescoreElement: function (node) {
        this.sinkDown(this.content.indexOf(node));
      },
      sinkDown: function (n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {
          // Compute the parent element's index, and fetch it.
          var parentN = ((n + 1) >> 1) - 1,
            parent = this.content[parentN];
          // Swap the elements if the parent is greater.
          if (this.scoreFunction(element) < this.scoreFunction(parent)) {
            this.content[parentN] = element;
            this.content[n] = parent;
            // Update 'n' to continue at the new position.
            n = parentN;
            // Found a parent that is less, no need to sink any further.
          } else {
            break;
          }
        }
      },
      bubbleUp: function (n) {
        // Look up the target element and its score.
        var length = this.content.length,
          element = this.content[n],
          elemScore = this.scoreFunction(element);

        while (true) {
          // Compute the indices of the child elements.
          var child2N = (n + 1) << 1,
            child1N = child2N - 1;
          // This is used to store the new position of the element, if any.
          var swap = null,
            child1Score;
          // If the first child exists (is inside the array)...
          if (child1N < length) {
            // Look it up and compute its score.
            var child1 = this.content[child1N];
            child1Score = this.scoreFunction(child1);

            // If the score is less than our element's, we need to swap.
            if (child1Score < elemScore) {
              swap = child1N;
            }
          }

          // Do the same checks for the other child.
          if (child2N < length) {
            var child2 = this.content[child2N],
              child2Score = this.scoreFunction(child2);
            if (child2Score < (swap === null ? elemScore : child1Score)) {
              swap = child2N;
            }
          }

          // If the element needs to be moved, swap it, and continue.
          if (swap !== null) {
            this.content[n] = this.content[swap];
            this.content[swap] = element;
            n = swap;
            // Otherwise, we are done.
          } else {
            break;
          }
        }
      },
    };

    /**
     * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with
     * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}
     *
     * @name shortestPath
     * @param {Coord} start point
     * @param {Coord} end point
     * @param {Object} [options={}] optional parameters
     * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel
     * @param {number} [options.minDistance] minimum distance between shortest path and obstacles
     * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...
     * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated
     * @returns {Feature<LineString>} shortest path between start and end
     * @example
     * var start = [-5, -6];
     * var end = [9, -6];
     * var options = {
     *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])
     * };
     *
     * var path = turf.shortestPath(start, end, options);
     *
     * //addToMap
     * var addToMap = [start, end, options.obstacles, path];
     */
    function shortestPath(start, end, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var resolution = options.resolution;
      var minDistance = options.minDistance;
      var obstacles = options.obstacles || featureCollection$1([]);

      // validation
      if (!start) throw new Error("start is required");
      if (!end) throw new Error("end is required");
      if ((resolution && !isNumber(resolution)) || resolution <= 0)
        throw new Error("options.resolution must be a number, greater than 0");
      if (minDistance)
        throw new Error("options.minDistance is not yet implemented");

      // Normalize Inputs
      var startCoord = getCoord(start);
      var endCoord = getCoord(end);
      start = point(startCoord);
      end = point(endCoord);

      // Handle obstacles
      switch (getType$1(obstacles)) {
        case "FeatureCollection":
          if (obstacles.features.length === 0)
            return lineString([startCoord, endCoord]);
          break;
        case "Polygon":
          obstacles = featureCollection$1([feature(getGeom(obstacles))]);
          break;
        default:
          throw new Error("invalid obstacles");
      }

      // define path grid area
      var collection = obstacles;
      collection.features.push(start);
      collection.features.push(end);
      var box = bbox$2(transformScale(bboxPolygon(bbox$2(collection)), 1.15)); // extend 15%
      if (!resolution) {
        var width = distance$1([box[0], box[1]], [box[2], box[1]], options);
        resolution = width / 100;
      }
      collection.features.pop();
      collection.features.pop();

      var west = box[0];
      var south = box[1];
      var east = box[2];
      var north = box[3];

      var xFraction = resolution / distance$1([west, south], [east, south], options);
      var cellWidth = xFraction * (east - west);
      var yFraction = resolution / distance$1([west, south], [west, north], options);
      var cellHeight = yFraction * (north - south);

      var bboxHorizontalSide = east - west;
      var bboxVerticalSide = north - south;
      var columns = Math.floor(bboxHorizontalSide / cellWidth);
      var rows = Math.floor(bboxVerticalSide / cellHeight);
      // adjust origin of the grid
      var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
      var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;

      // loop through points only once to speed up process
      // define matrix grid for A-star algorithm
      var pointMatrix = [];
      var matrix = [];

      var closestToStart = [];
      var closestToEnd = [];
      var minDistStart = Infinity;
      var minDistEnd = Infinity;
      var currentY = north - deltaY;
      var r = 0;
      while (currentY >= south) {
        // var currentY = south + deltaY;
        var matrixRow = [];
        var pointMatrixRow = [];
        var currentX = west + deltaX;
        var c = 0;
        while (currentX <= east) {
          var pt = point([currentX, currentY]);
          var isInsideObstacle = isInside(pt, obstacles);
          // feed obstacles matrix
          matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar
          // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea
          // map point's coords
          pointMatrixRow.push(currentX + "|" + currentY);
          // set closest points
          var distStart = distance$1(pt, start);
          // if (distStart < minDistStart) {
          if (!isInsideObstacle && distStart < minDistStart) {
            minDistStart = distStart;
            closestToStart = { x: c, y: r };
          }
          var distEnd = distance$1(pt, end);
          // if (distEnd < minDistEnd) {
          if (!isInsideObstacle && distEnd < minDistEnd) {
            minDistEnd = distEnd;
            closestToEnd = { x: c, y: r };
          }
          currentX += cellWidth;
          c++;
        }
        matrix.push(matrixRow);
        pointMatrix.push(pointMatrixRow);
        currentY -= cellHeight;
        r++;
      }

      // find path on matrix grid

      // javascript-astar ----------------------
      var graph = new Graph(matrix, { diagonal: true });
      var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
      var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
      var result = astar.search(graph, startOnMatrix, endOnMatrix);

      var path = [startCoord];
      result.forEach(function (coord) {
        var coords = pointMatrix[coord.x][coord.y].split("|");
        path.push([+coords[0], +coords[1]]); // make sure coords are numbers
      });
      path.push(endCoord);
      // ---------------------------------------

      // astar-andrea ------------------------
      // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');
      // var path = [start.geometry.coordinates];
      // result.forEach(function (coord) {
      //     var coords = pointMatrix[coord[1]][coord[0]].split('|');
      //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers
      // });
      // path.push(end.geometry.coordinates);
      // ---------------------------------------

      return cleanCoords(lineString(path));
    }

    /**
     * Checks if Point is inside any of the Polygons
     *
     * @private
     * @param {Feature<Point>} pt to check
     * @param {FeatureCollection<Polygon>} polygons features
     * @returns {boolean} if inside or not
     */
    function isInside(pt, polygons) {
      for (var i = 0; i < polygons.features.length; i++) {
        if (booleanPointInPolygon(pt, polygons.features[i])) {
          return true;
        }
      }
      return false;
    }

    function constant(x) {
      return function() {
        return x;
      };
    }

    function x(d) {
      return d[0];
    }

    function y(d) {
      return d[1];
    }

    function RedBlackTree() {
      this._ = null; // root node
    }

    function RedBlackNode(node) {
      node.U = // parent node
      node.C = // color - true for red, false for black
      node.L = // left node
      node.R = // right node
      node.P = // previous node
      node.N = null; // next node
    }

    RedBlackTree.prototype = {
      constructor: RedBlackTree,

      insert: function(after, node) {
        var parent, grandpa, uncle;

        if (after) {
          node.P = after;
          node.N = after.N;
          if (after.N) after.N.P = node;
          after.N = node;
          if (after.R) {
            after = after.R;
            while (after.L) after = after.L;
            after.L = node;
          } else {
            after.R = node;
          }
          parent = after;
        } else if (this._) {
          after = RedBlackFirst(this._);
          node.P = null;
          node.N = after;
          after.P = after.L = node;
          parent = after;
        } else {
          node.P = node.N = null;
          this._ = node;
          parent = null;
        }
        node.L = node.R = null;
        node.U = parent;
        node.C = true;

        after = node;
        while (parent && parent.C) {
          grandpa = parent.U;
          if (parent === grandpa.L) {
            uncle = grandpa.R;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.R) {
                RedBlackRotateLeft(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              RedBlackRotateRight(this, grandpa);
            }
          } else {
            uncle = grandpa.L;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.L) {
                RedBlackRotateRight(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              RedBlackRotateLeft(this, grandpa);
            }
          }
          parent = after.U;
        }
        this._.C = false;
      },

      remove: function(node) {
        if (node.N) node.N.P = node.P;
        if (node.P) node.P.N = node.N;
        node.N = node.P = null;

        var parent = node.U,
            sibling,
            left = node.L,
            right = node.R,
            next,
            red;

        if (!left) next = right;
        else if (!right) next = left;
        else next = RedBlackFirst(right);

        if (parent) {
          if (parent.L === node) parent.L = next;
          else parent.R = next;
        } else {
          this._ = next;
        }

        if (left && right) {
          red = next.C;
          next.C = node.C;
          next.L = left;
          left.U = next;
          if (next !== right) {
            parent = next.U;
            next.U = node.U;
            node = next.R;
            parent.L = node;
            next.R = right;
            right.U = next;
          } else {
            next.U = parent;
            parent = next;
            node = next.R;
          }
        } else {
          red = node.C;
          node = next;
        }

        if (node) node.U = parent;
        if (red) return;
        if (node && node.C) { node.C = false; return; }

        do {
          if (node === this._) break;
          if (node === parent.L) {
            sibling = parent.R;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              RedBlackRotateLeft(this, parent);
              sibling = parent.R;
            }
            if ((sibling.L && sibling.L.C)
                || (sibling.R && sibling.R.C)) {
              if (!sibling.R || !sibling.R.C) {
                sibling.L.C = false;
                sibling.C = true;
                RedBlackRotateRight(this, sibling);
                sibling = parent.R;
              }
              sibling.C = parent.C;
              parent.C = sibling.R.C = false;
              RedBlackRotateLeft(this, parent);
              node = this._;
              break;
            }
          } else {
            sibling = parent.L;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              RedBlackRotateRight(this, parent);
              sibling = parent.L;
            }
            if ((sibling.L && sibling.L.C)
              || (sibling.R && sibling.R.C)) {
              if (!sibling.L || !sibling.L.C) {
                sibling.R.C = false;
                sibling.C = true;
                RedBlackRotateLeft(this, sibling);
                sibling = parent.L;
              }
              sibling.C = parent.C;
              parent.C = sibling.L.C = false;
              RedBlackRotateRight(this, parent);
              node = this._;
              break;
            }
          }
          sibling.C = true;
          node = parent;
          parent = parent.U;
        } while (!node.C);

        if (node) node.C = false;
      }
    };

    function RedBlackRotateLeft(tree, node) {
      var p = node,
          q = node.R,
          parent = p.U;

      if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
      } else {
        tree._ = q;
      }

      q.U = parent;
      p.U = q;
      p.R = q.L;
      if (p.R) p.R.U = p;
      q.L = p;
    }

    function RedBlackRotateRight(tree, node) {
      var p = node,
          q = node.L,
          parent = p.U;

      if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
      } else {
        tree._ = q;
      }

      q.U = parent;
      p.U = q;
      p.L = q.R;
      if (p.L) p.L.U = p;
      q.R = p;
    }

    function RedBlackFirst(node) {
      while (node.L) node = node.L;
      return node;
    }

    function createEdge(left, right, v0, v1) {
      var edge = [null, null],
          index = edges.push(edge) - 1;
      edge.left = left;
      edge.right = right;
      if (v0) setEdgeEnd(edge, left, right, v0);
      if (v1) setEdgeEnd(edge, right, left, v1);
      cells[left.index].halfedges.push(index);
      cells[right.index].halfedges.push(index);
      return edge;
    }

    function createBorderEdge(left, v0, v1) {
      var edge = [v0, v1];
      edge.left = left;
      return edge;
    }

    function setEdgeEnd(edge, left, right, vertex) {
      if (!edge[0] && !edge[1]) {
        edge[0] = vertex;
        edge.left = left;
        edge.right = right;
      } else if (edge.left === right) {
        edge[1] = vertex;
      } else {
        edge[0] = vertex;
      }
    }

    // Liang–Barsky line clipping.
    function clipEdge(edge, x0, y0, x1, y1) {
      var a = edge[0],
          b = edge[1],
          ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

      if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
      if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
      return true;
    }

    function connectEdge(edge, x0, y0, x1, y1) {
      var v1 = edge[1];
      if (v1) return true;

      var v0 = edge[0],
          left = edge.left,
          right = edge.right,
          lx = left[0],
          ly = left[1],
          rx = right[0],
          ry = right[1],
          fx = (lx + rx) / 2,
          fy = (ly + ry) / 2,
          fm,
          fb;

      if (ry === ly) {
        if (fx < x0 || fx >= x1) return;
        if (lx > rx) {
          if (!v0) v0 = [fx, y0];
          else if (v0[1] >= y1) return;
          v1 = [fx, y1];
        } else {
          if (!v0) v0 = [fx, y1];
          else if (v0[1] < y0) return;
          v1 = [fx, y0];
        }
      } else {
        fm = (lx - rx) / (ry - ly);
        fb = fy - fm * fx;
        if (fm < -1 || fm > 1) {
          if (lx > rx) {
            if (!v0) v0 = [(y0 - fb) / fm, y0];
            else if (v0[1] >= y1) return;
            v1 = [(y1 - fb) / fm, y1];
          } else {
            if (!v0) v0 = [(y1 - fb) / fm, y1];
            else if (v0[1] < y0) return;
            v1 = [(y0 - fb) / fm, y0];
          }
        } else {
          if (ly < ry) {
            if (!v0) v0 = [x0, fm * x0 + fb];
            else if (v0[0] >= x1) return;
            v1 = [x1, fm * x1 + fb];
          } else {
            if (!v0) v0 = [x1, fm * x1 + fb];
            else if (v0[0] < x0) return;
            v1 = [x0, fm * x0 + fb];
          }
        }
      }

      edge[0] = v0;
      edge[1] = v1;
      return true;
    }

    function clipEdges(x0, y0, x1, y1) {
      var i = edges.length,
          edge;

      while (i--) {
        if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
            || !clipEdge(edge, x0, y0, x1, y1)
            || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$1
                || Math.abs(edge[0][1] - edge[1][1]) > epsilon$1)) {
          delete edges[i];
        }
      }
    }

    function createCell(site) {
      return cells[site.index] = {
        site: site,
        halfedges: []
      };
    }

    function cellHalfedgeAngle(cell, edge) {
      var site = cell.site,
          va = edge.left,
          vb = edge.right;
      if (site === vb) vb = va, va = site;
      if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
      if (site === va) va = edge[1], vb = edge[0];
      else va = edge[0], vb = edge[1];
      return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
    }

    function cellHalfedgeStart(cell, edge) {
      return edge[+(edge.left !== cell.site)];
    }

    function cellHalfedgeEnd(cell, edge) {
      return edge[+(edge.left === cell.site)];
    }

    function sortCellHalfedges() {
      for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
        if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
          var index = new Array(m),
              array = new Array(m);
          for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
          index.sort(function(i, j) { return array[j] - array[i]; });
          for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
          for (j = 0; j < m; ++j) halfedges[j] = array[j];
        }
      }
    }

    function clipCells(x0, y0, x1, y1) {
      var nCells = cells.length,
          iCell,
          cell,
          site,
          iHalfedge,
          halfedges,
          nHalfedges,
          start,
          startX,
          startY,
          end,
          endX,
          endY,
          cover = true;

      for (iCell = 0; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          halfedges = cell.halfedges;
          iHalfedge = halfedges.length;

          // Remove any dangling clipped edges.
          while (iHalfedge--) {
            if (!edges[halfedges[iHalfedge]]) {
              halfedges.splice(iHalfedge, 1);
            }
          }

          // Insert any border edges as necessary.
          iHalfedge = 0, nHalfedges = halfedges.length;
          while (iHalfedge < nHalfedges) {
            end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
            start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
            if (Math.abs(endX - startX) > epsilon$1 || Math.abs(endY - startY) > epsilon$1) {
              halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
                  Math.abs(endX - x0) < epsilon$1 && y1 - endY > epsilon$1 ? [x0, Math.abs(startX - x0) < epsilon$1 ? startY : y1]
                  : Math.abs(endY - y1) < epsilon$1 && x1 - endX > epsilon$1 ? [Math.abs(startY - y1) < epsilon$1 ? startX : x1, y1]
                  : Math.abs(endX - x1) < epsilon$1 && endY - y0 > epsilon$1 ? [x1, Math.abs(startX - x1) < epsilon$1 ? startY : y0]
                  : Math.abs(endY - y0) < epsilon$1 && endX - x0 > epsilon$1 ? [Math.abs(startY - y0) < epsilon$1 ? startX : x0, y0]
                  : null)) - 1);
              ++nHalfedges;
            }
          }

          if (nHalfedges) cover = false;
        }
      }

      // If there weren’t any edges, have the closest site cover the extent.
      // It doesn’t matter which corner of the extent we measure!
      if (cover) {
        var dx, dy, d2, dc = Infinity;

        for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
          if (cell = cells[iCell]) {
            site = cell.site;
            dx = site[0] - x0;
            dy = site[1] - y0;
            d2 = dx * dx + dy * dy;
            if (d2 < dc) dc = d2, cover = cell;
          }
        }

        if (cover) {
          var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
          cover.halfedges.push(
            edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
            edges.push(createBorderEdge(site, v01, v11)) - 1,
            edges.push(createBorderEdge(site, v11, v10)) - 1,
            edges.push(createBorderEdge(site, v10, v00)) - 1
          );
        }
      }

      // Lastly delete any cells with no edges; these were entirely clipped.
      for (iCell = 0; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          if (!cell.halfedges.length) {
            delete cells[iCell];
          }
        }
      }
    }

    var circlePool = [];

    var firstCircle;

    function Circle() {
      RedBlackNode(this);
      this.x =
      this.y =
      this.arc =
      this.site =
      this.cy = null;
    }

    function attachCircle(arc) {
      var lArc = arc.P,
          rArc = arc.N;

      if (!lArc || !rArc) return;

      var lSite = lArc.site,
          cSite = arc.site,
          rSite = rArc.site;

      if (lSite === rSite) return;

      var bx = cSite[0],
          by = cSite[1],
          ax = lSite[0] - bx,
          ay = lSite[1] - by,
          cx = rSite[0] - bx,
          cy = rSite[1] - by;

      var d = 2 * (ax * cy - ay * cx);
      if (d >= -epsilon2) return;

      var ha = ax * ax + ay * ay,
          hc = cx * cx + cy * cy,
          x = (cy * ha - ay * hc) / d,
          y = (ax * hc - cx * ha) / d;

      var circle = circlePool.pop() || new Circle;
      circle.arc = arc;
      circle.site = cSite;
      circle.x = x + bx;
      circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

      arc.circle = circle;

      var before = null,
          node = circles._;

      while (node) {
        if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
          if (node.L) node = node.L;
          else { before = node.P; break; }
        } else {
          if (node.R) node = node.R;
          else { before = node; break; }
        }
      }

      circles.insert(before, circle);
      if (!before) firstCircle = circle;
    }

    function detachCircle(arc) {
      var circle = arc.circle;
      if (circle) {
        if (!circle.P) firstCircle = circle.N;
        circles.remove(circle);
        circlePool.push(circle);
        RedBlackNode(circle);
        arc.circle = null;
      }
    }

    var beachPool = [];

    function Beach() {
      RedBlackNode(this);
      this.edge =
      this.site =
      this.circle = null;
    }

    function createBeach(site) {
      var beach = beachPool.pop() || new Beach;
      beach.site = site;
      return beach;
    }

    function detachBeach(beach) {
      detachCircle(beach);
      beaches.remove(beach);
      beachPool.push(beach);
      RedBlackNode(beach);
    }

    function removeBeach(beach) {
      var circle = beach.circle,
          x = circle.x,
          y = circle.cy,
          vertex = [x, y],
          previous = beach.P,
          next = beach.N,
          disappearing = [beach];

      detachBeach(beach);

      var lArc = previous;
      while (lArc.circle
          && Math.abs(x - lArc.circle.x) < epsilon$1
          && Math.abs(y - lArc.circle.cy) < epsilon$1) {
        previous = lArc.P;
        disappearing.unshift(lArc);
        detachBeach(lArc);
        lArc = previous;
      }

      disappearing.unshift(lArc);
      detachCircle(lArc);

      var rArc = next;
      while (rArc.circle
          && Math.abs(x - rArc.circle.x) < epsilon$1
          && Math.abs(y - rArc.circle.cy) < epsilon$1) {
        next = rArc.N;
        disappearing.push(rArc);
        detachBeach(rArc);
        rArc = next;
      }

      disappearing.push(rArc);
      detachCircle(rArc);

      var nArcs = disappearing.length,
          iArc;
      for (iArc = 1; iArc < nArcs; ++iArc) {
        rArc = disappearing[iArc];
        lArc = disappearing[iArc - 1];
        setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
      }

      lArc = disappearing[0];
      rArc = disappearing[nArcs - 1];
      rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

      attachCircle(lArc);
      attachCircle(rArc);
    }

    function addBeach(site) {
      var x = site[0],
          directrix = site[1],
          lArc,
          rArc,
          dxl,
          dxr,
          node = beaches._;

      while (node) {
        dxl = leftBreakPoint(node, directrix) - x;
        if (dxl > epsilon$1) node = node.L; else {
          dxr = x - rightBreakPoint(node, directrix);
          if (dxr > epsilon$1) {
            if (!node.R) {
              lArc = node;
              break;
            }
            node = node.R;
          } else {
            if (dxl > -epsilon$1) {
              lArc = node.P;
              rArc = node;
            } else if (dxr > -epsilon$1) {
              lArc = node;
              rArc = node.N;
            } else {
              lArc = rArc = node;
            }
            break;
          }
        }
      }

      createCell(site);
      var newArc = createBeach(site);
      beaches.insert(lArc, newArc);

      if (!lArc && !rArc) return;

      if (lArc === rArc) {
        detachCircle(lArc);
        rArc = createBeach(lArc.site);
        beaches.insert(newArc, rArc);
        newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
        attachCircle(lArc);
        attachCircle(rArc);
        return;
      }

      if (!rArc) { // && lArc
        newArc.edge = createEdge(lArc.site, newArc.site);
        return;
      }

      // else lArc !== rArc
      detachCircle(lArc);
      detachCircle(rArc);

      var lSite = lArc.site,
          ax = lSite[0],
          ay = lSite[1],
          bx = site[0] - ax,
          by = site[1] - ay,
          rSite = rArc.site,
          cx = rSite[0] - ax,
          cy = rSite[1] - ay,
          d = 2 * (bx * cy - by * cx),
          hb = bx * bx + by * by,
          hc = cx * cx + cy * cy,
          vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

      setEdgeEnd(rArc.edge, lSite, rSite, vertex);
      newArc.edge = createEdge(lSite, site, null, vertex);
      rArc.edge = createEdge(site, rSite, null, vertex);
      attachCircle(lArc);
      attachCircle(rArc);
    }

    function leftBreakPoint(arc, directrix) {
      var site = arc.site,
          rfocx = site[0],
          rfocy = site[1],
          pby2 = rfocy - directrix;

      if (!pby2) return rfocx;

      var lArc = arc.P;
      if (!lArc) return -Infinity;

      site = lArc.site;
      var lfocx = site[0],
          lfocy = site[1],
          plby2 = lfocy - directrix;

      if (!plby2) return lfocx;

      var hl = lfocx - rfocx,
          aby2 = 1 / pby2 - 1 / plby2,
          b = hl / plby2;

      if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

      return (rfocx + lfocx) / 2;
    }

    function rightBreakPoint(arc, directrix) {
      var rArc = arc.N;
      if (rArc) return leftBreakPoint(rArc, directrix);
      var site = arc.site;
      return site[1] === directrix ? site[0] : Infinity;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var beaches;
    var cells;
    var circles;
    var edges;

    function triangleArea(a, b, c) {
      return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
    }

    function lexicographic(a, b) {
      return b[1] - a[1]
          || b[0] - a[0];
    }

    function Diagram(sites, extent) {
      var site = sites.sort(lexicographic).pop(),
          x,
          y,
          circle;

      edges = [];
      cells = new Array(sites.length);
      beaches = new RedBlackTree;
      circles = new RedBlackTree;

      while (true) {
        circle = firstCircle;
        if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
          if (site[0] !== x || site[1] !== y) {
            addBeach(site);
            x = site[0], y = site[1];
          }
          site = sites.pop();
        } else if (circle) {
          removeBeach(circle.arc);
        } else {
          break;
        }
      }

      sortCellHalfedges();

      if (extent) {
        var x0 = +extent[0][0],
            y0 = +extent[0][1],
            x1 = +extent[1][0],
            y1 = +extent[1][1];
        clipEdges(x0, y0, x1, y1);
        clipCells(x0, y0, x1, y1);
      }

      this.edges = edges;
      this.cells = cells;

      beaches =
      circles =
      edges =
      cells = null;
    }

    Diagram.prototype = {
      constructor: Diagram,

      polygons: function() {
        var edges = this.edges;

        return this.cells.map(function(cell) {
          var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
          polygon.data = cell.site.data;
          return polygon;
        });
      },

      triangles: function() {
        var triangles = [],
            edges = this.edges;

        this.cells.forEach(function(cell, i) {
          if (!(m = (halfedges = cell.halfedges).length)) return;
          var site = cell.site,
              halfedges,
              j = -1,
              m,
              s0,
              e1 = edges[halfedges[m - 1]],
              s1 = e1.left === site ? e1.right : e1.left;

          while (++j < m) {
            s0 = s1;
            e1 = edges[halfedges[j]];
            s1 = e1.left === site ? e1.right : e1.left;
            if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
              triangles.push([site.data, s0.data, s1.data]);
            }
          }
        });

        return triangles;
      },

      links: function() {
        return this.edges.filter(function(edge) {
          return edge.right;
        }).map(function(edge) {
          return {
            source: edge.left.data,
            target: edge.right.data
          };
        });
      },

      find: function(x, y, radius) {
        var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

        // Use the previously-found cell, or start with an arbitrary one.
        while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
        var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

        // Traverse the half-edges to find a closer cell, if any.
        do {
          cell = that.cells[i0 = i1], i1 = null;
          cell.halfedges.forEach(function(e) {
            var edge = that.edges[e], v = edge.left;
            if ((v === cell.site || !v) && !(v = edge.right)) return;
            var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
            if (v2 < d2) d2 = v2, i1 = v.index;
          });
        } while (i1 !== null);

        that._found = i0;

        return radius == null || d2 <= radius * radius ? cell.site : null;
      }
    };

    function voronoi$1() {
      var x$1 = x,
          y$1 = y,
          extent = null;

      function voronoi(data) {
        return new Diagram(data.map(function(d, i) {
          var s = [Math.round(x$1(d, i, data) / epsilon$1) * epsilon$1, Math.round(y$1(d, i, data) / epsilon$1) * epsilon$1];
          s.index = i;
          s.data = d;
          return s;
        }), extent);
      }

      voronoi.polygons = function(data) {
        return voronoi(data).polygons();
      };

      voronoi.links = function(data) {
        return voronoi(data).links();
      };

      voronoi.triangles = function(data) {
        return voronoi(data).triangles();
      };

      voronoi.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$1;
      };

      voronoi.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$1;
      };

      voronoi.extent = function(_) {
        return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
      };

      voronoi.size = function(_) {
        return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
      };

      return voronoi;
    }

    /**
     * @private
     * @param {Array<Array<number>>} coords representing a polygon
     * @returns {Feature<Polygon>} polygon
     */
    function coordsToPolygon(coords) {
      coords = coords.slice();
      coords.push(coords[0]);
      return polygon([coords]);
    }

    /**
     * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection
     * of Voronoi polygons.
     *
     * The Voronoi algorithim used comes from the d3-voronoi package.
     *
     * @name voronoi
     * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.
     * @param {Object} [options={}] Optional parameters
     * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.
     * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.
     * @example
     * var options = {
     *   bbox: [-70, 40, -60, 60]
     * };
     * var points = turf.randomPoint(100, options);
     * var voronoiPolygons = turf.voronoi(points, options);
     *
     * //addToMap
     * var addToMap = [voronoiPolygons, points];
     */
    function voronoi(points, options) {
      // Optional params
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var bbox = options.bbox || [-180, -85, 180, 85];

      // Input Validation
      if (!points) throw new Error("points is required");
      if (!Array.isArray(bbox)) throw new Error("bbox is invalid");
      collectionOf(points, "Point", "points");

      // Main
      return featureCollection$1(
        voronoi$1()
          .x(function (feature) {
            return feature.geometry.coordinates[0];
          })
          .y(function (feature) {
            return feature.geometry.coordinates[1];
          })
          .extent([
            [bbox[0], bbox[1]],
            [bbox[2], bbox[3]],
          ])
          .polygons(points.features)
          .map(coordsToPolygon)
      );
    }

    /**
     * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.
     *
     * @param {Coord} center center point
     * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis
     * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis
     * @param {Object} [options={}] Optional parameters
     * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise
     * @param {Coord} [options.pivot='origin'] point around which the rotation will be performed
     * @param {number} [options.steps=64] number of steps
     * @param {string} [options.units='kilometers'] unit of measurement for axes
     * @param {Object} [options.properties={}] properties
     * @returns {Feature<Polygon>} ellipse polygon
     * @example
     * var center = [-75, 40];
     * var xSemiAxis = 5;
     * var ySemiAxis = 2;
     * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);
     *
     * //addToMap
     * var addToMap = [turf.point(center), ellipse]
     */
    function ellipse(center, xSemiAxis, ySemiAxis, options) {
      // Optional params
      options = options || {};
      var steps = options.steps || 64;
      var units = options.units || "kilometers";
      var angle = options.angle || 0;
      var pivot = options.pivot || center;
      var properties = options.properties || center.properties || {};

      // validation
      if (!center) throw new Error("center is required");
      if (!xSemiAxis) throw new Error("xSemiAxis is required");
      if (!ySemiAxis) throw new Error("ySemiAxis is required");
      if (!isObject(options)) throw new Error("options must be an object");
      if (!isNumber(steps)) throw new Error("steps must be a number");
      if (!isNumber(angle)) throw new Error("angle must be a number");

      var centerCoords = getCoord(center);
      if (units === "degrees") {
        var angleRad = degreesToRadians(angle);
      } else {
        xSemiAxis = rhumbDestination(center, xSemiAxis, 90, { units: units });
        ySemiAxis = rhumbDestination(center, ySemiAxis, 0, { units: units });
        xSemiAxis = getCoord(xSemiAxis)[0] - centerCoords[0];
        ySemiAxis = getCoord(ySemiAxis)[1] - centerCoords[1];
      }

      var coordinates = [];
      for (var i = 0; i < steps; i += 1) {
        var stepAngle = (i * -360) / steps;
        var x =
          (xSemiAxis * ySemiAxis) /
          Math.sqrt(
            Math.pow(ySemiAxis, 2) +
              Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2)
          );
        var y =
          (xSemiAxis * ySemiAxis) /
          Math.sqrt(
            Math.pow(xSemiAxis, 2) +
              Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2)
          );

        if (stepAngle < -90 && stepAngle >= -270) x = -x;
        if (stepAngle < -180 && stepAngle >= -360) y = -y;
        if (units === "degrees") {
          var newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);
          var newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);
          x = newx;
          y = newy;
        }

        coordinates.push([x + centerCoords[0], y + centerCoords[1]]);
      }
      coordinates.push(coordinates[0]);
      if (units === "degrees") {
        return polygon([coordinates], properties);
      } else {
        return transformRotate(polygon([coordinates], properties), angle, {
          pivot: pivot,
        });
      }
    }

    /**
     * Get Tan Degrees
     *
     * @private
     * @param {number} deg Degrees
     * @returns {number} Tan Degrees
     */
    function getTanDeg(deg) {
      var rad = (deg * Math.PI) / 180;
      return Math.tan(rad);
    }

    /**
     * Takes a {@link Feature} or {@link FeatureCollection} and returns the mean center. Can be weighted.
     *
     * @name centerMean
     * @param {GeoJSON} geojson GeoJSON to be centered
     * @param {Object} [options={}] Optional parameters
     * @param {Object} [options.properties={}] Translate GeoJSON Properties to Point
     * @param {Object} [options.bbox={}] Translate GeoJSON BBox to Point
     * @param {Object} [options.id={}] Translate GeoJSON Id to Point
     * @param {string} [options.weight] the property name used to weight the center
     * @returns {Feature<Point>} a Point feature at the mean center point of all input features
     * @example
     * var features = turf.featureCollection([
     *   turf.point([-97.522259, 35.4691], {value: 10}),
     *   turf.point([-97.502754, 35.463455], {value: 3}),
     *   turf.point([-97.508269, 35.463245], {value: 5})
     * ]);
     *
     * var options = {weight: "value"}
     * var mean = turf.centerMean(features, options);
     *
     * //addToMap
     * var addToMap = [features, mean]
     * mean.properties['marker-size'] = 'large';
     * mean.properties['marker-color'] = '#000';
     */
    function centerMean(geojson, // To-Do include Typescript AllGeoJSON
    options) {
        if (options === void 0) { options = {}; }
        var sumXs = 0;
        var sumYs = 0;
        var sumNs = 0;
        geomEach$1(geojson, function (geom, featureIndex, properties) {
            var weight = options.weight ? properties === null || properties === void 0 ? void 0 : properties[options.weight] : undefined;
            weight = weight === undefined || weight === null ? 1 : weight;
            if (!isNumber(weight))
                throw new Error("weight value must be a number for feature index " + featureIndex);
            weight = Number(weight);
            if (weight > 0) {
                coordEach$1(geom, function (coord) {
                    sumXs += coord[0] * weight;
                    sumYs += coord[1] * weight;
                    sumNs += weight;
                });
            }
        });
        return point([sumXs / sumNs, sumYs / sumNs], options.properties, options);
    }

    /**
     * Takes a {@link FeatureCollection} of points and calculates the median center,
     * algorithimically. The median center is understood as the point that is
     * requires the least total travel from all other points.
     *
     * Turfjs has four different functions for calculating the center of a set of
     * data. Each is useful depending on circumstance.
     *
     * `@turf/center` finds the simple center of a dataset, by finding the
     * midpoint between the extents of the data. That is, it divides in half the
     * farthest east and farthest west point as well as the farthest north and
     * farthest south.
     *
     * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.
     * The center of mass is where the sheet would balance on a fingertip.
     *
     * `@turf/center-mean` takes the averages of all the coordinates and
     * produces a value that respects that. Unlike `@turf/center`, it is
     * sensitive to clusters and outliers. It lands in the statistical middle of a
     * dataset, not the geographical. It can also be weighted, meaning certain
     * points are more important than others.
     *
     * `@turf/center-median` takes the mean center and tries to find, iteratively,
     * a new point that requires the least amount of travel from all the points in
     * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is
     * attracted to clustered data. It, too, can be weighted.
     *
     * **Bibliography**
     *
     * Harold W. Kuhn and Robert E. Kuenne, “An Efficient Algorithm for the
     * Numerical Solution of the Generalized Weber Problem in Spatial
     * Economics,” _Journal of Regional Science_ 4, no. 2 (1962): 21–33,
     * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.
     *
     * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary
     * Statistics for Geographers_, 3rd ed., New York: The Guilford
     * Press, 2009, 150–151.
     *
     * @name centerMedian
     * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.weight] the property name used to weight the center
     * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.
     * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.
     * @returns {Feature<Point>} The median center of the collection
     * @example
     * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);
     * var medianCenter = turf.centerMedian(points);
     *
     * //addToMap
     * var addToMap = [points, medianCenter]
     */
    function centerMedian(features, options) {
        if (options === void 0) { options = {}; }
        // Optional params
        options = options || {};
        if (!isObject(options))
            throw new Error("options is invalid");
        var counter = options.counter || 10;
        if (!isNumber(counter))
            throw new Error("counter must be a number");
        var weightTerm = options.weight;
        // Calculate mean center:
        var meanCenter = centerMean(features, { weight: options.weight });
        // Calculate center of every feature:
        var centroids = featureCollection$1([]);
        featureEach$2(features, function (feature) {
            var _a;
            centroids.features.push(centroid(feature, {
                properties: { weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm] },
            }));
        });
        var properties = {
            tolerance: options.tolerance,
            medianCandidates: [],
        };
        return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);
    }
    /**
     * Recursive function to find new candidate medians.
     *
     * @private
     * @param {Position} candidateMedian current candidate median
     * @param {Position} previousCandidate the previous candidate median
     * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining
     * @param {number} counter how many attempts to try before quitting.
     * @returns {Feature<Point>} the median center of the dataset.
     */
    function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
        var tolerance = properties.tolerance || 0.001;
        var candidateXsum = 0;
        var candidateYsum = 0;
        var kSum = 0;
        var centroidCount = 0;
        featureEach$2(centroids, function (theCentroid) {
            var _a;
            var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;
            var weight = weightValue === undefined || weightValue === null ? 1 : weightValue;
            weight = Number(weight);
            if (!isNumber(weight))
                throw new Error("weight value must be a number");
            if (weight > 0) {
                centroidCount += 1;
                var distanceFromCandidate = weight * distance$1(theCentroid, candidateMedian);
                if (distanceFromCandidate === 0)
                    distanceFromCandidate = 1;
                var k = weight / distanceFromCandidate;
                candidateXsum += theCentroid.geometry.coordinates[0] * k;
                candidateYsum += theCentroid.geometry.coordinates[1] * k;
                kSum += k;
            }
        });
        if (centroidCount < 1)
            throw new Error("no features to measure");
        var candidateX = candidateXsum / kSum;
        var candidateY = candidateYsum / kSum;
        if (centroidCount === 1 ||
            counter === 0 ||
            (Math.abs(candidateX - previousCandidate[0]) < tolerance &&
                Math.abs(candidateY - previousCandidate[1]) < tolerance)) {
            return point([candidateX, candidateY], {
                medianCandidates: properties.medianCandidates,
            });
        }
        else {
            properties.medianCandidates.push([candidateX, candidateY]);
            return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);
        }
    }

    /**
     * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,
     * also known as a “directional distribution.” The standard deviational ellipse
     * aims to show the direction and the distribution of a dataset by drawing
     * an ellipse that contains about one standard deviation’s worth (~ 70%) of the
     * data.
     *
     * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)
     * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)
     *
     * **Bibliography**
     *
     * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for
     * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,
     * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.
     *
     * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”
     * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,
     * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.
     *
     *
     * @name standardDeviationalEllipse
     * @param {FeatureCollection<Point>} points GeoJSON points
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.weight] the property name used to weight the center
     * @param {number} [options.steps=64] number of steps for the polygon
     * @param {Object} [options.properties={}] properties to pass to the resulting ellipse
     * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.
     * @example
     *
     * var bbox = [-74, 40.72, -73.98, 40.74];
     * var points = turf.randomPoint(400, {bbox: bbox});
     * var sdEllipse = turf.standardDeviationalEllipse(points);
     *
     * //addToMap
     * var addToMap = [points, sdEllipse];
     *
     */
    function standardDeviationalEllipse(points, options) {
      // Optional params
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var steps = options.steps || 64;
      var weightTerm = options.weight;
      var properties = options.properties || {};

      // Validation:
      if (!isNumber(steps)) throw new Error("steps must be a number");
      if (!isObject(properties)) throw new Error("properties must be a number");

      // Calculate mean center & number of features:
      var numberOfFeatures = coordAll$1(points).length;
      var meanCenter = centerMean(points, { weight: weightTerm });

      // Calculate angle of rotation:
      // [X, Y] = mean center of all [x, y].
      // theta = arctan( (A + B) / C )
      // A = sum((x - X)^2) - sum((y - Y)^2)
      // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))
      // C = 2(sum((x - X)(y - Y)))

      var xDeviationSquaredSum = 0;
      var yDeviationSquaredSum = 0;
      var xyDeviationSum = 0;

      featureEach$2(points, function (point) {
        var weight = point.properties[weightTerm] || 1;
        var deviation = getDeviations(getCoords(point), getCoords(meanCenter));
        xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
        yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
        xyDeviationSum += deviation.x * deviation.y * weight;
      });

      var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
      var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
      var bigC = 2 * xyDeviationSum;
      var theta = Math.atan((bigA + bigB) / bigC);
      var thetaDeg = (theta * 180) / Math.PI;

      // Calculate axes:
      // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))
      // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))
      var sigmaXsum = 0;
      var sigmaYsum = 0;
      var weightsum = 0;
      featureEach$2(points, function (point) {
        var weight = point.properties[weightTerm] || 1;
        var deviation = getDeviations(getCoords(point), getCoords(meanCenter));
        sigmaXsum +=
          Math.pow(
            deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
            2
          ) * weight;
        sigmaYsum +=
          Math.pow(
            deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
            2
          ) * weight;
        weightsum += weight;
      });

      var sigmaX = Math.sqrt((2 * sigmaXsum) / weightsum);
      var sigmaY = Math.sqrt((2 * sigmaYsum) / weightsum);

      var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {
        units: "degrees",
        angle: thetaDeg,
        steps: steps,
        properties: properties,
      });
      var pointsWithinEllipse = pointsWithinPolygon(
        points,
        featureCollection$1([theEllipse])
      );
      var standardDeviationalEllipseProperties = {
        meanCenterCoordinates: getCoords(meanCenter),
        semiMajorAxis: sigmaX,
        semiMinorAxis: sigmaY,
        numberOfFeatures: numberOfFeatures,
        angle: thetaDeg,
        percentageWithinEllipse:
          (100 * coordAll$1(pointsWithinEllipse).length) / numberOfFeatures,
      };
      theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;

      return theEllipse;
    }

    /**
     * Get x_i - X and y_i - Y
     *
     * @private
     * @param {Array} coordinates Array of [x_i, y_i]
     * @param {Array} center Array of [X, Y]
     * @returns {Object} { x: n, y: m }
     */
    function getDeviations(coordinates, center) {
      return {
        x: coordinates[0] - center[0],
        y: coordinates[1] - center[1],
      };
    }

    /**
     * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)
     * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.
     *
     * @name angle
     * @param {Coord} startPoint Start Point Coordinates
     * @param {Coord} midPoint Mid Point Coordinates
     * @param {Coord} endPoint End Point Coordinates
     * @param {Object} [options={}] Optional parameters
     * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)
     * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection
     * @returns {number} Angle between the provided points, or its explementary.
     * @example
     * turf.angle([5, 5], [5, 6], [3, 4]);
     * //=45
     */
    function angle(startPoint, midPoint, endPoint, options) {
        if (options === void 0) { options = {}; }
        // Optional Parameters
        if (!isObject(options)) {
            throw new Error("options is invalid");
        }
        // Validation
        if (!startPoint) {
            throw new Error("startPoint is required");
        }
        if (!midPoint) {
            throw new Error("midPoint is required");
        }
        if (!endPoint) {
            throw new Error("endPoint is required");
        }
        // Rename to shorter variables
        var A = startPoint;
        var O = midPoint;
        var B = endPoint;
        // Main
        var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));
        var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));
        var angleAO = Math.abs(azimuthAO - azimuthBO);
        // Explementary angle
        if (options.explementary === true) {
            return 360 - angleAO;
        }
        return angleAO;
    }

    /**
     * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).
     * Warning: may create degenerate polygons.
     *
     * @name polygonSmooth
     * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} inputPolys (Multi)Polygon(s) to smooth
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.iterations=1] THe number of times to smooth the polygon. A higher value means a smoother polygon.
     * @returns {FeatureCollection<Polygon>} FeatureCollection containing the smoothed polygon/poylgons
     * @example
     * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);
     *
     * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})
     *
     * //addToMap
     * var addToMap = [smoothed, polygon];
     */
    function polygonSmooth(inputPolys, options) {
      var outPolys = [];
      // Optional parameters
      var iterations = options.iterations || 1;
      if (!inputPolys) throw new Error("inputPolys is required");

      geomEach$1(inputPolys, function (geom, geomIndex, properties) {
        var outCoords;
        var poly;
        var tempOutput;

        switch (geom.type) {
          case "Polygon":
            outCoords = [[]];
            for (var i = 0; i < iterations; i++) {
              tempOutput = [[]];
              poly = geom;
              if (i > 0) poly = polygon(outCoords).geometry;
              processPolygon(poly, tempOutput);
              outCoords = tempOutput.slice(0);
            }
            outPolys.push(polygon(outCoords, properties));
            break;
          case "MultiPolygon":
            outCoords = [[[]]];
            for (var y = 0; y < iterations; y++) {
              tempOutput = [[[]]];
              poly = geom;
              if (y > 0) poly = multiPolygon(outCoords).geometry;
              processMultiPolygon(poly, tempOutput);
              outCoords = tempOutput.slice(0);
            }
            outPolys.push(multiPolygon(outCoords, properties));
            break;
          default:
            throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
        }
      });
      return featureCollection$1(outPolys);
    }

    /**
     * @param {poly} poly to process
     * @param {poly} tempOutput to place the results in
     * @private
     */
    function processPolygon(poly, tempOutput) {
      var prevGeomIndex = 0;
      var subtractCoordIndex = 0;

      coordEach$1(
        poly,
        function (
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        ) {
          if (geometryIndex > prevGeomIndex) {
            prevGeomIndex = geometryIndex;
            subtractCoordIndex = coordIndex;
            tempOutput.push([]);
          }
          var realCoordIndex = coordIndex - subtractCoordIndex;
          var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];
          var p0x = currentCoord[0];
          var p0y = currentCoord[1];
          var p1x = p1[0];
          var p1y = p1[1];
          tempOutput[geometryIndex].push([
            0.75 * p0x + 0.25 * p1x,
            0.75 * p0y + 0.25 * p1y,
          ]);
          tempOutput[geometryIndex].push([
            0.25 * p0x + 0.75 * p1x,
            0.25 * p0y + 0.75 * p1y,
          ]);
        },
        true
      );
      tempOutput.forEach(function (ring) {
        ring.push(ring[0]);
      });
    }

    /**
     * @param {poly} poly to process
     * @param {poly} tempOutput to place the results in
     * @private
     */
    function processMultiPolygon(poly, tempOutput) {
      var prevGeomIndex = 0;
      var subtractCoordIndex = 0;
      var prevMultiIndex = 0;

      coordEach$1(
        poly,
        function (
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        ) {
          if (multiFeatureIndex > prevMultiIndex) {
            prevMultiIndex = multiFeatureIndex;
            subtractCoordIndex = coordIndex;
            tempOutput.push([[]]);
          }
          if (geometryIndex > prevGeomIndex) {
            prevGeomIndex = geometryIndex;
            subtractCoordIndex = coordIndex;
            tempOutput[multiFeatureIndex].push([]);
          }
          var realCoordIndex = coordIndex - subtractCoordIndex;
          var p1 =
            poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];
          var p0x = currentCoord[0];
          var p0y = currentCoord[1];
          var p1x = p1[0];
          var p1y = p1[1];
          tempOutput[multiFeatureIndex][geometryIndex].push([
            0.75 * p0x + 0.25 * p1x,
            0.75 * p0y + 0.25 * p1y,
          ]);
          tempOutput[multiFeatureIndex][geometryIndex].push([
            0.25 * p0x + 0.75 * p1x,
            0.25 * p0y + 0.75 * p1y,
          ]);
        },
        true
      );

      tempOutput.forEach(function (poly) {
        poly.forEach(function (ring) {
          ring.push(ring[0]);
        });
      });
    }

    /**
     * calcualte the Minkowski p-norm distance between two features.
     * @param feature1 point feature
     * @param feature2 point feature
     * @param p p-norm 1=<p<=infinity 1: Manhattan distance 2: Euclidean distance
     */
    function pNormDistance(feature1, feature2, p) {
        if (p === void 0) { p = 2; }
        var coordinate1 = getCoord(feature1);
        var coordinate2 = getCoord(feature2);
        var xDiff = coordinate1[0] - coordinate2[0];
        var yDiff = coordinate1[1] - coordinate2[1];
        if (p === 1) {
            return Math.abs(xDiff) + Math.abs(yDiff);
        }
        return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
    }
    /**
     *
     *
     * @name distanceWeight
     * @param {FeatureCollection<any>} fc FeatureCollection.
     * @param {Object} [options] option object.
     * @param {number} [options.threshold=10000] If the distance between neighbor and
     * target features is greater than threshold, the weight of that neighbor is 0.
     * @param {number} [options.p=2] Minkowski p-norm distance parameter.
     * 1: Manhattan distance. 2: Euclidean distance. 1=<p<=infinity.
     * @param {boolean} [options.binary=false] If true, weight=1 if d <= threshold otherwise weight=0.
     *  If false, weight=Math.pow(d, alpha).
     * @param {number} [options.alpha=-1] distance decay parameter.
     * A big value means the weight decay quickly as distance increases.
     * @param {boolean} [options.standardization=false] row standardization.
     * @returns {Array<Array<number>>} distance weight matrix.
     * @example
     *
     * var bbox = [-65, 40, -63, 42];
     * var dataset = turf.randomPoint(100, { bbox: bbox });
     * var result = turf.distanceWeight(dataset);
     */
    function distanceWeight(fc, options) {
        options = options || {};
        var threshold = options.threshold || 10000;
        var p = options.p || 2;
        var binary = options.binary || false;
        var alpha = options.alpha || -1;
        var rowTransform = options.standardization || false;
        var features = [];
        featureEach$2(fc, function (feature) {
            features.push(centroid(feature));
        });
        // computing the distance between the features
        var weights = [];
        for (var i = 0; i < features.length; i++) {
            weights[i] = [];
        }
        for (var i = 0; i < features.length; i++) {
            for (var j = i; j < features.length; j++) {
                if (i === j) {
                    weights[i][j] = 0;
                }
                var dis = pNormDistance(features[i], features[j], p);
                weights[i][j] = dis;
                weights[j][i] = dis;
            }
        }
        // binary or distance decay
        for (var i = 0; i < features.length; i++) {
            for (var j = 0; j < features.length; j++) {
                var dis = weights[i][j];
                if (dis === 0) {
                    continue;
                }
                if (binary) {
                    if (dis <= threshold) {
                        weights[i][j] = 1.0;
                    }
                    else {
                        weights[i][j] = 0.0;
                    }
                }
                else {
                    if (dis <= threshold) {
                        weights[i][j] = Math.pow(dis, alpha);
                    }
                    else {
                        weights[i][j] = 0.0;
                    }
                }
            }
        }
        if (rowTransform) {
            for (var i = 0; i < features.length; i++) {
                var rowSum = weights[i].reduce(function (sum, currentVal) {
                    return sum + currentVal;
                }, 0);
                for (var j = 0; j < features.length; j++) {
                    weights[i][j] = weights[i][j] / rowSum;
                }
            }
        }
        return weights;
    }

    /**
     * Moran's I measures patterns of attribute values associated with features.
     * The method reveal whether similar values tend to occur near each other,
     * or whether high or low values are interspersed.
     *
     * Moran's I > 0 means a clusterd pattern.
     * Moran's I < 0 means a dispersed pattern.
     * Moran's I = 0 means a random pattern.
     *
     * In order to test the significance of the result. The z score is calculated.
     * A positive enough z-score (ex. >1.96) indicates clustering,
     * while a negative enough z-score (ex. <-1.96) indicates a dispersed pattern.
     *
     * the z-score can be calculated based on a normal or random assumption.
     *
     * **Bibliography***
     *
     * 1. [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I)
     *
     * 2. [pysal](http://pysal.readthedocs.io/en/latest/index.html)
     *
     * 3. Andy Mitchell, The ESRI Guide to GIS Analysis Volume 2: Spatial Measurements & Statistics.
     *
     * @name moranIndex
     * @param {FeatureCollection<any>} fc
     * @param {Object} options
     * @param {string} options.inputField the property name, must contain numeric values
     * @param {number} [options.threshold=100000] the distance threshold
     * @param {number} [options.p=2] the Minkowski p-norm distance parameter
     * @param {boolean} [options.binary=false] whether transfrom the distance to binary
     * @param {number} [options.alpha=-1] the distance decay parameter
     * @param {boolean} [options.standardization=true] wheter row standardization the distance
     * @returns {MoranIndex}
     * @example
     *
     * const bbox = [-65, 40, -63, 42];
     * const dataset = turf.randomPoint(100, { bbox: bbox });
     *
     * const result = turf.moranIndex(dataset, {
     *   inputField: 'CRIME',
     * });
     */
    function index$3 (fc, options) {
        var inputField = options.inputField;
        var threshold = options.threshold || 100000;
        var p = options.p || 2;
        var binary = options.binary || false;
        var alpha = options.alpha || -1;
        var standardization = options.standardization || true;
        var weight = distanceWeight(fc, {
            alpha: alpha,
            binary: binary,
            p: p,
            standardization: standardization,
            threshold: threshold,
        });
        var y = [];
        featureEach$2(fc, function (feature) {
            var feaProperties = feature.properties || {};
            // validate inputField exists
            y.push(feaProperties[inputField]);
        });
        var yMean = mean(y);
        var yVar = variance(y);
        var weightSum = 0;
        var s0 = 0;
        var s1 = 0;
        var s2 = 0;
        var n = weight.length;
        // validate y.length is the same as weight.length
        for (var i = 0; i < n; i++) {
            var subS2 = 0;
            for (var j = 0; j < n; j++) {
                weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);
                s0 += weight[i][j];
                s1 += Math.pow(weight[i][j] + weight[j][i], 2);
                subS2 += weight[i][j] + weight[j][i];
            }
            s2 += Math.pow(subS2, 2);
        }
        s1 = 0.5 * s1;
        var moranIndex = weightSum / s0 / yVar;
        var expectedMoranIndex = -1 / (n - 1);
        var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
        var vDen = (n - 1) * (n + 1) * (s0 * s0);
        var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
        var stdNorm = Math.sqrt(vNorm);
        var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;
        return {
            expectedMoranIndex: expectedMoranIndex,
            moranIndex: moranIndex,
            stdNorm: stdNorm,
            zNorm: zNorm,
        };
    }
    /**
     * get mean of a list
     * @param {number[]} y
     * @returns {number}
     *
     */
    function mean(y) {
        var sum = 0;
        for (var _i = 0, y_1 = y; _i < y_1.length; _i++) {
            var item = y_1[_i];
            sum += item;
        }
        return sum / y.length;
    }
    /**
     * get variance of a list
     * @param {number[]} y
     * @returns {number}
     *
     */
    function variance(y) {
        var yMean = mean(y);
        var sum = 0;
        for (var _i = 0, y_2 = y; _i < y_2.length; _i++) {
            var item = y_2[_i];
            sum += Math.pow(item - yMean, 2);
        }
        return sum / y.length;
    }
    /**
     * @typedef {Object} MoranIndex
     * @property {number} moranIndex the moran's Index of the observed feature set
     * @property {number} expectedMoranIndex the moran's Index of the random distribution
     * @property {number} stdNorm the standard devitaion of the random distribution
     * @property {number} zNorm the z-score of the observe samples with regard to the random distribution
     */

    /**
     * Converts a WGS84 GeoJSON object into Mercator (EPSG:900913) projection
     *
     * @name toMercator
     * @param {GeoJSON|Position} geojson WGS84 GeoJSON object
     * @param {Object} [options] Optional parameters
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} Projected GeoJSON
     * @example
     * var pt = turf.point([-71,41]);
     * var converted = turf.toMercator(pt);
     *
     * //addToMap
     * var addToMap = [pt, converted];
     */
    function toMercator(geojson, options) {
        if (options === void 0) { options = {}; }
        return convert(geojson, "mercator", options);
    }
    /**
     * Converts a Mercator (EPSG:900913) GeoJSON object into WGS84 projection
     *
     * @name toWgs84
     * @param {GeoJSON|Position} geojson Mercator GeoJSON object
     * @param {Object} [options] Optional parameters
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} Projected GeoJSON
     * @example
     * var pt = turf.point([-7903683.846322424, 5012341.663847514]);
     * var converted = turf.toWgs84(pt);
     *
     * //addToMap
     * var addToMap = [pt, converted];
     */
    function toWgs84(geojson, options) {
        if (options === void 0) { options = {}; }
        return convert(geojson, "wgs84", options);
    }
    /**
     * Converts a GeoJSON coordinates to the defined `projection`
     *
     * @private
     * @param {GeoJSON} geojson GeoJSON Feature or Geometry
     * @param {string} projection defines the projection system to convert the coordinates to
     * @param {Object} [options] Optional parameters
     * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} Converted GeoJSON
     */
    function convert(geojson, projection, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        options = options || {};
        var mutate = options.mutate;
        // Validation
        if (!geojson)
            throw new Error("geojson is required");
        // Handle Position
        if (Array.isArray(geojson) && isNumber(geojson[0]))
            geojson =
                projection === "mercator"
                    ? convertToMercator(geojson)
                    : convertToWgs84(geojson);
        // Handle GeoJSON
        else {
            // Handle possible data mutation
            if (mutate !== true)
                geojson = clone(geojson);
            coordEach$1(geojson, function (coord) {
                var newCoord = projection === "mercator"
                    ? convertToMercator(coord)
                    : convertToWgs84(coord);
                coord[0] = newCoord[0];
                coord[1] = newCoord[1];
            });
        }
        return geojson;
    }
    /**
     * Convert lon/lat values to 900913 x/y.
     * (from https://github.com/mapbox/sphericalmercator)
     *
     * @private
     * @param {Array<number>} lonLat WGS84 point
     * @returns {Array<number>} Mercator [x, y] point
     */
    function convertToMercator(lonLat) {
        var D2R = Math.PI / 180, 
        // 900913 properties
        A = 6378137.0, MAXEXTENT = 20037508.342789244;
        // compensate longitudes passing the 180th meridian
        // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js
        var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
        var xy = [
            A * adjusted * D2R,
            A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R)),
        ];
        // if xy value is beyond maxextent (e.g. poles), return maxextent
        if (xy[0] > MAXEXTENT)
            xy[0] = MAXEXTENT;
        if (xy[0] < -MAXEXTENT)
            xy[0] = -MAXEXTENT;
        if (xy[1] > MAXEXTENT)
            xy[1] = MAXEXTENT;
        if (xy[1] < -MAXEXTENT)
            xy[1] = -MAXEXTENT;
        return xy;
    }
    /**
     * Convert 900913 x/y values to lon/lat.
     * (from https://github.com/mapbox/sphericalmercator)
     *
     * @private
     * @param {Array<number>} xy Mercator [x, y] point
     * @returns {Array<number>} WGS84 [lon, lat] point
     */
    function convertToWgs84(xy) {
        // 900913 properties.
        var R2D = 180 / Math.PI;
        var A = 6378137.0;
        return [
            (xy[0] * R2D) / A,
            (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D,
        ];
    }
    /**
     * Returns the sign of the input, or zero
     *
     * @private
     * @param {number} x input
     * @returns {number} -1|0|1 output
     */
    function sign(x) {
        return x < 0 ? -1 : x > 0 ? 1 : 0;
    }

    var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        toMercator: toMercator,
        toWgs84: toWgs84
    });

    var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    /**
     * Returns a random position within a {@link bounding box}.
     *
     * @name randomPosition
     * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.
     * @returns {Array<number>} Position [longitude, latitude]
     * @example
     * var position = turf.randomPosition([-180, -90, 180, 90])
     * // => position
     */
    function randomPosition(bbox) {
        if (Array.isArray(bbox)) {
            return coordInBBox(bbox);
        }
        if (bbox && bbox.bbox) {
            return coordInBBox(bbox.bbox);
        }
        return [lon(), lat()];
    }
    /**
     * Returns a random {@link point}.
     *
     * @name randomPoint
     * @param {number} [count=1] how many geometries will be generated
     * @param {Object} [options={}] Optional parameters
     * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
     * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points
     * @example
     * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})
     * // => points
     */
    function randomPoint(count, options) {
        if (options === void 0) { options = {}; }
        if (count === undefined || count === null) {
            count = 1;
        }
        var features = [];
        for (var i = 0; i < count; i++) {
            features.push(point(randomPosition(options.bbox)));
        }
        return featureCollection$1(features);
    }
    /**
     * Returns a random {@link polygon}.
     *
     * @name randomPolygon
     * @param {number} [count=1] how many geometries will be generated
     * @param {Object} [options={}] Optional parameters
     * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
     * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.
     * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a
     * vertex can reach out of the center of the Polygon.
     * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons
     * @example
     * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})
     * // => polygons
     */
    function randomPolygon(count, options) {
        if (options === void 0) { options = {}; }
        // Default param
        if (count === undefined || count === null) {
            count = 1;
        }
        if (!isNumber(options.num_vertices) || options.num_vertices === undefined) {
            options.num_vertices = 10;
        }
        if (!isNumber(options.max_radial_length) ||
            options.max_radial_length === undefined) {
            options.max_radial_length = 10;
        }
        var features = [];
        var _loop_1 = function (i) {
            var vertices = [];
            var circleOffsets = __spreadArrays(Array(options.num_vertices + 1)).map(Math.random);
            // Sum Offsets
            circleOffsets.forEach(function (cur, index, arr) {
                arr[index] = index > 0 ? cur + arr[index - 1] : cur;
            });
            // scaleOffsets
            circleOffsets.forEach(function (cur) {
                cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];
                var radialScaler = Math.random();
                vertices.push([
                    radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
                    radialScaler * (options.max_radial_length || 10) * Math.cos(cur),
                ]);
            });
            vertices[vertices.length - 1] = vertices[0]; // close the ring
            // center the polygon around something
            vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));
            features.push(polygon([vertices]));
        };
        for (var i = 0; i < count; i++) {
            _loop_1();
        }
        return featureCollection$1(features);
    }
    /**
     * Returns a random {@link linestring}.
     *
     * @name randomLineString
     * @param {number} [count=1] how many geometries will be generated
     * @param {Object} [options={}] Optional parameters
     * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.
     * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.
     * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a
     * vertex can be from its predecessor
     * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a
     * line segment can turn from the previous segment.
     * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings
     * @example
     * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})
     * // => lineStrings
     */
    function randomLineString(count, options) {
        if (options === void 0) { options = {}; }
        // Optional parameters
        options = options || {};
        if (!isObject(options)) {
            throw new Error("options is invalid");
        }
        var bbox = options.bbox;
        var num_vertices = options.num_vertices;
        var max_length = options.max_length;
        var max_rotation = options.max_rotation;
        if (count === undefined || count === null) {
            count = 1;
        }
        // Default parameters
        if (!isNumber(num_vertices) ||
            num_vertices === undefined ||
            num_vertices < 2) {
            num_vertices = 10;
        }
        if (!isNumber(max_length) || max_length === undefined) {
            max_length = 0.0001;
        }
        if (!isNumber(max_rotation) || max_rotation === undefined) {
            max_rotation = Math.PI / 8;
        }
        var features = [];
        for (var i = 0; i < count; i++) {
            var startingPoint = randomPosition(bbox);
            var vertices = [startingPoint];
            for (var j = 0; j < num_vertices - 1; j++) {
                var priorAngle = j === 0
                    ? Math.random() * 2 * Math.PI
                    : Math.tan((vertices[j][1] - vertices[j - 1][1]) /
                        (vertices[j][0] - vertices[j - 1][0]));
                var angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
                var distance = Math.random() * max_length;
                vertices.push([
                    vertices[j][0] + distance * Math.cos(angle),
                    vertices[j][1] + distance * Math.sin(angle),
                ]);
            }
            features.push(lineString(vertices));
        }
        return featureCollection$1(features);
    }
    function vertexToCoordinate(hub) {
        return function (cur) {
            return [cur[0] + hub[0], cur[1] + hub[1]];
        };
    }
    function rnd() {
        return Math.random() - 0.5;
    }
    function lon() {
        return rnd() * 360;
    }
    function lat() {
        return rnd() * 180;
    }
    function coordInBBox(bbox) {
        return [
            Math.random() * (bbox[2] - bbox[0]) + bbox[0],
            Math.random() * (bbox[3] - bbox[1]) + bbox[1],
        ];
    }

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        randomPosition: randomPosition,
        randomPoint: randomPoint,
        randomPolygon: randomPolygon,
        randomLineString: randomLineString
    });

    /**
     * Get Cluster
     *
     * @name getCluster
     * @param {FeatureCollection} geojson GeoJSON Features
     * @param {*} filter Filter used on GeoJSON properties to get Cluster
     * @returns {FeatureCollection} Single Cluster filtered by GeoJSON Properties
     * @example
     * var geojson = turf.featureCollection([
     *     turf.point([0, 0], {'marker-symbol': 'circle'}),
     *     turf.point([2, 4], {'marker-symbol': 'star'}),
     *     turf.point([3, 6], {'marker-symbol': 'star'}),
     *     turf.point([5, 1], {'marker-symbol': 'square'}),
     *     turf.point([4, 2], {'marker-symbol': 'circle'})
     * ]);
     *
     * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
     * var clustered = turf.clustersKmeans(geojson);
     *
     * // Retrieve first cluster (0)
     * var cluster = turf.getCluster(clustered, {cluster: 0});
     * //= cluster
     *
     * // Retrieve cluster based on custom properties
     * turf.getCluster(clustered, {'marker-symbol': 'circle'}).length;
     * //= 2
     * turf.getCluster(clustered, {'marker-symbol': 'square'}).length;
     * //= 1
     */
    function getCluster(geojson, filter) {
        // Validation
        if (!geojson)
            throw new Error("geojson is required");
        if (geojson.type !== "FeatureCollection")
            throw new Error("geojson must be a FeatureCollection");
        if (filter === undefined || filter === null)
            throw new Error("filter is required");
        // Filter Features
        var features = [];
        featureEach$2(geojson, function (feature) {
            if (applyFilter(feature.properties, filter))
                features.push(feature);
        });
        return featureCollection$1(features);
    }
    /**
     * Callback for clusterEach
     *
     * @callback clusterEachCallback
     * @param {FeatureCollection} [cluster] The current cluster being processed.
     * @param {*} [clusterValue] Value used to create cluster being processed.
     * @param {number} [currentIndex] The index of the current element being processed in the array.Starts at index 0
     * @returns {void}
     */
    /**
     * clusterEach
     *
     * @name clusterEach
     * @param {FeatureCollection} geojson GeoJSON Features
     * @param {string|number} property GeoJSON property key/value used to create clusters
     * @param {Function} callback a method that takes (cluster, clusterValue, currentIndex)
     * @returns {void}
     * @example
     * var geojson = turf.featureCollection([
     *     turf.point([0, 0]),
     *     turf.point([2, 4]),
     *     turf.point([3, 6]),
     *     turf.point([5, 1]),
     *     turf.point([4, 2])
     * ]);
     *
     * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
     * var clustered = turf.clustersKmeans(geojson);
     *
     * // Iterate over each cluster
     * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue, currentIndex) {
     *     //= cluster
     *     //= clusterValue
     *     //= currentIndex
     * })
     *
     * // Calculate the total number of clusters
     * var total = 0
     * turf.clusterEach(clustered, 'cluster', function () {
     *     total++;
     * });
     *
     * // Create an Array of all the values retrieved from the 'cluster' property
     * var values = []
     * turf.clusterEach(clustered, 'cluster', function (cluster, clusterValue) {
     *     values.push(clusterValue);
     * });
     */
    function clusterEach(geojson, property, callback) {
        // Validation
        if (!geojson)
            throw new Error("geojson is required");
        if (geojson.type !== "FeatureCollection")
            throw new Error("geojson must be a FeatureCollection");
        if (property === undefined || property === null)
            throw new Error("property is required");
        // Create clusters based on property values
        var bins = createBins(geojson, property);
        var values = Object.keys(bins);
        for (var index = 0; index < values.length; index++) {
            var value = values[index];
            var bin = bins[value];
            var features = [];
            for (var i = 0; i < bin.length; i++) {
                features.push(geojson.features[bin[i]]);
            }
            callback(featureCollection$1(features), value, index);
        }
    }
    /**
     * Callback for clusterReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback clusterReduceCallback
     * @param {*} [previousValue] The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {FeatureCollection} [cluster] The current cluster being processed.
     * @param {*} [clusterValue] Value used to create cluster being processed.
     * @param {number} [currentIndex] The index of the current element being processed in the
     * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */
    /**
     * Reduce clusters in GeoJSON Features, similar to Array.reduce()
     *
     * @name clusterReduce
     * @param {FeatureCollection} geojson GeoJSON Features
     * @param {string|number} property GeoJSON property key/value used to create clusters
     * @param {Function} callback a method that takes (previousValue, cluster, clusterValue, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var geojson = turf.featureCollection([
     *     turf.point([0, 0]),
     *     turf.point([2, 4]),
     *     turf.point([3, 6]),
     *     turf.point([5, 1]),
     *     turf.point([4, 2])
     * ]);
     *
     * // Create a cluster using K-Means (adds `cluster` to GeoJSON properties)
     * var clustered = turf.clustersKmeans(geojson);
     *
     * // Iterate over each cluster and perform a calculation
     * var initialValue = 0
     * turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue, currentIndex) {
     *     //=previousValue
     *     //=cluster
     *     //=clusterValue
     *     //=currentIndex
     *     return previousValue++;
     * }, initialValue);
     *
     * // Calculate the total number of clusters
     * var total = turf.clusterReduce(clustered, 'cluster', function (previousValue) {
     *     return previousValue++;
     * }, 0);
     *
     * // Create an Array of all the values retrieved from the 'cluster' property
     * var values = turf.clusterReduce(clustered, 'cluster', function (previousValue, cluster, clusterValue) {
     *     return previousValue.concat(clusterValue);
     * }, []);
     */
    function clusterReduce(geojson, property, callback, initialValue) {
        var previousValue = initialValue;
        clusterEach(geojson, property, function (cluster, clusterValue, currentIndex) {
            if (currentIndex === 0 && initialValue === undefined)
                previousValue = cluster;
            else
                previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
        });
        return previousValue;
    }
    /**
     * Create Bins
     *
     * @private
     * @param {FeatureCollection} geojson GeoJSON Features
     * @param {string|number} property Property values are used to create bins
     * @returns {Object} bins with Feature IDs
     * @example
     * var geojson = turf.featureCollection([
     *     turf.point([0, 0], {cluster: 0, foo: 'null'}),
     *     turf.point([2, 4], {cluster: 1, foo: 'bar'}),
     *     turf.point([5, 1], {0: 'foo'}),
     *     turf.point([3, 6], {cluster: 1}),
     * ]);
     * createBins(geojson, 'cluster');
     * //= { '0': [ 0 ], '1': [ 1, 3 ] }
     */
    function createBins(geojson, property) {
        var bins = {};
        featureEach$2(geojson, function (feature, i) {
            var properties = feature.properties || {};
            if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
                var value = properties[property];
                if (Object.prototype.hasOwnProperty.call(bins, value))
                    bins[value].push(i);
                else
                    bins[value] = [i];
            }
        });
        return bins;
    }
    /**
     * Apply Filter
     *
     * @private
     * @param {*} properties Properties
     * @param {*} filter Filter
     * @returns {boolean} applied Filter to properties
     */
    function applyFilter(properties, filter) {
        if (properties === undefined)
            return false;
        var filterType = typeof filter;
        // String & Number
        if (filterType === "number" || filterType === "string")
            return Object.prototype.hasOwnProperty.call(properties, filter);
        // Array
        else if (Array.isArray(filter)) {
            for (var i = 0; i < filter.length; i++) {
                if (!applyFilter(properties, filter[i]))
                    return false;
            }
            return true;
            // Object
        }
        else {
            return propertiesContainsFilter(properties, filter);
        }
    }
    /**
     * Properties contains filter (does not apply deepEqual operations)
     *
     * @private
     * @param {*} properties Properties
     * @param {Object} filter Filter
     * @returns {boolean} does filter equal Properties
     * @example
     * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 0})
     * //= true
     * propertiesContainsFilter({foo: 'bar', cluster: 0}, {cluster: 1})
     * //= false
     */
    function propertiesContainsFilter(properties, filter) {
        var keys = Object.keys(filter);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (properties[key] !== filter[key])
                return false;
        }
        return true;
    }
    /**
     * Filter Properties
     *
     * @private
     * @param {*} properties Properties
     * @param {Array<string>} keys Used to filter Properties
     * @returns {*} filtered Properties
     * @example
     * filterProperties({foo: 'bar', cluster: 0}, ['cluster'])
     * //= {cluster: 0}
     */
    function filterProperties(properties, keys) {
        if (!keys)
            return {};
        if (!keys.length)
            return {};
        var newProperties = {};
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (Object.prototype.hasOwnProperty.call(properties, key))
                newProperties[key] = properties[key];
        }
        return newProperties;
    }

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCluster: getCluster,
        clusterEach: clusterEach,
        clusterReduce: clusterReduce,
        createBins: createBins,
        applyFilter: applyFilter,
        propertiesContainsFilter: propertiesContainsFilter,
        filterProperties: filterProperties
    });

    var polygonClipping_umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        /**
         * splaytree v3.1.2
         * Fast Splay tree for Node and browser
         *
         * @author Alexander Milevski <info@w8r.name>
         * @license MIT
         * @preserve
         */

        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */

        function __generator(thisArg, body) {
          var _ = {
              label: 0,
              sent: function () {
                if (t[0] & 1) throw t[1];
                return t[1];
              },
              trys: [],
              ops: []
            },
            f,
            y,
            t,
            g;
          return g = {
            next: verb(0),
            "throw": verb(1),
            "return": verb(2)
          }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
            return this;
          }), g;
          function verb(n) {
            return function (v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return {
                    value: op[1],
                    done: false
                  };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2]) _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true
            };
          }
        }
        var Node = /** @class */function () {
          function Node(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
          }
          return Node;
        }();

        /* follows "An implementation of top-down splaying"
         * by D. Sleator <sleator@cs.cmu.edu> March 1992
         */
        function DEFAULT_COMPARE(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        /**
         * Simple top down splay, not requiring i to be in the tree t.
         */
        function splay(i, t, comparator) {
          var N = new Node(null, null);
          var l = N;
          var r = N;
          while (true) {
            var cmp = comparator(i, t.key);
            //if (i < t.key) {
            if (cmp < 0) {
              if (t.left === null) break;
              //if (i < t.left.key) {
              if (comparator(i, t.left.key) < 0) {
                var y = t.left; /* rotate right */
                t.left = y.right;
                y.right = t;
                t = y;
                if (t.left === null) break;
              }
              r.left = t; /* link right */
              r = t;
              t = t.left;
              //} else if (i > t.key) {
            } else if (cmp > 0) {
              if (t.right === null) break;
              //if (i > t.right.key) {
              if (comparator(i, t.right.key) > 0) {
                var y = t.right; /* rotate left */
                t.right = y.left;
                y.left = t;
                t = y;
                if (t.right === null) break;
              }
              l.right = t; /* link left */
              l = t;
              t = t.right;
            } else break;
          }
          /* assemble */
          l.right = t.left;
          r.left = t.right;
          t.left = N.right;
          t.right = N.left;
          return t;
        }
        function insert(i, data, t, comparator) {
          var node = new Node(i, data);
          if (t === null) {
            node.left = node.right = null;
            return node;
          }
          t = splay(i, t, comparator);
          var cmp = comparator(i, t.key);
          if (cmp < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          return node;
        }
        function split(key, v, comparator) {
          var left = null;
          var right = null;
          if (v) {
            v = splay(key, v, comparator);
            var cmp = comparator(v.key, key);
            if (cmp === 0) {
              left = v.left;
              right = v.right;
            } else if (cmp < 0) {
              right = v.right;
              v.right = null;
              left = v;
            } else {
              left = v.left;
              v.left = null;
              right = v;
            }
          }
          return {
            left: left,
            right: right
          };
        }
        function merge(left, right, comparator) {
          if (right === null) return left;
          if (left === null) return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        /**
         * Prints level of the tree
         */
        function printRow(root, prefix, isTail, out, printNode) {
          if (root) {
            out("" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + "\n");
            var indent = prefix + (isTail ? '    ' : '│   ');
            if (root.left) printRow(root.left, indent, false, out, printNode);
            if (root.right) printRow(root.right, indent, true, out, printNode);
          }
        }
        var Tree = /** @class */function () {
          function Tree(comparator) {
            if (comparator === void 0) {
              comparator = DEFAULT_COMPARE;
            }
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
          }
          /**
           * Inserts a key, allows duplicates
           */
          Tree.prototype.insert = function (key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
          };
          /**
           * Adds a key, if it is not present in the tree
           */
          Tree.prototype.add = function (key, data) {
            var node = new Node(key, data);
            if (this._root === null) {
              node.left = node.right = null;
              this._size++;
              this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key, this._root, comparator);
            var cmp = comparator(key, t.key);
            if (cmp === 0) this._root = t;else {
              if (cmp < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
              } else if (cmp > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
              }
              this._size++;
              this._root = node;
            }
            return this._root;
          };
          /**
           * @param  {Key} key
           * @return {Node|null}
           */
          Tree.prototype.remove = function (key) {
            this._root = this._remove(key, this._root, this._comparator);
          };
          /**
           * Deletes i from the tree if it's there
           */
          Tree.prototype._remove = function (i, t, comparator) {
            var x;
            if (t === null) return null;
            t = splay(i, t, comparator);
            var cmp = comparator(i, t.key);
            if (cmp === 0) {
              /* found it */
              if (t.left === null) {
                x = t.right;
              } else {
                x = splay(i, t.left, comparator);
                x.right = t.right;
              }
              this._size--;
              return x;
            }
            return t; /* It wasn't there */
          };
          /**
           * Removes and returns the node with smallest key
           */
          Tree.prototype.pop = function () {
            var node = this._root;
            if (node) {
              while (node.left) node = node.left;
              this._root = splay(node.key, this._root, this._comparator);
              this._root = this._remove(node.key, this._root, this._comparator);
              return {
                key: node.key,
                data: node.data
              };
            }
            return null;
          };
          /**
           * Find without splaying
           */
          Tree.prototype.findStatic = function (key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp = compare(key, current.key);
              if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;
            }
            return null;
          };
          Tree.prototype.find = function (key) {
            if (this._root) {
              this._root = splay(key, this._root, this._comparator);
              if (this._comparator(key, this._root.key) !== 0) return null;
            }
            return this._root;
          };
          Tree.prototype.contains = function (key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp = compare(key, current.key);
              if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;
            }
            return false;
          };
          Tree.prototype.forEach = function (visitor, ctx) {
            var current = this._root;
            var Q = []; /* Initialize stack s */
            var done = false;
            while (!done) {
              if (current !== null) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length !== 0) {
                  current = Q.pop();
                  visitor.call(ctx, current);
                  current = current.right;
                } else done = true;
              }
            }
            return this;
          };
          /**
           * Walk key range from `low` to `high`. Stops if `fn` returns a value.
           */
          Tree.prototype.range = function (low, high, fn, ctx) {
            var Q = [];
            var compare = this._comparator;
            var node = this._root;
            var cmp;
            while (Q.length !== 0 || node) {
              if (node) {
                Q.push(node);
                node = node.left;
              } else {
                node = Q.pop();
                cmp = compare(node.key, high);
                if (cmp > 0) {
                  break;
                } else if (compare(node.key, low) >= 0) {
                  if (fn.call(ctx, node)) return this; // stop if smth is returned
                }
                node = node.right;
              }
            }
            return this;
          };
          /**
           * Returns array of keys
           */
          Tree.prototype.keys = function () {
            var keys = [];
            this.forEach(function (_a) {
              var key = _a.key;
              return keys.push(key);
            });
            return keys;
          };
          /**
           * Returns array of all the data in the nodes
           */
          Tree.prototype.values = function () {
            var values = [];
            this.forEach(function (_a) {
              var data = _a.data;
              return values.push(data);
            });
            return values;
          };
          Tree.prototype.min = function () {
            if (this._root) return this.minNode(this._root).key;
            return null;
          };
          Tree.prototype.max = function () {
            if (this._root) return this.maxNode(this._root).key;
            return null;
          };
          Tree.prototype.minNode = function (t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t) while (t.left) t = t.left;
            return t;
          };
          Tree.prototype.maxNode = function (t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t) while (t.right) t = t.right;
            return t;
          };
          /**
           * Returns node at given index
           */
          Tree.prototype.at = function (index) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while (!done) {
              if (current) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length > 0) {
                  current = Q.pop();
                  if (i === index) return current;
                  i++;
                  current = current.right;
                } else done = true;
              }
            }
            return null;
          };
          Tree.prototype.next = function (d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
              successor = d.right;
              while (successor.left) successor = successor.left;
              return successor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp = comparator(d.key, root.key);
              if (cmp === 0) break;else if (cmp < 0) {
                successor = root;
                root = root.left;
              } else root = root.right;
            }
            return successor;
          };
          Tree.prototype.prev = function (d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
              predecessor = d.left;
              while (predecessor.right) predecessor = predecessor.right;
              return predecessor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp = comparator(d.key, root.key);
              if (cmp === 0) break;else if (cmp < 0) root = root.left;else {
                predecessor = root;
                root = root.right;
              }
            }
            return predecessor;
          };
          Tree.prototype.clear = function () {
            this._root = null;
            this._size = 0;
            return this;
          };
          Tree.prototype.toList = function () {
            return toList(this._root);
          };
          /**
           * Bulk-load items. Both array have to be same size
           */
          Tree.prototype.load = function (keys, values, presort) {
            if (values === void 0) {
              values = [];
            }
            if (presort === void 0) {
              presort = false;
            }
            var size = keys.length;
            var comparator = this._comparator;
            // sort if needed
            if (presort) sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
              // empty tree
              this._root = loadRecursive(keys, values, 0, size);
              this._size = size;
            } else {
              // that re-builds the whole tree from two in-order traversals
              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
              size = this._size + size;
              this._root = sortedListToBST({
                head: mergedList
              }, 0, size);
            }
            return this;
          };
          Tree.prototype.isEmpty = function () {
            return this._root === null;
          };
          Object.defineProperty(Tree.prototype, "size", {
            get: function () {
              return this._size;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Tree.prototype, "root", {
            get: function () {
              return this._root;
            },
            enumerable: true,
            configurable: true
          });
          Tree.prototype.toString = function (printNode) {
            if (printNode === void 0) {
              printNode = function (n) {
                return String(n.key);
              };
            }
            var out = [];
            printRow(this._root, '', true, function (v) {
              return out.push(v);
            }, printNode);
            return out.join('');
          };
          Tree.prototype.update = function (key, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key, this._root, comparator),
              left = _a.left,
              right = _a.right;
            if (comparator(key, newKey) < 0) {
              right = insert(newKey, newData, right, comparator);
            } else {
              left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
          };
          Tree.prototype.split = function (key) {
            return split(key, this._root, this._comparator);
          };
          Tree.prototype[Symbol.iterator] = function () {
            var current, Q, done;
            return __generator(this, function (_a) {
              switch (_a.label) {
                case 0:
                  current = this._root;
                  Q = [];
                  done = false;
                  _a.label = 1;
                case 1:
                  if (!!done) return [3 /*break*/, 6];
                  if (!(current !== null)) return [3 /*break*/, 2];
                  Q.push(current);
                  current = current.left;
                  return [3 /*break*/, 5];
                case 2:
                  if (!(Q.length !== 0)) return [3 /*break*/, 4];
                  current = Q.pop();
                  return [4 /*yield*/, current];
                case 3:
                  _a.sent();
                  current = current.right;
                  return [3 /*break*/, 5];
                case 4:
                  done = true;
                  _a.label = 5;
                case 5:
                  return [3 /*break*/, 1];
                case 6:
                  return [2 /*return*/];
              }
            });
          };
          return Tree;
        }();
        function loadRecursive(keys, values, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var key = keys[middle];
            var data = values[middle];
            var node = new Node(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys, values) {
          var head = new Node(null, null);
          var p = head;
          for (var i = 0; i < keys.length; i++) {
            p = p.next = new Node(keys[i], values[i]);
          }
          p.next = null;
          return head.next;
        }
        function toList(root) {
          var current = root;
          var Q = [];
          var done = false;
          var head = new Node(null, null);
          var p = head;
          while (!done) {
            if (current) {
              Q.push(current);
              current = current.left;
            } else {
              if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
              } else done = true;
            }
          }
          p.next = null; // that'll work even if the tree was empty
          return head.next;
        }
        function sortedListToBST(list, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var left = sortedListToBST(list, start, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
          }
          return null;
        }
        function mergeLists(l1, l2, compare) {
          var head = new Node(null, null); // dummy
          var p = head;
          var p1 = l1;
          var p2 = l2;
          while (p1 !== null && p2 !== null) {
            if (compare(p1.key, p2.key) < 0) {
              p.next = p1;
              p1 = p1.next;
            } else {
              p.next = p2;
              p2 = p2.next;
            }
            p = p.next;
          }
          if (p1 !== null) {
            p.next = p1;
          } else if (p2 !== null) {
            p.next = p2;
          }
          return head.next;
        }
        function sort(keys, values, left, right, compare) {
          if (left >= right) return;
          var pivot = keys[left + right >> 1];
          var i = left - 1;
          var j = right + 1;
          while (true) {
            do i++; while (compare(keys[i], pivot) < 0);
            do j--; while (compare(keys[j], pivot) > 0);
            if (i >= j) break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
          }
          sort(keys, values, left, j, compare);
          sort(keys, values, j + 1, right, compare);
        }

        /**
         * A bounding box has the format:
         *
         *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
         *
         */

        const isInBbox = (bbox, point) => {
          return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
        };

        /* Returns either null, or a bbox (aka an ordered pair of points)
         * If there is only one point of overlap, a bbox with identical points
         * will be returned */
        const getBboxOverlap = (b1, b2) => {
          // check if the bboxes overlap at all
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;

          // find the middle two X values
          const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;

          // find the middle two Y values
          const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;

          // put those middle values together to get the overlap
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };

        /* Javascript doesn't do integer math. Everything is
         * floating point with percision Number.EPSILON.
         *
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
         */

        let epsilon$1 = Number.EPSILON;

        // IE Polyfill
        if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);
        const EPSILON_SQ = epsilon$1 * epsilon$1;

        /* FLP comparator */
        const cmp = (a, b) => {
          // check if they're both 0
          if (-epsilon$1 < a && a < epsilon$1) {
            if (-epsilon$1 < b && b < epsilon$1) {
              return 0;
            }
          }

          // check if they're flp equal
          const ab = a - b;
          if (ab * ab < EPSILON_SQ * a * b) {
            return 0;
          }

          // normal comparison
          return a < b ? -1 : 1;
        };

        /**
         * This class rounds incoming values sufficiently so that
         * floating points problems are, for the most part, avoided.
         *
         * Incoming points are have their x & y values tested against
         * all previously seen x & y values. If either is 'too close'
         * to a previously seen value, it's value is 'snapped' to the
         * previously seen value.
         *
         * All points should be rounded by this class before being
         * stored in any data structures in the rest of this algorithm.
         */

        class PtRounder {
          constructor() {
            this.reset();
          }
          reset() {
            this.xRounder = new CoordRounder();
            this.yRounder = new CoordRounder();
          }
          round(x, y) {
            return {
              x: this.xRounder.round(x),
              y: this.yRounder.round(y)
            };
          }
        }
        class CoordRounder {
          constructor() {
            this.tree = new Tree();
            // preseed with 0 so we don't end up with values < Number.EPSILON
            this.round(0);
          }

          // Note: this can rounds input values backwards or forwards.
          //       You might ask, why not restrict this to just rounding
          //       forwards? Wouldn't that allow left endpoints to always
          //       remain left endpoints during splitting (never change to
          //       right). No - it wouldn't, because we snap intersections
          //       to endpoints (to establish independence from the segment
          //       angle for t-intersections).
          round(coord) {
            const node = this.tree.add(coord);
            const prevNode = this.tree.prev(node);
            if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
              this.tree.remove(coord);
              return prevNode.key;
            }
            const nextNode = this.tree.next(node);
            if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
              this.tree.remove(coord);
              return nextNode.key;
            }
            return coord;
          }
        }

        // singleton available by import
        const rounder = new PtRounder();

        const epsilon = 1.1102230246251565e-16;
        const splitter = 134217729;
        const resulterrbound = (3 + 8 * epsilon) * epsilon;

        // fast_expansion_sum_zeroelim routine from oritinal code
        function sum(elen, e, flen, f, h) {
          let Q, Qnew, hh, bvirt;
          let enow = e[0];
          let fnow = f[0];
          let eindex = 0;
          let findex = 0;
          if (fnow > enow === fnow > -enow) {
            Q = enow;
            enow = e[++eindex];
          } else {
            Q = fnow;
            fnow = f[++findex];
          }
          let hindex = 0;
          if (eindex < elen && findex < flen) {
            if (fnow > enow === fnow > -enow) {
              Qnew = enow + Q;
              hh = Q - (Qnew - enow);
              enow = e[++eindex];
            } else {
              Qnew = fnow + Q;
              hh = Q - (Qnew - fnow);
              fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
              h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
              if (fnow > enow === fnow > -enow) {
                Qnew = Q + enow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (enow - bvirt);
                enow = e[++eindex];
              } else {
                Qnew = Q + fnow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f[++findex];
              }
              Q = Qnew;
              if (hh !== 0) {
                h[hindex++] = hh;
              }
            }
          }
          while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
              h[hindex++] = hh;
            }
          }
          while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
              h[hindex++] = hh;
            }
          }
          if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
          }
          return hindex;
        }
        function estimate(elen, e) {
          let Q = e[0];
          for (let i = 1; i < elen; i++) Q += e[i];
          return Q;
        }
        function vec(n) {
          return new Float64Array(n);
        }

        const ccwerrboundA = (3 + 16 * epsilon) * epsilon;
        const ccwerrboundB = (2 + 12 * epsilon) * epsilon;
        const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
        const B = vec(4);
        const C1 = vec(8);
        const C2 = vec(12);
        const D = vec(16);
        const u = vec(4);
        function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
          let acxtail, acytail, bcxtail, bcytail;
          let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
          const acx = ax - cx;
          const bcx = bx - cx;
          const acy = ay - cy;
          const bcy = by - cy;
          s1 = acx * bcy;
          c = splitter * acx;
          ahi = c - (c - acx);
          alo = acx - ahi;
          c = splitter * bcy;
          bhi = c - (c - bcy);
          blo = bcy - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acy * bcx;
          c = splitter * acy;
          ahi = c - (c - acy);
          alo = acy - ahi;
          c = splitter * bcx;
          bhi = c - (c - bcx);
          blo = bcx - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          B[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          B[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          B[2] = _j - (u3 - bvirt) + (_i - bvirt);
          B[3] = u3;
          let det = estimate(4, B);
          let errbound = ccwerrboundB * detsum;
          if (det >= errbound || -det >= errbound) {
            return det;
          }
          bvirt = ax - acx;
          acxtail = ax - (acx + bvirt) + (bvirt - cx);
          bvirt = bx - bcx;
          bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
          bvirt = ay - acy;
          acytail = ay - (acy + bvirt) + (bvirt - cy);
          bvirt = by - bcy;
          bcytail = by - (bcy + bvirt) + (bvirt - cy);
          if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
          }
          errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
          det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
          if (det >= errbound || -det >= errbound) return det;
          s1 = acxtail * bcy;
          c = splitter * acxtail;
          ahi = c - (c - acxtail);
          alo = acxtail - ahi;
          c = splitter * bcy;
          bhi = c - (c - bcy);
          blo = bcy - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acytail * bcx;
          c = splitter * acytail;
          ahi = c - (c - acytail);
          alo = acytail - ahi;
          c = splitter * bcx;
          bhi = c - (c - bcx);
          blo = bcx - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          u[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          u[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          u[2] = _j - (u3 - bvirt) + (_i - bvirt);
          u[3] = u3;
          const C1len = sum(4, B, 4, u, C1);
          s1 = acx * bcytail;
          c = splitter * acx;
          ahi = c - (c - acx);
          alo = acx - ahi;
          c = splitter * bcytail;
          bhi = c - (c - bcytail);
          blo = bcytail - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acy * bcxtail;
          c = splitter * acy;
          ahi = c - (c - acy);
          alo = acy - ahi;
          c = splitter * bcxtail;
          bhi = c - (c - bcxtail);
          blo = bcxtail - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          u[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          u[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          u[2] = _j - (u3 - bvirt) + (_i - bvirt);
          u[3] = u3;
          const C2len = sum(C1len, C1, 4, u, C2);
          s1 = acxtail * bcytail;
          c = splitter * acxtail;
          ahi = c - (c - acxtail);
          alo = acxtail - ahi;
          c = splitter * bcytail;
          bhi = c - (c - bcytail);
          blo = bcytail - bhi;
          s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
          t1 = acytail * bcxtail;
          c = splitter * acytail;
          ahi = c - (c - acytail);
          alo = acytail - ahi;
          c = splitter * bcxtail;
          bhi = c - (c - bcxtail);
          blo = bcxtail - bhi;
          t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
          _i = s0 - t0;
          bvirt = s0 - _i;
          u[0] = s0 - (_i + bvirt) + (bvirt - t0);
          _j = s1 + _i;
          bvirt = _j - s1;
          _0 = s1 - (_j - bvirt) + (_i - bvirt);
          _i = _0 - t1;
          bvirt = _0 - _i;
          u[1] = _0 - (_i + bvirt) + (bvirt - t1);
          u3 = _j + _i;
          bvirt = u3 - _j;
          u[2] = _j - (u3 - bvirt) + (_i - bvirt);
          u[3] = u3;
          const Dlen = sum(C2len, C2, 4, u, D);
          return D[Dlen - 1];
        }
        function orient2d(ax, ay, bx, by, cx, cy) {
          const detleft = (ay - cy) * (bx - cx);
          const detright = (ax - cx) * (by - cy);
          const det = detleft - detright;
          const detsum = Math.abs(detleft + detright);
          if (Math.abs(det) >= ccwerrboundA * detsum) return det;
          return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
        }

        /* Cross Product of two vectors with first point at origin */
        const crossProduct = (a, b) => a.x * b.y - a.y * b.x;

        /* Dot Product of two vectors with first point at origin */
        const dotProduct = (a, b) => a.x * b.x + a.y * b.y;

        /* Comparator for two vectors with same starting point */
        const compareVectorAngles = (basePt, endPt1, endPt2) => {
          const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
          if (res > 0) return -1;
          if (res < 0) return 1;
          return 0;
        };
        const length = v => Math.sqrt(dotProduct(v, v));

        /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */
        const sineOfAngle = (pShared, pBase, pAngle) => {
          const vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          const vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
        };

        /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */
        const cosineOfAngle = (pShared, pBase, pAngle) => {
          const vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          const vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
        };

        /* Get the x coordinate where the given line (defined by a point and vector)
         * crosses the horizontal line with the given y coordiante.
         * In the case of parrallel lines (including overlapping ones) returns null. */
        const horizontalIntersection = (pt, v, y) => {
          if (v.y === 0) return null;
          return {
            x: pt.x + v.x / v.y * (y - pt.y),
            y: y
          };
        };

        /* Get the y coordinate where the given line (defined by a point and vector)
         * crosses the vertical line with the given x coordiante.
         * In the case of parrallel lines (including overlapping ones) returns null. */
        const verticalIntersection = (pt, v, x) => {
          if (v.x === 0) return null;
          return {
            x: x,
            y: pt.y + v.y / v.x * (x - pt.x)
          };
        };

        /* Get the intersection of two lines, each defined by a base point and a vector.
         * In the case of parrallel lines (including overlapping ones) returns null. */
        const intersection$1 = (pt1, v1, pt2, v2) => {
          // take some shortcuts for vertical and horizontal lines
          // this also ensures we don't calculate an intersection and then discover
          // it's actually outside the bounding box of the line
          if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
          if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
          if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
          if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);

          // General case for non-overlapping segments.
          // This algorithm is based on Schneider and Eberly.
          // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

          const kross = crossProduct(v1, v2);
          if (kross == 0) return null;
          const ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          const d1 = crossProduct(ve, v1) / kross;
          const d2 = crossProduct(ve, v2) / kross;

          // take the average of the two calculations to minimize rounding error
          const x1 = pt1.x + d2 * v1.x,
            x2 = pt2.x + d1 * v2.x;
          const y1 = pt1.y + d2 * v1.y,
            y2 = pt2.y + d1 * v2.y;
          const x = (x1 + x2) / 2;
          const y = (y1 + y2) / 2;
          return {
            x: x,
            y: y
          };
        };

        class SweepEvent {
          // for ordering sweep events in the sweep event queue
          static compare(a, b) {
            // favor event with a point that the sweep line hits first
            const ptCmp = SweepEvent.comparePoints(a.point, b.point);
            if (ptCmp !== 0) return ptCmp;

            // the points are the same, so link them if needed
            if (a.point !== b.point) a.link(b);

            // favor right events over left
            if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;

            // we have two matching left or right endpoints
            // ordering of this case is the same as for their segments
            return Segment.compare(a.segment, b.segment);
          }

          // for ordering points in sweep line order
          static comparePoints(aPt, bPt) {
            if (aPt.x < bPt.x) return -1;
            if (aPt.x > bPt.x) return 1;
            if (aPt.y < bPt.y) return -1;
            if (aPt.y > bPt.y) return 1;
            return 0;
          }

          // Warning: 'point' input will be modified and re-used (for performance)
          constructor(point, isLeft) {
            if (point.events === undefined) point.events = [this];else point.events.push(this);
            this.point = point;
            this.isLeft = isLeft;
            // this.segment, this.otherSE set by factory
          }
          link(other) {
            if (other.point === this.point) {
              throw new Error("Tried to link already linked events");
            }
            const otherEvents = other.point.events;
            for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
              const evt = otherEvents[i];
              this.point.events.push(evt);
              evt.point = this.point;
            }
            this.checkForConsuming();
          }

          /* Do a pass over our linked events and check to see if any pair
           * of segments match, and should be consumed. */
          checkForConsuming() {
            // FIXME: The loops in this method run O(n^2) => no good.
            //        Maintain little ordered sweep event trees?
            //        Can we maintaining an ordering that avoids the need
            //        for the re-sorting with getLeftmostComparator in geom-out?

            // Compare each pair of events to see if other events also match
            const numEvents = this.point.events.length;
            for (let i = 0; i < numEvents; i++) {
              const evt1 = this.point.events[i];
              if (evt1.segment.consumedBy !== undefined) continue;
              for (let j = i + 1; j < numEvents; j++) {
                const evt2 = this.point.events[j];
                if (evt2.consumedBy !== undefined) continue;
                if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
                evt1.segment.consume(evt2.segment);
              }
            }
          }
          getAvailableLinkedEvents() {
            // point.events is always of length 2 or greater
            const events = [];
            for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
              const evt = this.point.events[i];
              if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                events.push(evt);
              }
            }
            return events;
          }

          /**
           * Returns a comparator function for sorting linked events that will
           * favor the event that will give us the smallest left-side angle.
           * All ring construction starts as low as possible heading to the right,
           * so by always turning left as sharp as possible we'll get polygons
           * without uncessary loops & holes.
           *
           * The comparator function has a compute cache such that it avoids
           * re-computing already-computed values.
           */
          getLeftmostComparator(baseEvent) {
            const cache = new Map();
            const fillCache = linkedEvent => {
              const nextEvent = linkedEvent.otherSE;
              cache.set(linkedEvent, {
                sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
                cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
              });
            };
            return (a, b) => {
              if (!cache.has(a)) fillCache(a);
              if (!cache.has(b)) fillCache(b);
              const {
                sine: asine,
                cosine: acosine
              } = cache.get(a);
              const {
                sine: bsine,
                cosine: bcosine
              } = cache.get(b);

              // both on or above x-axis
              if (asine >= 0 && bsine >= 0) {
                if (acosine < bcosine) return 1;
                if (acosine > bcosine) return -1;
                return 0;
              }

              // both below x-axis
              if (asine < 0 && bsine < 0) {
                if (acosine < bcosine) return -1;
                if (acosine > bcosine) return 1;
                return 0;
              }

              // one above x-axis, one below
              if (bsine < asine) return -1;
              if (bsine > asine) return 1;
              return 0;
            };
          }
        }

        // Give segments unique ID's to get consistent sorting of
        // segments and sweep events when all else is identical
        let segmentId = 0;
        class Segment {
          /* This compare() function is for ordering segments in the sweep
           * line tree, and does so according to the following criteria:
           *
           * Consider the vertical line that lies an infinestimal step to the
           * right of the right-more of the two left endpoints of the input
           * segments. Imagine slowly moving a point up from negative infinity
           * in the increasing y direction. Which of the two segments will that
           * point intersect first? That segment comes 'before' the other one.
           *
           * If neither segment would be intersected by such a line, (if one
           * or more of the segments are vertical) then the line to be considered
           * is directly on the right-more of the two left inputs.
           */
          static compare(a, b) {
            const alx = a.leftSE.point.x;
            const blx = b.leftSE.point.x;
            const arx = a.rightSE.point.x;
            const brx = b.rightSE.point.x;

            // check if they're even in the same vertical plane
            if (brx < alx) return 1;
            if (arx < blx) return -1;
            const aly = a.leftSE.point.y;
            const bly = b.leftSE.point.y;
            const ary = a.rightSE.point.y;
            const bry = b.rightSE.point.y;

            // is left endpoint of segment B the right-more?
            if (alx < blx) {
              // are the two segments in the same horizontal plane?
              if (bly < aly && bly < ary) return 1;
              if (bly > aly && bly > ary) return -1;

              // is the B left endpoint colinear to segment A?
              const aCmpBLeft = a.comparePoint(b.leftSE.point);
              if (aCmpBLeft < 0) return 1;
              if (aCmpBLeft > 0) return -1;

              // is the A right endpoint colinear to segment B ?
              const bCmpARight = b.comparePoint(a.rightSE.point);
              if (bCmpARight !== 0) return bCmpARight;

              // colinear segments, consider the one with left-more
              // left endpoint to be first (arbitrary?)
              return -1;
            }

            // is left endpoint of segment A the right-more?
            if (alx > blx) {
              if (aly < bly && aly < bry) return -1;
              if (aly > bly && aly > bry) return 1;

              // is the A left endpoint colinear to segment B?
              const bCmpALeft = b.comparePoint(a.leftSE.point);
              if (bCmpALeft !== 0) return bCmpALeft;

              // is the B right endpoint colinear to segment A?
              const aCmpBRight = a.comparePoint(b.rightSE.point);
              if (aCmpBRight < 0) return 1;
              if (aCmpBRight > 0) return -1;

              // colinear segments, consider the one with left-more
              // left endpoint to be first (arbitrary?)
              return 1;
            }

            // if we get here, the two left endpoints are in the same
            // vertical plane, ie alx === blx

            // consider the lower left-endpoint to come first
            if (aly < bly) return -1;
            if (aly > bly) return 1;

            // left endpoints are identical
            // check for colinearity by using the left-more right endpoint

            // is the A right endpoint more left-more?
            if (arx < brx) {
              const bCmpARight = b.comparePoint(a.rightSE.point);
              if (bCmpARight !== 0) return bCmpARight;
            }

            // is the B right endpoint more left-more?
            if (arx > brx) {
              const aCmpBRight = a.comparePoint(b.rightSE.point);
              if (aCmpBRight < 0) return 1;
              if (aCmpBRight > 0) return -1;
            }
            if (arx !== brx) {
              // are these two [almost] vertical segments with opposite orientation?
              // if so, the one with the lower right endpoint comes first
              const ay = ary - aly;
              const ax = arx - alx;
              const by = bry - bly;
              const bx = brx - blx;
              if (ay > ax && by < bx) return 1;
              if (ay < ax && by > bx) return -1;
            }

            // we have colinear segments with matching orientation
            // consider the one with more left-more right endpoint to be first
            if (arx > brx) return 1;
            if (arx < brx) return -1;

            // if we get here, two two right endpoints are in the same
            // vertical plane, ie arx === brx

            // consider the lower right-endpoint to come first
            if (ary < bry) return -1;
            if (ary > bry) return 1;

            // right endpoints identical as well, so the segments are idential
            // fall back on creation order as consistent tie-breaker
            if (a.id < b.id) return -1;
            if (a.id > b.id) return 1;

            // identical segment, ie a === b
            return 0;
          }

          /* Warning: a reference to ringWindings input will be stored,
           *  and possibly will be later modified */
          constructor(leftSE, rightSE, rings, windings) {
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
            // left unset for performance, set later in algorithm
            // this.ringOut, this.consumedBy, this.prev
          }
          static fromRing(pt1, pt2, ring) {
            let leftPt, rightPt, winding;

            // ordering the two points according to sweep line ordering
            const cmpPts = SweepEvent.comparePoints(pt1, pt2);
            if (cmpPts < 0) {
              leftPt = pt1;
              rightPt = pt2;
              winding = 1;
            } else if (cmpPts > 0) {
              leftPt = pt2;
              rightPt = pt1;
              winding = -1;
            } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
            const leftSE = new SweepEvent(leftPt, true);
            const rightSE = new SweepEvent(rightPt, false);
            return new Segment(leftSE, rightSE, [ring], [winding]);
          }

          /* When a segment is split, the rightSE is replaced with a new sweep event */
          replaceRightSE(newRightSE) {
            this.rightSE = newRightSE;
            this.rightSE.segment = this;
            this.rightSE.otherSE = this.leftSE;
            this.leftSE.otherSE = this.rightSE;
          }
          bbox() {
            const y1 = this.leftSE.point.y;
            const y2 = this.rightSE.point.y;
            return {
              ll: {
                x: this.leftSE.point.x,
                y: y1 < y2 ? y1 : y2
              },
              ur: {
                x: this.rightSE.point.x,
                y: y1 > y2 ? y1 : y2
              }
            };
          }

          /* A vector from the left point to the right */
          vector() {
            return {
              x: this.rightSE.point.x - this.leftSE.point.x,
              y: this.rightSE.point.y - this.leftSE.point.y
            };
          }
          isAnEndpoint(pt) {
            return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
          }

          /* Compare this segment with a point.
           *
           * A point P is considered to be colinear to a segment if there
           * exists a distance D such that if we travel along the segment
           * from one * endpoint towards the other a distance D, we find
           * ourselves at point P.
           *
           * Return value indicates:
           *
           *   1: point lies above the segment (to the left of vertical)
           *   0: point is colinear to segment
           *  -1: point lies below the segment (to the right of vertical)
           */
          comparePoint(point) {
            if (this.isAnEndpoint(point)) return 0;
            const lPt = this.leftSE.point;
            const rPt = this.rightSE.point;
            const v = this.vector();

            // Exactly vertical segments.
            if (lPt.x === rPt.x) {
              if (point.x === lPt.x) return 0;
              return point.x < lPt.x ? 1 : -1;
            }

            // Nearly vertical segments with an intersection.
            // Check to see where a point on the line with matching Y coordinate is.
            const yDist = (point.y - lPt.y) / v.y;
            const xFromYDist = lPt.x + yDist * v.x;
            if (point.x === xFromYDist) return 0;

            // General case.
            // Check to see where a point on the line with matching X coordinate is.
            const xDist = (point.x - lPt.x) / v.x;
            const yFromXDist = lPt.y + xDist * v.y;
            if (point.y === yFromXDist) return 0;
            return point.y < yFromXDist ? -1 : 1;
          }

          /**
           * Given another segment, returns the first non-trivial intersection
           * between the two segments (in terms of sweep line ordering), if it exists.
           *
           * A 'non-trivial' intersection is one that will cause one or both of the
           * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
           *
           *   * endpoint of segA with endpoint of segB --> trivial
           *   * endpoint of segA with point along segB --> non-trivial
           *   * endpoint of segB with point along segA --> non-trivial
           *   * point along segA with point along segB --> non-trivial
           *
           * If no non-trivial intersection exists, return null
           * Else, return null.
           */
          getIntersection(other) {
            // If bboxes don't overlap, there can't be any intersections
            const tBbox = this.bbox();
            const oBbox = other.bbox();
            const bboxOverlap = getBboxOverlap(tBbox, oBbox);
            if (bboxOverlap === null) return null;

            // We first check to see if the endpoints can be considered intersections.
            // This will 'snap' intersections to endpoints if possible, and will
            // handle cases of colinearity.

            const tlp = this.leftSE.point;
            const trp = this.rightSE.point;
            const olp = other.leftSE.point;
            const orp = other.rightSE.point;

            // does each endpoint touch the other segment?
            // note that we restrict the 'touching' definition to only allow segments
            // to touch endpoints that lie forward from where we are in the sweep line pass
            const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
            const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
            const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
            const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;

            // do left endpoints match?
            if (touchesThisLSE && touchesOtherLSE) {
              // these two cases are for colinear segments with matching left
              // endpoints, and one segment being longer than the other
              if (touchesThisRSE && !touchesOtherRSE) return trp;
              if (!touchesThisRSE && touchesOtherRSE) return orp;
              // either the two segments match exactly (two trival intersections)
              // or just on their left endpoint (one trivial intersection
              return null;
            }

            // does this left endpoint matches (other doesn't)
            if (touchesThisLSE) {
              // check for segments that just intersect on opposing endpoints
              if (touchesOtherRSE) {
                if (tlp.x === orp.x && tlp.y === orp.y) return null;
              }
              // t-intersection on left endpoint
              return tlp;
            }

            // does other left endpoint matches (this doesn't)
            if (touchesOtherLSE) {
              // check for segments that just intersect on opposing endpoints
              if (touchesThisRSE) {
                if (trp.x === olp.x && trp.y === olp.y) return null;
              }
              // t-intersection on left endpoint
              return olp;
            }

            // trivial intersection on right endpoints
            if (touchesThisRSE && touchesOtherRSE) return null;

            // t-intersections on just one right endpoint
            if (touchesThisRSE) return trp;
            if (touchesOtherRSE) return orp;

            // None of our endpoints intersect. Look for a general intersection between
            // infinite lines laid over the segments
            const pt = intersection$1(tlp, this.vector(), olp, other.vector());

            // are the segments parrallel? Note that if they were colinear with overlap,
            // they would have an endpoint intersection and that case was already handled above
            if (pt === null) return null;

            // is the intersection found between the lines not on the segments?
            if (!isInBbox(bboxOverlap, pt)) return null;

            // round the the computed point if needed
            return rounder.round(pt.x, pt.y);
          }

          /**
           * Split the given segment into multiple segments on the given points.
           *  * Each existing segment will retain its leftSE and a new rightSE will be
           *    generated for it.
           *  * A new segment will be generated which will adopt the original segment's
           *    rightSE, and a new leftSE will be generated for it.
           *  * If there are more than two points given to split on, new segments
           *    in the middle will be generated with new leftSE and rightSE's.
           *  * An array of the newly generated SweepEvents will be returned.
           *
           * Warning: input array of points is modified
           */
          split(point) {
            const newEvents = [];
            const alreadyLinked = point.events !== undefined;
            const newLeftSE = new SweepEvent(point, true);
            const newRightSE = new SweepEvent(point, false);
            const oldRightSE = this.rightSE;
            this.replaceRightSE(newRightSE);
            newEvents.push(newRightSE);
            newEvents.push(newLeftSE);
            const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());

            // when splitting a nearly vertical downward-facing segment,
            // sometimes one of the resulting new segments is vertical, in which
            // case its left and right events may need to be swapped
            if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
              newSeg.swapEvents();
            }
            if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
              this.swapEvents();
            }

            // in the point we just used to create new sweep events with was already
            // linked to other events, we need to check if either of the affected
            // segments should be consumed
            if (alreadyLinked) {
              newLeftSE.checkForConsuming();
              newRightSE.checkForConsuming();
            }
            return newEvents;
          }

          /* Swap which event is left and right */
          swapEvents() {
            const tmpEvt = this.rightSE;
            this.rightSE = this.leftSE;
            this.leftSE = tmpEvt;
            this.leftSE.isLeft = true;
            this.rightSE.isLeft = false;
            for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
              this.windings[i] *= -1;
            }
          }

          /* Consume another segment. We take their rings under our wing
           * and mark them as consumed. Use for perfectly overlapping segments */
          consume(other) {
            let consumer = this;
            let consumee = other;
            while (consumer.consumedBy) consumer = consumer.consumedBy;
            while (consumee.consumedBy) consumee = consumee.consumedBy;
            const cmp = Segment.compare(consumer, consumee);
            if (cmp === 0) return; // already consumed
            // the winner of the consumption is the earlier segment
            // according to sweep line ordering
            if (cmp > 0) {
              const tmp = consumer;
              consumer = consumee;
              consumee = tmp;
            }

            // make sure a segment doesn't consume it's prev
            if (consumer.prev === consumee) {
              const tmp = consumer;
              consumer = consumee;
              consumee = tmp;
            }
            for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
              const ring = consumee.rings[i];
              const winding = consumee.windings[i];
              const index = consumer.rings.indexOf(ring);
              if (index === -1) {
                consumer.rings.push(ring);
                consumer.windings.push(winding);
              } else consumer.windings[index] += winding;
            }
            consumee.rings = null;
            consumee.windings = null;
            consumee.consumedBy = consumer;

            // mark sweep events consumed as to maintain ordering in sweep event queue
            consumee.leftSE.consumedBy = consumer.leftSE;
            consumee.rightSE.consumedBy = consumer.rightSE;
          }

          /* The first segment previous segment chain that is in the result */
          prevInResult() {
            if (this._prevInResult !== undefined) return this._prevInResult;
            if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
            return this._prevInResult;
          }
          beforeState() {
            if (this._beforeState !== undefined) return this._beforeState;
            if (!this.prev) this._beforeState = {
              rings: [],
              windings: [],
              multiPolys: []
            };else {
              const seg = this.prev.consumedBy || this.prev;
              this._beforeState = seg.afterState();
            }
            return this._beforeState;
          }
          afterState() {
            if (this._afterState !== undefined) return this._afterState;
            const beforeState = this.beforeState();
            this._afterState = {
              rings: beforeState.rings.slice(0),
              windings: beforeState.windings.slice(0),
              multiPolys: []
            };
            const ringsAfter = this._afterState.rings;
            const windingsAfter = this._afterState.windings;
            const mpsAfter = this._afterState.multiPolys;

            // calculate ringsAfter, windingsAfter
            for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
              const ring = this.rings[i];
              const winding = this.windings[i];
              const index = ringsAfter.indexOf(ring);
              if (index === -1) {
                ringsAfter.push(ring);
                windingsAfter.push(winding);
              } else windingsAfter[index] += winding;
            }

            // calcualte polysAfter
            const polysAfter = [];
            const polysExclude = [];
            for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
              if (windingsAfter[i] === 0) continue; // non-zero rule
              const ring = ringsAfter[i];
              const poly = ring.poly;
              if (polysExclude.indexOf(poly) !== -1) continue;
              if (ring.isExterior) polysAfter.push(poly);else {
                if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
                const index = polysAfter.indexOf(ring.poly);
                if (index !== -1) polysAfter.splice(index, 1);
              }
            }

            // calculate multiPolysAfter
            for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
              const mp = polysAfter[i].multiPoly;
              if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
            }
            return this._afterState;
          }

          /* Is this segment part of the final result? */
          isInResult() {
            // if we've been consumed, we're not in the result
            if (this.consumedBy) return false;
            if (this._isInResult !== undefined) return this._isInResult;
            const mpsBefore = this.beforeState().multiPolys;
            const mpsAfter = this.afterState().multiPolys;
            switch (operation.type) {
              case "union":
                {
                  // UNION - included iff:
                  //  * On one side of us there is 0 poly interiors AND
                  //  * On the other side there is 1 or more.
                  const noBefores = mpsBefore.length === 0;
                  const noAfters = mpsAfter.length === 0;
                  this._isInResult = noBefores !== noAfters;
                  break;
                }
              case "intersection":
                {
                  // INTERSECTION - included iff:
                  //  * on one side of us all multipolys are rep. with poly interiors AND
                  //  * on the other side of us, not all multipolys are repsented
                  //    with poly interiors
                  let least;
                  let most;
                  if (mpsBefore.length < mpsAfter.length) {
                    least = mpsBefore.length;
                    most = mpsAfter.length;
                  } else {
                    least = mpsAfter.length;
                    most = mpsBefore.length;
                  }
                  this._isInResult = most === operation.numMultiPolys && least < most;
                  break;
                }
              case "xor":
                {
                  // XOR - included iff:
                  //  * the difference between the number of multipolys represented
                  //    with poly interiors on our two sides is an odd number
                  const diff = Math.abs(mpsBefore.length - mpsAfter.length);
                  this._isInResult = diff % 2 === 1;
                  break;
                }
              case "difference":
                {
                  // DIFFERENCE included iff:
                  //  * on exactly one side, we have just the subject
                  const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;
                  this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                  break;
                }
              default:
                throw new Error(`Unrecognized operation type found ${operation.type}`);
            }
            return this._isInResult;
          }
        }

        class RingIn {
          constructor(geomRing, poly, isExterior) {
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            let prevPoint = firstPoint;
            for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
              if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              let point = rounder.round(geomRing[i][0], geomRing[i][1]);
              // skip repeated points
              if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
              this.segments.push(Segment.fromRing(prevPoint, point, this));
              if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
              if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
              if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
              if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
              prevPoint = point;
            }
            // add segment from last to first if last is not the same as first
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
            }
          }
          getSweepEvents() {
            const sweepEvents = [];
            for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
              const segment = this.segments[i];
              sweepEvents.push(segment.leftSE);
              sweepEvents.push(segment.rightSE);
            }
            return sweepEvents;
          }
        }
        class PolyIn {
          constructor(geomPoly, multiPoly) {
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            // copy by value
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
              const ring = new RingIn(geomPoly[i], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          getSweepEvents() {
            const sweepEvents = this.exteriorRing.getSweepEvents();
            for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
              const ringSweepEvents = this.interiorRings[i].getSweepEvents();
              for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                sweepEvents.push(ringSweepEvents[j]);
              }
            }
            return sweepEvents;
          }
        }
        class MultiPolyIn {
          constructor(geom, isSubject) {
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              // if the input looks like a polygon, convert it to a multipolygon
              if (typeof geom[0][0][0] === "number") geom = [geom];
            } catch (ex) {
              // The input is either malformed or has empty arrays.
              // In either case, it will be handled later on.
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (let i = 0, iMax = geom.length; i < iMax; i++) {
              const poly = new PolyIn(geom[i], this);
              if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          getSweepEvents() {
            const sweepEvents = [];
            for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
              const polySweepEvents = this.polys[i].getSweepEvents();
              for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                sweepEvents.push(polySweepEvents[j]);
              }
            }
            return sweepEvents;
          }
        }

        class RingOut {
          /* Given the segments from the sweep line pass, compute & return a series
           * of closed rings from all the segments marked to be part of the result */
          static factory(allSegments) {
            const ringsOut = [];
            for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
              const segment = allSegments[i];
              if (!segment.isInResult() || segment.ringOut) continue;
              let prevEvent = null;
              let event = segment.leftSE;
              let nextEvent = segment.rightSE;
              const events = [event];
              const startingPoint = event.point;
              const intersectionLEs = [];

              /* Walk the chain of linked events to form a closed ring */
              while (true) {
                prevEvent = event;
                event = nextEvent;
                events.push(event);

                /* Is the ring complete? */
                if (event.point === startingPoint) break;
                while (true) {
                  const availableLEs = event.getAvailableLinkedEvents();

                  /* Did we hit a dead end? This shouldn't happen.
                   * Indicates some earlier part of the algorithm malfunctioned. */
                  if (availableLEs.length === 0) {
                    const firstPt = events[0].point;
                    const lastPt = events[events.length - 1].point;
                    throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);
                  }

                  /* Only one way to go, so cotinue on the path */
                  if (availableLEs.length === 1) {
                    nextEvent = availableLEs[0].otherSE;
                    break;
                  }

                  /* We must have an intersection. Check for a completed loop */
                  let indexLE = null;
                  for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                    if (intersectionLEs[j].point === event.point) {
                      indexLE = j;
                      break;
                    }
                  }
                  /* Found a completed loop. Cut that off and make a ring */
                  if (indexLE !== null) {
                    const intersectionLE = intersectionLEs.splice(indexLE)[0];
                    const ringEvents = events.splice(intersectionLE.index);
                    ringEvents.unshift(ringEvents[0].otherSE);
                    ringsOut.push(new RingOut(ringEvents.reverse()));
                    continue;
                  }
                  /* register the intersection */
                  intersectionLEs.push({
                    index: events.length,
                    point: event.point
                  });
                  /* Choose the left-most option to continue the walk */
                  const comparator = event.getLeftmostComparator(prevEvent);
                  nextEvent = availableLEs.sort(comparator)[0].otherSE;
                  break;
                }
              }
              ringsOut.push(new RingOut(events));
            }
            return ringsOut;
          }
          constructor(events) {
            this.events = events;
            for (let i = 0, iMax = events.length; i < iMax; i++) {
              events[i].segment.ringOut = this;
            }
            this.poly = null;
          }
          getGeom() {
            // Remove superfluous points (ie extra points along a straight line),
            let prevPt = this.events[0].point;
            const points = [prevPt];
            for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
              const pt = this.events[i].point;
              const nextPt = this.events[i + 1].point;
              if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;
              points.push(pt);
              prevPt = pt;
            }

            // ring was all (within rounding error of angle calc) colinear points
            if (points.length === 1) return null;

            // check if the starting point is necessary
            const pt = points[0];
            const nextPt = points[1];
            if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
            points.push(points[0]);
            const step = this.isExteriorRing() ? 1 : -1;
            const iStart = this.isExteriorRing() ? 0 : points.length - 1;
            const iEnd = this.isExteriorRing() ? points.length : -1;
            const orderedPoints = [];
            for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);
            return orderedPoints;
          }
          isExteriorRing() {
            if (this._isExteriorRing === undefined) {
              const enclosing = this.enclosingRing();
              this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
            }
            return this._isExteriorRing;
          }
          enclosingRing() {
            if (this._enclosingRing === undefined) {
              this._enclosingRing = this._calcEnclosingRing();
            }
            return this._enclosingRing;
          }

          /* Returns the ring that encloses this one, if any */
          _calcEnclosingRing() {
            // start with the ealier sweep line event so that the prevSeg
            // chain doesn't lead us inside of a loop of ours
            let leftMostEvt = this.events[0];
            for (let i = 1, iMax = this.events.length; i < iMax; i++) {
              const evt = this.events[i];
              if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
            }
            let prevSeg = leftMostEvt.segment.prevInResult();
            let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            while (true) {
              // no segment found, thus no ring can enclose us
              if (!prevSeg) return null;

              // no segments below prev segment found, thus the ring of the prev
              // segment must loop back around and enclose us
              if (!prevPrevSeg) return prevSeg.ringOut;

              // if the two segments are of different rings, the ring of the prev
              // segment must either loop around us or the ring of the prev prev
              // seg, which would make us and the ring of the prev peers
              if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                  return prevSeg.ringOut;
                } else return prevSeg.ringOut.enclosingRing();
              }

              // two segments are from the same ring, so this was a penisula
              // of that ring. iterate downward, keep searching
              prevSeg = prevPrevSeg.prevInResult();
              prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
            }
          }
        }
        class PolyOut {
          constructor(exteriorRing) {
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          addInterior(ring) {
            this.interiorRings.push(ring);
            ring.poly = this;
          }
          getGeom() {
            const geom = [this.exteriorRing.getGeom()];
            // exterior ring was all (within rounding error of angle calc) colinear points
            if (geom[0] === null) return null;
            for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
              const ringGeom = this.interiorRings[i].getGeom();
              // interior ring was all (within rounding error of angle calc) colinear points
              if (ringGeom === null) continue;
              geom.push(ringGeom);
            }
            return geom;
          }
        }
        class MultiPolyOut {
          constructor(rings) {
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          getGeom() {
            const geom = [];
            for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
              const polyGeom = this.polys[i].getGeom();
              // exterior ring was all (within rounding error of angle calc) colinear points
              if (polyGeom === null) continue;
              geom.push(polyGeom);
            }
            return geom;
          }
          _composePolys(rings) {
            const polys = [];
            for (let i = 0, iMax = rings.length; i < iMax; i++) {
              const ring = rings[i];
              if (ring.poly) continue;
              if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {
                const enclosingRing = ring.enclosingRing();
                if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
                enclosingRing.poly.addInterior(ring);
              }
            }
            return polys;
          }
        }

        /**
         * NOTE:  We must be careful not to change any segments while
         *        they are in the SplayTree. AFAIK, there's no way to tell
         *        the tree to rebalance itself - thus before splitting
         *        a segment that's in the tree, we remove it from the tree,
         *        do the split, then re-insert it. (Even though splitting a
         *        segment *shouldn't* change its correct position in the
         *        sweep line tree, the reality is because of rounding errors,
         *        it sometimes does.)
         */

        class SweepLine {
          constructor(queue) {
            let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          process(event) {
            const segment = event.segment;
            const newEvents = [];

            // if we've already been consumed by another segment,
            // clean up our body parts and get out
            if (event.consumedBy) {
              if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);
              return newEvents;
            }
            const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
            if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + "in SweepLine tree.");
            let prevNode = node;
            let nextNode = node;
            let prevSeg = undefined;
            let nextSeg = undefined;

            // skip consumed segments still in tree
            while (prevSeg === undefined) {
              prevNode = this.tree.prev(prevNode);
              if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
            }

            // skip consumed segments still in tree
            while (nextSeg === undefined) {
              nextNode = this.tree.next(nextNode);
              if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
            }
            if (event.isLeft) {
              // Check for intersections against the previous segment in the sweep line
              let prevMySplitter = null;
              if (prevSeg) {
                const prevInter = prevSeg.getIntersection(segment);
                if (prevInter !== null) {
                  if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
                  if (!prevSeg.isAnEndpoint(prevInter)) {
                    const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                    for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                      newEvents.push(newEventsFromSplit[i]);
                    }
                  }
                }
              }

              // Check for intersections against the next segment in the sweep line
              let nextMySplitter = null;
              if (nextSeg) {
                const nextInter = nextSeg.getIntersection(segment);
                if (nextInter !== null) {
                  if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
                  if (!nextSeg.isAnEndpoint(nextInter)) {
                    const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                    for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                      newEvents.push(newEventsFromSplit[i]);
                    }
                  }
                }
              }

              // For simplicity, even if we find more than one intersection we only
              // spilt on the 'earliest' (sweep-line style) of the intersections.
              // The other intersection will be handled in a future process().
              if (prevMySplitter !== null || nextMySplitter !== null) {
                let mySplitter = null;
                if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {
                  const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                  mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                }

                // Rounding errors can cause changes in ordering,
                // so remove afected segments and right sweep events before splitting
                this.queue.remove(segment.rightSE);
                newEvents.push(segment.rightSE);
                const newEventsFromSplit = segment.split(mySplitter);
                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                  newEvents.push(newEventsFromSplit[i]);
                }
              }
              if (newEvents.length > 0) {
                // We found some intersections, so re-do the current event to
                // make sure sweep line ordering is totally consistent for later
                // use with the segment 'prev' pointers
                this.tree.remove(segment);
                newEvents.push(event);
              } else {
                // done with left event
                this.segments.push(segment);
                segment.prev = prevSeg;
              }
            } else {
              // event.isRight

              // since we're about to be removed from the sweep line, check for
              // intersections between our previous and next segments
              if (prevSeg && nextSeg) {
                const inter = prevSeg.getIntersection(nextSeg);
                if (inter !== null) {
                  if (!prevSeg.isAnEndpoint(inter)) {
                    const newEventsFromSplit = this._splitSafely(prevSeg, inter);
                    for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                      newEvents.push(newEventsFromSplit[i]);
                    }
                  }
                  if (!nextSeg.isAnEndpoint(inter)) {
                    const newEventsFromSplit = this._splitSafely(nextSeg, inter);
                    for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                      newEvents.push(newEventsFromSplit[i]);
                    }
                  }
                }
              }
              this.tree.remove(segment);
            }
            return newEvents;
          }

          /* Safely split a segment that is currently in the datastructures
           * IE - a segment other than the one that is currently being processed. */
          _splitSafely(seg, pt) {
            // Rounding errors can cause changes in ordering,
            // so remove afected segments and right sweep events before splitting
            // removeNode() doesn't work, so have re-find the seg
            // https://github.com/w8r/splay-tree/pull/5
            this.tree.remove(seg);
            const rightSE = seg.rightSE;
            this.queue.remove(rightSE);
            const newEvents = seg.split(pt);
            newEvents.push(rightSE);
            // splitting can trigger consumption
            if (seg.consumedBy === undefined) this.tree.add(seg);
            return newEvents;
          }
        }

        // Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.
        const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
        const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
        class Operation {
          run(type, geom, moreGeoms) {
            operation.type = type;
            rounder.reset();

            /* Convert inputs to MultiPoly objects */
            const multipolys = [new MultiPolyIn(geom, true)];
            for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
              multipolys.push(new MultiPolyIn(moreGeoms[i], false));
            }
            operation.numMultiPolys = multipolys.length;

            /* BBox optimization for difference operation
             * If the bbox of a multipolygon that's part of the clipping doesn't
             * intersect the bbox of the subject at all, we can just drop that
             * multiploygon. */
            if (operation.type === "difference") {
              // in place removal
              const subject = multipolys[0];
              let i = 1;
              while (i < multipolys.length) {
                if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);
              }
            }

            /* BBox optimization for intersection operation
             * If we can find any pair of multipolygons whose bbox does not overlap,
             * then the result will be empty. */
            if (operation.type === "intersection") {
              // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
              //       it could be optimized to O(n * ln(n))
              for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
                const mpA = multipolys[i];
                for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
                  if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
                }
              }
            }

            /* Put segment endpoints in a priority queue */
            const queue = new Tree(SweepEvent.compare);
            for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
              const sweepEvents = multipolys[i].getSweepEvents();
              for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
                queue.insert(sweepEvents[j]);
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  // prevents an infinite loop, an otherwise common manifestation of bugs
                  throw new Error("Infinite loop when putting segment endpoints in a priority queue " + "(queue size too big).");
                }
              }
            }

            /* Pass the sweep line over those endpoints */
            const sweepLine = new SweepLine(queue);
            let prevQueueSize = queue.size;
            let node = queue.pop();
            while (node) {
              const evt = node.key;
              if (queue.size === prevQueueSize) {
                // prevents an infinite loop, an otherwise common manifestation of bugs
                const seg = evt.segment;
                throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
              }
              if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                // prevents an infinite loop, an otherwise common manifestation of bugs
                throw new Error("Infinite loop when passing sweep line over endpoints " + "(queue size too big).");
              }
              if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                // prevents an infinite loop, an otherwise common manifestation of bugs
                throw new Error("Infinite loop when passing sweep line over endpoints " + "(too many sweep line segments).");
              }
              const newEvents = sweepLine.process(evt);
              for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
                const evt = newEvents[i];
                if (evt.consumedBy === undefined) queue.insert(evt);
              }
              prevQueueSize = queue.size;
              node = queue.pop();
            }

            // free some memory we don't need anymore
            rounder.reset();

            /* Collect and compile segments we're keeping into a multipolygon */
            const ringsOut = RingOut.factory(sweepLine.segments);
            const result = new MultiPolyOut(ringsOut);
            return result.getGeom();
          }
        }

        // singleton available by import
        const operation = new Operation();

        const union = function (geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation.run("union", geom, moreGeoms);
        };
        const intersection = function (geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation.run("intersection", geom, moreGeoms);
        };
        const xor = function (geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation.run("xor", geom, moreGeoms);
        };
        const difference = function (subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union: union,
          intersection: intersection,
          xor: xor,
          difference: difference
        };

        return index;

    }));
    });

    var polygonClipping = polygonClipping_umd;

    /**
     * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.
     *
     * @name difference
     * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature
     * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1
     * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)
     * @example
     * var polygon1 = turf.polygon([[
     *   [128, -26],
     *   [141, -26],
     *   [141, -21],
     *   [128, -21],
     *   [128, -26]
     * ]], {
     *   "fill": "#F00",
     *   "fill-opacity": 0.1
     * });
     * var polygon2 = turf.polygon([[
     *   [126, -28],
     *   [140, -28],
     *   [140, -20],
     *   [126, -20],
     *   [126, -28]
     * ]], {
     *   "fill": "#00F",
     *   "fill-opacity": 0.1
     * });
     *
     * var difference = turf.difference(polygon1, polygon2);
     *
     * //addToMap
     * var addToMap = [polygon1, polygon2, difference];
     */
    function difference(polygon1, polygon2) {
      var geom1 = getGeom(polygon1);
      var geom2 = getGeom(polygon2);
      var properties = polygon1.properties || {};

      var differenced = polygonClipping.difference(
        geom1.coordinates,
        geom2.coordinates
      );
      if (differenced.length === 0) return null;
      if (differenced.length === 1) return polygon(differenced[0], properties);
      return multiPolygon(differenced, properties);
    }

    var jsts_min = createCommonjsModule(function (module, exports) {
    !function(t,e){e(exports);}(commonjsGlobal,function(t){function e(){}function n(t){this.message=t||"";}function i(t){this.message=t||"";}function r(t){this.message=t||"";}function o(){}function s(t){return null===t?Mt:t.color}function a(t){return null===t?null:t.parent}function u(t,e){null!==t&&(t.color=e);}function l(t){return null===t?null:t.left}function c(t){return null===t?null:t.right}function p(){this.root_=null,this.size_=0;}function h(){}function f(){this.array_=[],arguments[0]instanceof It&&this.addAll(arguments[0]);}function g(){}function d(t){this.message=t||"";}function y(){this.array_=[];}"fill"in Array.prototype||Object.defineProperty(Array.prototype,"fill",{configurable:!0,value:function(t){if(void 0===this||null===this)throw new TypeError(this+" is not an object");var e=Object(this),n=Math.max(Math.min(e.length,9007199254740991),0)||0,i=1 in arguments?parseInt(Number(arguments[1]),10)||0:0;i=i<0?Math.max(n+i,0):Math.min(i,n);var r=2 in arguments&&void 0!==arguments[2]?parseInt(Number(arguments[2]),10)||0:n;for(r=r<0?Math.max(n+arguments[2],0):Math.min(r,n);i<r;)e[i]=t,++i;return e},writable:!0}),Number.isFinite=Number.isFinite||function(t){return "number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return "number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!=t},Math.trunc=Math.trunc||function(t){return t<0?Math.ceil(t):Math.floor(t)};var _=function(){};_.prototype.interfaces_=function(){return []},_.prototype.getClass=function(){return _},_.prototype.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n};var m=function(t){function e(e){t.call(this,e),this.name="IllegalArgumentException",this.message=e,this.stack=(new t).stack;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),v=function(){},I={MAX_VALUE:{configurable:!0}};v.isNaN=function(t){return Number.isNaN(t)},v.doubleToLongBits=function(t){return t},v.longBitsToDouble=function(t){return t},v.isInfinite=function(t){return !Number.isFinite(t)},I.MAX_VALUE.get=function(){return Number.MAX_VALUE},Object.defineProperties(v,I);var E=function(){},x=function(){},N=function(){},C=function t(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)this.x=0,this.y=0,this.z=t.NULL_ORDINATE;else if(1===arguments.length){var e=arguments[0];this.x=e.x,this.y=e.y,this.z=e.z;}else 2===arguments.length?(this.x=arguments[0],this.y=arguments[1],this.z=t.NULL_ORDINATE):3===arguments.length&&(this.x=arguments[0],this.y=arguments[1],this.z=arguments[2]);},S={DimensionalComparator:{configurable:!0},serialVersionUID:{configurable:!0},NULL_ORDINATE:{configurable:!0},X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0}};C.prototype.setOrdinate=function(t,e){switch(t){case C.X:this.x=e;break;case C.Y:this.y=e;break;case C.Z:this.z=e;break;default:throw new m("Invalid ordinate index: "+t)}},C.prototype.equals2D=function(){if(1===arguments.length){var t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){var e=arguments[0],n=arguments[1];return !!_.equalsWithTolerance(this.x,e.x,n)&&!!_.equalsWithTolerance(this.y,e.y,n)}},C.prototype.getOrdinate=function(t){switch(t){case C.X:return this.x;case C.Y:return this.y;case C.Z:return this.z}throw new m("Invalid ordinate index: "+t)},C.prototype.equals3D=function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||v.isNaN(this.z))&&v.isNaN(t.z)},C.prototype.equals=function(t){return t instanceof C&&this.equals2D(t)},C.prototype.equalInZ=function(t,e){return _.equalsWithTolerance(this.z,t.z,e)},C.prototype.compareTo=function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},C.prototype.clone=function(){},C.prototype.copy=function(){return new C(this)},C.prototype.toString=function(){return "("+this.x+", "+this.y+", "+this.z+")"},C.prototype.distance3D=function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},C.prototype.distance=function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},C.prototype.hashCode=function(){var t=17;return t=37*t+C.hashCode(this.x),t=37*t+C.hashCode(this.y)},C.prototype.setCoordinate=function(t){this.x=t.x,this.y=t.y,this.z=t.z;},C.prototype.interfaces_=function(){return [E,x,e]},C.prototype.getClass=function(){return C},C.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=v.doubleToLongBits(t);return Math.trunc((e^e)>>>32)}},S.DimensionalComparator.get=function(){return L},S.serialVersionUID.get=function(){return 0x5cbf2c235c7e5800},S.NULL_ORDINATE.get=function(){return v.NaN},S.X.get=function(){return 0},S.Y.get=function(){return 1},S.Z.get=function(){return 2},Object.defineProperties(C,S);var L=function(t){if(this._dimensionsToTest=2,0===arguments.length);else if(1===arguments.length){var e=arguments[0];if(2!==e&&3!==e)throw new m("only 2 or 3 dimensions may be specified");this._dimensionsToTest=e;}};L.prototype.compare=function(t,e){var n=t,i=e,r=L.compare(n.x,i.x);if(0!==r)return r;var o=L.compare(n.y,i.y);if(0!==o)return o;if(this._dimensionsToTest<=2)return 0;return L.compare(n.z,i.z)},L.prototype.interfaces_=function(){return [N]},L.prototype.getClass=function(){return L},L.compare=function(t,e){return t<e?-1:t>e?1:v.isNaN(t)?v.isNaN(e)?0:-1:v.isNaN(e)?1:0};var b=function(){};b.prototype.create=function(){},b.prototype.interfaces_=function(){return []},b.prototype.getClass=function(){return b};var w=function(){},O={INTERIOR:{configurable:!0},BOUNDARY:{configurable:!0},EXTERIOR:{configurable:!0},NONE:{configurable:!0}};w.prototype.interfaces_=function(){return []},w.prototype.getClass=function(){return w},w.toLocationSymbol=function(t){switch(t){case w.EXTERIOR:return "e";case w.BOUNDARY:return "b";case w.INTERIOR:return "i";case w.NONE:return "-"}throw new m("Unknown location value: "+t)},O.INTERIOR.get=function(){return 0},O.BOUNDARY.get=function(){return 1},O.EXTERIOR.get=function(){return 2},O.NONE.get=function(){return -1},Object.defineProperties(w,O);var T=function(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1},R=function(){},P={LOG_10:{configurable:!0}};R.prototype.interfaces_=function(){return []},R.prototype.getClass=function(){return R},R.log10=function(t){var e=Math.log(t);return v.isInfinite(e)?e:v.isNaN(e)?e:e/R.LOG_10},R.min=function(t,e,n,i){var r=t;return e<r&&(r=e),n<r&&(r=n),i<r&&(r=i),r},R.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],o=arguments[2];return i<r?r:i>o?o:i}},R.wrap=function(t,e){return t<0?e- -t%e:t%e},R.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3],u=r;return o>u&&(u=o),s>u&&(u=s),a>u&&(u=a),u}},R.average=function(t,e){return (t+e)/2},P.LOG_10.get=function(){return Math.log(10)},Object.defineProperties(R,P);var D=function(t){this.str=t;};D.prototype.append=function(t){this.str+=t;},D.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1);},D.prototype.toString=function(t){return this.str};var M=function(t){this.value=t;};M.prototype.intValue=function(){return this.value},M.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},M.isNaN=function(t){return Number.isNaN(t)};var A=function(){};A.isWhitespace=function(t){return t<=32&&t>=0||127===t},A.toUpperCase=function(t){return t.toUpperCase()};var F=function t(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var e=arguments[0];this.init(e);}else if(arguments[0]instanceof t){var n=arguments[0];this.init(n);}else if("string"==typeof arguments[0]){var i=arguments[0];t.call(this,t.parse(i));}}else if(2===arguments.length){var r=arguments[0],o=arguments[1];this.init(r,o);}},G={PI:{configurable:!0},TWO_PI:{configurable:!0},PI_2:{configurable:!0},E:{configurable:!0},NaN:{configurable:!0},EPS:{configurable:!0},SPLIT:{configurable:!0},MAX_PRINT_DIGITS:{configurable:!0},TEN:{configurable:!0},ONE:{configurable:!0},SCI_NOT_EXPONENT_CHAR:{configurable:!0},SCI_NOT_ZERO:{configurable:!0}};F.prototype.le=function(t){return (this._hi<t._hi||this._hi===t._hi)&&this._lo<=t._lo},F.prototype.extractSignificantDigits=function(t,e){var n=this.abs(),i=F.magnitude(n._hi),r=F.TEN.pow(i);(n=n.divide(r)).gt(F.TEN)?(n=n.divide(F.TEN),i+=1):n.lt(F.ONE)&&(n=n.multiply(F.TEN),i-=1);for(var o=i+1,s=new D,a=F.MAX_PRINT_DIGITS-1,u=0;u<=a;u++){t&&u===o&&s.append(".");var l=Math.trunc(n._hi);if(l<0)break;var c=!1,p=0;l>9?(c=!0,p="9"):p="0"+l,s.append(p),n=n.subtract(F.valueOf(l)).multiply(F.TEN),c&&n.selfAdd(F.TEN);var h=!0,f=F.magnitude(n._hi);if(f<0&&Math.abs(f)>=a-u&&(h=!1),!h)break}return e[0]=i,s.toString()},F.prototype.sqr=function(){return this.multiply(this)},F.prototype.doubleValue=function(){return this._hi+this._lo},F.prototype.subtract=function(){if(arguments[0]instanceof F){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},F.prototype.equals=function(){if(1===arguments.length){var t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}},F.prototype.isZero=function(){return 0===this._hi&&0===this._lo},F.prototype.selfSubtract=function(){if(arguments[0]instanceof F){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},F.prototype.getSpecialNumberString=function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},F.prototype.min=function(t){return this.le(t)?this:t},F.prototype.selfDivide=function(){if(1===arguments.length){if(arguments[0]instanceof F){var t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,o=null,s=null,a=null,u=null,l=null,c=null,p=null;return u=this._hi/n,l=F.SPLIT*u,r=l-u,p=F.SPLIT*n,r=l-r,o=u-r,s=p-n,c=u*n,s=p-s,a=n-s,p=r*s-c+r*a+o*s+o*a,l=(this._hi-c-p+this._lo-u*i)/n,p=u+l,this._hi=p,this._lo=u-p+l,this}},F.prototype.dump=function(){return "DD<"+this._hi+", "+this._lo+">"},F.prototype.divide=function(){if(arguments[0]instanceof F){var t=arguments[0],e=null,n=null,i=null,r=null,o=null,s=null,a=null,u=null;n=(o=this._hi/t._hi)-(e=(s=F.SPLIT*o)-(e=s-o)),u=e*(i=(u=F.SPLIT*t._hi)-(i=u-t._hi))-(a=o*t._hi)+e*(r=t._hi-i)+n*i+n*r,s=(this._hi-a-u+this._lo-o*t._lo)/t._hi;return new F(u=o+s,o-u+s)}if("number"==typeof arguments[0]){var l=arguments[0];return v.isNaN(l)?F.createNaN():F.copy(this).selfDivide(l,0)}},F.prototype.ge=function(t){return (this._hi>t._hi||this._hi===t._hi)&&this._lo>=t._lo},F.prototype.pow=function(t){if(0===t)return F.valueOf(1);var e=new F(this),n=F.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2==1&&n.selfMultiply(e),(i/=2)>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n},F.prototype.ceil=function(){if(this.isNaN())return F.NaN;var t=Math.ceil(this._hi),e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new F(t,e)},F.prototype.compareTo=function(t){var e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0},F.prototype.rint=function(){if(this.isNaN())return this;return this.add(.5).floor()},F.prototype.setValue=function(){if(arguments[0]instanceof F){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},F.prototype.max=function(t){return this.ge(t)?this:t},F.prototype.sqrt=function(){if(this.isZero())return F.valueOf(0);if(this.isNegative())return F.NaN;var t=1/Math.sqrt(this._hi),e=this._hi*t,n=F.valueOf(e),i=this.subtract(n.sqr())._hi*(.5*t);return n.add(i)},F.prototype.selfAdd=function(){if(1===arguments.length){if(arguments[0]instanceof F){var t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,o=null,s=null,a=null;return r=this._hi+e,s=r-this._hi,o=r-s,o=e-s+(this._hi-o),a=o+this._lo,n=r+a,i=a+(r-n),this._hi=n+i,this._lo=i+(n-this._hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],c=null,p=null,h=null,f=null,g=null,d=null,y=null;f=this._hi+u,p=this._lo+l,g=f-(d=f-this._hi),h=p-(y=p-this._lo);var _=(c=f+(d=(g=u-d+(this._hi-g))+p))+(d=(h=l-y+(this._lo-h))+(d+(f-c))),m=d+(c-_);return this._hi=_,this._lo=m,this}},F.prototype.selfMultiply=function(){if(1===arguments.length){if(arguments[0]instanceof F){var t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,o=null,s=null,a=null,u=null,l=null;r=(u=F.SPLIT*this._hi)-this._hi,l=F.SPLIT*n,r=u-r,o=this._hi-r,s=l-n;var c=(u=this._hi*n)+(l=r*(s=l-s)-u+r*(a=n-s)+o*s+o*a+(this._hi*i+this._lo*n)),p=l+(r=u-c);return this._hi=c,this._lo=p,this}},F.prototype.selfSqr=function(){return this.selfMultiply(this)},F.prototype.floor=function(){if(this.isNaN())return F.NaN;var t=Math.floor(this._hi),e=0;return t===this._hi&&(e=Math.floor(this._lo)),new F(t,e)},F.prototype.negate=function(){return this.isNaN()?this:new F(-this._hi,-this._lo)},F.prototype.clone=function(){},F.prototype.multiply=function(){if(arguments[0]instanceof F){var t=arguments[0];return t.isNaN()?F.createNaN():F.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return v.isNaN(e)?F.createNaN():F.copy(this).selfMultiply(e,0)}},F.prototype.isNaN=function(){return v.isNaN(this._hi)},F.prototype.intValue=function(){return Math.trunc(this._hi)},F.prototype.toString=function(){var t=F.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()},F.prototype.toStandardNotation=function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(i<0)r="0."+F.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var o=i-n.length;r=n+F.stringOfChar("0",o)+".0";}return this.isNegative()?"-"+r:r},F.prototype.reciprocal=function(){var t=null,e=null,n=null,i=null,r=null,o=null,s=null,a=null;e=(r=1/this._hi)-(t=(o=F.SPLIT*r)-(t=o-r)),n=(a=F.SPLIT*this._hi)-this._hi;var u=r+(o=(1-(s=r*this._hi)-(a=t*(n=a-n)-s+t*(i=this._hi-n)+e*n+e*i)-r*this._lo)/this._hi);return new F(u,r-u+o)},F.prototype.toSciNotation=function(){if(this.isZero())return F.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=F.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new Error("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var o=n.charAt(0)+"."+r;return this.isNegative()?"-"+o+i:o+i},F.prototype.abs=function(){return this.isNaN()?F.NaN:this.isNegative()?this.negate():new F(this)},F.prototype.isPositive=function(){return (this._hi>0||0===this._hi)&&this._lo>0},F.prototype.lt=function(t){return (this._hi<t._hi||this._hi===t._hi)&&this._lo<t._lo},F.prototype.add=function(){if(arguments[0]instanceof F){var t=arguments[0];return F.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return F.copy(this).selfAdd(e)}},F.prototype.init=function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this._hi=t,this._lo=0;}else if(arguments[0]instanceof F){var e=arguments[0];this._hi=e._hi,this._lo=e._lo;}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this._hi=n,this._lo=i;}},F.prototype.gt=function(t){return (this._hi>t._hi||this._hi===t._hi)&&this._lo>t._lo},F.prototype.isNegative=function(){return (this._hi<0||0===this._hi)&&this._lo<0},F.prototype.trunc=function(){return this.isNaN()?F.NaN:this.isPositive()?this.floor():this.ceil()},F.prototype.signum=function(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0},F.prototype.interfaces_=function(){return [e,E,x]},F.prototype.getClass=function(){return F},F.sqr=function(t){return F.valueOf(t).selfMultiply(t)},F.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return F.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new F(e)}},F.sqrt=function(t){return F.valueOf(t).sqrt()},F.parse=function(t){for(var e=0,n=t.length;A.isWhitespace(t.charAt(e));)e++;var i=!1;if(e<n){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0));}for(var o=new F,s=0,a=0,u=0;!(e>=n);){var l=t.charAt(e);if(e++,A.isDigit(l)){var c=l-"0";o.selfMultiply(F.TEN),o.selfAdd(c),s++;}else {if("."!==l){if("e"===l||"E"===l){var p=t.substring(e);try{u=M.parseInt(p);}catch(e){throw e instanceof Error?new Error("Invalid exponent "+p+" in string "+t):e}break}throw new Error("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=s;}}var h=o,f=s-a-u;if(0===f)h=o;else if(f>0){var g=F.TEN.pow(f);h=o.divide(g);}else if(f<0){var d=F.TEN.pow(-f);h=o.multiply(d);}return i?h.negate():h},F.createNaN=function(){return new F(v.NaN,v.NaN)},F.copy=function(t){return new F(t)},F.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n));return 10*Math.pow(10,i)<=e&&(i+=1),i},F.stringOfChar=function(t,e){for(var n=new D,i=0;i<e;i++)n.append(t);return n.toString()},G.PI.get=function(){return new F(3.141592653589793,1.2246467991473532e-16)},G.TWO_PI.get=function(){return new F(6.283185307179586,2.4492935982947064e-16)},G.PI_2.get=function(){return new F(1.5707963267948966,6.123233995736766e-17)},G.E.get=function(){return new F(2.718281828459045,1.4456468917292502e-16)},G.NaN.get=function(){return new F(v.NaN,v.NaN)},G.EPS.get=function(){return 1.23259516440783e-32},G.SPLIT.get=function(){return 134217729},G.MAX_PRINT_DIGITS.get=function(){return 32},G.TEN.get=function(){return F.valueOf(10)},G.ONE.get=function(){return F.valueOf(1)},G.SCI_NOT_EXPONENT_CHAR.get=function(){return "E"},G.SCI_NOT_ZERO.get=function(){return "0.0E0"},Object.defineProperties(F,G);var q=function(){},B={DP_SAFE_EPSILON:{configurable:!0}};q.prototype.interfaces_=function(){return []},q.prototype.getClass=function(){return q},q.orientationIndex=function(t,e,n){var i=q.orientationIndexFilter(t,e,n);if(i<=1)return i;var r=F.valueOf(e.x).selfAdd(-t.x),o=F.valueOf(e.y).selfAdd(-t.y),s=F.valueOf(n.x).selfAdd(-e.x),a=F.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()},q.signOfDet2x2=function(t,e,n,i){return t.multiply(i).selfSubtract(e.multiply(n)).signum()},q.intersection=function(t,e,n,i){var r=F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(e.x).selfSubtract(t.x)),o=F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(e.y).selfSubtract(t.y)),s=r.subtract(o),a=F.valueOf(i.x).selfSubtract(n.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),u=F.valueOf(i.y).selfSubtract(n.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u).selfDivide(s).doubleValue(),c=F.valueOf(t.x).selfAdd(F.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(),p=F.valueOf(e.x).selfSubtract(t.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)),h=F.valueOf(e.y).selfSubtract(t.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)),f=p.subtract(h).selfDivide(s).doubleValue(),g=F.valueOf(n.y).selfAdd(F.valueOf(i.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();return new C(c,g)},q.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),o=(t.y-n.y)*(e.x-n.x),s=r-o;if(r>0){if(o<=0)return q.signum(s);i=r+o;}else {if(!(r<0))return q.signum(s);if(o>=0)return q.signum(s);i=-r-o;}var a=q.DP_SAFE_EPSILON*i;return s>=a||-s>=a?q.signum(s):2},q.signum=function(t){return t>0?1:t<0?-1:0},B.DP_SAFE_EPSILON.get=function(){return 1e-15},Object.defineProperties(q,B);var V=function(){},U={X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0},M:{configurable:!0}};U.X.get=function(){return 0},U.Y.get=function(){return 1},U.Z.get=function(){return 2},U.M.get=function(){return 3},V.prototype.setOrdinate=function(t,e,n){},V.prototype.size=function(){},V.prototype.getOrdinate=function(t,e){},V.prototype.getCoordinate=function(){},V.prototype.getCoordinateCopy=function(t){},V.prototype.getDimension=function(){},V.prototype.getX=function(t){},V.prototype.clone=function(){},V.prototype.expandEnvelope=function(t){},V.prototype.copy=function(){},V.prototype.getY=function(t){},V.prototype.toCoordinateArray=function(){},V.prototype.interfaces_=function(){return [x]},V.prototype.getClass=function(){return V},Object.defineProperties(V,U);var z=function(){},X=function(t){function e(){t.call(this,"Projective point not representable on the Cartesian plane.");}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(z),Y=function(){};Y.arraycopy=function(t,e,n,i,r){for(var o=0,s=e;s<e+r;s++)n[i+o]=t[s],o++;},Y.getProperty=function(t){return {"line.separator":"\n"}[t]};var k=function t(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var e=arguments[0];this.x=e.x,this.y=e.y,this.w=1;}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.x=n,this.y=i,this.w=1;}else if(arguments[0]instanceof t&&arguments[1]instanceof t){var r=arguments[0],o=arguments[1];this.x=r.y*o.w-o.y*r.w,this.y=o.x*r.w-r.x*o.w,this.w=r.x*o.y-o.x*r.y;}else if(arguments[0]instanceof C&&arguments[1]instanceof C){var s=arguments[0],a=arguments[1];this.x=s.y-a.y,this.y=a.x-s.x,this.w=s.x*a.y-a.x*s.y;}}else if(3===arguments.length){var u=arguments[0],l=arguments[1],c=arguments[2];this.x=u,this.y=l,this.w=c;}else if(4===arguments.length){var p=arguments[0],h=arguments[1],f=arguments[2],g=arguments[3],d=p.y-h.y,y=h.x-p.x,_=p.x*h.y-h.x*p.y,m=f.y-g.y,v=g.x-f.x,I=f.x*g.y-g.x*f.y;this.x=y*I-v*_,this.y=m*_-d*I,this.w=d*v-m*y;}};k.prototype.getY=function(){var t=this.y/this.w;if(v.isNaN(t)||v.isInfinite(t))throw new X;return t},k.prototype.getX=function(){var t=this.x/this.w;if(v.isNaN(t)||v.isInfinite(t))throw new X;return t},k.prototype.getCoordinate=function(){var t=new C;return t.x=this.getX(),t.y=this.getY(),t},k.prototype.interfaces_=function(){return []},k.prototype.getClass=function(){return k},k.intersection=function(t,e,n,i){var r=t.y-e.y,o=e.x-t.x,s=t.x*e.y-e.x*t.y,a=n.y-i.y,u=i.x-n.x,l=n.x*i.y-i.x*n.y,c=r*u-a*o,p=(o*l-u*s)/c,h=(a*s-r*l)/c;if(v.isNaN(p)||v.isInfinite(p)||v.isNaN(h)||v.isInfinite(h))throw new X;return new C(p,h)};var j=function t(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof C){var e=arguments[0];this.init(e.x,e.x,e.y,e.y);}else if(arguments[0]instanceof t){var n=arguments[0];this.init(n);}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i.x,r.x,i.y,r.y);}else if(4===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2],u=arguments[3];this.init(o,s,a,u);}},H={serialVersionUID:{configurable:!0}};j.prototype.getArea=function(){return this.getWidth()*this.getHeight()},j.prototype.equals=function(t){if(!(t instanceof j))return !1;var e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()},j.prototype.intersection=function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new j;var e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,i=this._maxx<t._maxx?this._maxx:t._maxx,r=this._maxy<t._maxy?this._maxy:t._maxy;return new j(e,i,n,r)},j.prototype.isNull=function(){return this._maxx<this._minx},j.prototype.getMaxX=function(){return this._maxx},j.prototype.covers=function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof j){var e=arguments[0];return !this.isNull()&&!e.isNull()&&(e.getMinX()>=this._minx&&e.getMaxX()<=this._maxx&&e.getMinY()>=this._miny&&e.getMaxY()<=this._maxy)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return !this.isNull()&&(n>=this._minx&&n<=this._maxx&&i>=this._miny&&i<=this._maxy)}},j.prototype.intersects=function(){if(1===arguments.length){if(arguments[0]instanceof j){var t=arguments[0];return !this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof C){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return !this.isNull()&&!(n>this._maxx||n<this._minx||i>this._maxy||i<this._miny)}},j.prototype.getMinY=function(){return this._miny},j.prototype.getMinX=function(){return this._minx},j.prototype.expandToInclude=function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];this.expandToInclude(t.x,t.y);}else if(arguments[0]instanceof j){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this._minx=e.getMinX(),this._maxx=e.getMaxX(),this._miny=e.getMinY(),this._maxy=e.getMaxY()):(e._minx<this._minx&&(this._minx=e._minx),e._maxx>this._maxx&&(this._maxx=e._maxx),e._miny<this._miny&&(this._miny=e._miny),e._maxy>this._maxy&&(this._maxy=e._maxy));}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this._minx=n,this._maxx=n,this._miny=i,this._maxy=i):(n<this._minx&&(this._minx=n),n>this._maxx&&(this._maxx=n),i<this._miny&&(this._miny=i),i>this._maxy&&(this._maxy=i));}},j.prototype.minExtent=function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t<e?t:e},j.prototype.getWidth=function(){return this.isNull()?0:this._maxx-this._minx},j.prototype.compareTo=function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0},j.prototype.translate=function(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e);},j.prototype.toString=function(){return "Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"},j.prototype.setToNull=function(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1;},j.prototype.getHeight=function(){return this.isNull()?0:this._maxy-this._miny},j.prototype.maxExtent=function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},j.prototype.expandBy=function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this._minx-=e,this._maxx+=e,this._miny-=n,this._maxy+=n,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull();}},j.prototype.contains=function(){if(1===arguments.length){if(arguments[0]instanceof j){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof C){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},j.prototype.centre=function(){return this.isNull()?null:new C((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},j.prototype.init=function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];this.init(t.x,t.x,t.y,t.y);}else if(arguments[0]instanceof j){var e=arguments[0];this._minx=e._minx,this._maxx=e._maxx,this._miny=e._miny,this._maxy=e._maxy;}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y);}else if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];r<o?(this._minx=r,this._maxx=o):(this._minx=o,this._maxx=r),s<a?(this._miny=s,this._maxy=a):(this._miny=a,this._maxy=s);}},j.prototype.getMaxY=function(){return this._maxy},j.prototype.distance=function(t){if(this.intersects(t))return 0;var e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);var n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},j.prototype.hashCode=function(){var t=17;return t=37*t+C.hashCode(this._minx),t=37*t+C.hashCode(this._maxx),t=37*t+C.hashCode(this._miny),t=37*t+C.hashCode(this._maxy)},j.prototype.interfaces_=function(){return [E,e]},j.prototype.getClass=function(){return j},j.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2],s=arguments[3],a=Math.min(o.x,s.x),u=Math.max(o.x,s.x),l=Math.min(i.x,r.x),c=Math.max(i.x,r.x);return !(l>u)&&(!(c<a)&&(a=Math.min(o.y,s.y),u=Math.max(o.y,s.y),l=Math.min(i.y,r.y),c=Math.max(i.y,r.y),!(l>u)&&!(c<a)))}},H.serialVersionUID.get=function(){return 0x51845cd552189800},Object.defineProperties(j,H);var W={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/},K=function(t){this.geometryFactory=t||new _e;};K.prototype.read=function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=W.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((r=W.emptyTypeStr.exec(t))[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],Q[n]&&(e=Q[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},K.prototype.write=function(t){return this.extractGeometry(t)},K.prototype.extractGeometry=function(t){var e=t.getGeometryType().toLowerCase();if(!J[e])return null;var n=e.toUpperCase();return t.isEmpty()?n+" EMPTY":n+"("+J[e].apply(this,[t])+")"};var J={coordinate:function(t){return t.x+" "+t.y},point:function(t){return J.coordinate.call(this,t._coordinates._coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push("("+J.point.apply(this,[t._geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t._points._coordinates.length;n<i;++n)e.push(J.coordinate.apply(this,[t._points._coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t._points._coordinates.length;n<i;++n)e.push(J.coordinate.apply(this,[t._points._coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push("("+J.linestring.apply(this,[t._geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+J.linestring.apply(this,[t._shell])+")");for(var n=0,i=t._holes.length;n<i;++n)e.push("("+J.linestring.apply(this,[t._holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push("("+J.polygon.apply(this,[t._geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t._geometries.length;n<i;++n)e.push(this.extractGeometry(t._geometries[n]));return e.join(",")}},Q={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(W.spaces);return this.geometryFactory.createPoint(new C(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,o=n.length;r<o;++r)e=n[r].replace(W.trimParens,"$1"),i.push(Q.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,o=n.length;r<o;++r)e=n[r].trim().split(W.spaces),i.push(new C(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,o=n.length;r<o;++r)e=n[r].trim().split(W.spaces),i.push(new C(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(W.parenComma),i=[],r=0,o=n.length;r<o;++r)e=n[r].replace(W.trimParens,"$1"),i.push(Q.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,o=t.trim().split(W.parenComma),s=[],a=0,u=o.length;a<u;++a)e=o[a].replace(W.trimParens,"$1"),n=Q.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n._points),0===a?r=i:s.push(i);return this.geometryFactory.createPolygon(r,s)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(W.doubleParenComma),i=[],r=0,o=n.length;r<o;++r)e=n[r].replace(W.trimParens,"$1"),i.push(Q.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();for(var e=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),n=[],i=0,r=e.length;i<r;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}},Z=function(t){this.parser=new K(t);};Z.prototype.write=function(t){return this.parser.write(t)},Z.toLineString=function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return "LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"};var $=function(t){function e(e){t.call(this,e),this.name="RuntimeException",this.message=e,this.stack=(new t).stack;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Error),tt=function(t){function e(){if(t.call(this),0===arguments.length)t.call(this);else if(1===arguments.length){var e=arguments[0];t.call(this,e);}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}($),et=function(){};et.prototype.interfaces_=function(){return []},et.prototype.getClass=function(){return et},et.shouldNeverReachHere=function(){if(0===arguments.length)et.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new tt("Should never reach here"+(null!==t?": "+t:""))}},et.isTrue=function(){var t,e;if(1===arguments.length)t=arguments[0],et.isTrue(t,null);else if(2===arguments.length&&(t=arguments[0],e=arguments[1],!t))throw null===e?new tt:new tt(e)},et.equals=function(){var t,e,n;if(2===arguments.length)t=arguments[0],e=arguments[1],et.equals(t,e,null);else if(3===arguments.length&&(t=arguments[0],e=arguments[1],n=arguments[2],!e.equals(t)))throw new tt("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))};var nt=function(){this._result=null,this._inputLines=Array(2).fill().map(function(){return Array(2)}),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new C,this._intPt[1]=new C,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0;},it={DONT_INTERSECT:{configurable:!0},DO_INTERSECT:{configurable:!0},COLLINEAR:{configurable:!0},NO_INTERSECTION:{configurable:!0},POINT_INTERSECTION:{configurable:!0},COLLINEAR_INTERSECTION:{configurable:!0}};nt.prototype.getIndexAlongSegment=function(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]},nt.prototype.getTopologySummary=function(){var t=new D;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},nt.prototype.computeIntersection=function(t,e,n,i){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=i,this._result=this.computeIntersect(t,e,n,i);},nt.prototype.getIntersectionNum=function(){return this._result},nt.prototype.computeIntLineIndex=function(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0);}},nt.prototype.isProper=function(){return this.hasIntersection()&&this._isProper},nt.prototype.setPrecisionModel=function(t){this._precisionModel=t;},nt.prototype.isInteriorIntersection=function(){if(0===arguments.length)return !!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return !0;return !1}},nt.prototype.getIntersection=function(t){return this._intPt[t]},nt.prototype.isEndPoint=function(){return this.hasIntersection()&&!this._isProper},nt.prototype.hasIntersection=function(){return this._result!==nt.NO_INTERSECTION},nt.prototype.getEdgeDistance=function(t,e){return nt.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])},nt.prototype.isCollinear=function(){return this._result===nt.COLLINEAR_INTERSECTION},nt.prototype.toString=function(){return Z.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Z.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()},nt.prototype.getEndpoint=function(t,e){return this._inputLines[t][e]},nt.prototype.isIntersection=function(t){for(var e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return !0;return !1},nt.prototype.getIntersectionAlongSegment=function(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]},nt.prototype.interfaces_=function(){return []},nt.prototype.getClass=function(){return nt},nt.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),o=-1;if(t.equals(e))o=0;else if(t.equals(n))o=i>r?i:r;else {var s=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);0!==(o=i>r?s:a)||t.equals(e)||(o=Math.max(s,a));}return et.isTrue(!(0===o&&!t.equals(e)),"Bad distance calculation"),o},nt.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,o=Math.sqrt(i*i+r*r);return et.isTrue(!(0===o&&!t.equals(e)),"Invalid distance calculation"),o},it.DONT_INTERSECT.get=function(){return 0},it.DO_INTERSECT.get=function(){return 1},it.COLLINEAR.get=function(){return 2},it.NO_INTERSECTION.get=function(){return 0},it.POINT_INTERSECTION.get=function(){return 1},it.COLLINEAR_INTERSECTION.get=function(){return 2},Object.defineProperties(nt,it);var rt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isInSegmentEnvelopes=function(t){var e=new j(this._inputLines[0][0],this._inputLines[0][1]),n=new j(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)},e.prototype.computeIntersection=function(){if(3!==arguments.length)return t.prototype.computeIntersection.apply(this,arguments);var e=arguments[0],n=arguments[1],i=arguments[2];if(this._isProper=!1,j.intersects(n,i,e)&&0===at.orientationIndex(n,i,e)&&0===at.orientationIndex(i,n,e))return this._isProper=!0,(e.equals(n)||e.equals(i))&&(this._isProper=!1),this._result=t.POINT_INTERSECTION,null;this._result=t.NO_INTERSECTION;},e.prototype.normalizeToMinimum=function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y;},e.prototype.safeHCoordinateIntersection=function(t,n,i,r){var o=null;try{o=k.intersection(t,n,i,r);}catch(s){if(!(s instanceof X))throw s;o=e.nearestEndpoint(t,n,i,r);}return o},e.prototype.intersection=function(t,n,i,r){var o=this.intersectionWithNormalization(t,n,i,r);return this.isInSegmentEnvelopes(o)||(o=new C(e.nearestEndpoint(t,n,i,r))),null!==this._precisionModel&&this._precisionModel.makePrecise(o),o},e.prototype.smallestInAbsValue=function(t,e,n,i){var r=t,o=Math.abs(r);return Math.abs(e)<o&&(r=e,o=Math.abs(e)),Math.abs(n)<o&&(r=n,o=Math.abs(n)),Math.abs(i)<o&&(r=i),r},e.prototype.checkDD=function(t,e,n,i,r){var o=q.intersection(t,e,n,i),s=this.isInSegmentEnvelopes(o);Y.out.println("DD in env = "+s+"  --------------------- "+o),r.distance(o)>1e-4&&Y.out.println("Distance = "+r.distance(o));},e.prototype.intersectionWithNormalization=function(t,e,n,i){var r=new C(t),o=new C(e),s=new C(n),a=new C(i),u=new C;this.normalizeToEnvCentre(r,o,s,a,u);var l=this.safeHCoordinateIntersection(r,o,s,a);return l.x+=u.x,l.y+=u.y,l},e.prototype.computeCollinearIntersection=function(e,n,i,r){var o=j.intersects(e,n,i),s=j.intersects(e,n,r),a=j.intersects(i,r,e),u=j.intersects(i,r,n);return o&&s?(this._intPt[0]=i,this._intPt[1]=r,t.COLLINEAR_INTERSECTION):a&&u?(this._intPt[0]=e,this._intPt[1]=n,t.COLLINEAR_INTERSECTION):o&&a?(this._intPt[0]=i,this._intPt[1]=e,!i.equals(e)||s||u?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):o&&u?(this._intPt[0]=i,this._intPt[1]=n,!i.equals(n)||s||a?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):s&&a?(this._intPt[0]=r,this._intPt[1]=e,!r.equals(e)||o||u?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):s&&u?(this._intPt[0]=r,this._intPt[1]=n,!r.equals(n)||o||a?t.COLLINEAR_INTERSECTION:t.POINT_INTERSECTION):t.NO_INTERSECTION},e.prototype.normalizeToEnvCentre=function(t,e,n,i,r){var o=t.x<e.x?t.x:e.x,s=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,c=n.y<i.y?n.y:i.y,p=n.x>i.x?n.x:i.x,h=n.y>i.y?n.y:i.y,f=((o>l?o:l)+(a<p?a:p))/2,g=((s>c?s:c)+(u<h?u:h))/2;r.x=f,r.y=g,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y;},e.prototype.computeIntersect=function(e,n,i,r){if(this._isProper=!1,!j.intersects(e,n,i,r))return t.NO_INTERSECTION;var o=at.orientationIndex(e,n,i),s=at.orientationIndex(e,n,r);if(o>0&&s>0||o<0&&s<0)return t.NO_INTERSECTION;var a=at.orientationIndex(i,r,e),u=at.orientationIndex(i,r,n);if(a>0&&u>0||a<0&&u<0)return t.NO_INTERSECTION;return 0===o&&0===s&&0===a&&0===u?this.computeCollinearIntersection(e,n,i,r):(0===o||0===s||0===a||0===u?(this._isProper=!1,e.equals2D(i)||e.equals2D(r)?this._intPt[0]=e:n.equals2D(i)||n.equals2D(r)?this._intPt[0]=n:0===o?this._intPt[0]=new C(i):0===s?this._intPt[0]=new C(r):0===a?this._intPt[0]=new C(e):0===u&&(this._intPt[0]=new C(n))):(this._isProper=!0,this._intPt[0]=this.intersection(e,n,i,r)),t.POINT_INTERSECTION)},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e.nearestEndpoint=function(t,e,n,i){var r=t,o=at.distancePointLine(t,n,i),s=at.distancePointLine(e,n,i);return s<o&&(o=s,r=e),(s=at.distancePointLine(n,t,e))<o&&(o=s,r=n),(s=at.distancePointLine(i,t,e))<o&&(o=s,r=i),r},e}(nt),ot=function(){};ot.prototype.interfaces_=function(){return []},ot.prototype.getClass=function(){return ot},ot.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,o=n.x-e.x,s=n.y-e.y;return ot.signOfDet2x2(i,r,o,s)},ot.signOfDet2x2=function(t,e,n,i){var r=null,o=null,s=null;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?e<=i||(r=-r,o=t,t=n,n=o,o=e,e=i,i=o):e<=-i?(r=-r,n=-n,i=-i):(o=t,t=-n,n=o,o=e,e=-i,i=o):i>0?-e<=i?(r=-r,t=-t,e=-e):(o=-t,t=n,n=o,o=-e,e=i,i=o):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,o=-t,t=-n,n=o,o=-e,e=-i,i=o),t>0){if(!(n>0))return r;if(!(t<=n))return r}else {if(n>0)return -r;if(!(t>=n))return -r;r=-r,t=-t,n=-n;}for(;;){if(s=Math.floor(n/t),n-=s*t,(i-=s*e)<0)return -r;if(i>e)return r;if(t>n+n){if(e<i+i)return r}else {if(e>i+i)return -r;n=t-n,i=e-i,r=-r;}if(0===i)return 0===n?0:-r;if(0===n)return r;if(s=Math.floor(t/n),t-=s*n,(e-=s*i)<0)return r;if(e>i)return -r;if(n>t+t){if(i<e+e)return -r}else {if(i>e+e)return r;t=n-t,e=i-e,r=-r;}if(0===e)return 0===t?0:r;if(0===t)return -r}};var st=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;var t=arguments[0];this._p=t;};st.prototype.countSegment=function(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this._p.x>=n&&this._p.x<=i&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){var r=t.x-this._p.x,o=t.y-this._p.y,s=e.x-this._p.x,a=e.y-this._p.y,u=ot.signOfDet2x2(r,o,s,a);if(0===u)return this._isPointOnSegment=!0,null;a<o&&(u=-u),u>0&&this._crossingCount++;}},st.prototype.isPointInPolygon=function(){return this.getLocation()!==w.EXTERIOR},st.prototype.getLocation=function(){return this._isPointOnSegment?w.BOUNDARY:this._crossingCount%2==1?w.INTERIOR:w.EXTERIOR},st.prototype.isOnSegment=function(){return this._isPointOnSegment},st.prototype.interfaces_=function(){return []},st.prototype.getClass=function(){return st},st.locatePointInRing=function(){if(arguments[0]instanceof C&&T(arguments[1],V)){for(var t=arguments[0],e=arguments[1],n=new st(t),i=new C,r=new C,o=1;o<e.size();o++)if(e.getCoordinate(o,i),e.getCoordinate(o-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof C&&arguments[1]instanceof Array){for(var s=arguments[0],a=arguments[1],u=new st(s),l=1;l<a.length;l++){var c=a[l],p=a[l-1];if(u.countSegment(c,p),u.isOnSegment())return u.getLocation()}return u.getLocation()}};var at=function(){},ut={CLOCKWISE:{configurable:!0},RIGHT:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},LEFT:{configurable:!0},COLLINEAR:{configurable:!0},STRAIGHT:{configurable:!0}};at.prototype.interfaces_=function(){return []},at.prototype.getClass=function(){return at},at.orientationIndex=function(t,e,n){return q.orientationIndex(t,e,n)},at.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,o=t[i+1].y;e+=r*(t[i-1].y-o);}return e/2}if(T(arguments[0],V)){var s=arguments[0],a=s.size();if(a<3)return 0;var u=new C,l=new C,c=new C;s.getCoordinate(0,l),s.getCoordinate(1,c);var p=l.x;c.x-=p;for(var h=0,f=1;f<a-1;f++)u.y=l.y,l.x=c.x,l.y=c.y,s.getCoordinate(f+1,c),c.x-=p,h+=l.x*(u.y-c.y);return h/2}},at.distanceLineLine=function(t,e,n,i){if(t.equals(e))return at.distancePointLine(t,n,i);if(n.equals(i))return at.distancePointLine(i,t,e);var r=!1;if(j.intersects(t,e,n,i)){var o=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===o)r=!0;else {var s=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/o,u=s/o;(u<0||u>1||a<0||a>1)&&(r=!0);}}else r=!0;return r?R.min(at.distancePointLine(t,n,i),at.distancePointLine(e,n,i),at.distancePointLine(n,t,e),at.distancePointLine(i,t,e)):0},at.isPointInRing=function(t,e){return at.locatePointInRing(t,e)!==w.EXTERIOR},at.computeLength=function(t){var e=t.size();if(e<=1)return 0;var n=0,i=new C;t.getCoordinate(0,i);for(var r=i.x,o=i.y,s=1;s<e;s++){t.getCoordinate(s,i);var a=i.x,u=i.y,l=a-r,c=u-o;n+=Math.sqrt(l*l+c*c),r=a,o=u;}return n},at.isCCW=function(t){var e=t.length-1;if(e<3)throw new m("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],i=0,r=1;r<=e;r++){var o=t[r];o.y>n.y&&(n=o,i=r);}var s=i;do{(s-=1)<0&&(s=e);}while(t[s].equals2D(n)&&s!==i);var a=i;do{a=(a+1)%e;}while(t[a].equals2D(n)&&a!==i);var u=t[s],l=t[a];if(u.equals2D(n)||l.equals2D(n)||u.equals2D(l))return !1;var c=at.computeOrientation(u,n,l),p=!1;return p=0===c?u.x>l.x:c>0,p},at.locatePointInRing=function(t,e){return st.locatePointInRing(t,e)},at.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},at.computeOrientation=function(t,e,n){return at.orientationIndex(t,e,n)},at.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new m("Line array must contain at least one vertex");for(var n=t.distance(e[0]),i=0;i<e.length-1;i++){var r=at.distancePointLine(t,e[i],e[i+1]);r<n&&(n=r);}return n}if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];if(s.x===a.x&&s.y===a.y)return o.distance(s);var u=(a.x-s.x)*(a.x-s.x)+(a.y-s.y)*(a.y-s.y),l=((o.x-s.x)*(a.x-s.x)+(o.y-s.y)*(a.y-s.y))/u;if(l<=0)return o.distance(s);if(l>=1)return o.distance(a);var c=((s.y-o.y)*(a.x-s.x)-(s.x-o.x)*(a.y-s.y))/u;return Math.abs(c)*Math.sqrt(u)}},at.isOnLine=function(t,e){for(var n=new rt,i=1;i<e.length;i++){var r=e[i-1],o=e[i];if(n.computeIntersection(t,r,o),n.hasIntersection())return !0}return !1},ut.CLOCKWISE.get=function(){return -1},ut.RIGHT.get=function(){return at.CLOCKWISE},ut.COUNTERCLOCKWISE.get=function(){return 1},ut.LEFT.get=function(){return at.COUNTERCLOCKWISE},ut.COLLINEAR.get=function(){return 0},ut.STRAIGHT.get=function(){return at.COLLINEAR},Object.defineProperties(at,ut);var lt=function(){};lt.prototype.filter=function(t){},lt.prototype.interfaces_=function(){return []},lt.prototype.getClass=function(){return lt};var ct=function(){var t=arguments[0];this._envelope=null,this._factory=null,this._SRID=null,this._userData=null,this._factory=t,this._SRID=t.getSRID();},pt={serialVersionUID:{configurable:!0},SORTINDEX_POINT:{configurable:!0},SORTINDEX_MULTIPOINT:{configurable:!0},SORTINDEX_LINESTRING:{configurable:!0},SORTINDEX_LINEARRING:{configurable:!0},SORTINDEX_MULTILINESTRING:{configurable:!0},SORTINDEX_POLYGON:{configurable:!0},SORTINDEX_MULTIPOLYGON:{configurable:!0},SORTINDEX_GEOMETRYCOLLECTION:{configurable:!0},geometryChangedFilter:{configurable:!0}};ct.prototype.isGeometryCollection=function(){return this.getSortIndex()===ct.SORTINDEX_GEOMETRYCOLLECTION},ct.prototype.getFactory=function(){return this._factory},ct.prototype.getGeometryN=function(t){return this},ct.prototype.getArea=function(){return 0},ct.prototype.isRectangle=function(){return !1},ct.prototype.equals=function(){if(arguments[0]instanceof ct){var t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof ct))return !1;var n=e;return this.equalsExact(n)}},ct.prototype.equalsExact=function(t){return this===t||this.equalsExact(t,0)},ct.prototype.geometryChanged=function(){this.apply(ct.geometryChangedFilter);},ct.prototype.geometryChangedAction=function(){this._envelope=null;},ct.prototype.equalsNorm=function(t){return null!==t&&this.norm().equalsExact(t.norm())},ct.prototype.getLength=function(){return 0},ct.prototype.getNumGeometries=function(){return 1},ct.prototype.compareTo=function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.getSortIndex()!==n.getSortIndex()?this.getSortIndex()-n.getSortIndex():this.isEmpty()&&n.isEmpty()?0:this.isEmpty()?-1:n.isEmpty()?1:this.compareToSameClass(n,i)}},ct.prototype.getUserData=function(){return this._userData},ct.prototype.getSRID=function(){return this._SRID},ct.prototype.getEnvelope=function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},ct.prototype.checkNotGeometryCollection=function(t){if(t.getSortIndex()===ct.SORTINDEX_GEOMETRYCOLLECTION)throw new m("This method does not support GeometryCollection arguments")},ct.prototype.equal=function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},ct.prototype.norm=function(){var t=this.copy();return t.normalize(),t},ct.prototype.getPrecisionModel=function(){return this._factory.getPrecisionModel()},ct.prototype.getEnvelopeInternal=function(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new j(this._envelope)},ct.prototype.setSRID=function(t){this._SRID=t;},ct.prototype.setUserData=function(t){this._userData=t;},ct.prototype.compare=function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),o=i.next(),s=r.compareTo(o);if(0!==s)return s}return n.hasNext()?1:i.hasNext()?-1:0},ct.prototype.hashCode=function(){return this.getEnvelopeInternal().hashCode()},ct.prototype.isGeometryCollectionOrDerived=function(){return this.getSortIndex()===ct.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===ct.SORTINDEX_MULTIPOINT||this.getSortIndex()===ct.SORTINDEX_MULTILINESTRING||this.getSortIndex()===ct.SORTINDEX_MULTIPOLYGON},ct.prototype.interfaces_=function(){return [x,E,e]},ct.prototype.getClass=function(){return ct},ct.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return !0;return !1},ct.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return !0;return !1},pt.serialVersionUID.get=function(){return 0x799ea46522854c00},pt.SORTINDEX_POINT.get=function(){return 0},pt.SORTINDEX_MULTIPOINT.get=function(){return 1},pt.SORTINDEX_LINESTRING.get=function(){return 2},pt.SORTINDEX_LINEARRING.get=function(){return 3},pt.SORTINDEX_MULTILINESTRING.get=function(){return 4},pt.SORTINDEX_POLYGON.get=function(){return 5},pt.SORTINDEX_MULTIPOLYGON.get=function(){return 6},pt.SORTINDEX_GEOMETRYCOLLECTION.get=function(){return 7},pt.geometryChangedFilter.get=function(){return ht},Object.defineProperties(ct,pt);var ht=function(){};ht.interfaces_=function(){return [lt]},ht.filter=function(t){t.geometryChangedAction();};var ft=function(){};ft.prototype.filter=function(t){},ft.prototype.interfaces_=function(){return []},ft.prototype.getClass=function(){return ft};var gt=function(){},dt={Mod2BoundaryNodeRule:{configurable:!0},EndPointBoundaryNodeRule:{configurable:!0},MultiValentEndPointBoundaryNodeRule:{configurable:!0},MonoValentEndPointBoundaryNodeRule:{configurable:!0},MOD2_BOUNDARY_RULE:{configurable:!0},ENDPOINT_BOUNDARY_RULE:{configurable:!0},MULTIVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},MONOVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},OGC_SFS_BOUNDARY_RULE:{configurable:!0}};gt.prototype.isInBoundary=function(t){},gt.prototype.interfaces_=function(){return []},gt.prototype.getClass=function(){return gt},dt.Mod2BoundaryNodeRule.get=function(){return yt},dt.EndPointBoundaryNodeRule.get=function(){return _t},dt.MultiValentEndPointBoundaryNodeRule.get=function(){return mt},dt.MonoValentEndPointBoundaryNodeRule.get=function(){return vt},dt.MOD2_BOUNDARY_RULE.get=function(){return new yt},dt.ENDPOINT_BOUNDARY_RULE.get=function(){return new _t},dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new mt},dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new vt},dt.OGC_SFS_BOUNDARY_RULE.get=function(){return gt.MOD2_BOUNDARY_RULE},Object.defineProperties(gt,dt);var yt=function(){};yt.prototype.isInBoundary=function(t){return t%2==1},yt.prototype.interfaces_=function(){return [gt]},yt.prototype.getClass=function(){return yt};var _t=function(){};_t.prototype.isInBoundary=function(t){return t>0},_t.prototype.interfaces_=function(){return [gt]},_t.prototype.getClass=function(){return _t};var mt=function(){};mt.prototype.isInBoundary=function(t){return t>1},mt.prototype.interfaces_=function(){return [gt]},mt.prototype.getClass=function(){return mt};var vt=function(){};vt.prototype.isInBoundary=function(t){return 1===t},vt.prototype.interfaces_=function(){return [gt]},vt.prototype.getClass=function(){return vt};var It=function(){};It.prototype.add=function(){},It.prototype.addAll=function(){},It.prototype.isEmpty=function(){},It.prototype.iterator=function(){},It.prototype.size=function(){},It.prototype.toArray=function(){},It.prototype.remove=function(){},(n.prototype=new Error).name="IndexOutOfBoundsException";var Et=function(){};Et.prototype.hasNext=function(){},Et.prototype.next=function(){},Et.prototype.remove=function(){};var xt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(){},e.prototype.set=function(){},e.prototype.isEmpty=function(){},e}(It);(i.prototype=new Error).name="NoSuchElementException";var Nt=function(t){function e(){t.call(this),this.array_=[],arguments[0]instanceof It&&this.addAll(arguments[0]);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.ensureCapacity=function(){},e.prototype.interfaces_=function(){return [t,It]},e.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],arguments[1]),!0},e.prototype.clear=function(){this.array_=[];},e.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return !0},e.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},e.prototype.iterator=function(){return new Ct(this)},e.prototype.get=function(t){if(t<0||t>=this.size())throw new n;return this.array_[t]},e.prototype.isEmpty=function(){return 0===this.array_.length},e.prototype.size=function(){return this.array_.length},e.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},e.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;n<i;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e},e}(xt),Ct=function(t){function e(e){t.call(this),this.arrayList_=e,this.position_=0;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new i;return this.arrayList_.get(this.position_++)},e.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},e.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},e.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_));},e}(Et),St=function(t){function e(){if(t.call(this),0===arguments.length);else if(1===arguments.length){var e=arguments[0];this.ensureCapacity(e.length),this.add(e,!0);}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.ensureCapacity(n.length),this.add(n,i);}}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={coordArrayType:{configurable:!0}};return n.coordArrayType.get=function(){return new Array(0).fill(null)},e.prototype.getCoordinate=function(t){return this.get(t)},e.prototype.addAll=function(){if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=!1,r=e.iterator();r.hasNext();)this.add(r.next(),n),i=!0;return i}return t.prototype.addAll.apply(this,arguments)},e.prototype.clone=function(){for(var e=t.prototype.clone.call(this),n=0;n<this.size();n++)e.add(n,this.get(n).copy());return e},e.prototype.toCoordinateArray=function(){return this.toArray(e.coordArrayType)},e.prototype.add=function(){if(1===arguments.length){var e=arguments[0];t.prototype.add.call(this,e);}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var n=arguments[0],i=arguments[1];return this.add(n,i,!0),!0}if(arguments[0]instanceof C&&"boolean"==typeof arguments[1]){var r=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(r))return null}t.prototype.add.call(this,r);}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],s=arguments[1];return this.add(o,s),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var a=arguments[0],u=arguments[1];if(arguments[2])for(var l=0;l<a.length;l++)this.add(a[l],u);else for(var c=a.length-1;c>=0;c--)this.add(a[c],u);return !0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof C){var p=arguments[0],h=arguments[1];if(!arguments[2]){var f=this.size();if(f>0){if(p>0){if(this.get(p-1).equals2D(h))return null}if(p<f){if(this.get(p).equals2D(h))return null}}}t.prototype.add.call(this,p,h);}}else if(4===arguments.length){var g=arguments[0],d=arguments[1],y=arguments[2],_=arguments[3],m=1;y>_&&(m=-1);for(var v=y;v!==_;v+=m)this.add(g[v],d);return !0}},e.prototype.closeRing=function(){this.size()>0&&this.add(new C(this.get(0)),!1);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},Object.defineProperties(e,n),e}(Nt),Lt=function(){},bt={ForwardComparator:{configurable:!0},BidirectionalComparator:{configurable:!0},coordArrayType:{configurable:!0}};bt.ForwardComparator.get=function(){return wt},bt.BidirectionalComparator.get=function(){return Ot},bt.coordArrayType.get=function(){return new Array(0).fill(null)},Lt.prototype.interfaces_=function(){return []},Lt.prototype.getClass=function(){return Lt},Lt.isRing=function(t){return !(t.length<4)&&!!t[0].equals2D(t[t.length-1])},Lt.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(Lt.indexOf(i,e)<0)return i}return null},Lt.scroll=function(t,e){var n=Lt.indexOf(e,t);if(n<0)return null;var i=new Array(t.length).fill(null);Y.arraycopy(t,n,i,0,t.length-n),Y.arraycopy(t,0,i,t.length-n,n),Y.arraycopy(i,0,t,0,t.length);},Lt.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return !0;if(null===t||null===e)return !1;if(t.length!==e.length)return !1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return !1;return !0}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];if(i===r)return !0;if(null===i||null===r)return !1;if(i.length!==r.length)return !1;for(var s=0;s<i.length;s++)if(0!==o.compare(i[s],r[s]))return !1;return !0}},Lt.intersection=function(t,e){for(var n=new St,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},Lt.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return !0;return !1},Lt.removeRepeatedPoints=function(t){if(!Lt.hasRepeatedPoints(t))return t;return new St(t,!1).toCoordinateArray()},Lt.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;i<=n;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r;}},Lt.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,o=0;o<t.length;o++)null!==t[o]&&(i[r++]=t[o]);return i},Lt.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new C(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],o=arguments[2],s=arguments[3],a=arguments[4],u=0;u<a;u++)o[s+u]=new C(i[r+u]);},Lt.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return !1}return !0},Lt.envelope=function(t){for(var e=new j,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},Lt.toCoordinateArray=function(t){return t.toArray(Lt.coordArrayType)},Lt.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},Lt.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return -1},Lt.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},Lt.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++;}return n<e.length?-1:n<t.length?1:0},Lt.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},Lt.extract=function(t,e,n){e=R.clamp(e,0,t.length);var i=(n=R.clamp(n,-1,t.length))-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var o=0,s=e;s<=n;s++)r[o++]=t[s];return r},Object.defineProperties(Lt,bt);var wt=function(){};wt.prototype.compare=function(t,e){return Lt.compare(t,e)},wt.prototype.interfaces_=function(){return [N]},wt.prototype.getClass=function(){return wt};var Ot=function(){};Ot.prototype.compare=function(t,e){var n=t,i=e;if(n.length<i.length)return -1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=Lt.compare(n,i);return Lt.isEqualReversed(n,i)?0:r},Ot.prototype.OLDcompare=function(t,e){var n=t,i=e;if(n.length<i.length)return -1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=Lt.increasingDirection(n),o=Lt.increasingDirection(i),s=r>0?0:n.length-1,a=o>0?0:n.length-1,u=0;u<n.length;u++){var l=n[s].compareTo(i[a]);if(0!==l)return l;s+=r,a+=o;}return 0},Ot.prototype.interfaces_=function(){return [N]},Ot.prototype.getClass=function(){return Ot};var Tt=function(){};Tt.prototype.get=function(){},Tt.prototype.put=function(){},Tt.prototype.size=function(){},Tt.prototype.values=function(){},Tt.prototype.entrySet=function(){};var Rt=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Tt);(r.prototype=new Error).name="OperationNotSupported",(o.prototype=new It).contains=function(){};var Pt=function(t){function e(){t.call(this),this.array_=[],arguments[0]instanceof It&&this.addAll(arguments[0]);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.contains=function(t){for(var e=0,n=this.array_.length;e<n;e++){if(this.array_[e]===t)return !0}return !1},e.prototype.add=function(t){return !this.contains(t)&&(this.array_.push(t),!0)},e.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return !0},e.prototype.remove=function(t){throw new Error},e.prototype.size=function(){return this.array_.length},e.prototype.isEmpty=function(){return 0===this.array_.length},e.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},e.prototype.iterator=function(){return new Dt(this)},e}(o),Dt=function(t){function e(e){t.call(this),this.hashSet_=e,this.position_=0;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new i;return this.hashSet_.array_[this.position_++]},e.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},e.prototype.remove=function(){throw new r},e}(Et),Mt=0;(p.prototype=new Rt).get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else {if(!(n>0))return e.value;e=e.right;}}return null},p.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:Mt,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do{if(n=r,(i=t.compareTo(r.key))<0)r=r.left;else {if(!(i>0)){var o=r.value;return r.value=e,o}r=r.right;}}while(null!==r);var s={key:t,left:null,right:null,value:e,parent:n,color:Mt,getValue:function(){return this.value},getKey:function(){return this.key}};return i<0?n.left=s:n.right=s,this.fixAfterInsertion(s),this.size_++,null},p.prototype.fixAfterInsertion=function(t){for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)if(a(t)===l(a(a(t)))){var e=c(a(a(t)));1===s(e)?(u(a(t),Mt),u(e,Mt),u(a(a(t)),1),t=a(a(t))):(t===c(a(t))&&(t=a(t),this.rotateLeft(t)),u(a(t),Mt),u(a(a(t)),1),this.rotateRight(a(a(t))));}else {var n=l(a(a(t)));1===s(n)?(u(a(t),Mt),u(n,Mt),u(a(a(t)),1),t=a(a(t))):(t===l(a(t))&&(t=a(t),this.rotateRight(t)),u(a(t),Mt),u(a(a(t)),1),this.rotateLeft(a(a(t))));}this.root_.color=Mt;},p.prototype.values=function(){var t=new Nt,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=p.successor(e));)t.add(e.value);return t},p.prototype.entrySet=function(){var t=new Pt,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=p.successor(e));)t.add(e);return t},p.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null===t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e;}},p.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null===t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e;}},p.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},p.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var n=t.parent,i=t;null!==n&&i===n.right;)i=n,n=n.parent;return n},p.prototype.size=function(){return this.size_};var At=function(){};At.prototype.interfaces_=function(){return []},At.prototype.getClass=function(){return At},h.prototype=new o,(f.prototype=new h).contains=function(t){for(var e=0,n=this.array_.length;e<n;e++){if(0===this.array_[e].compareTo(t))return !0}return !1},f.prototype.add=function(t){if(this.contains(t))return !1;for(var e=0,n=this.array_.length;e<n;e++){if(1===this.array_[e].compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},f.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return !0},f.prototype.remove=function(t){throw new r},f.prototype.size=function(){return this.array_.length},f.prototype.isEmpty=function(){return 0===this.array_.length},f.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},f.prototype.iterator=function(){return new Ft(this)};var Ft=function(t){this.treeSet_=t,this.position_=0;};Ft.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new i;return this.treeSet_.array_[this.position_++]},Ft.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},Ft.prototype.remove=function(){throw new r};var Gt=function(){};Gt.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)i=function(t,e){return t.compareTo(e)},r.sort(i);else if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else if(3===arguments.length){(e=r.slice(arguments[1],arguments[2])).sort();var o=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<o.length;t++)r.push(o[t]);}else if(4===arguments.length)for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),o=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<o.length;t++)r.push(o[t]);},Gt.asList=function(t){for(var e=new Nt,n=0,i=t.length;n<i;n++)e.add(t[n]);return e};var qt=function(){},Bt={P:{configurable:!0},L:{configurable:!0},A:{configurable:!0},FALSE:{configurable:!0},TRUE:{configurable:!0},DONTCARE:{configurable:!0},SYM_FALSE:{configurable:!0},SYM_TRUE:{configurable:!0},SYM_DONTCARE:{configurable:!0},SYM_P:{configurable:!0},SYM_L:{configurable:!0},SYM_A:{configurable:!0}};Bt.P.get=function(){return 0},Bt.L.get=function(){return 1},Bt.A.get=function(){return 2},Bt.FALSE.get=function(){return -1},Bt.TRUE.get=function(){return -2},Bt.DONTCARE.get=function(){return -3},Bt.SYM_FALSE.get=function(){return "F"},Bt.SYM_TRUE.get=function(){return "T"},Bt.SYM_DONTCARE.get=function(){return "*"},Bt.SYM_P.get=function(){return "0"},Bt.SYM_L.get=function(){return "1"},Bt.SYM_A.get=function(){return "2"},qt.prototype.interfaces_=function(){return []},qt.prototype.getClass=function(){return qt},qt.toDimensionSymbol=function(t){switch(t){case qt.FALSE:return qt.SYM_FALSE;case qt.TRUE:return qt.SYM_TRUE;case qt.DONTCARE:return qt.SYM_DONTCARE;case qt.P:return qt.SYM_P;case qt.L:return qt.SYM_L;case qt.A:return qt.SYM_A}throw new m("Unknown dimension value: "+t)},qt.toDimensionValue=function(t){switch(A.toUpperCase(t)){case qt.SYM_FALSE:return qt.FALSE;case qt.SYM_TRUE:return qt.TRUE;case qt.SYM_DONTCARE:return qt.DONTCARE;case qt.SYM_P:return qt.P;case qt.SYM_L:return qt.L;case qt.SYM_A:return qt.A}throw new m("Unknown dimension symbol: "+t)},Object.defineProperties(qt,Bt);var Vt=function(){};Vt.prototype.filter=function(t){},Vt.prototype.interfaces_=function(){return []},Vt.prototype.getClass=function(){return Vt};var Ut=function(){};Ut.prototype.filter=function(t,e){},Ut.prototype.isDone=function(){},Ut.prototype.isGeometryChanged=function(){},Ut.prototype.interfaces_=function(){return []},Ut.prototype.getClass=function(){return Ut};var zt=function(t){function e(e,n){if(t.call(this,n),this._geometries=e||[],t.hasNullElements(this._geometries))throw new m("geometries must not contain null elements")}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){for(var t=new j,e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t},e.prototype.getGeometryN=function(t){return this._geometries[t]},e.prototype.getSortIndex=function(){return t.SORTINDEX_GEOMETRYCOLLECTION},e.prototype.getCoordinates=function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this._geometries.length;n++)for(var i=this._geometries[n].getCoordinates(),r=0;r<i.length;r++)t[++e]=i[r];return t},e.prototype.getArea=function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!this.isEquivalentClass(e))return !1;var i=e;if(this._geometries.length!==i._geometries.length)return !1;for(var r=0;r<this._geometries.length;r++)if(!this._geometries[r].equalsExact(i._geometries[r],n))return !1;return !0}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){for(var t=0;t<this._geometries.length;t++)this._geometries[t].normalize();Gt.sort(this._geometries);},e.prototype.getCoordinate=function(){return this.isEmpty()?null:this._geometries[0].getCoordinate()},e.prototype.getBoundaryDimension=function(){for(var t=qt.FALSE,e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t},e.prototype.getDimension=function(){for(var t=qt.FALSE,e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t},e.prototype.getLength=function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t},e.prototype.getNumPoints=function(){for(var t=0,e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t},e.prototype.getNumGeometries=function(){return this._geometries.length},e.prototype.reverse=function(){for(var t=this._geometries.length,e=new Array(t).fill(null),n=0;n<this._geometries.length;n++)e[n]=this._geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},e.prototype.compareToSameClass=function(){if(1===arguments.length){var t=arguments[0],e=new f(Gt.asList(this._geometries)),n=new f(Gt.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],o=i,s=this.getNumGeometries(),a=o.getNumGeometries(),u=0;u<s&&u<a;){var l=this.getGeometryN(u),c=o.getGeometryN(u),p=l.compareToSameClass(c,r);if(0!==p)return p;u++;}return u<s?1:u<a?-1:0}},e.prototype.apply=function(){if(T(arguments[0],ft))for(var t=arguments[0],e=0;e<this._geometries.length;e++)this._geometries[e].apply(t);else if(T(arguments[0],Ut)){var n=arguments[0];if(0===this._geometries.length)return null;for(var i=0;i<this._geometries.length&&(this._geometries[i].apply(n),!n.isDone());i++);n.isGeometryChanged()&&this.geometryChanged();}else if(T(arguments[0],Vt)){var r=arguments[0];r.filter(this);for(var o=0;o<this._geometries.length;o++)this._geometries[o].apply(r);}else if(T(arguments[0],lt)){var s=arguments[0];s.filter(this);for(var a=0;a<this._geometries.length;a++)this._geometries[a].apply(s);}},e.prototype.getBoundary=function(){return this.checkNotGeometryCollection(this),et.shouldNeverReachHere(),null},e.prototype.clone=function(){var e=t.prototype.clone.call(this);e._geometries=new Array(this._geometries.length).fill(null);for(var n=0;n<this._geometries.length;n++)e._geometries[n]=this._geometries[n].clone();return e},e.prototype.getGeometryType=function(){return "GeometryCollection"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.isEmpty=function(){for(var t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return !1;return !0},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return -0x4f07bcb1f857d800},Object.defineProperties(e,n),e}(ct),Xt=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_MULTILINESTRING},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return !!this.isEquivalentClass(e)&&t.prototype.equalsExact.call(this,e,n)}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.getBoundaryDimension=function(){return this.isClosed()?qt.FALSE:0},e.prototype.isClosed=function(){if(this.isEmpty())return !1;for(var t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return !1;return !0},e.prototype.getDimension=function(){return 1},e.prototype.reverse=function(){for(var t=this._geometries.length,e=new Array(t).fill(null),n=0;n<this._geometries.length;n++)e[t-1-n]=this._geometries[n].reverse();return this.getFactory().createMultiLineString(e)},e.prototype.getBoundary=function(){return new Yt(this).getBoundary()},e.prototype.getGeometryType=function(){return "MultiLineString"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.interfaces_=function(){return [At]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return 0x7155d2ab4afa8000},Object.defineProperties(e,n),e}(zt),Yt=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){var t=arguments[0],e=gt.MOD2_BOUNDARY_RULE;this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e;}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this._geom=n,this._geomFact=n.getFactory(),this._bnRule=i;}};Yt.prototype.boundaryMultiLineString=function(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)},Yt.prototype.getBoundary=function(){return this._geom instanceof Kt?this.boundaryLineString(this._geom):this._geom instanceof Xt?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()},Yt.prototype.boundaryLineString=function(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},Yt.prototype.getEmptyMultiPoint=function(){return this._geomFact.createMultiPoint()},Yt.prototype.computeBoundaryCoordinates=function(t){var e=new Nt;this._endpointMap=new p;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)));}for(var r=this._endpointMap.entrySet().iterator();r.hasNext();){var o=r.next(),s=o.getValue().count;this._bnRule.isInBoundary(s)&&e.add(o.getKey());}return Lt.toCoordinateArray(e)},Yt.prototype.addEndpoint=function(t){var e=this._endpointMap.get(t);null===e&&(e=new kt,this._endpointMap.put(t,e)),e.count++;},Yt.prototype.interfaces_=function(){return []},Yt.prototype.getClass=function(){return Yt},Yt.getBoundary=function(){if(1===arguments.length){var t=arguments[0];return new Yt(t).getBoundary()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return new Yt(e,n).getBoundary()}};var kt=function(){this.count=null;};kt.prototype.interfaces_=function(){return []},kt.prototype.getClass=function(){return kt};var jt=function(){},Ht={NEWLINE:{configurable:!0},SIMPLE_ORDINATE_FORMAT:{configurable:!0}};jt.prototype.interfaces_=function(){return []},jt.prototype.getClass=function(){return jt},jt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;i<e;i++)n[i]=t;return String(n)},jt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new function(){},n=new function(){}(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],o="",s=new function(){}(new function(){}(jt.getStackTrace(i))),a=0;a<r;a++)try{o+=s.readLine()+jt.NEWLINE;}catch(t){if(!(t instanceof g))throw t;et.shouldNeverReachHere();}return o}},jt.split=function(t,e){for(var n=e.length,i=new Nt,r=""+t,o=r.indexOf(e);o>=0;){var s=r.substring(0,o);i.add(s),o=(r=r.substring(o+n)).indexOf(e);}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},jt.toString=function(){if(1===arguments.length){var t=arguments[0];return jt.SIMPLE_ORDINATE_FORMAT.format(t)}},jt.spaces=function(t){return jt.chars(" ",t)},Ht.NEWLINE.get=function(){return Y.getProperty("line.separator")},Ht.SIMPLE_ORDINATE_FORMAT.get=function(){return new function(){}("0.#")},Object.defineProperties(jt,Ht);var Wt=function(){};Wt.prototype.interfaces_=function(){return []},Wt.prototype.getClass=function(){return Wt},Wt.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),o=0;o<r;o++)n.setOrdinate(i,o,t.getOrdinate(e,o));},Wt.isRing=function(t){var e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,V.X)===t.getOrdinate(e-1,V.X)&&t.getOrdinate(0,V.Y)===t.getOrdinate(e-1,V.Y))},Wt.isEqual=function(t,e){var n=t.size();if(n!==e.size())return !1;for(var i=Math.min(t.getDimension(),e.getDimension()),r=0;r<n;r++)for(var o=0;o<i;o++){var s=t.getOrdinate(r,o),a=e.getOrdinate(r,o);if(t.getOrdinate(r,o)!==e.getOrdinate(r,o)&&(!v.isNaN(s)||!v.isNaN(a)))return !1}return !0},Wt.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Wt.copy(e,0,i,0,r),r>0)for(var o=r;o<n;o++)Wt.copy(e,r-1,i,o,1);return i},Wt.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;i<=n;i++)Wt.swap(t,i,e-i);},Wt.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r);}},Wt.copy=function(t,e,n,i,r){for(var o=0;o<r;o++)Wt.copyCoord(t,e+o,n,i+o);},Wt.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return "()";var n=t.getDimension(),i=new D;i.append("(");for(var r=0;r<e;r++){r>0&&i.append(" ");for(var o=0;o<n;o++)o>0&&i.append(","),i.append(jt.toString(t.getOrdinate(r,o)));}return i.append(")"),i.toString()}},Wt.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(n<=3)return Wt.createClosedRing(t,e,4);return e.getOrdinate(0,V.X)===e.getOrdinate(n-1,V.X)&&e.getOrdinate(0,V.Y)===e.getOrdinate(n-1,V.Y)?e:Wt.createClosedRing(t,e,n+1)},Wt.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Wt.copy(e,0,i,0,r);for(var o=r;o<n;o++)Wt.copy(e,0,i,o,1);return i};var Kt=function(t){function e(e,n){t.call(this,n),this._points=null,this.init(e);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){return this.isEmpty()?new j:this._points.expandEnvelope(new j)},e.prototype.isRing=function(){return this.isClosed()&&this.isSimple()},e.prototype.getSortIndex=function(){return t.SORTINDEX_LINESTRING},e.prototype.getCoordinates=function(){return this._points.toCoordinateArray()},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!this.isEquivalentClass(e))return !1;var i=e;if(this._points.size()!==i._points.size())return !1;for(var r=0;r<this._points.size();r++)if(!this.equal(this._points.getCoordinate(r),i._points.getCoordinate(r),n))return !1;return !0}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){for(var t=0;t<Math.trunc(this._points.size()/2);t++){var e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e)))return this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0&&Wt.reverse(this._points),null}},e.prototype.getCoordinate=function(){return this.isEmpty()?null:this._points.getCoordinate(0)},e.prototype.getBoundaryDimension=function(){return this.isClosed()?qt.FALSE:0},e.prototype.isClosed=function(){return !this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},e.prototype.getEndPoint=function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},e.prototype.getDimension=function(){return 1},e.prototype.getLength=function(){return at.computeLength(this._points)},e.prototype.getNumPoints=function(){return this._points.size()},e.prototype.reverse=function(){var t=this._points.copy();Wt.reverse(t);return this.getFactory().createLineString(t)},e.prototype.compareToSameClass=function(){if(1===arguments.length){for(var t=arguments[0],e=0,n=0;e<this._points.size()&&n<t._points.size();){var i=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==i)return i;e++,n++;}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){var r=arguments[0];return arguments[1].compare(this._points,r._points)}},e.prototype.apply=function(){if(T(arguments[0],ft))for(var t=arguments[0],e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e));else if(T(arguments[0],Ut)){var n=arguments[0];if(0===this._points.size())return null;for(var i=0;i<this._points.size()&&(n.filter(this._points,i),!n.isDone());i++);n.isGeometryChanged()&&this.geometryChanged();}else if(T(arguments[0],Vt)){arguments[0].filter(this);}else if(T(arguments[0],lt)){arguments[0].filter(this);}},e.prototype.getBoundary=function(){return new Yt(this).getBoundary()},e.prototype.isEquivalentClass=function(t){return t instanceof e},e.prototype.clone=function(){var e=t.prototype.clone.call(this);return e._points=this._points.clone(),e},e.prototype.getCoordinateN=function(t){return this._points.getCoordinate(t)},e.prototype.getGeometryType=function(){return "LineString"},e.prototype.copy=function(){return new e(this._points.copy(),this._factory)},e.prototype.getCoordinateSequence=function(){return this._points},e.prototype.isEmpty=function(){return 0===this._points.size()},e.prototype.init=function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new m("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t;},e.prototype.isCoordinate=function(t){for(var e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return !0;return !1},e.prototype.getStartPoint=function(){return this.isEmpty()?null:this.getPointN(0)},e.prototype.getPointN=function(t){return this.getFactory().createPoint(this._points.getCoordinate(t))},e.prototype.interfaces_=function(){return [At]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return 0x2b2b51ba435c8e00},Object.defineProperties(e,n),e}(ct),Jt=function(){};Jt.prototype.interfaces_=function(){return []},Jt.prototype.getClass=function(){return Jt};var Qt=function(t){function e(e,n){t.call(this,n),this._coordinates=e||null,this.init(this._coordinates);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){if(this.isEmpty())return new j;var t=new j;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t},e.prototype.getSortIndex=function(){return t.SORTINDEX_POINT},e.prototype.getCoordinates=function(){return this.isEmpty()?[]:[this.getCoordinate()]},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return !!this.isEquivalentClass(e)&&(!(!this.isEmpty()||!e.isEmpty())||this.isEmpty()===e.isEmpty()&&this.equal(e.getCoordinate(),this.getCoordinate(),n))}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){},e.prototype.getCoordinate=function(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null},e.prototype.getBoundaryDimension=function(){return qt.FALSE},e.prototype.getDimension=function(){return 0},e.prototype.getNumPoints=function(){return this.isEmpty()?0:1},e.prototype.reverse=function(){return this.copy()},e.prototype.getX=function(){if(null===this.getCoordinate())throw new Error("getX called on empty Point");return this.getCoordinate().x},e.prototype.compareToSameClass=function(){if(1===arguments.length){var t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){var e=arguments[0];return arguments[1].compare(this._coordinates,e._coordinates)}},e.prototype.apply=function(){if(T(arguments[0],ft)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate());}else if(T(arguments[0],Ut)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this._coordinates,0),e.isGeometryChanged()&&this.geometryChanged();}else if(T(arguments[0],Vt)){arguments[0].filter(this);}else if(T(arguments[0],lt)){arguments[0].filter(this);}},e.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},e.prototype.clone=function(){var e=t.prototype.clone.call(this);return e._coordinates=this._coordinates.clone(),e},e.prototype.getGeometryType=function(){return "Point"},e.prototype.copy=function(){return new e(this._coordinates.copy(),this._factory)},e.prototype.getCoordinateSequence=function(){return this._coordinates},e.prototype.getY=function(){if(null===this.getCoordinate())throw new Error("getY called on empty Point");return this.getCoordinate().y},e.prototype.isEmpty=function(){return 0===this._coordinates.size()},e.prototype.init=function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),et.isTrue(t.size()<=1),this._coordinates=t;},e.prototype.isSimple=function(){return !0},e.prototype.interfaces_=function(){return [Jt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return 0x44077bad161cbc00},Object.defineProperties(e,n),e}(ct),Zt=function(){};Zt.prototype.interfaces_=function(){return []},Zt.prototype.getClass=function(){return Zt};var $t=function(t){function e(e,n,i){if(t.call(this,i),this._shell=null,this._holes=null,null===e&&(e=this.getFactory().createLinearRing()),null===n&&(n=[]),t.hasNullElements(n))throw new m("holes must not contain null elements");if(e.isEmpty()&&t.hasNonEmptyElements(n))throw new m("shell is empty but holes are not");this._shell=e,this._holes=n;}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.computeEnvelopeInternal=function(){return this._shell.getEnvelopeInternal()},e.prototype.getSortIndex=function(){return t.SORTINDEX_POLYGON},e.prototype.getCoordinates=function(){if(this.isEmpty())return [];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this._shell.getCoordinates(),i=0;i<n.length;i++)t[++e]=n[i];for(var r=0;r<this._holes.length;r++)for(var o=this._holes[r].getCoordinates(),s=0;s<o.length;s++)t[++e]=o[s];return t},e.prototype.getArea=function(){var t=0;t+=Math.abs(at.signedArea(this._shell.getCoordinateSequence()));for(var e=0;e<this._holes.length;e++)t-=Math.abs(at.signedArea(this._holes[e].getCoordinateSequence()));return t},e.prototype.isRectangle=function(){if(0!==this.getNumInteriorRing())return !1;if(null===this._shell)return !1;if(5!==this._shell.getNumPoints())return !1;for(var t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;n<5;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return !1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return !1}for(var o=t.getX(0),s=t.getY(0),a=1;a<=4;a++){var u=t.getX(a),l=t.getY(a);if(u!==o===(l!==s))return !1;o=u,s=l;}return !0},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!this.isEquivalentClass(e))return !1;var i=e,r=this._shell,o=i._shell;if(!r.equalsExact(o,n))return !1;if(this._holes.length!==i._holes.length)return !1;for(var s=0;s<this._holes.length;s++)if(!this._holes[s].equalsExact(i._holes[s],n))return !1;return !0}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.normalize=function(){if(0===arguments.length){this.normalize(this._shell,!0);for(var t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);Gt.sort(this._holes);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);Y.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=Lt.minCoordinate(e.getCoordinates());Lt.scroll(i,r),Y.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],at.isCCW(e.getCoordinates())===n&&Lt.reverse(e.getCoordinates());}},e.prototype.getCoordinate=function(){return this._shell.getCoordinate()},e.prototype.getNumInteriorRing=function(){return this._holes.length},e.prototype.getBoundaryDimension=function(){return 1},e.prototype.getDimension=function(){return 2},e.prototype.getLength=function(){var t=0;t+=this._shell.getLength();for(var e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t},e.prototype.getNumPoints=function(){for(var t=this._shell.getNumPoints(),e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t},e.prototype.reverse=function(){var t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=new Array(this._holes.length).fill(null);for(var e=0;e<this._holes.length;e++)t._holes[e]=this._holes[e].copy().reverse();return t},e.prototype.convexHull=function(){return this.getExteriorRing().convexHull()},e.prototype.compareToSameClass=function(){if(1===arguments.length){var t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],o=i,s=this._shell,a=o._shell,u=s.compareToSameClass(a,r);if(0!==u)return u;for(var l=this.getNumInteriorRing(),c=o.getNumInteriorRing(),p=0;p<l&&p<c;){var h=this.getInteriorRingN(p),f=o.getInteriorRingN(p),g=h.compareToSameClass(f,r);if(0!==g)return g;p++;}return p<l?1:p<c?-1:0}},e.prototype.apply=function(t){if(T(t,ft)){this._shell.apply(t);for(var e=0;e<this._holes.length;e++)this._holes[e].apply(t);}else if(T(t,Ut)){if(this._shell.apply(t),!t.isDone())for(var n=0;n<this._holes.length&&(this._holes[n].apply(t),!t.isDone());n++);t.isGeometryChanged()&&this.geometryChanged();}else if(T(t,Vt))t.filter(this);else if(T(t,lt)){t.filter(this),this._shell.apply(t);for(var i=0;i<this._holes.length;i++)this._holes[i].apply(t);}},e.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(var e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},e.prototype.clone=function(){var e=t.prototype.clone.call(this);e._shell=this._shell.clone(),e._holes=new Array(this._holes.length).fill(null);for(var n=0;n<this._holes.length;n++)e._holes[n]=this._holes[n].clone();return e},e.prototype.getGeometryType=function(){return "Polygon"},e.prototype.copy=function(){for(var t=this._shell.copy(),n=new Array(this._holes.length).fill(null),i=0;i<n.length;i++)n[i]=this._holes[i].copy();return new e(t,n,this._factory)},e.prototype.getExteriorRing=function(){return this._shell},e.prototype.isEmpty=function(){return this._shell.isEmpty()},e.prototype.getInteriorRingN=function(t){return this._holes[t]},e.prototype.interfaces_=function(){return [Zt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return -0x307ffefd8dc97200},Object.defineProperties(e,n),e}(ct),te=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_MULTIPOINT},e.prototype.isValid=function(){return !0},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return !!this.isEquivalentClass(e)&&t.prototype.equalsExact.call(this,e,n)}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.getCoordinate=function(){if(1===arguments.length){var e=arguments[0];return this._geometries[e].getCoordinate()}return t.prototype.getCoordinate.apply(this,arguments)},e.prototype.getBoundaryDimension=function(){return qt.FALSE},e.prototype.getDimension=function(){return 0},e.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},e.prototype.getGeometryType=function(){return "MultiPoint"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.interfaces_=function(){return [Jt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return -0x6fb1ed4162e0fc00},Object.defineProperties(e,n),e}(zt),ee=function(t){function e(e,n){e instanceof C&&n instanceof _e&&(e=n.getCoordinateSequenceFactory().create(e)),t.call(this,e,n),this.validateConstruction();}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={MINIMUM_VALID_SIZE:{configurable:!0},serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_LINEARRING},e.prototype.getBoundaryDimension=function(){return qt.FALSE},e.prototype.isClosed=function(){return !!this.isEmpty()||t.prototype.isClosed.call(this)},e.prototype.reverse=function(){var t=this._points.copy();Wt.reverse(t);return this.getFactory().createLinearRing(t)},e.prototype.validateConstruction=function(){if(!this.isEmpty()&&!t.prototype.isClosed.call(this))throw new m("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<e.MINIMUM_VALID_SIZE)throw new m("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},e.prototype.getGeometryType=function(){return "LinearRing"},e.prototype.copy=function(){return new e(this._points.copy(),this._factory)},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},n.MINIMUM_VALID_SIZE.get=function(){return 4},n.serialVersionUID.get=function(){return -0x3b229e262367a600},Object.defineProperties(e,n),e}(Kt),ne=function(t){function e(){t.apply(this,arguments);}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={serialVersionUID:{configurable:!0}};return e.prototype.getSortIndex=function(){return ct.SORTINDEX_MULTIPOLYGON},e.prototype.equalsExact=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return !!this.isEquivalentClass(e)&&t.prototype.equalsExact.call(this,e,n)}return t.prototype.equalsExact.apply(this,arguments)},e.prototype.getBoundaryDimension=function(){return 1},e.prototype.getDimension=function(){return 2},e.prototype.reverse=function(){for(var t=this._geometries.length,e=new Array(t).fill(null),n=0;n<this._geometries.length;n++)e[n]=this._geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},e.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new Nt,e=0;e<this._geometries.length;e++)for(var n=this._geometries[e].getBoundary(),i=0;i<n.getNumGeometries();i++)t.add(n.getGeometryN(i));var r=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(r))},e.prototype.getGeometryType=function(){return "MultiPolygon"},e.prototype.copy=function(){for(var t=new Array(this._geometries.length).fill(null),n=0;n<t.length;n++)t[n]=this._geometries[n].copy();return new e(t,this._factory)},e.prototype.interfaces_=function(){return [Zt]},e.prototype.getClass=function(){return e},n.serialVersionUID.get=function(){return -0x7a5aa1369171980},Object.defineProperties(e,n),e}(zt),ie=function(t){this._factory=t||null,this._isUserDataCopied=!1;},re={NoOpGeometryOperation:{configurable:!0},CoordinateOperation:{configurable:!0},CoordinateSequenceOperation:{configurable:!0}};ie.prototype.setCopyUserData=function(t){this._isUserDataCopied=t;},ie.prototype.edit=function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n},ie.prototype.editInternal=function(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof zt?this.editGeometryCollection(t,e):t instanceof $t?this.editPolygon(t,e):t instanceof Qt?e.edit(t,this._factory):t instanceof Kt?e.edit(t,this._factory):(et.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},ie.prototype.editGeometryCollection=function(t,e){for(var n=e.edit(t,this._factory),i=new Nt,r=0;r<n.getNumGeometries();r++){var o=this.edit(n.getGeometryN(r),e);null===o||o.isEmpty()||i.add(o);}return n.getClass()===te?this._factory.createMultiPoint(i.toArray([])):n.getClass()===Xt?this._factory.createMultiLineString(i.toArray([])):n.getClass()===ne?this._factory.createMultiPolygon(i.toArray([])):this._factory.createGeometryCollection(i.toArray([]))},ie.prototype.editPolygon=function(t,e){var n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this._factory.createPolygon();for(var r=new Nt,o=0;o<n.getNumInteriorRing();o++){var s=this.edit(n.getInteriorRingN(o),e);null===s||s.isEmpty()||r.add(s);}return this._factory.createPolygon(i,r.toArray([]))},ie.prototype.interfaces_=function(){return []},ie.prototype.getClass=function(){return ie},ie.GeometryEditorOperation=function(){},re.NoOpGeometryOperation.get=function(){return oe},re.CoordinateOperation.get=function(){return se},re.CoordinateSequenceOperation.get=function(){return ae},Object.defineProperties(ie,re);var oe=function(){};oe.prototype.edit=function(t,e){return t},oe.prototype.interfaces_=function(){return [ie.GeometryEditorOperation]},oe.prototype.getClass=function(){return oe};var se=function(){};se.prototype.edit=function(t,e){var n=this.editCoordinates(t.getCoordinates(),t);return null===n?t:t instanceof ee?e.createLinearRing(n):t instanceof Kt?e.createLineString(n):t instanceof Qt?n.length>0?e.createPoint(n[0]):e.createPoint():t},se.prototype.interfaces_=function(){return [ie.GeometryEditorOperation]},se.prototype.getClass=function(){return se};var ae=function(){};ae.prototype.edit=function(t,e){return t instanceof ee?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Kt?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Qt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},ae.prototype.interfaces_=function(){return [ie.GeometryEditorOperation]},ae.prototype.getClass=function(){return ae};var ue=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array)this._coordinates=arguments[0],this._dimension=3;else if(Number.isInteger(arguments[0])){var t=arguments[0];this._coordinates=new Array(t).fill(null);for(var e=0;e<t;e++)this._coordinates[e]=new C;}else if(T(arguments[0],V)){var n=arguments[0];if(null===n)return this._coordinates=new Array(0).fill(null),null;this._dimension=n.getDimension(),this._coordinates=new Array(n.size()).fill(null);for(var i=0;i<this._coordinates.length;i++)this._coordinates[i]=n.getCoordinateCopy(i);}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],o=arguments[1];this._coordinates=r,this._dimension=o,null===r&&(this._coordinates=new Array(0).fill(null));}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var s=arguments[0],a=arguments[1];this._coordinates=new Array(s).fill(null),this._dimension=a;for(var u=0;u<s;u++)this._coordinates[u]=new C;}},le={serialVersionUID:{configurable:!0}};ue.prototype.setOrdinate=function(t,e,n){switch(e){case V.X:this._coordinates[t].x=n;break;case V.Y:this._coordinates[t].y=n;break;case V.Z:this._coordinates[t].z=n;break;default:throw new m("invalid ordinateIndex")}},ue.prototype.size=function(){return this._coordinates.length},ue.prototype.getOrdinate=function(t,e){switch(e){case V.X:return this._coordinates[t].x;case V.Y:return this._coordinates[t].y;case V.Z:return this._coordinates[t].z}return v.NaN},ue.prototype.getCoordinate=function(){if(1===arguments.length){var t=arguments[0];return this._coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this._coordinates[e].x,n.y=this._coordinates[e].y,n.z=this._coordinates[e].z;}},ue.prototype.getCoordinateCopy=function(t){return new C(this._coordinates[t])},ue.prototype.getDimension=function(){return this._dimension},ue.prototype.getX=function(t){return this._coordinates[t].x},ue.prototype.clone=function(){for(var t=new Array(this.size()).fill(null),e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].clone();return new ue(t,this._dimension)},ue.prototype.expandEnvelope=function(t){for(var e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t},ue.prototype.copy=function(){for(var t=new Array(this.size()).fill(null),e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].copy();return new ue(t,this._dimension)},ue.prototype.toString=function(){if(this._coordinates.length>0){var t=new D(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(var e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return "()"},ue.prototype.getY=function(t){return this._coordinates[t].y},ue.prototype.toCoordinateArray=function(){return this._coordinates},ue.prototype.interfaces_=function(){return [V,e]},ue.prototype.getClass=function(){return ue},le.serialVersionUID.get=function(){return -0xcb44a778db18e00},Object.defineProperties(ue,le);var ce=function(){},pe={serialVersionUID:{configurable:!0},instanceObject:{configurable:!0}};ce.prototype.readResolve=function(){return ce.instance()},ce.prototype.create=function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new ue(t)}if(T(arguments[0],V)){var e=arguments[0];return new ue(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),i<2?new ue(n):new ue(n,i)}},ce.prototype.interfaces_=function(){return [b,e]},ce.prototype.getClass=function(){return ce},ce.instance=function(){return ce.instanceObject},pe.serialVersionUID.get=function(){return -0x38e49fa6cf6f2e00},pe.instanceObject.get=function(){return new ce},Object.defineProperties(ce,pe);var he=function(t){function e(){t.call(this),this.map_=new Map;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.get=function(t){return this.map_.get(t)||null},e.prototype.put=function(t,e){return this.map_.set(t,e),e},e.prototype.values=function(){for(var t=new Nt,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},e.prototype.entrySet=function(){var t=new Pt;return this.map_.entries().forEach(function(e){return t.add(e)}),t},e.prototype.size=function(){return this.map_.size()},e}(Tt),fe=function t(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=t.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof de){var e=arguments[0];this._modelType=e,e===t.FIXED&&this.setScale(1);}else if("number"==typeof arguments[0]){var n=arguments[0];this._modelType=t.FIXED,this.setScale(n);}else if(arguments[0]instanceof t){var i=arguments[0];this._modelType=i._modelType,this._scale=i._scale;}},ge={serialVersionUID:{configurable:!0},maximumPreciseValue:{configurable:!0}};fe.prototype.equals=function(t){if(!(t instanceof fe))return !1;var e=t;return this._modelType===e._modelType&&this._scale===e._scale},fe.prototype.compareTo=function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new M(n).compareTo(new M(i))},fe.prototype.getScale=function(){return this._scale},fe.prototype.isFloating=function(){return this._modelType===fe.FLOATING||this._modelType===fe.FLOATING_SINGLE},fe.prototype.getType=function(){return this._modelType},fe.prototype.toString=function(){var t="UNKNOWN";return this._modelType===fe.FLOATING?t="Floating":this._modelType===fe.FLOATING_SINGLE?t="Floating-Single":this._modelType===fe.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},fe.prototype.makePrecise=function(){if("number"==typeof arguments[0]){var t=arguments[0];if(v.isNaN(t))return t;if(this._modelType===fe.FLOATING_SINGLE){return t}return this._modelType===fe.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof C){var e=arguments[0];if(this._modelType===fe.FLOATING)return null;e.x=this.makePrecise(e.x),e.y=this.makePrecise(e.y);}},fe.prototype.getMaximumSignificantDigits=function(){var t=16;return this._modelType===fe.FLOATING?t=16:this._modelType===fe.FLOATING_SINGLE?t=6:this._modelType===fe.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},fe.prototype.setScale=function(t){this._scale=Math.abs(t);},fe.prototype.interfaces_=function(){return [e,E]},fe.prototype.getClass=function(){return fe},fe.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},ge.serialVersionUID.get=function(){return 0x6bee6404e9a25c00},ge.maximumPreciseValue.get=function(){return 9007199254740992},Object.defineProperties(fe,ge);var de=function t(e){this._name=e||null,t.nameToTypeMap.put(e,this);},ye={serialVersionUID:{configurable:!0},nameToTypeMap:{configurable:!0}};de.prototype.readResolve=function(){return de.nameToTypeMap.get(this._name)},de.prototype.toString=function(){return this._name},de.prototype.interfaces_=function(){return [e]},de.prototype.getClass=function(){return de},ye.serialVersionUID.get=function(){return -552860263173159e4},ye.nameToTypeMap.get=function(){return new he},Object.defineProperties(de,ye),fe.Type=de,fe.FIXED=new de("FIXED"),fe.FLOATING=new de("FLOATING"),fe.FLOATING_SINGLE=new de("FLOATING SINGLE");var _e=function t(){this._precisionModel=new fe,this._SRID=0,this._coordinateSequenceFactory=t.getDefaultCoordinateSequenceFactory(),0===arguments.length||(1===arguments.length?T(arguments[0],b)?this._coordinateSequenceFactory=arguments[0]:arguments[0]instanceof fe&&(this._precisionModel=arguments[0]):2===arguments.length?(this._precisionModel=arguments[0],this._SRID=arguments[1]):3===arguments.length&&(this._precisionModel=arguments[0],this._SRID=arguments[1],this._coordinateSequenceFactory=arguments[2]));},me={serialVersionUID:{configurable:!0}};_e.prototype.toGeometry=function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new C(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new C(t.getMinX(),t.getMinY()),new C(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new C(t.getMinX(),t.getMinY()),new C(t.getMinX(),t.getMaxY()),new C(t.getMaxX(),t.getMaxY()),new C(t.getMaxX(),t.getMinY()),new C(t.getMinX(),t.getMinY())]),null)},_e.prototype.createLineString=function(t){return t?t instanceof Array?new Kt(this.getCoordinateSequenceFactory().create(t),this):T(t,V)?new Kt(t,this):void 0:new Kt(this.getCoordinateSequenceFactory().create([]),this)},_e.prototype.createMultiLineString=function(){if(0===arguments.length)return new Xt(null,this);if(1===arguments.length){var t=arguments[0];return new Xt(t,this)}},_e.prototype.buildGeometry=function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var o=r.next(),s=o.getClass();null===e&&(e=s),s!==e&&(n=!0),o.isGeometryCollectionOrDerived()&&(i=!0);}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(_e.toGeometryArray(t));var a=t.iterator().next();if(t.size()>1){if(a instanceof $t)return this.createMultiPolygon(_e.toPolygonArray(t));if(a instanceof Kt)return this.createMultiLineString(_e.toLineStringArray(t));if(a instanceof Qt)return this.createMultiPoint(_e.toPointArray(t));et.shouldNeverReachHere("Unhandled class: "+a.getClass().getName());}return a},_e.prototype.createMultiPointFromCoords=function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},_e.prototype.createPoint=function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(T(arguments[0],V)){var e=arguments[0];return new Qt(e,this)}}},_e.prototype.getCoordinateSequenceFactory=function(){return this._coordinateSequenceFactory},_e.prototype.createPolygon=function(){if(0===arguments.length)return new $t(null,null,this);if(1===arguments.length){if(T(arguments[0],V)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof ee){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new $t(i,r,this)}},_e.prototype.getSRID=function(){return this._SRID},_e.prototype.createGeometryCollection=function(){if(0===arguments.length)return new zt(null,this);if(1===arguments.length){var t=arguments[0];return new zt(t,this)}},_e.prototype.createGeometry=function(t){return new ie(this).edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];return this._coordinateSequenceFactory.create(t)}}})},_e.prototype.getPrecisionModel=function(){return this._precisionModel},_e.prototype.createLinearRing=function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(T(arguments[0],V)){var e=arguments[0];return new ee(e,this)}}},_e.prototype.createMultiPolygon=function(){if(0===arguments.length)return new ne(null,this);if(1===arguments.length){var t=arguments[0];return new ne(t,this)}},_e.prototype.createMultiPoint=function(){if(0===arguments.length)return new te(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new te(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(T(arguments[0],V)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var o=this.getCoordinateSequenceFactory().create(1,n.getDimension());Wt.copy(n,r,o,0,1),i[r]=this.createPoint(o);}return this.createMultiPoint(i)}}},_e.prototype.interfaces_=function(){return [e]},_e.prototype.getClass=function(){return _e},_e.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.getDefaultCoordinateSequenceFactory=function(){return ce.instance()},_e.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},_e.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},me.serialVersionUID.get=function(){return -0x5ea75f2051eeb400},Object.defineProperties(_e,me);var ve=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],Ie=function(t){this.geometryFactory=t||new _e;};Ie.prototype.read=function(t){var e,n=(e="string"==typeof t?JSON.parse(t):t).type;if(!Ee[n])throw new Error("Unknown GeoJSON type: "+e.type);return -1!==ve.indexOf(n)?Ee[n].apply(this,[e.coordinates]):"GeometryCollection"===n?Ee[n].apply(this,[e.geometries]):Ee[n].apply(this,[e])},Ie.prototype.write=function(t){var e=t.getGeometryType();if(!xe[e])throw new Error("Geometry is not supported");return xe[e].apply(this,[t])};var Ee={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!Ee[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry);}return t.bbox&&(e.bbox=Ee.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]));}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(new C(i[0],i[1]));}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new C(t[0],t[1]),new C(t[2],t[1]),new C(t[2],t[3]),new C(t[0],t[3]),new C(t[0],t[1])])},Point:function(t){var e=new C(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Ee.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=Ee.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Ee.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=Ee.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var o=t[r],s=Ee.coordinates.apply(this,[o]),a=this.geometryFactory.createLinearRing(s);i.push(a);}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(Ee.Polygon.apply(this,[i]));}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i));}return this.geometryFactory.createGeometryCollection(e)}},xe={coordinate:function(t){return [t.x,t.y]},Point:function(t){return {type:"Point",coordinates:xe.coordinate.apply(this,[t.getCoordinate()])}},MultiPoint:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=xe.Point.apply(this,[i]);e.push(r.coordinates);}return {type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(xe.coordinate.apply(this,[r]));}return {type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=xe.LineString.apply(this,[i]);e.push(r.coordinates);}return {type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=xe.LineString.apply(this,[t._shell]);e.push(n.coordinates);for(var i=0;i<t._holes.length;++i){var r=t._holes[i],o=xe.LineString.apply(this,[r]);e.push(o.coordinates);}return {type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=xe.Polygon.apply(this,[i]);e.push(r.coordinates);}return {type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t._geometries.length;++n){var i=t._geometries[n],r=i.getGeometryType();e.push(xe[r].apply(this,[i]));}return {type:"GeometryCollection",geometries:e}}},Ne=function(t){this.geometryFactory=t||new _e,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new Ie(this.geometryFactory);};Ne.prototype.read=function(t){var e=this.parser.read(t);return this.precisionModel.getType()===fe.FIXED&&this.reducePrecision(e),e},Ne.prototype.reducePrecision=function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;e<n;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;e<n;e++)this.reducePrecision(t.geometries[e]);};var Ce=function(){this.parser=new Ie(this.geometryFactory);};Ce.prototype.write=function(t){return this.parser.write(t)};var Se=function(){},Le={ON:{configurable:!0},LEFT:{configurable:!0},RIGHT:{configurable:!0}};Se.prototype.interfaces_=function(){return []},Se.prototype.getClass=function(){return Se},Se.opposite=function(t){return t===Se.LEFT?Se.RIGHT:t===Se.RIGHT?Se.LEFT:t},Le.ON.get=function(){return 0},Le.LEFT.get=function(){return 1},Le.RIGHT.get=function(){return 2},Object.defineProperties(Se,Le),(d.prototype=new Error).name="EmptyStackException",(y.prototype=new xt).add=function(t){return this.array_.push(t),!0},y.prototype.get=function(t){if(t<0||t>=this.size())throw new Error;return this.array_[t]},y.prototype.push=function(t){return this.array_.push(t),t},y.prototype.pop=function(t){if(0===this.array_.length)throw new d;return this.array_.pop()},y.prototype.peek=function(){if(0===this.array_.length)throw new d;return this.array_[this.array_.length-1]},y.prototype.empty=function(){return 0===this.array_.length},y.prototype.isEmpty=function(){return this.empty()},y.prototype.search=function(t){return this.array_.indexOf(t)},y.prototype.size=function(){return this.array_.length},y.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t};var be=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null;};be.prototype.getCoordinate=function(){return this._minCoord},be.prototype.getRightmostSide=function(t,e){var n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n},be.prototype.findRightmostEdgeAtVertex=function(){var t=this._minDe.getEdge().getCoordinates();et.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this._minIndex-1],n=t[this._minIndex+1],i=at.computeOrientation(this._minCoord,n,e),r=!1;e.y<this._minCoord.y&&n.y<this._minCoord.y&&i===at.COUNTERCLOCKWISE?r=!0:e.y>this._minCoord.y&&n.y>this._minCoord.y&&i===at.CLOCKWISE&&(r=!0),r&&(this._minIndex=this._minIndex-1);},be.prototype.getRightmostSideOfSegment=function(t,e){var n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return -1;if(n[e].y===n[e+1].y)return -1;var i=Se.LEFT;return n[e].y<n[e+1].y&&(i=Se.RIGHT),i},be.prototype.getEdge=function(){return this._orientedDe},be.prototype.checkForRightmostCoordinate=function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n]);},be.prototype.findRightmostEdgeAtNode=function(){var t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1);},be.prototype.findEdge=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n);}et.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe;this.getRightmostSide(this._minDe,this._minIndex)===Se.LEFT&&(this._orientedDe=this._minDe.getSym());},be.prototype.interfaces_=function(){return []},be.prototype.getClass=function(){return be};var we=function(t){function e(n,i){t.call(this,e.msgWithCoord(n,i)),this.pt=i?new C(i):null,this.name="TopologyException";}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getCoordinate=function(){return this.pt},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e.msgWithCoord=function(t,e){return e?t:t+" [ "+e+" ]"},e}($),Oe=function(){this.array_=[];};Oe.prototype.addLast=function(t){this.array_.push(t);},Oe.prototype.removeFirst=function(){return this.array_.shift()},Oe.prototype.isEmpty=function(){return 0===this.array_.length};var Te=function(){this._finder=null,this._dirEdgeList=new Nt,this._nodes=new Nt,this._rightMostCoord=null,this._env=null,this._finder=new be;};Te.prototype.clearVisitedEdges=function(){for(var t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1);}},Te.prototype.getRightmostCoordinate=function(){return this._rightMostCoord},Te.prototype.computeNodeDepth=function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new we("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var r=t.getEdges().iterator();r.hasNext();){var o=r.next();o.setVisited(!0),this.copySymDepths(o);}},Te.prototype.computeDepth=function(t){this.clearVisitedEdges();var e=this._finder.getEdge();e.setEdgeDepths(Se.RIGHT,t),this.copySymDepths(e),this.computeDepths(e);},Te.prototype.create=function(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate();},Te.prototype.findResultEdges=function(){for(var t=this._dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(Se.RIGHT)>=1&&e.getDepth(Se.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0);}},Te.prototype.computeDepths=function(t){var e=new Pt,n=new Oe,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var o=r.getEdges().iterator();o.hasNext();){var s=o.next().getSym();if(!s.isVisited()){var a=s.getNode();e.contains(a)||(n.addLast(a),e.add(a));}}}},Te.prototype.compareTo=function(t){var e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0},Te.prototype.getEnvelope=function(){if(null===this._env){for(var t=new j,e=this._dirEdgeList.iterator();e.hasNext();)for(var n=e.next().getEdge().getCoordinates(),i=0;i<n.length-1;i++)t.expandToInclude(n[i]);this._env=t;}return this._env},Te.prototype.addReachable=function(t){var e=new y;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e);}},Te.prototype.copySymDepths=function(t){var e=t.getSym();e.setDepth(Se.LEFT,t.getDepth(Se.RIGHT)),e.setDepth(Se.RIGHT,t.getDepth(Se.LEFT));},Te.prototype.add=function(t,e){t.setVisited(!0),this._nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this._dirEdgeList.add(i);var r=i.getSym().getNode();r.isVisited()||e.push(r);}},Te.prototype.getNodes=function(){return this._nodes},Te.prototype.getDirectedEdges=function(){return this._dirEdgeList},Te.prototype.interfaces_=function(){return [E]},Te.prototype.getClass=function(){return Te};var Re=function t(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var e=arguments[0];this.init(e.length);}else if(Number.isInteger(arguments[0])){var n=arguments[0];this.init(1),this.location[Se.ON]=n;}else if(arguments[0]instanceof t){var i=arguments[0];if(this.init(i.location.length),null!==i)for(var r=0;r<this.location.length;r++)this.location[r]=i.location[r];}}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this.init(3),this.location[Se.ON]=o,this.location[Se.LEFT]=s,this.location[Se.RIGHT]=a;}};Re.prototype.setAllLocations=function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t;},Re.prototype.isNull=function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==w.NONE)return !1;return !0},Re.prototype.setAllLocationsIfNull=function(t){for(var e=0;e<this.location.length;e++)this.location[e]===w.NONE&&(this.location[e]=t);},Re.prototype.isLine=function(){return 1===this.location.length},Re.prototype.merge=function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[Se.ON]=this.location[Se.ON],e[Se.LEFT]=w.NONE,e[Se.RIGHT]=w.NONE,this.location=e;}for(var n=0;n<this.location.length;n++)this.location[n]===w.NONE&&n<t.location.length&&(this.location[n]=t.location[n]);},Re.prototype.getLocations=function(){return this.location},Re.prototype.flip=function(){if(this.location.length<=1)return null;var t=this.location[Se.LEFT];this.location[Se.LEFT]=this.location[Se.RIGHT],this.location[Se.RIGHT]=t;},Re.prototype.toString=function(){var t=new D;return this.location.length>1&&t.append(w.toLocationSymbol(this.location[Se.LEFT])),t.append(w.toLocationSymbol(this.location[Se.ON])),this.location.length>1&&t.append(w.toLocationSymbol(this.location[Se.RIGHT])),t.toString()},Re.prototype.setLocations=function(t,e,n){this.location[Se.ON]=t,this.location[Se.LEFT]=e,this.location[Se.RIGHT]=n;},Re.prototype.get=function(t){return t<this.location.length?this.location[t]:w.NONE},Re.prototype.isArea=function(){return this.location.length>1},Re.prototype.isAnyNull=function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===w.NONE)return !0;return !1},Re.prototype.setLocation=function(){if(1===arguments.length){var t=arguments[0];this.setLocation(Se.ON,t);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n;}},Re.prototype.init=function(t){this.location=new Array(t).fill(null),this.setAllLocations(w.NONE);},Re.prototype.isEqualOnSide=function(t,e){return this.location[e]===t.location[e]},Re.prototype.allPositionsEqual=function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return !1;return !0},Re.prototype.interfaces_=function(){return []},Re.prototype.getClass=function(){return Re};var Pe=function t(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var e=arguments[0];this.elt[0]=new Re(e),this.elt[1]=new Re(e);}else if(arguments[0]instanceof t){var n=arguments[0];this.elt[0]=new Re(n.elt[0]),this.elt[1]=new Re(n.elt[1]);}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.elt[0]=new Re(w.NONE),this.elt[1]=new Re(w.NONE),this.elt[i].setLocation(r);}else if(3===arguments.length){var o=arguments[0],s=arguments[1],a=arguments[2];this.elt[0]=new Re(o,s,a),this.elt[1]=new Re(o,s,a);}else if(4===arguments.length){var u=arguments[0],l=arguments[1],c=arguments[2],p=arguments[3];this.elt[0]=new Re(w.NONE,w.NONE,w.NONE),this.elt[1]=new Re(w.NONE,w.NONE,w.NONE),this.elt[u].setLocations(l,c,p);}};Pe.prototype.getGeometryCount=function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},Pe.prototype.setAllLocations=function(t,e){this.elt[t].setAllLocations(e);},Pe.prototype.isNull=function(t){return this.elt[t].isNull()},Pe.prototype.setAllLocationsIfNull=function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n);}},Pe.prototype.isLine=function(t){return this.elt[t].isLine()},Pe.prototype.merge=function(t){for(var e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new Re(t.elt[e]):this.elt[e].merge(t.elt[e]);},Pe.prototype.flip=function(){this.elt[0].flip(),this.elt[1].flip();},Pe.prototype.getLocation=function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(Se.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},Pe.prototype.toString=function(){var t=new D;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},Pe.prototype.isArea=function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},Pe.prototype.isAnyNull=function(t){return this.elt[t].isAnyNull()},Pe.prototype.setLocation=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(Se.ON,e);}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r);}},Pe.prototype.isEqualOnSide=function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},Pe.prototype.allPositionsEqual=function(t,e){return this.elt[t].allPositionsEqual(e)},Pe.prototype.toLine=function(t){this.elt[t].isArea()&&(this.elt[t]=new Re(this.elt[t].location[0]));},Pe.prototype.interfaces_=function(){return []},Pe.prototype.getClass=function(){return Pe},Pe.toLineLabel=function(t){for(var e=new Pe(w.NONE),n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e};var De=function(){this._startDe=null,this._maxNodeDegree=-1,this._edges=new Nt,this._pts=new Nt,this._label=new Pe(w.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new Nt,this._geometryFactory=null;var t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing();};De.prototype.computeRing=function(){if(null!==this._ring)return null;for(var t=new Array(this._pts.size()).fill(null),e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=at.isCCW(this._ring.getCoordinates());},De.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},De.prototype.computePoints=function(t){this._startDe=t;var e=t,n=!0;do{if(null===e)throw new we("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new we("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);var i=e.getLabel();et.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e);}while(e!==this._startDe)},De.prototype.getLinearRing=function(){return this._ring},De.prototype.getCoordinate=function(t){return this._pts.get(t)},De.prototype.computeMaxNodeDegree=function(){this._maxNodeDegree=0;var t=this._startDe;do{var e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t);}while(t!==this._startDe);this._maxNodeDegree*=2;},De.prototype.addPoints=function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var o=r;o<i.length;o++)this._pts.add(i[o]);}else {var s=i.length-2;n&&(s=i.length-1);for(var a=s;a>=0;a--)this._pts.add(i[a]);}},De.prototype.isHole=function(){return this._isHole},De.prototype.setInResult=function(){var t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext();}while(t!==this._startDe)},De.prototype.containsPoint=function(t){var e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return !1;if(!at.isPointInRing(t,e.getCoordinates()))return !1;for(var n=this._holes.iterator();n.hasNext();){if(n.next().containsPoint(t))return !1}return !0},De.prototype.addHole=function(t){this._holes.add(t);},De.prototype.isShell=function(){return null===this._shell},De.prototype.getLabel=function(){return this._label},De.prototype.getEdges=function(){return this._edges},De.prototype.getMaxNodeDegree=function(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree},De.prototype.getShell=function(){return this._shell},De.prototype.mergeLabel=function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1);}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,Se.RIGHT);if(i===w.NONE)return null;if(this._label.getLocation(n)===w.NONE)return this._label.setLocation(n,i),null}},De.prototype.setShell=function(t){this._shell=t,null!==t&&t.addHole(this);},De.prototype.toPolygon=function(t){for(var e=new Array(this._holes.size()).fill(null),n=0;n<this._holes.size();n++)e[n]=this._holes.get(n).getLinearRing();return t.createPolygon(this.getLinearRing(),e)},De.prototype.interfaces_=function(){return []},De.prototype.getClass=function(){return De};var Me=function(t){function e(){var e=arguments[0],n=arguments[1];t.call(this,e,n);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.setEdgeRing=function(t,e){t.setMinEdgeRing(e);},e.prototype.getNext=function(t){return t.getNextMin()},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(De),Ae=function(t){function e(){var e=arguments[0],n=arguments[1];t.call(this,e,n);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.buildMinimalRings=function(){var t=new Nt,e=this._startDe;do{if(null===e.getMinEdgeRing()){var n=new Me(e,this._geometryFactory);t.add(n);}e=e.getNext();}while(e!==this._startDe);return t},e.prototype.setEdgeRing=function(t,e){t.setEdgeRing(e);},e.prototype.linkDirectedEdgesForMinimalEdgeRings=function(){var t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext();}while(t!==this._startDe)},e.prototype.getNext=function(t){return t.getNext()},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(De),Fe=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this._label=t;}};Fe.prototype.setVisited=function(t){this._isVisited=t;},Fe.prototype.setInResult=function(t){this._isInResult=t;},Fe.prototype.isCovered=function(){return this._isCovered},Fe.prototype.isCoveredSet=function(){return this._isCoveredSet},Fe.prototype.setLabel=function(t){this._label=t;},Fe.prototype.getLabel=function(){return this._label},Fe.prototype.setCovered=function(t){this._isCovered=t,this._isCoveredSet=!0;},Fe.prototype.updateIM=function(t){et.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t);},Fe.prototype.isInResult=function(){return this._isInResult},Fe.prototype.isVisited=function(){return this._isVisited},Fe.prototype.interfaces_=function(){return []},Fe.prototype.getClass=function(){return Fe};var Ge=function(t){function e(){t.call(this),this._coord=null,this._edges=null;var e=arguments[0],n=arguments[1];this._coord=e,this._edges=n,this._label=new Pe(0,w.NONE);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isIncidentEdgeInResult=function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return !0}return !1},e.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},e.prototype.getCoordinate=function(){return this._coord},e.prototype.print=function(t){t.println("node "+this._coord+" lbl: "+this._label);},e.prototype.computeIM=function(t){},e.prototype.computeMergedLocation=function(t,e){var n=w.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==w.BOUNDARY&&(n=i);}return n},e.prototype.setLabel=function(){if(2!==arguments.length)return t.prototype.setLabel.apply(this,arguments);var e=arguments[0],n=arguments[1];null===this._label?this._label=new Pe(e,n):this._label.setLocation(e,n);},e.prototype.getEdges=function(){return this._edges},e.prototype.mergeLabel=function(){if(arguments[0]instanceof e){var t=arguments[0];this.mergeLabel(t._label);}else if(arguments[0]instanceof Pe)for(var n=arguments[0],i=0;i<2;i++){var r=this.computeMergedLocation(n,i);this._label.getLocation(i)===w.NONE&&this._label.setLocation(i,r);}},e.prototype.add=function(t){this._edges.insert(t),t.setNode(this);},e.prototype.setLabelBoundary=function(t){if(null===this._label)return null;var e=w.NONE;null!==this._label&&(e=this._label.getLocation(t));var n=null;switch(e){case w.BOUNDARY:n=w.INTERIOR;break;case w.INTERIOR:default:n=w.BOUNDARY;}this._label.setLocation(t,n);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(Fe),qe=function(){this.nodeMap=new p,this.nodeFact=null;var t=arguments[0];this.nodeFact=t;};qe.prototype.find=function(t){return this.nodeMap.get(t)},qe.prototype.addNode=function(){if(arguments[0]instanceof C){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof Ge){var n=arguments[0],i=this.nodeMap.get(n.getCoordinate());return null===i?(this.nodeMap.put(n.getCoordinate(),n),n):(i.mergeLabel(n),i)}},qe.prototype.print=function(t){for(var e=this.iterator();e.hasNext();){e.next().print(t);}},qe.prototype.iterator=function(){return this.nodeMap.values().iterator()},qe.prototype.values=function(){return this.nodeMap.values()},qe.prototype.getBoundaryNodes=function(t){for(var e=new Nt,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===w.BOUNDARY&&e.add(i);}return e},qe.prototype.add=function(t){var e=t.getCoordinate();this.addNode(e).add(t);},qe.prototype.interfaces_=function(){return []},qe.prototype.getClass=function(){return qe};var Be=function(){},Ve={NE:{configurable:!0},NW:{configurable:!0},SW:{configurable:!0},SE:{configurable:!0}};Be.prototype.interfaces_=function(){return []},Be.prototype.getClass=function(){return Be},Be.isNorthern=function(t){return t===Be.NE||t===Be.NW},Be.isOpposite=function(t,e){if(t===e)return !1;return 2===(t-e+4)%4},Be.commonHalfPlane=function(t,e){if(t===e)return t;if(2===(t-e+4)%4)return -1;var n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n},Be.isInHalfPlane=function(t,e){return e===Be.SE?t===Be.SE||t===Be.SW:t===e||t===e+1},Be.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new m("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Be.NE:Be.SE:e>=0?Be.NW:Be.SW}if(arguments[0]instanceof C&&arguments[1]instanceof C){var n=arguments[0],i=arguments[1];if(i.x===n.x&&i.y===n.y)throw new m("Cannot compute the quadrant for two identical points "+n);return i.x>=n.x?i.y>=n.y?Be.NE:Be.SE:i.y>=n.y?Be.NW:Be.SW}},Ve.NE.get=function(){return 0},Ve.NW.get=function(){return 1},Ve.SW.get=function(){return 2},Ve.SE.get=function(){return 3},Object.defineProperties(Be,Ve);var Ue=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){var t=arguments[0];this._edge=t;}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];this._edge=e,this.init(n,i),this._label=null;}else if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];this._edge=r,this.init(o,s),this._label=a;}};Ue.prototype.compareDirection=function(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:at.computeOrientation(t._p0,t._p1,this._p1)},Ue.prototype.getDy=function(){return this._dy},Ue.prototype.getCoordinate=function(){return this._p0},Ue.prototype.setNode=function(t){this._node=t;},Ue.prototype.print=function(t){var e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label);},Ue.prototype.compareTo=function(t){var e=t;return this.compareDirection(e)},Ue.prototype.getDirectedCoordinate=function(){return this._p1},Ue.prototype.getDx=function(){return this._dx},Ue.prototype.getLabel=function(){return this._label},Ue.prototype.getEdge=function(){return this._edge},Ue.prototype.getQuadrant=function(){return this._quadrant},Ue.prototype.getNode=function(){return this._node},Ue.prototype.toString=function(){var t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return "  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label},Ue.prototype.computeLabel=function(t){},Ue.prototype.init=function(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=Be.quadrant(this._dx,this._dy),et.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found");},Ue.prototype.interfaces_=function(){return [E]},Ue.prototype.getClass=function(){return Ue};var ze=function(t){function e(){var e=arguments[0],n=arguments[1];if(t.call(this,e),this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999],this._isForward=n,n)this.init(e.getCoordinate(0),e.getCoordinate(1));else {var i=e.getNumPoints()-1;this.init(e.getCoordinate(i),e.getCoordinate(i-1));}this.computeDirectedLabel();}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getNextMin=function(){return this._nextMin},e.prototype.getDepth=function(t){return this._depth[t]},e.prototype.setVisited=function(t){this._isVisited=t;},e.prototype.computeDirectedLabel=function(){this._label=new Pe(this._edge.getLabel()),this._isForward||this._label.flip();},e.prototype.getNext=function(){return this._next},e.prototype.setDepth=function(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new we("assigned depths do not match",this.getCoordinate());this._depth[t]=e;},e.prototype.isInteriorAreaEdge=function(){for(var t=!0,e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Se.LEFT)===w.INTERIOR&&this._label.getLocation(e,Se.RIGHT)===w.INTERIOR||(t=!1);return t},e.prototype.setNextMin=function(t){this._nextMin=t;},e.prototype.print=function(e){t.prototype.print.call(this,e),e.print(" "+this._depth[Se.LEFT]+"/"+this._depth[Se.RIGHT]),e.print(" ("+this.getDepthDelta()+")"),this._isInResult&&e.print(" inResult");},e.prototype.setMinEdgeRing=function(t){this._minEdgeRing=t;},e.prototype.isLineEdge=function(){var t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,w.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,w.EXTERIOR);return t&&e&&n},e.prototype.setEdgeRing=function(t){this._edgeRing=t;},e.prototype.getMinEdgeRing=function(){return this._minEdgeRing},e.prototype.getDepthDelta=function(){var t=this._edge.getDepthDelta();return this._isForward||(t=-t),t},e.prototype.setInResult=function(t){this._isInResult=t;},e.prototype.getSym=function(){return this._sym},e.prototype.isForward=function(){return this._isForward},e.prototype.getEdge=function(){return this._edge},e.prototype.printEdge=function(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t);},e.prototype.setSym=function(t){this._sym=t;},e.prototype.setVisitedEdge=function(t){this.setVisited(t),this._sym.setVisited(t);},e.prototype.setEdgeDepths=function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===Se.LEFT&&(i=-1);var r=Se.opposite(t),o=e+n*i;this.setDepth(t,e),this.setDepth(r,o);},e.prototype.getEdgeRing=function(){return this._edgeRing},e.prototype.isInResult=function(){return this._isInResult},e.prototype.setNext=function(t){this._next=t;},e.prototype.isVisited=function(){return this._isVisited},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e.depthFactor=function(t,e){return t===w.EXTERIOR&&e===w.INTERIOR?1:t===w.INTERIOR&&e===w.EXTERIOR?-1:0},e}(Ue),Xe=function(){};Xe.prototype.createNode=function(t){return new Ge(t,null)},Xe.prototype.interfaces_=function(){return []},Xe.prototype.getClass=function(){return Xe};var Ye=function(){if(this._edges=new Nt,this._nodes=null,this._edgeEndList=new Nt,0===arguments.length)this._nodes=new qe(new Xe);else if(1===arguments.length){var t=arguments[0];this._nodes=new qe(t);}};Ye.prototype.printEdges=function(t){t.println("Edges:");for(var e=0;e<this._edges.size();e++){t.println("edge "+e+":");var n=this._edges.get(e);n.print(t),n.eiList.print(t);}},Ye.prototype.find=function(t){return this._nodes.find(t)},Ye.prototype.addNode=function(){if(arguments[0]instanceof Ge){var t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof C){var e=arguments[0];return this._nodes.addNode(e)}},Ye.prototype.getNodeIterator=function(){return this._nodes.iterator()},Ye.prototype.linkResultDirectedEdges=function(){for(var t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges();}},Ye.prototype.debugPrintln=function(t){Y.out.println(t);},Ye.prototype.isBoundaryNode=function(t,e){var n=this._nodes.find(e);if(null===n)return !1;var i=n.getLabel();return null!==i&&i.getLocation(t)===w.BOUNDARY},Ye.prototype.linkAllDirectedEdges=function(){for(var t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges();}},Ye.prototype.matchInSameDirection=function(t,e,n,i){return !!t.equals(n)&&(at.computeOrientation(t,e,i)===at.COLLINEAR&&Be.quadrant(t,e)===Be.quadrant(n,i))},Ye.prototype.getEdgeEnds=function(){return this._edgeEndList},Ye.prototype.debugPrint=function(t){Y.out.print(t);},Ye.prototype.getEdgeIterator=function(){return this._edges.iterator()},Ye.prototype.findEdgeInSameDirection=function(t,e){for(var n=0;n<this._edges.size();n++){var i=this._edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},Ye.prototype.insertEdge=function(t){this._edges.add(t);},Ye.prototype.findEdgeEnd=function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},Ye.prototype.addEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this._edges.add(n);var i=new ze(n,!0),r=new ze(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r);}},Ye.prototype.add=function(t){this._nodes.add(t),this._edgeEndList.add(t);},Ye.prototype.getNodes=function(){return this._nodes.values()},Ye.prototype.findEdge=function(t,e){for(var n=0;n<this._edges.size();n++){var i=this._edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},Ye.prototype.interfaces_=function(){return []},Ye.prototype.getClass=function(){return Ye},Ye.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges();}};var ke=function(){this._geometryFactory=null,this._shellList=new Nt;var t=arguments[0];this._geometryFactory=t;};ke.prototype.sortShellsAndHoles=function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r);}},ke.prototype.computePolygons=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next().toPolygon(this._geometryFactory);e.add(i);}return e},ke.prototype.placeFreeHoles=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new we("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r);}}},ke.prototype.buildMinimalEdgeRings=function(t,e,n){for(var i=new Nt,r=t.iterator();r.hasNext();){var o=r.next();if(o.getMaxNodeDegree()>2){o.linkDirectedEdgesForMinimalEdgeRings();var s=o.buildMinimalRings(),a=this.findShell(s);null!==a?(this.placePolygonHoles(a,s),e.add(a)):n.addAll(s);}else i.add(o);}return i},ke.prototype.containsPoint=function(t){for(var e=this._shellList.iterator();e.hasNext();){if(e.next().containsPoint(t))return !0}return !1},ke.prototype.buildMaximalEdgeRings=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new Ae(i,this._geometryFactory);e.add(r),r.setInResult();}}return e},ke.prototype.placePolygonHoles=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t);}},ke.prototype.getPolygons=function(){return this.computePolygons(this._shellList)},ke.prototype.findEdgeRingContaining=function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),o=null,s=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),c=l.getEnvelopeInternal();null!==o&&(s=o.getLinearRing().getEnvelopeInternal());var p=!1;c.contains(i)&&at.isPointInRing(r,l.getCoordinates())&&(p=!0),p&&(null===o||s.contains(c))&&(o=u);}return o},ke.prototype.findShell=function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++);}return et.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n},ke.prototype.add=function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes());}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Ye.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new Nt,o=this.buildMinimalEdgeRings(i,this._shellList,r);this.sortShellsAndHoles(o,this._shellList,r),this.placeFreeHoles(this._shellList,r);}},ke.prototype.interfaces_=function(){return []},ke.prototype.getClass=function(){return ke};var je=function(){};je.prototype.getBounds=function(){},je.prototype.interfaces_=function(){return []},je.prototype.getClass=function(){return je};var He=function(){this._bounds=null,this._item=null;var t=arguments[0],e=arguments[1];this._bounds=t,this._item=e;};He.prototype.getItem=function(){return this._item},He.prototype.getBounds=function(){return this._bounds},He.prototype.interfaces_=function(){return [je,e]},He.prototype.getClass=function(){return He};var We=function(){this._size=null,this._items=null,this._size=0,this._items=new Nt,this._items.add(null);};We.prototype.poll=function(){if(this.isEmpty())return null;var t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t},We.prototype.size=function(){return this._size},We.prototype.reorder=function(t){for(var e=null,n=this._items.get(t);2*t<=this._size&&((e=2*t)!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n);},We.prototype.clear=function(){this._size=0,this._items.clear();},We.prototype.isEmpty=function(){return 0===this._size},We.prototype.add=function(t){this._items.add(null),this._size+=1;var e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t);},We.prototype.interfaces_=function(){return []},We.prototype.getClass=function(){return We};var Ke=function(){};Ke.prototype.visitItem=function(t){},Ke.prototype.interfaces_=function(){return []},Ke.prototype.getClass=function(){return Ke};var Je=function(){};Je.prototype.insert=function(t,e){},Je.prototype.remove=function(t,e){},Je.prototype.query=function(){},Je.prototype.interfaces_=function(){return []},Je.prototype.getClass=function(){return Je};var Qe=function(){if(this._childBoundables=new Nt,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this._level=t;}},Ze={serialVersionUID:{configurable:!0}};Qe.prototype.getLevel=function(){return this._level},Qe.prototype.size=function(){return this._childBoundables.size()},Qe.prototype.getChildBoundables=function(){return this._childBoundables},Qe.prototype.addChildBoundable=function(t){et.isTrue(null===this._bounds),this._childBoundables.add(t);},Qe.prototype.isEmpty=function(){return this._childBoundables.isEmpty()},Qe.prototype.getBounds=function(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds},Qe.prototype.interfaces_=function(){return [je,e]},Qe.prototype.getClass=function(){return Qe},Ze.serialVersionUID.get=function(){return 0x5a1e55ec41369800},Object.defineProperties(Qe,Ze);var $e=function(){};$e.reverseOrder=function(){return {compare:function(t,e){return e.compareTo(t)}}},$e.min=function(t){return $e.sort(t),t.get(0)},$e.sort=function(t,e){var n=t.toArray();e?Gt.sort(n,e):Gt.sort(n);for(var i=t.iterator(),r=0,o=n.length;r<o;r++)i.next(),i.set(n[r]);},$e.singletonList=function(t){var e=new Nt;return e.add(t),e};var tn=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance();};tn.prototype.expandToQueue=function(t,e){var n=tn.isComposite(this._boundable1),i=tn.isComposite(this._boundable2);if(n&&i)return tn.area(this._boundable1)>tn.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,t,e),null):(this.expand(this._boundable2,this._boundable1,t,e),null);if(n)return this.expand(this._boundable1,this._boundable2,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,t,e),null;throw new m("neither boundable is composite")},tn.prototype.isLeaves=function(){return !(tn.isComposite(this._boundable1)||tn.isComposite(this._boundable2))},tn.prototype.compareTo=function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},tn.prototype.expand=function(t,e,n,i){for(var r=t.getChildBoundables().iterator();r.hasNext();){var o=r.next(),s=new tn(o,e,this._itemDistance);s.getDistance()<i&&n.add(s);}},tn.prototype.getBoundable=function(t){return 0===t?this._boundable1:this._boundable2},tn.prototype.getDistance=function(){return this._distance},tn.prototype.distance=function(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())},tn.prototype.interfaces_=function(){return [E]},tn.prototype.getClass=function(){return tn},tn.area=function(t){return t.getBounds().getArea()},tn.isComposite=function(t){return t instanceof Qe};var en=function t(){if(this._root=null,this._built=!1,this._itemBoundables=new Nt,this._nodeCapacity=null,0===arguments.length){var e=t.DEFAULT_NODE_CAPACITY;this._nodeCapacity=e;}else if(1===arguments.length){var n=arguments[0];et.isTrue(n>1,"Node capacity must be greater than 1"),this._nodeCapacity=n;}},nn={IntersectsOp:{configurable:!0},serialVersionUID:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};en.prototype.getNodeCapacity=function(){return this._nodeCapacity},en.prototype.lastNode=function(t){return t.get(t.size()-1)},en.prototype.size=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){for(var t=0,e=arguments[0].getChildBoundables().iterator();e.hasNext();){var n=e.next();n instanceof Qe?t+=this.size(n):n instanceof He&&(t+=1);}return t}},en.prototype.removeItem=function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof He&&r.getItem()===e&&(n=r);}return null!==n&&(t.getChildBoundables().remove(n),!0)},en.prototype.itemsTree=function(){if(0===arguments.length){this.build();var t=this.itemsTree(this._root);return null===t?new Nt:t}if(1===arguments.length){for(var e=arguments[0],n=new Nt,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Qe){var o=this.itemsTree(r);null!==o&&n.add(o);}else r instanceof He?n.add(r.getItem()):et.shouldNeverReachHere();}return n.size()<=0?null:n}},en.prototype.insert=function(t,e){et.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new He(t,e));},en.prototype.boundablesAtLevel=function(){if(1===arguments.length){var t=arguments[0],e=new Nt;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(et.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var o=i.getChildBoundables().iterator();o.hasNext();){var s=o.next();s instanceof Qe?this.boundablesAtLevel(n,s,r):(et.isTrue(s instanceof He),-1===n&&r.add(s));}return null}},en.prototype.query=function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new Nt;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.query(t,this._root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),n)&&this.query(n,this._root,i);}else if(3===arguments.length)if(T(arguments[2],Ke)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe)for(var r=arguments[0],o=arguments[1],s=arguments[2],a=o.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Qe?this.query(r,l,s):l instanceof He?s.visitItem(l.getItem()):et.shouldNeverReachHere());}else if(T(arguments[2],xt)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe)for(var c=arguments[0],p=arguments[1],h=arguments[2],f=p.getChildBoundables(),g=0;g<f.size();g++){var d=f.get(g);this.getIntersectsOp().intersects(d.getBounds(),c)&&(d instanceof Qe?this.query(c,d,h):d instanceof He?h.add(d.getItem()):et.shouldNeverReachHere());}},en.prototype.build=function(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0;},en.prototype.getRoot=function(){return this.build(),this._root},en.prototype.remove=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=this.removeItem(i,r);if(o)return !0;for(var s=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&(u instanceof Qe&&(o=this.remove(n,u,r)))){s=u;break}}return null!==s&&s.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(s),o}},en.prototype.createHigherLevels=function(t,e){et.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},en.prototype.depth=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){for(var t=0,e=arguments[0].getChildBoundables().iterator();e.hasNext();){var n=e.next();if(n instanceof Qe){var i=this.depth(n);i>t&&(t=i);}}return t+1}},en.prototype.createParentBoundables=function(t,e){et.isTrue(!t.isEmpty());var n=new Nt;n.add(this.createNode(e));var i=new Nt(t);$e.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var o=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(o);}return n},en.prototype.isEmpty=function(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()},en.prototype.interfaces_=function(){return [e]},en.prototype.getClass=function(){return en},en.compareDoubles=function(t,e){return t>e?1:t<e?-1:0},nn.IntersectsOp.get=function(){return rn},nn.serialVersionUID.get=function(){return -0x35ef64c82d4c5400},nn.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(en,nn);var rn=function(){},on=function(){};on.prototype.distance=function(t,e){},on.prototype.interfaces_=function(){return []},on.prototype.getClass=function(){return on};var sn=function(t){function n(e){e=e||n.DEFAULT_NODE_CAPACITY,t.call(this,e);}t&&(n.__proto__=t),(n.prototype=Object.create(t&&t.prototype)).constructor=n;var i={STRtreeNode:{configurable:!0},serialVersionUID:{configurable:!0},xComparator:{configurable:!0},yComparator:{configurable:!0},intersectsOp:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};return n.prototype.createParentBoundablesFromVerticalSlices=function(t,e){et.isTrue(t.length>0);for(var n=new Nt,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},n.prototype.createNode=function(t){return new an(t)},n.prototype.size=function(){return 0===arguments.length?t.prototype.size.call(this):t.prototype.size.apply(this,arguments)},n.prototype.insert=function(){if(2!==arguments.length)return t.prototype.insert.apply(this,arguments);var e=arguments[0],n=arguments[1];if(e.isNull())return null;t.prototype.insert.call(this,e,n);},n.prototype.getIntersectsOp=function(){return n.intersectsOp},n.prototype.verticalSlices=function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),o=0;o<e;o++){i[o]=new Nt;for(var s=0;r.hasNext()&&s<n;){var a=r.next();i[o].add(a),s++;}}return i},n.prototype.query=function(){if(1===arguments.length){var e=arguments[0];return t.prototype.query.call(this,e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];t.prototype.query.call(this,n,i);}else if(3===arguments.length)if(T(arguments[2],Ke)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe){var r=arguments[0],o=arguments[1],s=arguments[2];t.prototype.query.call(this,r,o,s);}else if(T(arguments[2],xt)&&arguments[0]instanceof Object&&arguments[1]instanceof Qe){var a=arguments[0],u=arguments[1],l=arguments[2];t.prototype.query.call(this,a,u,l);}},n.prototype.getComparator=function(){return n.yComparator},n.prototype.createParentBoundablesFromVerticalSlice=function(e,n){return t.prototype.createParentBoundables.call(this,e,n)},n.prototype.remove=function(){if(2===arguments.length){var e=arguments[0],n=arguments[1];return t.prototype.remove.call(this,e,n)}return t.prototype.remove.apply(this,arguments)},n.prototype.depth=function(){return 0===arguments.length?t.prototype.depth.call(this):t.prototype.depth.apply(this,arguments)},n.prototype.createParentBoundables=function(t,e){et.isTrue(!t.isEmpty());var i=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),r=new Nt(t);$e.sort(r,n.xComparator);var o=this.verticalSlices(r,Math.trunc(Math.ceil(Math.sqrt(i))));return this.createParentBoundablesFromVerticalSlices(o,e)},n.prototype.nearestNeighbour=function(){if(1===arguments.length){if(T(arguments[0],on)){var t=arguments[0],e=new tn(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof tn){var i=arguments[0];return this.nearestNeighbour(i,v.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof n&&T(arguments[1],on)){var r=arguments[0],o=arguments[1],s=new tn(this.getRoot(),r.getRoot(),o);return this.nearestNeighbour(s)}if(arguments[0]instanceof tn&&"number"==typeof arguments[1]){var a=arguments[0],u=arguments[1],l=null,c=new We;for(c.add(a);!c.isEmpty()&&u>0;){var p=c.poll(),h=p.getDistance();if(h>=u)break;p.isLeaves()?(u=h,l=p):p.expandToQueue(c,u);}return [l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var f=arguments[0],g=arguments[1],d=arguments[2],y=new He(f,g),_=new tn(this.getRoot(),y,d);return this.nearestNeighbour(_)[0]}},n.prototype.interfaces_=function(){return [Je,e]},n.prototype.getClass=function(){return n},n.centreX=function(t){return n.avg(t.getMinX(),t.getMaxX())},n.avg=function(t,e){return (t+e)/2},n.centreY=function(t){return n.avg(t.getMinY(),t.getMaxY())},i.STRtreeNode.get=function(){return an},i.serialVersionUID.get=function(){return 0x39920f7d5f261e0},i.xComparator.get=function(){return {interfaces_:function(){return [N]},compare:function(e,i){return t.compareDoubles(n.centreX(e.getBounds()),n.centreX(i.getBounds()))}}},i.yComparator.get=function(){return {interfaces_:function(){return [N]},compare:function(e,i){return t.compareDoubles(n.centreY(e.getBounds()),n.centreY(i.getBounds()))}}},i.intersectsOp.get=function(){return {interfaces_:function(){return [t.IntersectsOp]},intersects:function(t,e){return t.intersects(e)}}},i.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(n,i),n}(en),an=function(t){function e(){var e=arguments[0];t.call(this,e);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.computeBounds=function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new j(n.getBounds()):t.expandToInclude(n.getBounds());}return t},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(Qe),un=function(){};un.prototype.interfaces_=function(){return []},un.prototype.getClass=function(){return un},un.relativeSign=function(t,e){return t<e?-1:t>e?1:0},un.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=un.relativeSign(e.x,n.x),r=un.relativeSign(e.y,n.y);switch(t){case 0:return un.compareValue(i,r);case 1:return un.compareValue(r,i);case 2:return un.compareValue(r,-i);case 3:return un.compareValue(-i,r);case 4:return un.compareValue(-i,-r);case 5:return un.compareValue(-r,-i);case 6:return un.compareValue(-r,i);case 7:return un.compareValue(i,-r)}return et.shouldNeverReachHere("invalid octant value"),0},un.compareValue=function(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0};var ln=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this._segString=t,this.coord=new C(e),this.segmentIndex=n,this._segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n));};ln.prototype.getCoordinate=function(){return this.coord},ln.prototype.print=function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex);},ln.prototype.compareTo=function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:un.compare(this._segmentOctant,this.coord,e.coord)},ln.prototype.isEndPoint=function(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t},ln.prototype.isInterior=function(){return this._isInterior},ln.prototype.interfaces_=function(){return [E]},ln.prototype.getClass=function(){return ln};var cn=function(){this._nodeMap=new p,this._edge=null;var t=arguments[0];this._edge=t;};cn.prototype.getSplitCoordinates=function(){var t=new St;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i;}return t.toCoordinateArray()},cn.prototype.addCollapsedNodes=function(){var t=new Nt;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this._edge.getCoordinate(n),n);}},cn.prototype.print=function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){e.next().print(t);}},cn.prototype.findCollapsesFromExistingVertices=function(t){for(var e=0;e<this._edge.size()-2;e++){var n=this._edge.getCoordinate(e),i=this._edge.getCoordinate(e+2);n.equals2D(i)&&t.add(new M(e+1));}},cn.prototype.addEdgeCoordinates=function(t,e,n){var i=this._edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);n.add(new C(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this._edge.getCoordinate(o));r&&n.add(new C(e.coord));},cn.prototype.iterator=function(){return this._nodeMap.values().iterator()},cn.prototype.addSplitEdges=function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i;}},cn.prototype.findCollapseIndex=function(t,e,n){if(!t.coord.equals2D(e.coord))return !1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i&&(n[0]=t.segmentIndex+1,!0)},cn.prototype.findCollapsesFromInsertedNodes=function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next();this.findCollapseIndex(i,r,e)&&t.add(new M(e[0])),i=r;}},cn.prototype.getEdge=function(){return this._edge},cn.prototype.addEndpoints=function(){var t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t);},cn.prototype.createSplitEdge=function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this._edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var o=new Array(n).fill(null),s=0;o[s++]=new C(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)o[s++]=this._edge.getCoordinate(a);return r&&(o[s]=new C(e.coord)),new gn(o,this._edge.getData())},cn.prototype.add=function(t,e){var n=new ln(this._edge,t,e,this._edge.getSegmentOctant(e)),i=this._nodeMap.get(n);return null!==i?(et.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this._nodeMap.put(n,n),n)},cn.prototype.checkSplitEdgesCorrectness=function(t){var e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new $("bad split edge start point at "+n);var i=t.get(t.size()-1).getCoordinates(),r=i[i.length-1];if(!r.equals2D(e[e.length-1]))throw new $("bad split edge end point at "+r)},cn.prototype.interfaces_=function(){return []},cn.prototype.getClass=function(){return cn};var pn=function(){};pn.prototype.interfaces_=function(){return []},pn.prototype.getClass=function(){return pn},pn.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new m("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?n>=i?0:1:n>=i?7:6:e>=0?n>=i?3:2:n>=i?4:5}if(arguments[0]instanceof C&&arguments[1]instanceof C){var r=arguments[0],o=arguments[1],s=o.x-r.x,a=o.y-r.y;if(0===s&&0===a)throw new m("Cannot compute the octant for two identical points "+r);return pn.octant(s,a)}};var hn=function(){};hn.prototype.getCoordinates=function(){},hn.prototype.size=function(){},hn.prototype.getCoordinate=function(t){},hn.prototype.isClosed=function(){},hn.prototype.setData=function(t){},hn.prototype.getData=function(){},hn.prototype.interfaces_=function(){return []},hn.prototype.getClass=function(){return hn};var fn=function(){};fn.prototype.addIntersection=function(t,e){},fn.prototype.interfaces_=function(){return [hn]},fn.prototype.getClass=function(){return fn};var gn=function(){this._nodeList=new cn(this),this._pts=null,this._data=null;var t=arguments[0],e=arguments[1];this._pts=t,this._data=e;};gn.prototype.getCoordinates=function(){return this._pts},gn.prototype.size=function(){return this._pts.length},gn.prototype.getCoordinate=function(t){return this._pts[t]},gn.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},gn.prototype.getSegmentOctant=function(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},gn.prototype.setData=function(t){this._data=t;},gn.prototype.safeOctant=function(t,e){return t.equals2D(e)?0:pn.octant(t,e)},gn.prototype.getData=function(){return this._data},gn.prototype.addIntersection=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e);}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[3],o=new C(n.getIntersection(r));this.addIntersection(o,i);}},gn.prototype.toString=function(){return Z.toLineString(new ue(this._pts))},gn.prototype.getNodeList=function(){return this._nodeList},gn.prototype.addIntersectionNode=function(t,e){var n=e,i=n+1;if(i<this._pts.length){var r=this._pts[i];t.equals2D(r)&&(n=i);}return this._nodeList.add(t,n)},gn.prototype.addIntersections=function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i);},gn.prototype.interfaces_=function(){return [fn]},gn.prototype.getClass=function(){return gn},gn.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new Nt;return gn.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){r.next().getNodeList().addSplitEdges(i);}};var dn=function(){if(this.p0=null,this.p1=null,0===arguments.length)this.p0=new C,this.p1=new C;else if(1===arguments.length){var t=arguments[0];this.p0=new C(t.p0),this.p1=new C(t.p1);}else if(2===arguments.length)this.p0=arguments[0],this.p1=arguments[1];else if(4===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=arguments[3];this.p0=new C(e,n),this.p1=new C(i,r);}},yn={serialVersionUID:{configurable:!0}};dn.prototype.minX=function(){return Math.min(this.p0.x,this.p1.x)},dn.prototype.orientationIndex=function(){if(arguments[0]instanceof dn){var t=arguments[0],e=at.orientationIndex(this.p0,this.p1,t.p0),n=at.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof C){var i=arguments[0];return at.orientationIndex(this.p0,this.p1,i)}},dn.prototype.toGeometry=function(t){return t.createLineString([this.p0,this.p1])},dn.prototype.isVertical=function(){return this.p0.x===this.p1.x},dn.prototype.equals=function(t){if(!(t instanceof dn))return !1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},dn.prototype.intersection=function(t){var e=new rt;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},dn.prototype.project=function(){if(arguments[0]instanceof C){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new C(t);var e=this.projectionFactor(t),n=new C;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof dn){var i=arguments[0],r=this.projectionFactor(i.p0),o=this.projectionFactor(i.p1);if(r>=1&&o>=1)return null;if(r<=0&&o<=0)return null;var s=this.project(i.p0);r<0&&(s=this.p0),r>1&&(s=this.p1);var a=this.project(i.p1);return o<0&&(a=this.p0),o>1&&(a=this.p1),new dn(s,a)}},dn.prototype.normalize=function(){this.p1.compareTo(this.p0)<0&&this.reverse();},dn.prototype.angle=function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},dn.prototype.getCoordinate=function(t){return 0===t?this.p0:this.p1},dn.prototype.distancePerpendicular=function(t){return at.distancePointLinePerpendicular(t,this.p0,this.p1)},dn.prototype.minY=function(){return Math.min(this.p0.y,this.p1.y)},dn.prototype.midPoint=function(){return dn.midPoint(this.p0,this.p1)},dn.prototype.projectionFactor=function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(i<=0)return v.NaN;return ((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i},dn.prototype.closestPoints=function(t){var e=this.intersection(t);if(null!==e)return [e,e];var n=new Array(2).fill(null),i=v.MAX_VALUE,r=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var s=this.closestPoint(t.p1);(r=s.distance(t.p1))<i&&(i=r,n[0]=s,n[1]=t.p1);var a=t.closestPoint(this.p0);(r=a.distance(this.p0))<i&&(i=r,n[0]=this.p0,n[1]=a);var u=t.closestPoint(this.p1);return (r=u.distance(this.p1))<i&&(i=r,n[0]=this.p1,n[1]=u),n},dn.prototype.closestPoint=function(t){var e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);return this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1},dn.prototype.maxX=function(){return Math.max(this.p0.x,this.p1.x)},dn.prototype.getLength=function(){return this.p0.distance(this.p1)},dn.prototype.compareTo=function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},dn.prototype.reverse=function(){var t=this.p0;this.p0=this.p1,this.p1=t;},dn.prototype.equalsTopo=function(t){return this.p0.equals(t.p0)&&(this.p1.equals(t.p1)||this.p0.equals(t.p1))&&this.p1.equals(t.p0)},dn.prototype.lineIntersection=function(t){try{return k.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof X))throw t}return null},dn.prototype.maxY=function(){return Math.max(this.p0.y,this.p1.y)},dn.prototype.pointAlongOffset=function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,o=this.p1.y-this.p0.y,s=Math.sqrt(r*r+o*o),a=0,u=0;if(0!==e){if(s<=0)throw new Error("Cannot compute offset from zero-length line segment");a=e*r/s,u=e*o/s;}return new C(n-u,i+a)},dn.prototype.setCoordinates=function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y;}},dn.prototype.segmentFraction=function(t){var e=this.projectionFactor(t);return e<0?e=0:(e>1||v.isNaN(e))&&(e=1),e},dn.prototype.toString=function(){return "LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},dn.prototype.isHorizontal=function(){return this.p0.y===this.p1.y},dn.prototype.distance=function(){if(arguments[0]instanceof dn){var t=arguments[0];return at.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof C){var e=arguments[0];return at.distancePointLine(e,this.p0,this.p1)}},dn.prototype.pointAlong=function(t){var e=new C;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},dn.prototype.hashCode=function(){var t=v.doubleToLongBits(this.p0.x);t^=31*v.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=v.doubleToLongBits(this.p1.x);n^=31*v.doubleToLongBits(this.p1.y);return e^(Math.trunc(n)^Math.trunc(n>>32))},dn.prototype.interfaces_=function(){return [E,e]},dn.prototype.getClass=function(){return dn},dn.midPoint=function(t,e){return new C((t.x+e.x)/2,(t.y+e.y)/2)},yn.serialVersionUID.get=function(){return 0x2d2172135f411c00},Object.defineProperties(dn,yn);var _n=function(){this.tempEnv1=new j,this.tempEnv2=new j,this._overlapSeg1=new dn,this._overlapSeg2=new dn;};_n.prototype.overlap=function(){if(2===arguments.length);else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this._overlapSeg1),n.getLineSegment(i,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2);}},_n.prototype.interfaces_=function(){return []},_n.prototype.getClass=function(){return _n};var mn=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=i;};mn.prototype.getLineSegment=function(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1];},mn.prototype.computeSelect=function(t,e,n,i){var r=this._pts[e],o=this._pts[n];if(i.tempEnv1.init(r,o),n-e==1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var s=Math.trunc((e+n)/2);e<s&&this.computeSelect(t,e,s,i),s<n&&this.computeSelect(t,s,n,i);},mn.prototype.getCoordinates=function(){for(var t=new Array(this._end-this._start+1).fill(null),e=0,n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t},mn.prototype.computeOverlaps=function(t,e){this.computeOverlapsInternal(this._start,this._end,t,t._start,t._end,e);},mn.prototype.setId=function(t){this._id=t;},mn.prototype.select=function(t,e){this.computeSelect(t,this._start,this._end,e);},mn.prototype.getEnvelope=function(){if(null===this._env){var t=this._pts[this._start],e=this._pts[this._end];this._env=new j(t,e);}return this._env},mn.prototype.getEndIndex=function(){return this._end},mn.prototype.getStartIndex=function(){return this._start},mn.prototype.getContext=function(){return this._context},mn.prototype.getId=function(){return this._id},mn.prototype.computeOverlapsInternal=function(t,e,n,i,r,o){var s=this._pts[t],a=this._pts[e],u=n._pts[i],l=n._pts[r];if(e-t==1&&r-i==1)return o.overlap(this,t,n,i),null;if(o.tempEnv1.init(s,a),o.tempEnv2.init(u,l),!o.tempEnv1.intersects(o.tempEnv2))return null;var c=Math.trunc((t+e)/2),p=Math.trunc((i+r)/2);t<c&&(i<p&&this.computeOverlapsInternal(t,c,n,i,p,o),p<r&&this.computeOverlapsInternal(t,c,n,p,r,o)),c<e&&(i<p&&this.computeOverlapsInternal(c,e,n,i,p,o),p<r&&this.computeOverlapsInternal(c,e,n,p,r,o));},mn.prototype.interfaces_=function(){return []},mn.prototype.getClass=function(){return mn};var vn=function(){};vn.prototype.interfaces_=function(){return []},vn.prototype.getClass=function(){return vn},vn.getChainStartIndices=function(t){var e=0,n=new Nt;n.add(new M(e));do{var i=vn.findChainEnd(t,e);n.add(new M(i)),e=i;}while(e<t.length-1);return vn.toIntArray(n)},vn.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Be.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){if(Be.quadrant(t[r-1],t[r])!==i)break}r++;}return r-1},vn.getChains=function(){if(1===arguments.length){var t=arguments[0];return vn.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new Nt,r=vn.getChainStartIndices(e),o=0;o<r.length-1;o++){var s=new mn(e,r[o],r[o+1],n);i.add(s);}return i}},vn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e};var In=function(){};In.prototype.computeNodes=function(t){},In.prototype.getNodedSubstrings=function(){},In.prototype.interfaces_=function(){return []},In.prototype.getClass=function(){return In};var En=function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t);}};En.prototype.setSegmentIntersector=function(t){this._segInt=t;},En.prototype.interfaces_=function(){return [In]},En.prototype.getClass=function(){return En};var xn=function(t){function e(e){e?t.call(this,e):t.call(this),this._monoChains=new Nt,this._index=new sn,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0;}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={SegmentOverlapAction:{configurable:!0}};return e.prototype.getMonotoneChains=function(){return this._monoChains},e.prototype.getNodedSubstrings=function(){return gn.getNodedSubstrings(this._nodedSegStrings)},e.prototype.getIndex=function(){return this._index},e.prototype.add=function(t){for(var e=vn.getChains(t.getCoordinates(),t).iterator();e.hasNext();){var n=e.next();n.setId(this._idCounter++),this._index.insert(n.getEnvelope(),n),this._monoChains.add(n);}},e.prototype.computeNodes=function(t){this._nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains();},e.prototype.intersectChains=function(){for(var t=new Nn(this._segInt),e=this._monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this._index.query(n.getEnvelope()).iterator();i.hasNext();){var r=i.next();if(r.getId()>n.getId()&&(n.computeOverlaps(r,t),this._nOverlaps++),this._segInt.isDone())return null}},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},n.SegmentOverlapAction.get=function(){return Nn},Object.defineProperties(e,n),e}(En),Nn=function(t){function e(){t.call(this),this._si=null;var e=arguments[0];this._si=e;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.overlap=function(){if(4!==arguments.length)return t.prototype.overlap.apply(this,arguments);var e=arguments[0],n=arguments[1],i=arguments[2],r=arguments[3],o=e.getContext(),s=i.getContext();this._si.processIntersections(o,n,s,r);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(_n),Cn=function t(){if(this._quadrantSegments=t.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=t.CAP_ROUND,this._joinStyle=t.JOIN_ROUND,this._mitreLimit=t.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=t.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var e=arguments[0];this.setQuadrantSegments(e);}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.setQuadrantSegments(n),this.setEndCapStyle(i);}else if(4===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3];this.setQuadrantSegments(r),this.setEndCapStyle(o),this.setJoinStyle(s),this.setMitreLimit(a);}},Sn={CAP_ROUND:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},JOIN_ROUND:{configurable:!0},JOIN_MITRE:{configurable:!0},JOIN_BEVEL:{configurable:!0},DEFAULT_QUADRANT_SEGMENTS:{configurable:!0},DEFAULT_MITRE_LIMIT:{configurable:!0},DEFAULT_SIMPLIFY_FACTOR:{configurable:!0}};Cn.prototype.getEndCapStyle=function(){return this._endCapStyle},Cn.prototype.isSingleSided=function(){return this._isSingleSided},Cn.prototype.setQuadrantSegments=function(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=Cn.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=Cn.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==Cn.JOIN_ROUND&&(this._quadrantSegments=Cn.DEFAULT_QUADRANT_SEGMENTS);},Cn.prototype.getJoinStyle=function(){return this._joinStyle},Cn.prototype.setJoinStyle=function(t){this._joinStyle=t;},Cn.prototype.setSimplifyFactor=function(t){this._simplifyFactor=t<0?0:t;},Cn.prototype.getSimplifyFactor=function(){return this._simplifyFactor},Cn.prototype.getQuadrantSegments=function(){return this._quadrantSegments},Cn.prototype.setEndCapStyle=function(t){this._endCapStyle=t;},Cn.prototype.getMitreLimit=function(){return this._mitreLimit},Cn.prototype.setMitreLimit=function(t){this._mitreLimit=t;},Cn.prototype.setSingleSided=function(t){this._isSingleSided=t;},Cn.prototype.interfaces_=function(){return []},Cn.prototype.getClass=function(){return Cn},Cn.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Sn.CAP_ROUND.get=function(){return 1},Sn.CAP_FLAT.get=function(){return 2},Sn.CAP_SQUARE.get=function(){return 3},Sn.JOIN_ROUND.get=function(){return 1},Sn.JOIN_MITRE.get=function(){return 2},Sn.JOIN_BEVEL.get=function(){return 3},Sn.DEFAULT_QUADRANT_SEGMENTS.get=function(){return 8},Sn.DEFAULT_MITRE_LIMIT.get=function(){return 5},Sn.DEFAULT_SIMPLIFY_FACTOR.get=function(){return .01},Object.defineProperties(Cn,Sn);var Ln=function(t){this._distanceTol=null,this._isDeleted=null,this._angleOrientation=at.COUNTERCLOCKWISE,this._inputLine=t||null;},bn={INIT:{configurable:!0},DELETE:{configurable:!0},KEEP:{configurable:!0},NUM_PTS_TO_CHECK:{configurable:!0}};Ln.prototype.isDeletable=function(t,e,n,i){var r=this._inputLine[t],o=this._inputLine[e],s=this._inputLine[n];return !!this.isConcave(r,o,s)&&(!!this.isShallow(r,o,s,i)&&this.isShallowSampled(r,o,t,n,i))},Ln.prototype.deleteShallowConcavities=function(){for(var t=1,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),i=!1;n<this._inputLine.length;){var r=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=Ln.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e);}return i},Ln.prototype.isShallowConcavity=function(t,e,n,i){if(!(at.computeOrientation(t,e,n)===this._angleOrientation))return !1;return at.distancePointLine(e,t,n)<i},Ln.prototype.isShallowSampled=function(t,e,n,i,r){var o=Math.trunc((i-n)/Ln.NUM_PTS_TO_CHECK);o<=0&&(o=1);for(var s=n;s<i;s+=o)if(!this.isShallow(t,e,this._inputLine[s],r))return !1;return !0},Ln.prototype.isConcave=function(t,e,n){var i=at.computeOrientation(t,e,n)===this._angleOrientation;return i},Ln.prototype.simplify=function(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=at.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);var e=!1;do{e=this.deleteShallowConcavities();}while(e);return this.collapseLine()},Ln.prototype.findNextNonDeletedIndex=function(t){for(var e=t+1;e<this._inputLine.length&&this._isDeleted[e]===Ln.DELETE;)e++;return e},Ln.prototype.isShallow=function(t,e,n,i){return at.distancePointLine(e,t,n)<i},Ln.prototype.collapseLine=function(){for(var t=new St,e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==Ln.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()},Ln.prototype.interfaces_=function(){return []},Ln.prototype.getClass=function(){return Ln},Ln.simplify=function(t,e){return new Ln(t).simplify(e)},bn.INIT.get=function(){return 0},bn.DELETE.get=function(){return 1},bn.KEEP.get=function(){return 1},bn.NUM_PTS_TO_CHECK.get=function(){return 10},Object.defineProperties(Ln,bn);var wn=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new Nt;},On={COORDINATE_ARRAY_TYPE:{configurable:!0}};wn.prototype.getCoordinates=function(){return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE)},wn.prototype.setPrecisionModel=function(t){this._precisionModel=t;},wn.prototype.addPt=function(t){var e=new C(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e);},wn.prototype.revere=function(){},wn.prototype.addPts=function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var i=t.length-1;i>=0;i--)this.addPt(t[i]);},wn.prototype.isRedundant=function(t){if(this._ptList.size()<1)return !1;var e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance},wn.prototype.toString=function(){return (new _e).createLineString(this.getCoordinates()).toString()},wn.prototype.closeRing=function(){if(this._ptList.size()<1)return null;var t=new C(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);if(t.equals(e))return null;this._ptList.add(t);},wn.prototype.setMinimumVertexDistance=function(t){this._minimimVertexDistance=t;},wn.prototype.interfaces_=function(){return []},wn.prototype.getClass=function(){return wn},On.COORDINATE_ARRAY_TYPE.get=function(){return new Array(0).fill(null)},Object.defineProperties(wn,On);var Tn=function(){},Rn={PI_TIMES_2:{configurable:!0},PI_OVER_2:{configurable:!0},PI_OVER_4:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},CLOCKWISE:{configurable:!0},NONE:{configurable:!0}};Tn.prototype.interfaces_=function(){return []},Tn.prototype.getClass=function(){return Tn},Tn.toDegrees=function(t){return 180*t/Math.PI},Tn.normalize=function(t){for(;t>Math.PI;)t-=Tn.PI_TIMES_2;for(;t<=-Math.PI;)t+=Tn.PI_TIMES_2;return t},Tn.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},Tn.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y;return i*(n.x-e.x)+r*(n.y-e.y)>0},Tn.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y;return i*(n.x-e.x)+r*(n.y-e.y)<0},Tn.interiorAngle=function(t,e,n){var i=Tn.angle(e,t),r=Tn.angle(e,n);return Math.abs(r-i)},Tn.normalizePositive=function(t){if(t<0){for(;t<0;)t+=Tn.PI_TIMES_2;t>=Tn.PI_TIMES_2&&(t=0);}else {for(;t>=Tn.PI_TIMES_2;)t-=Tn.PI_TIMES_2;t<0&&(t=0);}return t},Tn.angleBetween=function(t,e,n){var i=Tn.angle(e,t),r=Tn.angle(e,n);return Tn.diff(i,r)},Tn.diff=function(t,e){var n=null;return (n=t<e?e-t:t-e)>Math.PI&&(n=2*Math.PI-n),n},Tn.toRadians=function(t){return t*Math.PI/180},Tn.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?Tn.COUNTERCLOCKWISE:n<0?Tn.CLOCKWISE:Tn.NONE},Tn.angleBetweenOriented=function(t,e,n){var i=Tn.angle(e,t),r=Tn.angle(e,n)-i;return r<=-Math.PI?r+Tn.PI_TIMES_2:r>Math.PI?r-Tn.PI_TIMES_2:r},Rn.PI_TIMES_2.get=function(){return 2*Math.PI},Rn.PI_OVER_2.get=function(){return Math.PI/2},Rn.PI_OVER_4.get=function(){return Math.PI/4},Rn.COUNTERCLOCKWISE.get=function(){return at.COUNTERCLOCKWISE},Rn.CLOCKWISE.get=function(){return at.CLOCKWISE},Rn.NONE.get=function(){return at.COLLINEAR},Object.defineProperties(Tn,Rn);var Pn=function t(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new dn,this._seg1=new dn,this._offset0=new dn,this._offset1=new dn,this._side=0,this._hasNarrowConcaveAngle=!1;var e=arguments[0],n=arguments[1],i=arguments[2];this._precisionModel=e,this._bufParams=n,this._li=new rt,this._filletAngleQuantum=Math.PI/2/n.getQuadrantSegments(),n.getQuadrantSegments()>=8&&n.getJoinStyle()===Cn.JOIN_ROUND&&(this._closingSegLengthFactor=t.MAX_CLOSING_SEG_LEN_FACTOR),this.init(i);},Dn={OFFSET_SEGMENT_SEPARATION_FACTOR:{configurable:!0},INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},CURVE_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},MAX_CLOSING_SEG_LEN_FACTOR:{configurable:!0}};Pn.prototype.addNextSegment=function(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;var n=at.computeOrientation(this._s0,this._s1,this._s2),i=n===at.CLOCKWISE&&this._side===Se.LEFT||n===at.COUNTERCLOCKWISE&&this._side===Se.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e);},Pn.prototype.addLineEndCap=function(t,e){var n=new dn(t,e),i=new dn;this.computeOffsetSegment(n,Se.LEFT,this._distance,i);var r=new dn;this.computeOffsetSegment(n,Se.RIGHT,this._distance,r);var o=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,o);switch(this._bufParams.getEndCapStyle()){case Cn.CAP_ROUND:this._segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,at.CLOCKWISE,this._distance),this._segList.addPt(r.p1);break;case Cn.CAP_FLAT:this._segList.addPt(i.p1),this._segList.addPt(r.p1);break;case Cn.CAP_SQUARE:var u=new C;u.x=Math.abs(this._distance)*Math.cos(a),u.y=Math.abs(this._distance)*Math.sin(a);var l=new C(i.p1.x+u.x,i.p1.y+u.y),c=new C(r.p1.x+u.x,r.p1.y+u.y);this._segList.addPt(l),this._segList.addPt(c);}},Pn.prototype.getCoordinates=function(){return this._segList.getCoordinates()},Pn.prototype.addMitreJoin=function(t,e,n,i){var r=!0,o=null;try{o=k.intersection(e.p0,e.p1,n.p0,n.p1);(i<=0?1:o.distance(t)/Math.abs(i))>this._bufParams.getMitreLimit()&&(r=!1);}catch(t){if(!(t instanceof X))throw t;o=new C(0,0),r=!1;}r?this._segList.addPt(o):this.addLimitedMitreJoin(e,n,i,this._bufParams.getMitreLimit());},Pn.prototype.addFilletCorner=function(t,e,n,i,r){var o=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,o),u=n.x-t.x,l=n.y-t.y,c=Math.atan2(l,u);i===at.CLOCKWISE?a<=c&&(a+=2*Math.PI):a>=c&&(a-=2*Math.PI),this._segList.addPt(e),this.addFilletArc(t,a,c,i,r),this._segList.addPt(n);},Pn.prototype.addOutsideTurn=function(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===Cn.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===Cn.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0));},Pn.prototype.createSquare=function(t){this._segList.addPt(new C(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new C(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new C(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new C(t.x-this._distance,t.y+this._distance)),this._segList.closeRing();},Pn.prototype.addSegments=function(t,e){this._segList.addPts(t,e);},Pn.prototype.addFirstSegment=function(){this._segList.addPt(this._offset1.p0);},Pn.prototype.addLastSegment=function(){this._segList.addPt(this._offset1.p1);},Pn.prototype.initSideSegments=function(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1);},Pn.prototype.addLimitedMitreJoin=function(t,e,n,i){var r=this._seg0.p1,o=Tn.angle(r,this._seg0.p0),s=Tn.angleBetweenOriented(this._seg0.p0,r,this._seg1.p1)/2,a=Tn.normalize(o+s),u=Tn.normalize(a+Math.PI),l=i*n,c=n-l*Math.abs(Math.sin(s)),p=r.x+l*Math.cos(u),h=r.y+l*Math.sin(u),f=new C(p,h),g=new dn(r,f),d=g.pointAlongOffset(1,c),y=g.pointAlongOffset(1,-c);this._side===Se.LEFT?(this._segList.addPt(d),this._segList.addPt(y)):(this._segList.addPt(y),this._segList.addPt(d));},Pn.prototype.computeOffsetSegment=function(t,e,n,i){var r=e===Se.LEFT?1:-1,o=t.p1.x-t.p0.x,s=t.p1.y-t.p0.y,a=Math.sqrt(o*o+s*s),u=r*n*o/a,l=r*n*s/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u;},Pn.prototype.addFilletArc=function(t,e,n,i,r){var o=i===at.CLOCKWISE?-1:1,s=Math.abs(e-n),a=Math.trunc(s/this._filletAngleQuantum+.5);if(a<1)return null;for(var u=s/a,l=0,c=new C;l<s;){var p=e+o*l;c.x=t.x+r*Math.cos(p),c.y=t.y+r*Math.sin(p),this._segList.addPt(c),l+=u;}},Pn.prototype.addInsideTurn=function(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else {if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){var n=new C((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(n);var i=new C((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(i);}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0);}},Pn.prototype.createCircle=function(t){var e=new C(t.x+this._distance,t.y);this._segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing();},Pn.prototype.addBevelJoin=function(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0);},Pn.prototype.init=function(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new wn,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);},Pn.prototype.addCollinear=function(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2);this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===Cn.JOIN_BEVEL||this._bufParams.getJoinStyle()===Cn.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,at.CLOCKWISE,this._distance));},Pn.prototype.closeRing=function(){this._segList.closeRing();},Pn.prototype.hasNarrowConcaveAngle=function(){return this._hasNarrowConcaveAngle},Pn.prototype.interfaces_=function(){return []},Pn.prototype.getClass=function(){return Pn},Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get=function(){return .001},Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return .001},Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return 1e-6},Dn.MAX_CLOSING_SEG_LEN_FACTOR.get=function(){return 80},Object.defineProperties(Pn,Dn);var Mn=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;var t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e;};Mn.prototype.getOffsetCurve=function(t,e){if(this._distance=e,0===e)return null;var n=e<0,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var o=r.getCoordinates();return n&&Lt.reverse(o),o},Mn.prototype.computeSingleSidedBufferCurve=function(t,e,n){var i=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);var r=Ln.simplify(t,-i),o=r.length-1;n.initSideSegments(r[o],r[o-1],Se.LEFT),n.addFirstSegment();for(var s=o-2;s>=0;s--)n.addNextSegment(r[s],!0);}else {n.addSegments(t,!1);var a=Ln.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],Se.LEFT),n.addFirstSegment();for(var l=2;l<=u;l++)n.addNextSegment(a[l],!0);}n.addLastSegment(),n.closeRing();},Mn.prototype.computeRingBufferCurve=function(t,e,n){var i=this.simplifyTolerance(this._distance);e===Se.RIGHT&&(i=-i);var r=Ln.simplify(t,i),o=r.length-1;n.initSideSegments(r[o-1],r[0],e);for(var s=1;s<=o;s++){var a=1!==s;n.addNextSegment(r[s],a);}n.closeRing();},Mn.prototype.computeLineBufferCurve=function(t,e){var n=this.simplifyTolerance(this._distance),i=Ln.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],Se.LEFT);for(var o=2;o<=r;o++)e.addNextSegment(i[o],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var s=Ln.simplify(t,-n),a=s.length-1;e.initSideSegments(s[a],s[a-1],Se.LEFT);for(var u=a-2;u>=0;u--)e.addNextSegment(s[u],!0);e.addLastSegment(),e.addLineEndCap(s[1],s[0]),e.closeRing();},Mn.prototype.computePointCurve=function(t,e){switch(this._bufParams.getEndCapStyle()){case Cn.CAP_ROUND:e.createCircle(t);break;case Cn.CAP_SQUARE:e.createSquare(t);}},Mn.prototype.getLineCurve=function(t,e){if(this._distance=e,e<0&&!this._bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this._bufParams.isSingleSided()){var r=e<0;this.computeSingleSidedBufferCurve(t,r,i);}else this.computeLineBufferCurve(t,i);return i.getCoordinates()},Mn.prototype.getBufferParameters=function(){return this._bufParams},Mn.prototype.simplifyTolerance=function(t){return t*this._bufParams.getSimplifyFactor()},Mn.prototype.getRingCurve=function(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return Mn.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},Mn.prototype.computeOffsetCurve=function(t,e,n){var i=this.simplifyTolerance(this._distance);if(e){var r=Ln.simplify(t,-i),o=r.length-1;n.initSideSegments(r[o],r[o-1],Se.LEFT),n.addFirstSegment();for(var s=o-2;s>=0;s--)n.addNextSegment(r[s],!0);}else {var a=Ln.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],Se.LEFT),n.addFirstSegment();for(var l=2;l<=u;l++)n.addNextSegment(a[l],!0);}n.addLastSegment();},Mn.prototype.getSegGen=function(t){return new Pn(this._precisionModel,this._bufParams,t)},Mn.prototype.interfaces_=function(){return []},Mn.prototype.getClass=function(){return Mn},Mn.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new C(t[n]);return e};var An=function(){this._subgraphs=null,this._seg=new dn,this._cga=new at;var t=arguments[0];this._subgraphs=t;},Fn={DepthSegment:{configurable:!0}};An.prototype.findStabbedSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=new Nt,n=this._subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e);}return e}if(3===arguments.length)if(T(arguments[2],xt)&&arguments[0]instanceof C&&arguments[1]instanceof ze)for(var o=arguments[0],s=arguments[1],a=arguments[2],u=s.getEdge().getCoordinates(),l=0;l<u.length-1;l++){this._seg.p0=u[l],this._seg.p1=u[l+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse();if(!(Math.max(this._seg.p0.x,this._seg.p1.x)<o.x)&&!(this._seg.isHorizontal()||o.y<this._seg.p0.y||o.y>this._seg.p1.y||at.computeOrientation(this._seg.p0,this._seg.p1,o)===at.RIGHT)){var c=s.getDepth(Se.LEFT);this._seg.p0.equals(u[l])||(c=s.getDepth(Se.RIGHT));var p=new Gn(this._seg,c);a.add(p);}}else if(T(arguments[2],xt)&&arguments[0]instanceof C&&T(arguments[1],xt))for(var h=arguments[0],f=arguments[1],g=arguments[2],d=f.iterator();d.hasNext();){var y=d.next();y.isForward()&&this.findStabbedSegments(h,y,g);}},An.prototype.getDepth=function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;return $e.min(e)._leftDepth},An.prototype.interfaces_=function(){return []},An.prototype.getClass=function(){return An},Fn.DepthSegment.get=function(){return Gn},Object.defineProperties(An,Fn);var Gn=function(){this._upwardSeg=null,this._leftDepth=null;var t=arguments[0],e=arguments[1];this._upwardSeg=new dn(t),this._leftDepth=e;};Gn.prototype.compareTo=function(t){var e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return -1;var n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:0!=(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg))?n:this._upwardSeg.compareTo(e._upwardSeg)},Gn.prototype.compareX=function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},Gn.prototype.toString=function(){return this._upwardSeg.toString()},Gn.prototype.interfaces_=function(){return [E]},Gn.prototype.getClass=function(){return Gn};var qn=function(t,e,n){this.p0=t||null,this.p1=e||null,this.p2=n||null;};qn.prototype.area=function(){return qn.area(this.p0,this.p1,this.p2)},qn.prototype.signedArea=function(){return qn.signedArea(this.p0,this.p1,this.p2)},qn.prototype.interpolateZ=function(t){if(null===t)throw new m("Supplied point is null.");return qn.interpolateZ(t,this.p0,this.p1,this.p2)},qn.prototype.longestSideLength=function(){return qn.longestSideLength(this.p0,this.p1,this.p2)},qn.prototype.isAcute=function(){return qn.isAcute(this.p0,this.p1,this.p2)},qn.prototype.circumcentre=function(){return qn.circumcentre(this.p0,this.p1,this.p2)},qn.prototype.area3D=function(){return qn.area3D(this.p0,this.p1,this.p2)},qn.prototype.centroid=function(){return qn.centroid(this.p0,this.p1,this.p2)},qn.prototype.inCentre=function(){return qn.inCentre(this.p0,this.p1,this.p2)},qn.prototype.interfaces_=function(){return []},qn.prototype.getClass=function(){return qn},qn.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},qn.signedArea=function(t,e,n){return ((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},qn.det=function(t,e,n,i){return t*i-e*n},qn.interpolateZ=function(t,e,n,i){var r=e.x,o=e.y,s=n.x-r,a=i.x-r,u=n.y-o,l=i.y-o,c=s*l-a*u,p=t.x-r,h=t.y-o,f=(l*p-a*h)/c,g=(-u*p+s*h)/c;return e.z+f*(n.z-e.z)+g*(i.z-e.z)},qn.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),o=n.distance(t),s=i;return r>s&&(s=r),o>s&&(s=o),s},qn.isAcute=function(t,e,n){return !!Tn.isAcute(t,e,n)&&(!!Tn.isAcute(e,n,t)&&!!Tn.isAcute(n,t,e))},qn.circumcentre=function(t,e,n){var i=n.x,r=n.y,o=t.x-i,s=t.y-r,a=e.x-i,u=e.y-r,l=2*qn.det(o,s,a,u),c=qn.det(s,o*o+s*s,u,a*a+u*u),p=qn.det(o,o*o+s*s,a,a*a+u*u);return new C(i-c/l,r+p/l)},qn.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new k(t.x+n/2,t.y+i/2,1),o=new k(t.x-i+n/2,t.y+n+i/2,1);return new k(r,o)},qn.angleBisector=function(t,e,n){var i=e.distance(t),r=i/(i+e.distance(n)),o=n.x-t.x,s=n.y-t.y;return new C(t.x+r*o,t.y+r*s)},qn.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,o=e.z-t.z,s=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-o*a,c=o*s-i*u,p=i*a-r*s,h=l*l+c*c+p*p,f=Math.sqrt(h)/2;return f},qn.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new C(i,r)},qn.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),o=t.distance(e),s=i+r+o,a=(i*t.x+r*e.x+o*n.x)/s,u=(i*t.y+r*e.y+o*n.y)/s;return new C(a,u)};var Bn=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new Nt;var t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n;};Bn.prototype.addPoint=function(t){if(this._distance<=0)return null;var e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,w.EXTERIOR,w.INTERIOR);},Bn.prototype.addPolygon=function(t){var e=this._distance,n=Se.LEFT;this._distance<0&&(e=-this._distance,n=Se.RIGHT);var i=t.getExteriorRing(),r=Lt.removeRepeatedPoints(i.getCoordinates());if(this._distance<0&&this.isErodedCompletely(i,this._distance))return null;if(this._distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,w.EXTERIOR,w.INTERIOR);for(var o=0;o<t.getNumInteriorRing();o++){var s=t.getInteriorRingN(o),a=Lt.removeRepeatedPoints(s.getCoordinates());this._distance>0&&this.isErodedCompletely(s,-this._distance)||this.addPolygonRing(a,e,Se.opposite(n),w.INTERIOR,w.EXTERIOR);}},Bn.prototype.isTriangleErodedCompletely=function(t,e){var n=new qn(t[0],t[1],t[2]),i=n.inCentre();return at.distancePointLine(i,n.p0,n.p1)<Math.abs(e)},Bn.prototype.addLineString=function(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;var e=Lt.removeRepeatedPoints(t.getCoordinates()),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,w.EXTERIOR,w.INTERIOR);},Bn.prototype.addCurve=function(t,e,n){if(null===t||t.length<2)return null;var i=new gn(t,new Pe(0,w.BOUNDARY,e,n));this._curveList.add(i);},Bn.prototype.getCurves=function(){return this.add(this._inputGeom),this._curveList},Bn.prototype.addPolygonRing=function(t,e,n,i,r){if(0===e&&t.length<ee.MINIMUM_VALID_SIZE)return null;var o=i,s=r;t.length>=ee.MINIMUM_VALID_SIZE&&at.isCCW(t)&&(o=r,s=i,n=Se.opposite(n));var a=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(a,o,s);},Bn.prototype.add=function(t){if(t.isEmpty())return null;t instanceof $t?this.addPolygon(t):t instanceof Kt?this.addLineString(t):t instanceof Qt?this.addPoint(t):t instanceof te?this.addCollection(t):t instanceof Xt?this.addCollection(t):t instanceof ne?this.addCollection(t):t instanceof zt&&this.addCollection(t);},Bn.prototype.isErodedCompletely=function(t,e){var n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return e<0&&2*Math.abs(e)>r},Bn.prototype.addCollection=function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n);}},Bn.prototype.interfaces_=function(){return []},Bn.prototype.getClass=function(){return Bn};var Vn=function(){};Vn.prototype.locate=function(t){},Vn.prototype.interfaces_=function(){return []},Vn.prototype.getClass=function(){return Vn};var Un=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;var t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries();};Un.prototype.next=function(){if(this._atStart)return this._atStart=!1,Un.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null;}if(this._index>=this._max)throw new i;var t=this._parent.getGeometryN(this._index++);return t instanceof zt?(this._subcollectionIterator=new Un(t),this._subcollectionIterator.next()):t},Un.prototype.remove=function(){throw new Error(this.getClass().getName())},Un.prototype.hasNext=function(){if(this._atStart)return !0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return !0;this._subcollectionIterator=null;}return !(this._index>=this._max)},Un.prototype.interfaces_=function(){return [Et]},Un.prototype.getClass=function(){return Un},Un.isAtomic=function(t){return !(t instanceof zt)};var zn=function(){this._geom=null;var t=arguments[0];this._geom=t;};zn.prototype.locate=function(t){return zn.locate(t,this._geom)},zn.prototype.interfaces_=function(){return [Vn]},zn.prototype.getClass=function(){return zn},zn.isPointInRing=function(t,e){return !!e.getEnvelopeInternal().intersects(t)&&at.isPointInRing(t,e.getCoordinates())},zn.containsPointInPolygon=function(t,e){if(e.isEmpty())return !1;var n=e.getExteriorRing();if(!zn.isPointInRing(t,n))return !1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(zn.isPointInRing(t,r))return !1}return !0},zn.containsPoint=function(t,e){if(e instanceof $t)return zn.containsPointInPolygon(t,e);if(e instanceof zt)for(var n=new Un(e);n.hasNext();){var i=n.next();if(i!==e&&zn.containsPoint(t,i))return !0}return !1},zn.locate=function(t,e){return e.isEmpty()?w.EXTERIOR:zn.containsPoint(t,e)?w.INTERIOR:w.EXTERIOR};var Xn=function(){this._edgeMap=new p,this._edgeList=null,this._ptInAreaLocation=[w.NONE,w.NONE];};Xn.prototype.getNextCW=function(t){this.getEdges();var e=this._edgeList.indexOf(t),n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)},Xn.prototype.propagateSideLabels=function(t){for(var e=w.NONE,n=this.iterator();n.hasNext();){var i=n.next().getLabel();i.isArea(t)&&i.getLocation(t,Se.LEFT)!==w.NONE&&(e=i.getLocation(t,Se.LEFT));}if(e===w.NONE)return null;for(var r=e,o=this.iterator();o.hasNext();){var s=o.next(),a=s.getLabel();if(a.getLocation(t,Se.ON)===w.NONE&&a.setLocation(t,Se.ON,r),a.isArea(t)){var u=a.getLocation(t,Se.LEFT),l=a.getLocation(t,Se.RIGHT);if(l!==w.NONE){if(l!==r)throw new we("side location conflict",s.getCoordinate());u===w.NONE&&et.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),r=u;}else et.isTrue(a.getLocation(t,Se.LEFT)===w.NONE,"found single null side"),a.setLocation(t,Se.RIGHT,r),a.setLocation(t,Se.LEFT,r);}}},Xn.prototype.getCoordinate=function(){var t=this.iterator();if(!t.hasNext())return null;return t.next().getCoordinate()},Xn.prototype.print=function(t){Y.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){e.next().print(t);}},Xn.prototype.isAreaLabelsConsistent=function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},Xn.prototype.checkAreaLabelsConsistent=function(t){var e=this.getEdges();if(e.size()<=0)return !0;var n=e.size()-1,i=e.get(n).getLabel().getLocation(t,Se.LEFT);et.isTrue(i!==w.NONE,"Found unlabelled area edge");for(var r=i,o=this.iterator();o.hasNext();){var s=o.next().getLabel();et.isTrue(s.isArea(t),"Found non-area edge");var a=s.getLocation(t,Se.LEFT),u=s.getLocation(t,Se.RIGHT);if(a===u)return !1;if(u!==r)return !1;r=a;}return !0},Xn.prototype.findIndex=function(t){this.iterator();for(var e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return -1},Xn.prototype.iterator=function(){return this.getEdges().iterator()},Xn.prototype.getEdges=function(){return null===this._edgeList&&(this._edgeList=new Nt(this._edgeMap.values())),this._edgeList},Xn.prototype.getLocation=function(t,e,n){return this._ptInAreaLocation[t]===w.NONE&&(this._ptInAreaLocation[t]=zn.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]},Xn.prototype.toString=function(){var t=new D;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n");}return t.toString()},Xn.prototype.computeEdgeEndLabels=function(t){for(var e=this.iterator();e.hasNext();){e.next().computeLabel(t);}},Xn.prototype.computeLabelling=function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next().getLabel(),r=0;r<2;r++)i.isLine(r)&&i.getLocation(r)===w.BOUNDARY&&(e[r]=!0);for(var o=this.iterator();o.hasNext();)for(var s=o.next(),a=s.getLabel(),u=0;u<2;u++)if(a.isAnyNull(u)){var l=w.NONE;if(e[u])l=w.EXTERIOR;else {var c=s.getCoordinate();l=this.getLocation(u,c,t);}a.setAllLocationsIfNull(u,l);}},Xn.prototype.getDegree=function(){return this._edgeMap.size()},Xn.prototype.insertEdgeEnd=function(t,e){this._edgeMap.put(t,e),this._edgeList=null;},Xn.prototype.interfaces_=function(){return []},Xn.prototype.getClass=function(){return Xn};var Yn=function(t){function e(){t.call(this),this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.linkResultDirectedEdges=function(){this.getResultAreaEdges();for(var t=null,e=null,n=this._SCANNING_FOR_INCOMING,i=0;i<this._resultAreaEdgeList.size();i++){var r=this._resultAreaEdgeList.get(i),o=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this._SCANNING_FOR_INCOMING:if(!o.isInResult())continue;e=o,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this._SCANNING_FOR_INCOMING;}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new we("no outgoing dirEdge found",this.getCoordinate());et.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t);}},e.prototype.insert=function(t){var e=t;this.insertEdgeEnd(e,e);},e.prototype.getRightmostEdge=function(){var t=this.getEdges(),e=t.size();if(e<1)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),o=i.getQuadrant();return Be.isNorthern(r)&&Be.isNorthern(o)?n:Be.isNorthern(r)||Be.isNorthern(o)?0!==n.getDy()?n:0!==i.getDy()?i:(et.shouldNeverReachHere("found two horizontal edges incident on node"),null):i},e.prototype.print=function(t){Y.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println();}},e.prototype.getResultAreaEdges=function(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new Nt;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e);}return this._resultAreaEdgeList},e.prototype.updateLabelling=function(t){for(var e=this.iterator();e.hasNext();){var n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1));}},e.prototype.linkAllDirectedEdges=function(){this.getEdges();for(var t=null,e=null,n=this._edgeList.size()-1;n>=0;n--){var i=this._edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i;}e.setNext(t);},e.prototype.computeDepths=function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=t.getDepth(Se.LEFT),i=t.getDepth(Se.RIGHT),r=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,r)!==i)throw new we("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],s=arguments[1],a=arguments[2],u=o;u<s;u++){var l=this._edgeList.get(u);l.setEdgeDepths(Se.RIGHT,a),a=l.getDepth(Se.LEFT);}return a}},e.prototype.mergeSymLabels=function(){for(var t=this.iterator();t.hasNext();){var e=t.next();e.getLabel().merge(e.getSym().getLabel());}},e.prototype.linkMinimalDirectedEdges=function(t){for(var e=null,n=null,i=this._SCANNING_FOR_INCOMING,r=this._resultAreaEdgeList.size()-1;r>=0;r--){var o=this._resultAreaEdgeList.get(r),s=o.getSym();switch(null===e&&o.getEdgeRing()===t&&(e=o),i){case this._SCANNING_FOR_INCOMING:if(s.getEdgeRing()!==t)continue;n=s,i=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(o.getEdgeRing()!==t)continue;n.setNextMin(o),i=this._SCANNING_FOR_INCOMING;}}i===this._LINKING_TO_OUTGOING&&(et.isTrue(null!==e,"found null for first outgoing dirEdge"),et.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e));},e.prototype.getOutgoingDegree=function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){e.next().isInResult()&&t++;}return t}if(1===arguments.length){for(var n=arguments[0],i=0,r=this.iterator();r.hasNext();){r.next().getEdgeRing()===n&&i++;}return i}},e.prototype.getLabel=function(){return this._label},e.prototype.findCoveredLineEdges=function(){for(var t=w.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=w.INTERIOR;break}if(i.isInResult()){t=w.EXTERIOR;break}}}if(t===w.NONE)return null;for(var r=t,o=this.iterator();o.hasNext();){var s=o.next(),a=s.getSym();s.isLineEdge()?s.getEdge().setCovered(r===w.INTERIOR):(s.isInResult()&&(r=w.EXTERIOR),a.isInResult()&&(r=w.INTERIOR));}},e.prototype.computeLabelling=function(e){t.prototype.computeLabelling.call(this,e),this._label=new Pe(w.NONE);for(var n=this.iterator();n.hasNext();)for(var i=n.next().getEdge().getLabel(),r=0;r<2;r++){var o=i.getLocation(r);o!==w.INTERIOR&&o!==w.BOUNDARY||this._label.setLocation(r,w.INTERIOR);}},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(Xn),kn=function(t){function e(){t.apply(this,arguments);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.createNode=function(t){return new Ge(t,new Yn)},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(Xe),jn=function t(){this._pts=null,this._orientation=null;var e=arguments[0];this._pts=e,this._orientation=t.orientation(e);};jn.prototype.compareTo=function(t){var e=t;return jn.compareOriented(this._pts,this._orientation,e._pts,e._orientation)},jn.prototype.interfaces_=function(){return [E]},jn.prototype.getClass=function(){return jn},jn.orientation=function(t){return 1===Lt.increasingDirection(t)},jn.compareOriented=function(t,e,n,i){for(var r=e?1:-1,o=i?1:-1,s=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var c=t[u].compareTo(n[l]);if(0!==c)return c;var p=(u+=r)===s,h=(l+=o)===a;if(p&&!h)return -1;if(!p&&h)return 1;if(p&&h)return 0}};var Hn=function(){this._edges=new Nt,this._ocaMap=new p;};Hn.prototype.print=function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this._edges.size();e++){var n=this._edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")");}t.print(")  ");},Hn.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());},Hn.prototype.findEdgeIndex=function(t){for(var e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return -1},Hn.prototype.iterator=function(){return this._edges.iterator()},Hn.prototype.getEdges=function(){return this._edges},Hn.prototype.get=function(t){return this._edges.get(t)},Hn.prototype.findEqualEdge=function(t){var e=new jn(t.getCoordinates());return this._ocaMap.get(e)},Hn.prototype.add=function(t){this._edges.add(t);var e=new jn(t.getCoordinates());this._ocaMap.put(e,t);},Hn.prototype.interfaces_=function(){return []},Hn.prototype.getClass=function(){return Hn};var Wn=function(){};Wn.prototype.processIntersections=function(t,e,n,i){},Wn.prototype.isDone=function(){},Wn.prototype.interfaces_=function(){return []},Wn.prototype.getClass=function(){return Wn};var Kn=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this._li=t;};Kn.prototype.isTrivialIntersection=function(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(Kn.isAdjacentSegments(e,i))return !0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return !0}}return !1},Kn.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},Kn.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},Kn.prototype.getLineIntersector=function(){return this._li},Kn.prototype.hasProperIntersection=function(){return this._hasProper},Kn.prototype.processIntersections=function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)));},Kn.prototype.hasIntersection=function(){return this._hasIntersection},Kn.prototype.isDone=function(){return !1},Kn.prototype.hasInteriorIntersection=function(){return this._hasInterior},Kn.prototype.interfaces_=function(){return [Wn]},Kn.prototype.getClass=function(){return Kn},Kn.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)};var Jn=function(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new C(t),this.segmentIndex=e,this.dist=n;};Jn.prototype.getSegmentIndex=function(){return this.segmentIndex},Jn.prototype.getCoordinate=function(){return this.coord},Jn.prototype.print=function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist);},Jn.prototype.compareTo=function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},Jn.prototype.isEndPoint=function(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t},Jn.prototype.toString=function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},Jn.prototype.getDistance=function(){return this.dist},Jn.prototype.compare=function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},Jn.prototype.interfaces_=function(){return [E]},Jn.prototype.getClass=function(){return Jn};var Qn=function(){this._nodeMap=new p,this.edge=null;var t=arguments[0];this.edge=t;};Qn.prototype.print=function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){e.next().print(t);}},Qn.prototype.iterator=function(){return this._nodeMap.values().iterator()},Qn.prototype.addSplitEdges=function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i;}},Qn.prototype.addEndpoints=function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0);},Qn.prototype.createSplitEdge=function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var o=new Array(n).fill(null),s=0;o[s++]=new C(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)o[s++]=this.edge.pts[a];return r&&(o[s]=e.coord),new ni(o,new Pe(this.edge._label))},Qn.prototype.add=function(t,e,n){var i=new Jn(t,e,n),r=this._nodeMap.get(i);return null!==r?r:(this._nodeMap.put(i,i),i)},Qn.prototype.isIntersection=function(t){for(var e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return !0}return !1},Qn.prototype.interfaces_=function(){return []},Qn.prototype.getClass=function(){return Qn};var Zn=function(){};Zn.prototype.getChainStartIndices=function(t){var e=0,n=new Nt;n.add(new M(e));do{var i=this.findChainEnd(t,e);n.add(new M(i)),e=i;}while(e<t.length-1);return Zn.toIntArray(n)},Zn.prototype.findChainEnd=function(t,e){for(var n=Be.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){if(Be.quadrant(t[i-1],t[i])!==n)break;i++;}return i-1},Zn.prototype.interfaces_=function(){return []},Zn.prototype.getClass=function(){return Zn},Zn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e};var $n=function(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new j,this.env2=new j;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Zn;this.startIndex=e.getChainStartIndices(this.pts);};$n.prototype.getCoordinates=function(){return this.pts},$n.prototype.getMaxX=function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},$n.prototype.getMinX=function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n},$n.prototype.computeIntersectsForChain=function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i);}else if(6===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],c=this.pts[r],p=this.pts[o],h=s.pts[a],f=s.pts[u];if(o-r==1&&u-a==1)return l.addIntersections(this.e,r,s.e,a),null;if(this.env1.init(c,p),this.env2.init(h,f),!this.env1.intersects(this.env2))return null;var g=Math.trunc((r+o)/2),d=Math.trunc((a+u)/2);r<g&&(a<d&&this.computeIntersectsForChain(r,g,s,a,d,l),d<u&&this.computeIntersectsForChain(r,g,s,d,u,l)),g<o&&(a<d&&this.computeIntersectsForChain(g,o,s,a,d,l),d<u&&this.computeIntersectsForChain(g,o,s,d,u,l));}},$n.prototype.getStartIndexes=function(){return this.startIndex},$n.prototype.computeIntersects=function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e);},$n.prototype.interfaces_=function(){return []},$n.prototype.getClass=function(){return $n};var ti=function t(){this._depth=Array(2).fill().map(function(){return Array(3)});for(var e=0;e<2;e++)for(var n=0;n<3;n++)this._depth[e][n]=t.NULL_VALUE;},ei={NULL_VALUE:{configurable:!0}};ti.prototype.getDepth=function(t,e){return this._depth[t][e]},ti.prototype.setDepth=function(t,e,n){this._depth[t][e]=n;},ti.prototype.isNull=function(){if(0===arguments.length){for(var t=0;t<2;t++)for(var e=0;e<3;e++)if(this._depth[t][e]!==ti.NULL_VALUE)return !1;return !0}if(1===arguments.length){var n=arguments[0];return this._depth[n][1]===ti.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this._depth[i][r]===ti.NULL_VALUE}},ti.prototype.normalize=function(){for(var t=0;t<2;t++)if(!this.isNull(t)){var e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(var n=1;n<3;n++){var i=0;this._depth[t][n]>e&&(i=1),this._depth[t][n]=i;}}},ti.prototype.getDelta=function(t){return this._depth[t][Se.RIGHT]-this._depth[t][Se.LEFT]},ti.prototype.getLocation=function(t,e){return this._depth[t][e]<=0?w.EXTERIOR:w.INTERIOR},ti.prototype.toString=function(){return "A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]},ti.prototype.add=function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<2;e++)for(var n=1;n<3;n++){var i=t.getLocation(e,n);i!==w.EXTERIOR&&i!==w.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=ti.depthAtLocation(i):this._depth[e][n]+=ti.depthAtLocation(i));}else if(3===arguments.length){var r=arguments[0],o=arguments[1];arguments[2]===w.INTERIOR&&this._depth[r][o]++;}},ti.prototype.interfaces_=function(){return []},ti.prototype.getClass=function(){return ti},ti.depthAtLocation=function(t){return t===w.EXTERIOR?0:t===w.INTERIOR?1:ti.NULL_VALUE},ei.NULL_VALUE.get=function(){return -1},Object.defineProperties(ti,ei);var ni=function(t){function e(){if(t.call(this),this.pts=null,this._env=null,this.eiList=new Qn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new ti,this._depthDelta=0,1===arguments.length){var n=arguments[0];e.call(this,n,null);}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.pts=i,this._label=r;}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getDepth=function(){return this._depth},e.prototype.getCollapsedEdge=function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];return new e(t,Pe.toLineLabel(this._label))},e.prototype.isIsolated=function(){return this._isIsolated},e.prototype.getCoordinates=function(){return this.pts},e.prototype.setIsolated=function(t){this._isIsolated=t;},e.prototype.setName=function(t){this._name=t;},e.prototype.equals=function(t){if(!(t instanceof e))return !1;var n=t;if(this.pts.length!==n.pts.length)return !1;for(var i=!0,r=!0,o=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(n.pts[s])||(i=!1),this.pts[s].equals2D(n.pts[--o])||(r=!1),!i&&!r)return !1;return !0},e.prototype.getCoordinate=function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},e.prototype.print=function(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta);},e.prototype.computeIM=function(t){e.updateIM(this._label,t);},e.prototype.isCollapsed=function(){return !!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))},e.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1])},e.prototype.getMaximumSegmentIndex=function(){return this.pts.length-1},e.prototype.getDepthDelta=function(){return this._depthDelta},e.prototype.getNumPoints=function(){return this.pts.length},e.prototype.printReverse=function(t){t.print("edge "+this._name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("");},e.prototype.getMonotoneChainEdge=function(){return null===this._mce&&(this._mce=new $n(this)),this._mce},e.prototype.getEnvelope=function(){if(null===this._env){this._env=new j;for(var t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t]);}return this._env},e.prototype.addIntersection=function(t,e,n,i){var r=new C(t.getIntersection(i)),o=e,s=t.getEdgeDistance(n,i),a=o+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(o=a,s=0);}this.eiList.add(r,o,s);},e.prototype.toString=function(){var t=new D;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()},e.prototype.isPointwiseEqual=function(t){if(this.pts.length!==t.pts.length)return !1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return !1;return !0},e.prototype.setDepthDelta=function(t){this._depthDelta=t;},e.prototype.getEdgeIntersectionList=function(){return this.eiList},e.prototype.addIntersections=function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e.updateIM=function(){if(2!==arguments.length)return t.prototype.updateIM.apply(this,arguments);var e=arguments[0],n=arguments[1];n.setAtLeastIfValid(e.getLocation(0,Se.ON),e.getLocation(1,Se.ON),1),e.isArea()&&(n.setAtLeastIfValid(e.getLocation(0,Se.LEFT),e.getLocation(1,Se.LEFT),2),n.setAtLeastIfValid(e.getLocation(0,Se.RIGHT),e.getLocation(1,Se.RIGHT),2));},e}(Fe),ii=function(t){this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new Hn,this._bufParams=t||null;};ii.prototype.setWorkingPrecisionModel=function(t){this._workingPrecisionModel=t;},ii.prototype.insertUniqueEdge=function(t){var e=this._edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new Pe(t.getLabel())).flip(),n.merge(i);var r=ii.depthDelta(i),o=e.getDepthDelta()+r;e.setDepthDelta(o);}else this._edgeList.add(t),t.setDepthDelta(ii.depthDelta(t.getLabel()));},ii.prototype.buildSubgraphs=function(t,e){for(var n=new Nt,i=t.iterator();i.hasNext();){var r=i.next(),o=r.getRightmostCoordinate(),s=new An(n).getDepth(o);r.computeDepth(s),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes());}},ii.prototype.createSubgraphs=function(t){for(var e=new Nt,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new Te;r.create(i),e.add(r);}}return $e.sort(e,$e.reverseOrder()),e},ii.prototype.createEmptyResultGeometry=function(){return this._geomFact.createPolygon()},ii.prototype.getNoder=function(t){if(null!==this._workingNoder)return this._workingNoder;var e=new xn,n=new rt;return n.setPrecisionModel(t),e.setSegmentIntersector(new Kn(n)),e},ii.prototype.buffer=function(t,e){var n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();var i=new Mn(n,this._bufParams),r=new Bn(t,e,i).getCurves();if(r.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(r,n),this._graph=new Ye(new kn),this._graph.addEdges(this._edgeList.getEdges());var o=this.createSubgraphs(this._graph),s=new ke(this._geomFact);this.buildSubgraphs(o,s);var a=s.getPolygons();if(a.size()<=0)return this.createEmptyResultGeometry();return this._geomFact.buildGeometry(a)},ii.prototype.computeNodedEdges=function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings().iterator();i.hasNext();){var r=i.next(),o=r.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var s=r.getData(),a=new ni(r.getCoordinates(),new Pe(s));this.insertUniqueEdge(a);}}},ii.prototype.setNoder=function(t){this._workingNoder=t;},ii.prototype.interfaces_=function(){return []},ii.prototype.getClass=function(){return ii},ii.depthDelta=function(t){var e=t.getLocation(0,Se.LEFT),n=t.getLocation(0,Se.RIGHT);return e===w.INTERIOR&&n===w.EXTERIOR?1:e===w.EXTERIOR&&n===w.INTERIOR?-1:0},ii.convertSegStrings=function(t){for(var e=new _e,n=new Nt;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r);}return e.buildGeometry(n)};var ri=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._offsetX=0,this._offsetY=0,this._isScaled=!this.isIntegerPrecision();}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=arguments[3];this._noder=n,this._scaleFactor=i,this._offsetX=r,this._offsetY=o,this._isScaled=!this.isIntegerPrecision();}};ri.prototype.rescale=function(){if(T(arguments[0],It))for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.rescale(e.getCoordinates());}else if(arguments[0]instanceof Array){for(var n=arguments[0],i=0;i<n.length;i++)n[i].x=n[i].x/this._scaleFactor+this._offsetX,n[i].y=n[i].y/this._scaleFactor+this._offsetY;2===n.length&&n[0].equals2D(n[1])&&Y.out.println(n);}},ri.prototype.scale=function(){if(T(arguments[0],It)){for(var t=arguments[0],e=new Nt,n=t.iterator();n.hasNext();){var i=n.next();e.add(new gn(this.scale(i.getCoordinates()),i.getData()));}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],o=new Array(r.length).fill(null),s=0;s<r.length;s++)o[s]=new C(Math.round((r[s].x-this._offsetX)*this._scaleFactor),Math.round((r[s].y-this._offsetY)*this._scaleFactor),r[s].z);return Lt.removeRepeatedPoints(o)}},ri.prototype.isIntegerPrecision=function(){return 1===this._scaleFactor},ri.prototype.getNodedSubstrings=function(){var t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t},ri.prototype.computeNodes=function(t){var e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e);},ri.prototype.interfaces_=function(){return [In]},ri.prototype.getClass=function(){return ri};var oi=function(){this._li=new rt,this._segStrings=null;var t=arguments[0];this._segStrings=t;},si={fact:{configurable:!0}};oi.prototype.checkEndPtVertexIntersections=function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();){var e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings);}else if(2===arguments.length)for(var n=arguments[0],i=arguments[1].iterator();i.hasNext();)for(var r=i.next().getCoordinates(),o=1;o<r.length-1;o++)if(r[o].equals(n))throw new $("found endpt/interior pt intersection at index "+o+" :pt "+n)},oi.prototype.checkInteriorIntersections=function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this._segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i);}else if(2===arguments.length)for(var r=arguments[0],o=arguments[1],s=r.getCoordinates(),a=o.getCoordinates(),u=0;u<s.length-1;u++)for(var l=0;l<a.length-1;l++)this.checkInteriorIntersections(r,u,o,l);else if(4===arguments.length){var c=arguments[0],p=arguments[1],h=arguments[2],f=arguments[3];if(c===h&&p===f)return null;var g=c.getCoordinates()[p],d=c.getCoordinates()[p+1],y=h.getCoordinates()[f],_=h.getCoordinates()[f+1];if(this._li.computeIntersection(g,d,y,_),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,g,d)||this.hasInteriorIntersection(this._li,y,_)))throw new $("found non-noded intersection at "+g+"-"+d+" and "+y+"-"+_)}},oi.prototype.checkValid=function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses();},oi.prototype.checkCollapses=function(){if(0===arguments.length)for(var t=this._segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e);}else if(1===arguments.length)for(var n=arguments[0].getCoordinates(),i=0;i<n.length-2;i++)this.checkCollapse(n[i],n[i+1],n[i+2]);},oi.prototype.hasInteriorIntersection=function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return !0}return !1},oi.prototype.checkCollapse=function(t,e,n){if(t.equals(n))throw new $("found non-noded collapse at "+oi.fact.createLineString([t,e,n]))},oi.prototype.interfaces_=function(){return []},oi.prototype.getClass=function(){return oi},si.fact.get=function(){return new _e},Object.defineProperties(oi,si);var ai=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=n,e<=0)throw new m("Scale factor must be non-zero");1!==e&&(this._pt=new C(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new C,this._p1Scaled=new C),this.initCorners(this._pt);},ui={SAFE_ENV_EXPANSION_FACTOR:{configurable:!0}};ai.prototype.intersectsScaled=function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),o=Math.max(t.y,e.y),s=this._maxx<n||this._minx>i||this._maxy<r||this._miny>o;if(s)return !1;var a=this.intersectsToleranceSquare(t,e);return et.isTrue(!(s&&a),"Found bad envelope test"),a},ai.prototype.initCorners=function(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new C(this._maxx,this._maxy),this._corner[1]=new C(this._minx,this._maxy),this._corner[2]=new C(this._minx,this._miny),this._corner[3]=new C(this._maxx,this._miny);},ai.prototype.intersects=function(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))},ai.prototype.scale=function(t){return Math.round(t*this._scaleFactor)},ai.prototype.getCoordinate=function(){return this._originalPt},ai.prototype.copyScaled=function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y);},ai.prototype.getSafeEnvelope=function(){if(null===this._safeEnv){var t=ai.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new j(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t);}return this._safeEnv},ai.prototype.intersectsPixelClosure=function(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))},ai.prototype.intersectsToleranceSquare=function(t,e){var n=!1,i=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(i=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!i)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))},ai.prototype.addSnappedNode=function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return !!this.intersects(n,i)&&(t.addIntersection(this.getCoordinate(),e),!0)},ai.prototype.interfaces_=function(){return []},ai.prototype.getClass=function(){return ai},ui.SAFE_ENV_EXPANSION_FACTOR.get=function(){return .75},Object.defineProperties(ai,ui);var li=function(){this.tempEnv1=new j,this.selectedSegment=new dn;};li.prototype.select=function(){if(1===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment);}},li.prototype.interfaces_=function(){return []},li.prototype.getClass=function(){return li};var ci=function(){this._index=null;var t=arguments[0];this._index=t;},pi={HotPixelSnapAction:{configurable:!0}};ci.prototype.snap=function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),o=new hi(e,n,i);return this._index.query(r,{interfaces_:function(){return [Ke]},visitItem:function(t){t.select(r,o);}}),o.isNodeAdded()}},ci.prototype.interfaces_=function(){return []},ci.prototype.getClass=function(){return ci},pi.HotPixelSnapAction.get=function(){return hi},Object.defineProperties(ci,pi);var hi=function(t){function e(){t.call(this),this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;var e=arguments[0],n=arguments[1],i=arguments[2];this._hotPixel=e,this._parentEdge=n,this._hotPixelVertexIndex=i;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.isNodeAdded=function(){return this._isNodeAdded},e.prototype.select=function(){if(2!==arguments.length)return t.prototype.select.apply(this,arguments);var e=arguments[0],n=arguments[1],i=e.getContext();if(null!==this._parentEdge&&i===this._parentEdge&&n===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(i,n);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(li),fi=function(){this._li=null,this._interiorIntersections=null;var t=arguments[0];this._li=t,this._interiorIntersections=new Nt;};fi.prototype.processIntersections=function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(var u=0;u<this._li.getIntersectionNum();u++)this._interiorIntersections.add(this._li.getIntersection(u));t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1);}},fi.prototype.isDone=function(){return !1},fi.prototype.getInteriorIntersections=function(){return this._interiorIntersections},fi.prototype.interfaces_=function(){return [Wn]},fi.prototype.getClass=function(){return fi};var gi=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;var t=arguments[0];this._pm=t,this._li=new rt,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale();};gi.prototype.checkCorrectness=function(t){var e=gn.getNodedSubstrings(t),n=new oi(e);try{n.checkValid();}catch(t){if(!(t instanceof z))throw t;t.printStackTrace();}},gi.prototype.getNodedSubstrings=function(){return gn.getNodedSubstrings(this._nodedSegStrings)},gi.prototype.snapRound=function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t);},gi.prototype.findInteriorIntersections=function(t,e){var n=new fi(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()},gi.prototype.computeVertexSnaps=function(){if(T(arguments[0],It))for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.computeVertexSnaps(e);}else if(arguments[0]instanceof gn)for(var n=arguments[0],i=n.getCoordinates(),r=0;r<i.length;r++){var o=new ai(i[r],this._scaleFactor,this._li);this._pointSnapper.snap(o,n,r)&&n.addIntersection(i[r],r);}},gi.prototype.computeNodes=function(t){this._nodedSegStrings=t,this._noder=new xn,this._pointSnapper=new ci(this._noder.getIndex()),this.snapRound(t,this._li);},gi.prototype.computeIntersectionSnaps=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new ai(n,this._scaleFactor,this._li);this._pointSnapper.snap(i);}},gi.prototype.interfaces_=function(){return [In]},gi.prototype.getClass=function(){return gi};var di=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new Cn,this._resultGeometry=null,this._saveException=null,1===arguments.length){var t=arguments[0];this._argGeom=t;}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this._argGeom=e,this._bufParams=n;}},yi={CAP_ROUND:{configurable:!0},CAP_BUTT:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},MAX_PRECISION_DIGITS:{configurable:!0}};di.prototype.bufferFixedPrecision=function(t){var e=new ri(new gi(new fe(1)),t.getScale()),n=new ii(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance);},di.prototype.bufferReducedPrecision=function(){var t=this;if(0===arguments.length){for(var e=di.MAX_PRECISION_DIGITS;e>=0;e--){try{t.bufferReducedPrecision(e);}catch(e){if(!(e instanceof we))throw e;t._saveException=e;}if(null!==t._resultGeometry)return null}throw this._saveException}if(1===arguments.length){var n=arguments[0],i=di.precisionScaleFactor(this._argGeom,this._distance,n),r=new fe(i);this.bufferFixedPrecision(r);}},di.prototype.computeGeometry=function(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;var t=this._argGeom.getFactory().getPrecisionModel();t.getType()===fe.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision();},di.prototype.setQuadrantSegments=function(t){this._bufParams.setQuadrantSegments(t);},di.prototype.bufferOriginalPrecision=function(){try{var t=new ii(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance);}catch(t){if(!(t instanceof $))throw t;this._saveException=t;}},di.prototype.getResultGeometry=function(t){return this._distance=t,this.computeGeometry(),this._resultGeometry},di.prototype.setEndCapStyle=function(t){this._bufParams.setEndCapStyle(t);},di.prototype.interfaces_=function(){return []},di.prototype.getClass=function(){return di},di.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return new di(t).getResultGeometry(e)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof ct&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=arguments[2],o=new di(n);o.setQuadrantSegments(r);return o.getResultGeometry(i)}if(arguments[2]instanceof Cn&&arguments[0]instanceof ct&&"number"==typeof arguments[1]){var s=arguments[0],a=arguments[1],u=arguments[2];return new di(s,u).getResultGeometry(a)}}else if(4===arguments.length){var l=arguments[0],c=arguments[1],p=arguments[2],h=arguments[3],f=new di(l);f.setQuadrantSegments(p),f.setEndCapStyle(h);return f.getResultGeometry(c)}},di.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=R.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY()))+2*(e>0?e:0),o=n-Math.trunc(Math.log(r)/Math.log(10)+1);return Math.pow(10,o)},yi.CAP_ROUND.get=function(){return Cn.CAP_ROUND},yi.CAP_BUTT.get=function(){return Cn.CAP_FLAT},yi.CAP_FLAT.get=function(){return Cn.CAP_FLAT},yi.CAP_SQUARE.get=function(){return Cn.CAP_SQUARE},yi.MAX_PRECISION_DIGITS.get=function(){return 12},Object.defineProperties(di,yi);var _i=function(){this._pt=[new C,new C],this._distance=v.NaN,this._isNull=!0;};_i.prototype.getCoordinates=function(){return this._pt},_i.prototype.getCoordinate=function(t){return this._pt[t]},_i.prototype.setMinimum=function(){if(1===arguments.length){var t=arguments[0];this.setMinimum(t._pt[0],t._pt[1]);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i<this._distance&&this.initialize(e,n,i);}},_i.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1;}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this._pt[0].setCoordinate(n),this._pt[1].setCoordinate(i),this._distance=r,this._isNull=!1;}},_i.prototype.getDistance=function(){return this._distance},_i.prototype.setMaximum=function(){if(1===arguments.length){var t=arguments[0];this.setMaximum(t._pt[0],t._pt[1]);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i>this._distance&&this.initialize(e,n,i);}},_i.prototype.interfaces_=function(){return []},_i.prototype.getClass=function(){return _i};var mi=function(){};mi.prototype.interfaces_=function(){return []},mi.prototype.getClass=function(){return mi},mi.computeDistance=function(){if(arguments[2]instanceof _i&&arguments[0]instanceof Kt&&arguments[1]instanceof C)for(var t=arguments[0],e=arguments[1],n=arguments[2],i=t.getCoordinates(),r=new dn,o=0;o<i.length-1;o++){r.setCoordinates(i[o],i[o+1]);var s=r.closestPoint(e);n.setMinimum(s,e);}else if(arguments[2]instanceof _i&&arguments[0]instanceof $t&&arguments[1]instanceof C){var a=arguments[0],u=arguments[1],l=arguments[2];mi.computeDistance(a.getExteriorRing(),u,l);for(var c=0;c<a.getNumInteriorRing();c++)mi.computeDistance(a.getInteriorRingN(c),u,l);}else if(arguments[2]instanceof _i&&arguments[0]instanceof ct&&arguments[1]instanceof C){var p=arguments[0],h=arguments[1],f=arguments[2];if(p instanceof Kt)mi.computeDistance(p,h,f);else if(p instanceof $t)mi.computeDistance(p,h,f);else if(p instanceof zt)for(var g=p,d=0;d<g.getNumGeometries();d++){var y=g.getGeometryN(d);mi.computeDistance(y,h,f);}else f.setMinimum(p.getCoordinate(),h);}else if(arguments[2]instanceof _i&&arguments[0]instanceof dn&&arguments[1]instanceof C){var _=arguments[0],m=arguments[1],v=arguments[2],I=_.closestPoint(m);v.setMinimum(I,m);}};var vi=function(t){this._maxPtDist=new _i,this._inputGeom=t||null;},Ii={MaxPointDistanceFilter:{configurable:!0},MaxMidpointDistanceFilter:{configurable:!0}};vi.prototype.computeMaxMidpointDistance=function(t){var e=new xi(this._inputGeom);t.apply(e),this._maxPtDist.setMaximum(e.getMaxPointDistance());},vi.prototype.computeMaxVertexDistance=function(t){var e=new Ei(this._inputGeom);t.apply(e),this._maxPtDist.setMaximum(e.getMaxPointDistance());},vi.prototype.findDistance=function(t){return this.computeMaxVertexDistance(t),this.computeMaxMidpointDistance(t),this._maxPtDist.getDistance()},vi.prototype.getDistancePoints=function(){return this._maxPtDist},vi.prototype.interfaces_=function(){return []},vi.prototype.getClass=function(){return vi},Ii.MaxPointDistanceFilter.get=function(){return Ei},Ii.MaxMidpointDistanceFilter.get=function(){return xi},Object.defineProperties(vi,Ii);var Ei=function(t){this._maxPtDist=new _i,this._minPtDist=new _i,this._geom=t||null;};Ei.prototype.filter=function(t){this._minPtDist.initialize(),mi.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist);},Ei.prototype.getMaxPointDistance=function(){return this._maxPtDist},Ei.prototype.interfaces_=function(){return [ft]},Ei.prototype.getClass=function(){return Ei};var xi=function(t){this._maxPtDist=new _i,this._minPtDist=new _i,this._geom=t||null;};xi.prototype.filter=function(t,e){if(0===e)return null;var n=t.getCoordinate(e-1),i=t.getCoordinate(e),r=new C((n.x+i.x)/2,(n.y+i.y)/2);this._minPtDist.initialize(),mi.computeDistance(this._geom,r,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist);},xi.prototype.isDone=function(){return !1},xi.prototype.isGeometryChanged=function(){return !1},xi.prototype.getMaxPointDistance=function(){return this._maxPtDist},xi.prototype.interfaces_=function(){return [Ut]},xi.prototype.getClass=function(){return xi};var Ni=function(t){this._comps=t||null;};Ni.prototype.filter=function(t){t instanceof $t&&this._comps.add(t);},Ni.prototype.interfaces_=function(){return [Vt]},Ni.prototype.getClass=function(){return Ni},Ni.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return Ni.getPolygons(t,new Nt)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof $t?n.add(e):e instanceof zt&&e.apply(new Ni(n)),n}};var Ci=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this._lines=t;}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this._lines=e,this._isForcedToLineString=n;}};Ci.prototype.filter=function(t){if(this._isForcedToLineString&&t instanceof ee){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Kt&&this._lines.add(t);},Ci.prototype.setForceToLineString=function(t){this._isForcedToLineString=t;},Ci.prototype.interfaces_=function(){return [lt]},Ci.prototype.getClass=function(){return Ci},Ci.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(Ci.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(Ci.getLines(e,n))}},Ci.getLines=function(){if(1===arguments.length){var t=arguments[0];return Ci.getLines(t,!1)}if(2===arguments.length){if(T(arguments[0],It)&&T(arguments[1],It)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();Ci.getLines(r,n);}return n}if(arguments[0]instanceof ct&&"boolean"==typeof arguments[1]){var o=arguments[0],s=arguments[1],a=new Nt;return o.apply(new Ci(a,s)),a}if(arguments[0]instanceof ct&&T(arguments[1],It)){var u=arguments[0],l=arguments[1];return u instanceof Kt?l.add(u):u.apply(new Ci(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&T(arguments[0],It)&&T(arguments[1],It)){for(var c=arguments[0],p=arguments[1],h=arguments[2],f=c.iterator();f.hasNext();){var g=f.next();Ci.getLines(g,p,h);}return p}if("boolean"==typeof arguments[2]&&arguments[0]instanceof ct&&T(arguments[1],It)){var d=arguments[0],y=arguments[1],_=arguments[2];return d.apply(new Ci(y,_)),y}}};var Si=function(){if(this._boundaryRule=gt.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new m("Rule must be non-null");this._boundaryRule=t;}};Si.prototype.locateInternal=function(){if(arguments[0]instanceof C&&arguments[1]instanceof $t){var t=arguments[0],e=arguments[1];if(e.isEmpty())return w.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===w.EXTERIOR)return w.EXTERIOR;if(i===w.BOUNDARY)return w.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var o=e.getInteriorRingN(r),s=this.locateInPolygonRing(t,o);if(s===w.INTERIOR)return w.EXTERIOR;if(s===w.BOUNDARY)return w.BOUNDARY}return w.INTERIOR}if(arguments[0]instanceof C&&arguments[1]instanceof Kt){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return w.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?at.isOnLine(a,l)?w.INTERIOR:w.EXTERIOR:w.BOUNDARY}if(arguments[0]instanceof C&&arguments[1]instanceof Qt){var c=arguments[0];return arguments[1].getCoordinate().equals2D(c)?w.INTERIOR:w.EXTERIOR}},Si.prototype.locateInPolygonRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?at.locatePointInRing(t,e.getCoordinates()):w.EXTERIOR},Si.prototype.intersects=function(t,e){return this.locate(t,e)!==w.EXTERIOR},Si.prototype.updateLocationInfo=function(t){t===w.INTERIOR&&(this._isIn=!0),t===w.BOUNDARY&&this._numBoundaries++;},Si.prototype.computeLocation=function(t,e){if(e instanceof Qt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof Kt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof $t)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Xt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r));}else if(e instanceof ne)for(var o=e,s=0;s<o.getNumGeometries();s++){var a=o.getGeometryN(s);this.updateLocationInfo(this.locateInternal(t,a));}else if(e instanceof zt)for(var u=new Un(e);u.hasNext();){var l=u.next();l!==e&&this.computeLocation(t,l);}},Si.prototype.locate=function(t,e){return e.isEmpty()?w.EXTERIOR:e instanceof Kt?this.locateInternal(t,e):e instanceof $t?this.locateInternal(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?w.BOUNDARY:this._numBoundaries>0||this._isIn?w.INTERIOR:w.EXTERIOR)},Si.prototype.interfaces_=function(){return []},Si.prototype.getClass=function(){return Si};var Li=function t(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){var e=arguments[0],n=arguments[1];t.call(this,e,t.INSIDE_AREA,n);}else if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];this._component=i,this._segIndex=r,this._pt=o;}},bi={INSIDE_AREA:{configurable:!0}};Li.prototype.isInsideArea=function(){return this._segIndex===Li.INSIDE_AREA},Li.prototype.getCoordinate=function(){return this._pt},Li.prototype.getGeometryComponent=function(){return this._component},Li.prototype.getSegmentIndex=function(){return this._segIndex},Li.prototype.interfaces_=function(){return []},Li.prototype.getClass=function(){return Li},bi.INSIDE_AREA.get=function(){return -1},Object.defineProperties(Li,bi);var wi=function(t){this._pts=t||null;};wi.prototype.filter=function(t){t instanceof Qt&&this._pts.add(t);},wi.prototype.interfaces_=function(){return [Vt]},wi.prototype.getClass=function(){return wi},wi.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Qt?$e.singletonList(t):wi.getPoints(t,new Nt)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Qt?n.add(e):e instanceof zt&&e.apply(new wi(n)),n}};var Oi=function(){this._locations=null;var t=arguments[0];this._locations=t;};Oi.prototype.filter=function(t){(t instanceof Qt||t instanceof Kt||t instanceof $t)&&this._locations.add(new Li(t,0,t.getCoordinate()));},Oi.prototype.interfaces_=function(){return [Vt]},Oi.prototype.getClass=function(){return Oi},Oi.getLocations=function(t){var e=new Nt;return t.apply(new Oi(e)),e};var Ti=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new Si,this._minDistanceLocation=null,this._minDistance=v.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];this._geom=[t,e],this._terminateDistance=0;}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=n,this._geom[1]=i,this._terminateDistance=r;}};Ti.prototype.computeContainmentDistance=function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t);}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=Ni.getPolygons(this._geom[e]);if(r.size()>0){var o=Oi.getLocations(this._geom[i]);if(this.computeContainmentDistance(o,r,n),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[i]=n[0],this._minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&T(arguments[0],xt)&&T(arguments[1],xt)){for(var s=arguments[0],a=arguments[1],u=arguments[2],l=0;l<s.size();l++)for(var c=s.get(l),p=0;p<a.size();p++)if(this.computeContainmentDistance(c,a.get(p),u),this._minDistance<=this._terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof Li&&arguments[1]instanceof $t){var h=arguments[0],f=arguments[1],g=arguments[2],d=h.getCoordinate();if(w.EXTERIOR!==this._ptLocator.locate(d,f))return this._minDistance=0,g[0]=h,g[1]=new Li(f,d),null}},Ti.prototype.computeMinDistanceLinesPoints=function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),o=0;o<e.size();o++){var s=e.get(o);if(this.computeMinDistance(r,s,n),this._minDistance<=this._terminateDistance)return null}},Ti.prototype.computeFacetDistance=function(){var t=new Array(2).fill(null),e=Ci.getLines(this._geom[0]),n=Ci.getLines(this._geom[1]),i=wi.getPoints(this._geom[0]),r=wi.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},Ti.prototype.nearestLocations=function(){return this.computeMinDistance(),this._minDistanceLocation},Ti.prototype.updateMinDistance=function(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1]);},Ti.prototype.nearestPoints=function(){this.computeMinDistance();return [this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]},Ti.prototype.computeMinDistance=function(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance();}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Kt&&arguments[1]instanceof Qt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),o=0;o<i.length-1;o++){var s=at.distancePointLine(r,i[o],i[o+1]);if(s<this._minDistance){this._minDistance=s;var a=new dn(i[o],i[o+1]).closestPoint(r);n[0]=new Li(t,o,a),n[1]=new Li(e,0,r);}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Kt&&arguments[1]instanceof Kt){var u=arguments[0],l=arguments[1],c=arguments[2];if(u.getEnvelopeInternal().distance(l.getEnvelopeInternal())>this._minDistance)return null;for(var p=u.getCoordinates(),h=l.getCoordinates(),f=0;f<p.length-1;f++)for(var g=0;g<h.length-1;g++){var d=at.distanceLineLine(p[f],p[f+1],h[g],h[g+1]);if(d<this._minDistance){this._minDistance=d;var y=new dn(p[f],p[f+1]),_=new dn(h[g],h[g+1]),m=y.closestPoints(_);c[0]=new Li(u,f,m[0]),c[1]=new Li(l,g,m[1]);}if(this._minDistance<=this._terminateDistance)return null}}},Ti.prototype.computeMinDistancePoints=function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),o=0;o<e.size();o++){var s=e.get(o),a=r.getCoordinate().distance(s.getCoordinate());if(a<this._minDistance&&(this._minDistance=a,n[0]=new Li(r,0,r.getCoordinate()),n[1]=new Li(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}},Ti.prototype.distance=function(){if(null===this._geom[0]||null===this._geom[1])throw new m("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)},Ti.prototype.computeMinDistanceLines=function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),o=0;o<e.size();o++){var s=e.get(o);if(this.computeMinDistance(r,s,n),this._minDistance<=this._terminateDistance)return null}},Ti.prototype.interfaces_=function(){return []},Ti.prototype.getClass=function(){return Ti},Ti.distance=function(t,e){return new Ti(t,e).distance()},Ti.isWithinDistance=function(t,e,n){return new Ti(t,e,n).distance()<=n},Ti.nearestPoints=function(t,e){return new Ti(t,e).nearestPoints()};var Ri=function(){this._pt=[new C,new C],this._distance=v.NaN,this._isNull=!0;};Ri.prototype.getCoordinates=function(){return this._pt},Ri.prototype.getCoordinate=function(t){return this._pt[t]},Ri.prototype.setMinimum=function(){if(1===arguments.length){var t=arguments[0];this.setMinimum(t._pt[0],t._pt[1]);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i<this._distance&&this.initialize(e,n,i);}},Ri.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1;}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this._pt[0].setCoordinate(n),this._pt[1].setCoordinate(i),this._distance=r,this._isNull=!1;}},Ri.prototype.toString=function(){return Z.toLineString(this._pt[0],this._pt[1])},Ri.prototype.getDistance=function(){return this._distance},Ri.prototype.setMaximum=function(){if(1===arguments.length){var t=arguments[0];this.setMaximum(t._pt[0],t._pt[1]);}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this._isNull)return this.initialize(e,n),null;var i=e.distance(n);i>this._distance&&this.initialize(e,n,i);}},Ri.prototype.interfaces_=function(){return []},Ri.prototype.getClass=function(){return Ri};var Pi=function(){};Pi.prototype.interfaces_=function(){return []},Pi.prototype.getClass=function(){return Pi},Pi.computeDistance=function(){if(arguments[2]instanceof Ri&&arguments[0]instanceof Kt&&arguments[1]instanceof C)for(var t=arguments[0],e=arguments[1],n=arguments[2],i=new dn,r=t.getCoordinates(),o=0;o<r.length-1;o++){i.setCoordinates(r[o],r[o+1]);var s=i.closestPoint(e);n.setMinimum(s,e);}else if(arguments[2]instanceof Ri&&arguments[0]instanceof $t&&arguments[1]instanceof C){var a=arguments[0],u=arguments[1],l=arguments[2];Pi.computeDistance(a.getExteriorRing(),u,l);for(var c=0;c<a.getNumInteriorRing();c++)Pi.computeDistance(a.getInteriorRingN(c),u,l);}else if(arguments[2]instanceof Ri&&arguments[0]instanceof ct&&arguments[1]instanceof C){var p=arguments[0],h=arguments[1],f=arguments[2];if(p instanceof Kt)Pi.computeDistance(p,h,f);else if(p instanceof $t)Pi.computeDistance(p,h,f);else if(p instanceof zt)for(var g=p,d=0;d<g.getNumGeometries();d++){var y=g.getGeometryN(d);Pi.computeDistance(y,h,f);}else f.setMinimum(p.getCoordinate(),h);}else if(arguments[2]instanceof Ri&&arguments[0]instanceof dn&&arguments[1]instanceof C){var _=arguments[0],m=arguments[1],v=arguments[2],I=_.closestPoint(m);v.setMinimum(I,m);}};var Di=function(){this._g0=null,this._g1=null,this._ptDist=new Ri,this._densifyFrac=0;var t=arguments[0],e=arguments[1];this._g0=t,this._g1=e;},Mi={MaxPointDistanceFilter:{configurable:!0},MaxDensifiedByFractionDistanceFilter:{configurable:!0}};Di.prototype.getCoordinates=function(){return this._ptDist.getCoordinates()},Di.prototype.setDensifyFraction=function(t){if(t>1||t<=0)throw new m("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t;},Di.prototype.compute=function(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist);},Di.prototype.distance=function(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()},Di.prototype.computeOrientedDistance=function(t,e,n){var i=new Ai(e);if(t.apply(i),n.setMaximum(i.getMaxPointDistance()),this._densifyFrac>0){var r=new Fi(e,this._densifyFrac);t.apply(r),n.setMaximum(r.getMaxPointDistance());}},Di.prototype.orientedDistance=function(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()},Di.prototype.interfaces_=function(){return []},Di.prototype.getClass=function(){return Di},Di.distance=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return new Di(t,e).distance()}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=new Di(n,i);return o.setDensifyFraction(r),o.distance()}},Mi.MaxPointDistanceFilter.get=function(){return Ai},Mi.MaxDensifiedByFractionDistanceFilter.get=function(){return Fi},Object.defineProperties(Di,Mi);var Ai=function(){this._maxPtDist=new Ri,this._minPtDist=new Ri,this._euclideanDist=new Pi,this._geom=null;var t=arguments[0];this._geom=t;};Ai.prototype.filter=function(t){this._minPtDist.initialize(),Pi.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist);},Ai.prototype.getMaxPointDistance=function(){return this._maxPtDist},Ai.prototype.interfaces_=function(){return [ft]},Ai.prototype.getClass=function(){return Ai};var Fi=function(){this._maxPtDist=new Ri,this._minPtDist=new Ri,this._geom=null,this._numSubSegs=0;var t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e));};Fi.prototype.filter=function(t,e){if(0===e)return null;for(var n=t.getCoordinate(e-1),i=t.getCoordinate(e),r=(i.x-n.x)/this._numSubSegs,o=(i.y-n.y)/this._numSubSegs,s=0;s<this._numSubSegs;s++){var a=n.x+s*r,u=n.y+s*o,l=new C(a,u);this._minPtDist.initialize(),Pi.computeDistance(this._geom,l,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist);}},Fi.prototype.isDone=function(){return !1},Fi.prototype.isGeometryChanged=function(){return !1},Fi.prototype.getMaxPointDistance=function(){return this._maxPtDist},Fi.prototype.interfaces_=function(){return [Ut]},Fi.prototype.getClass=function(){return Fi};var Gi=function(t,e,n){this._minValidDistance=null,this._maxValidDistance=null,this._minDistanceFound=null,this._maxDistanceFound=null,this._isValid=!0,this._errMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=t||null,this._bufDistance=e||null,this._result=n||null;},qi={VERBOSE:{configurable:!0},MAX_DISTANCE_DIFF_FRAC:{configurable:!0}};Gi.prototype.checkMaximumDistance=function(t,e,n){var i=new Di(e,t);if(i.setDensifyFraction(.25),this._maxDistanceFound=i.orientedDistance(),this._maxDistanceFound>n){this._isValid=!1;var r=i.getCoordinates();this._errorLocation=r[1],this._errorIndicator=t.getFactory().createLineString(r),this._errMsg="Distance between buffer curve and input is too large ("+this._maxDistanceFound+" at "+Z.toLineString(r[0],r[1])+")";}},Gi.prototype.isValid=function(){var t=Math.abs(this._bufDistance),e=Gi.MAX_DISTANCE_DIFF_FRAC*t;return this._minValidDistance=t-e,this._maxValidDistance=t+e,!(!this._input.isEmpty()&&!this._result.isEmpty())||(this._bufDistance>0?this.checkPositiveValid():this.checkNegativeValid(),Gi.VERBOSE&&Y.out.println("Min Dist= "+this._minDistanceFound+"  err= "+(1-this._minDistanceFound/this._bufDistance)+"  Max Dist= "+this._maxDistanceFound+"  err= "+(this._maxDistanceFound/this._bufDistance-1)),this._isValid)},Gi.prototype.checkNegativeValid=function(){if(!(this._input instanceof $t||this._input instanceof ne||this._input instanceof zt))return null;var t=this.getPolygonLines(this._input);if(this.checkMinimumDistance(t,this._result,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(t,this._result,this._maxValidDistance);},Gi.prototype.getErrorIndicator=function(){return this._errorIndicator},Gi.prototype.checkMinimumDistance=function(t,e,n){var i=new Ti(t,e,n);if(this._minDistanceFound=i.distance(),this._minDistanceFound<n){this._isValid=!1;var r=i.nearestPoints();this._errorLocation=i.nearestPoints()[1],this._errorIndicator=t.getFactory().createLineString(r),this._errMsg="Distance between buffer curve and input is too small ("+this._minDistanceFound+" at "+Z.toLineString(r[0],r[1])+" )";}},Gi.prototype.checkPositiveValid=function(){var t=this._result.getBoundary();if(this.checkMinimumDistance(this._input,t,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(this._input,t,this._maxValidDistance);},Gi.prototype.getErrorLocation=function(){return this._errorLocation},Gi.prototype.getPolygonLines=function(t){for(var e=new Nt,n=new Ci(e),i=Ni.getPolygons(t).iterator();i.hasNext();){i.next().apply(n);}return t.getFactory().buildGeometry(e)},Gi.prototype.getErrorMessage=function(){return this._errMsg},Gi.prototype.interfaces_=function(){return []},Gi.prototype.getClass=function(){return Gi},qi.VERBOSE.get=function(){return !1},qi.MAX_DISTANCE_DIFF_FRAC.get=function(){return .012},Object.defineProperties(Gi,qi);var Bi=function(t,e,n){this._isValid=!0,this._errorMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=t||null,this._distance=e||null,this._result=n||null;},Vi={VERBOSE:{configurable:!0},MAX_ENV_DIFF_FRAC:{configurable:!0}};Bi.prototype.isValid=function(){return this.checkPolygonal(),this._isValid?(this.checkExpectedEmpty(),this._isValid?(this.checkEnvelope(),this._isValid?(this.checkArea(),this._isValid?(this.checkDistance(),this._isValid):this._isValid):this._isValid):this._isValid):this._isValid},Bi.prototype.checkEnvelope=function(){if(this._distance<0)return null;var t=this._distance*Bi.MAX_ENV_DIFF_FRAC;0===t&&(t=.001);var e=new j(this._input.getEnvelopeInternal());e.expandBy(this._distance);var n=new j(this._result.getEnvelopeInternal());n.expandBy(t),n.contains(e)||(this._isValid=!1,this._errorMsg="Buffer envelope is incorrect",this._errorIndicator=this._input.getFactory().toGeometry(n)),this.report("Envelope");},Bi.prototype.checkDistance=function(){var t=new Gi(this._input,this._distance,this._result);t.isValid()||(this._isValid=!1,this._errorMsg=t.getErrorMessage(),this._errorLocation=t.getErrorLocation(),this._errorIndicator=t.getErrorIndicator()),this.report("Distance");},Bi.prototype.checkArea=function(){var t=this._input.getArea(),e=this._result.getArea();this._distance>0&&t>e&&(this._isValid=!1,this._errorMsg="Area of positive buffer is smaller than input",this._errorIndicator=this._result),this._distance<0&&t<e&&(this._isValid=!1,this._errorMsg="Area of negative buffer is larger than input",this._errorIndicator=this._result),this.report("Area");},Bi.prototype.checkPolygonal=function(){this._result instanceof $t||this._result instanceof ne||(this._isValid=!1),this._errorMsg="Result is not polygonal",this._errorIndicator=this._result,this.report("Polygonal");},Bi.prototype.getErrorIndicator=function(){return this._errorIndicator},Bi.prototype.getErrorLocation=function(){return this._errorLocation},Bi.prototype.checkExpectedEmpty=function(){return this._input.getDimension()>=2?null:this._distance>0?null:(this._result.isEmpty()||(this._isValid=!1,this._errorMsg="Result is non-empty",this._errorIndicator=this._result),void this.report("ExpectedEmpty"))},Bi.prototype.report=function(t){if(!Bi.VERBOSE)return null;Y.out.println("Check "+t+": "+(this._isValid?"passed":"FAILED"));},Bi.prototype.getErrorMessage=function(){return this._errorMsg},Bi.prototype.interfaces_=function(){return []},Bi.prototype.getClass=function(){return Bi},Bi.isValidMsg=function(t,e,n){var i=new Bi(t,e,n);return i.isValid()?null:i.getErrorMessage()},Bi.isValid=function(t,e,n){return !!new Bi(t,e,n).isValid()},Vi.VERBOSE.get=function(){return !1},Vi.MAX_ENV_DIFF_FRAC.get=function(){return .012},Object.defineProperties(Bi,Vi);var Ui=function(){this._pts=null,this._data=null;var t=arguments[0],e=arguments[1];this._pts=t,this._data=e;};Ui.prototype.getCoordinates=function(){return this._pts},Ui.prototype.size=function(){return this._pts.length},Ui.prototype.getCoordinate=function(t){return this._pts[t]},Ui.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},Ui.prototype.getSegmentOctant=function(t){return t===this._pts.length-1?-1:pn.octant(this.getCoordinate(t),this.getCoordinate(t+1))},Ui.prototype.setData=function(t){this._data=t;},Ui.prototype.getData=function(){return this._data},Ui.prototype.toString=function(){return Z.toLineString(new ue(this._pts))},Ui.prototype.interfaces_=function(){return [hn]},Ui.prototype.getClass=function(){return Ui};var zi=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new Nt,this._intersectionCount=0,this._keepIntersections=!0;var t=arguments[0];this._li=t,this._interiorIntersection=null;};zi.prototype.getInteriorIntersection=function(){return this._interiorIntersection},zi.prototype.setCheckEndSegmentsOnly=function(t){this._isCheckEndSegmentsOnly=t;},zi.prototype.getIntersectionSegments=function(){return this._intSegments},zi.prototype.count=function(){return this._intersectionCount},zi.prototype.getIntersections=function(){return this._intersections},zi.prototype.setFindAllIntersections=function(t){this._findAllIntersections=t;},zi.prototype.setKeepIntersections=function(t){this._keepIntersections=t;},zi.prototype.processIntersections=function(t,e,n,i){if(!this._findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this._isCheckEndSegmentsOnly){if(!(this.isEndSegment(t,e)||this.isEndSegment(n,i)))return null}var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=r,this._intSegments[1]=o,this._intSegments[2]=s,this._intSegments[3]=a,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++);},zi.prototype.isEndSegment=function(t,e){return 0===e||e>=t.size()-2},zi.prototype.hasIntersection=function(){return null!==this._interiorIntersection},zi.prototype.isDone=function(){return !this._findAllIntersections&&null!==this._interiorIntersection},zi.prototype.interfaces_=function(){return [Wn]},zi.prototype.getClass=function(){return zi},zi.createAllIntersectionsFinder=function(t){var e=new zi(t);return e.setFindAllIntersections(!0),e},zi.createAnyIntersectionFinder=function(t){return new zi(t)},zi.createIntersectionCounter=function(t){var e=new zi(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e};var Xi=function(){this._li=new rt,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;var t=arguments[0];this._segStrings=t;};Xi.prototype.execute=function(){if(null!==this._segInt)return null;this.checkInteriorIntersections();},Xi.prototype.getIntersections=function(){return this._segInt.getIntersections()},Xi.prototype.isValid=function(){return this.execute(),this._isValid},Xi.prototype.setFindAllIntersections=function(t){this._findAllIntersections=t;},Xi.prototype.checkInteriorIntersections=function(){this._isValid=!0,this._segInt=new zi(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);var t=new xn;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null},Xi.prototype.checkValid=function(){if(this.execute(),!this._isValid)throw new we(this.getErrorMessage(),this._segInt.getInteriorIntersection())},Xi.prototype.getErrorMessage=function(){if(this._isValid)return "no intersections found";var t=this._segInt.getIntersectionSegments();return "found non-noded intersection between "+Z.toLineString(t[0],t[1])+" and "+Z.toLineString(t[2],t[3])},Xi.prototype.interfaces_=function(){return []},Xi.prototype.getClass=function(){return Xi},Xi.computeIntersections=function(t){var e=new Xi(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()};var Yi=function t(){this._nv=null;var e=arguments[0];this._nv=new Xi(t.toSegmentStrings(e));};Yi.prototype.checkValid=function(){this._nv.checkValid();},Yi.prototype.interfaces_=function(){return []},Yi.prototype.getClass=function(){return Yi},Yi.toSegmentStrings=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ui(i.getCoordinates(),i));}return e},Yi.checkValid=function(t){new Yi(t).checkValid();};var ki=function(t){this._mapOp=t;};ki.prototype.map=function(t){for(var e=new Nt,n=0;n<t.getNumGeometries();n++){var i=this._mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i);}return t.getFactory().createGeometryCollection(_e.toGeometryArray(e))},ki.prototype.interfaces_=function(){return []},ki.prototype.getClass=function(){return ki},ki.map=function(t,e){return new ki(e).map(t)};var ji=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new Nt,this._resultLineList=new Nt;var t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n;};ji.prototype.collectLines=function(t){for(var e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList);}},ji.prototype.labelIsolatedLine=function(t,e){var n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n);},ji.prototype.build=function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList},ji.prototype.collectLineEdge=function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!Lr.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)));},ji.prototype.findCoveredLineEdges=function(){for(var t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges();}for(var e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getEdge();if(n.isLineEdge()&&!i.isCoveredSet()){var r=this._op.isCoveredByA(n.getCoordinate());i.setCovered(r);}}},ji.prototype.labelIsolatedLines=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1));}},ji.prototype.buildLines=function(t){for(var e=this._lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=this._geometryFactory.createLineString(n.getCoordinates());this._resultLineList.add(i),n.setInResult(!0);}},ji.prototype.collectBoundaryTouchEdge=function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(et.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(Lr.isResultOfOp(i,e)&&e===Lr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},ji.prototype.interfaces_=function(){return []},ji.prototype.getClass=function(){return ji};var Hi=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new Nt;var t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e;};Hi.prototype.filterCoveredNodeToPoint=function(t){var e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){var n=this._geometryFactory.createPoint(e);this._resultPointList.add(n);}},Hi.prototype.extractNonCoveredResultNodes=function(t){for(var e=this._op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===Lr.INTERSECTION))){var i=n.getLabel();Lr.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n);}}},Hi.prototype.build=function(t){return this.extractNonCoveredResultNodes(t),this._resultPointList},Hi.prototype.interfaces_=function(){return []},Hi.prototype.getClass=function(){return Hi};var Wi=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1;};Wi.prototype.transformPoint=function(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},Wi.prototype.transformPolygon=function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof ee&&!i.isEmpty()||(n=!1);for(var r=new Nt,o=0;o<t.getNumInteriorRing();o++){var s=this.transformLinearRing(t.getInteriorRingN(o),t);null===s||s.isEmpty()||(s instanceof ee||(n=!1),r.add(s));}if(n)return this._factory.createPolygon(i,r.toArray([]));var a=new Nt;return null!==i&&a.add(i),a.addAll(r),this._factory.buildGeometry(a)},Wi.prototype.createCoordinateSequence=function(t){return this._factory.getCoordinateSequenceFactory().create(t)},Wi.prototype.getInputGeometry=function(){return this._inputGeom},Wi.prototype.transformMultiLineString=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r));}return this._factory.buildGeometry(n)},Wi.prototype.transformCoordinates=function(t,e){return this.copy(t)},Wi.prototype.transformLineString=function(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},Wi.prototype.transformMultiPoint=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r));}return this._factory.buildGeometry(n)},Wi.prototype.transformMultiPolygon=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r));}return this._factory.buildGeometry(n)},Wi.prototype.copy=function(t){return t.copy()},Wi.prototype.transformGeometryCollection=function(t,e){for(var n=new Nt,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this._pruneEmptyGeometry&&r.isEmpty()||n.add(r));}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(_e.toGeometryArray(n)):this._factory.buildGeometry(n)},Wi.prototype.transform=function(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof Qt)return this.transformPoint(t,null);if(t instanceof te)return this.transformMultiPoint(t,null);if(t instanceof ee)return this.transformLinearRing(t,null);if(t instanceof Kt)return this.transformLineString(t,null);if(t instanceof Xt)return this.transformMultiLineString(t,null);if(t instanceof $t)return this.transformPolygon(t,null);if(t instanceof ne)return this.transformMultiPolygon(t,null);if(t instanceof zt)return this.transformGeometryCollection(t,null);throw new m("Unknown Geometry subtype: "+t.getClass().getName())},Wi.prototype.transformLinearRing=function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);var i=n.size();return i>0&&i<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)},Wi.prototype.interfaces_=function(){return []},Wi.prototype.getClass=function(){return Wi};var Ki=function t(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new dn,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Kt&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];t.call(this,e.getCoordinates(),n);}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var i=arguments[0],r=arguments[1];this._srcPts=i,this._isClosed=t.isClosed(i),this._snapTolerance=r;}};Ki.prototype.snapVertices=function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;i<n;i++){var r=t.get(i),o=this.findSnapForVertex(r,e);null!==o&&(t.set(i,new C(o)),0===i&&this._isClosed&&t.set(t.size()-1,new C(o)));}},Ki.prototype.findSnapForVertex=function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null},Ki.prototype.snapTo=function(t){var e=new St(this._srcPts);this.snapVertices(e,t),this.snapSegments(e,t);return e.toCoordinateArray()},Ki.prototype.snapSegments=function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;i<n;i++){var r=e[i],o=this.findSegmentIndexToSnap(r,t);o>=0&&t.add(o+1,new C(r),!1);}},Ki.prototype.findSegmentIndexToSnap=function(t,e){for(var n=v.MAX_VALUE,i=-1,r=0;r<e.size()-1;r++){if(this._seg.p0=e.get(r),this._seg.p1=e.get(r+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return -1}var o=this._seg.distance(t);o<this._snapTolerance&&o<n&&(n=o,i=r);}return i},Ki.prototype.setAllowSnappingToSourceVertices=function(t){this._allowSnappingToSourceVertices=t;},Ki.prototype.interfaces_=function(){return []},Ki.prototype.getClass=function(){return Ki},Ki.isClosed=function(t){return !(t.length<=1)&&t[0].equals2D(t[t.length-1])};var Ji=function(t){this._srcGeom=t||null;},Qi={SNAP_PRECISION_FACTOR:{configurable:!0}};Ji.prototype.snapTo=function(t,e){var n=this.extractTargetCoordinates(t);return new Zi(e,n).transform(this._srcGeom)},Ji.prototype.snapToSelf=function(t,e){var n=this.extractTargetCoordinates(this._srcGeom),i=new Zi(t,n,!0).transform(this._srcGeom),r=i;return e&&T(r,Zt)&&(r=i.buffer(0)),r},Ji.prototype.computeSnapTolerance=function(t){return this.computeMinimumSegmentLength(t)/10},Ji.prototype.extractTargetCoordinates=function(t){for(var e=new f,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},Ji.prototype.computeMinimumSegmentLength=function(t){for(var e=v.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);i<e&&(e=i);}return e},Ji.prototype.interfaces_=function(){return []},Ji.prototype.getClass=function(){return Ji},Ji.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ji(t);i[0]=r.snapTo(e,n);var o=new Ji(e);return i[1]=o.snapTo(i[0],n),i},Ji.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ji.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===fe.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i);}return e}if(2===arguments.length){var r=arguments[0],o=arguments[1];return Math.min(Ji.computeOverlaySnapTolerance(r),Ji.computeOverlaySnapTolerance(o))}},Ji.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*Ji.SNAP_PRECISION_FACTOR},Ji.snapToSelf=function(t,e,n){return new Ji(t).snapToSelf(e,n)},Qi.SNAP_PRECISION_FACTOR.get=function(){return 1e-9},Object.defineProperties(Ji,Qi);var Zi=function(t){function e(e,n,i){t.call(this),this._snapTolerance=e||null,this._snapPts=n||null,this._isSelfSnap=void 0!==i&&i;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.snapLine=function(t,e){var n=new Ki(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)},e.prototype.transformCoordinates=function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(i)},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(Wi),$i=function(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=0,this._commonSignExp=null;};$i.prototype.getCommon=function(){return v.longBitsToDouble(this._commonBits)},$i.prototype.add=function(t){var e=v.doubleToLongBits(t);if(this._isFirst)return this._commonBits=e,this._commonSignExp=$i.signExpBits(this._commonBits),this._isFirst=!1,null;if($i.signExpBits(e)!==this._commonSignExp)return this._commonBits=0,null;this._commonMantissaBitsCount=$i.numCommonMostSigMantissaBits(this._commonBits,e),this._commonBits=$i.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount));},$i.prototype.toString=function(){if(1===arguments.length){var t=arguments[0],e=v.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+v.toBinaryString(t),i=n.substring(n.length-64);return i.substring(0,1)+"  "+i.substring(1,12)+"(exp) "+i.substring(12)+" [ "+e+" ]"}},$i.prototype.interfaces_=function(){return []},$i.prototype.getClass=function(){return $i},$i.getBit=function(t,e){return 0!=(t&1<<e)?1:0},$i.signExpBits=function(t){return t>>52},$i.zeroLowerBits=function(t,e){return t&~((1<<e)-1)},$i.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if($i.getBit(t,i)!==$i.getBit(e,i))return n;n++;}return 52};var tr=function(){this._commonCoord=null,this._ccFilter=new nr;},er={CommonCoordinateFilter:{configurable:!0},Translater:{configurable:!0}};tr.prototype.addCommonBits=function(t){var e=new ir(this._commonCoord);t.apply(e),t.geometryChanged();},tr.prototype.removeCommonBits=function(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;var e=new C(this._commonCoord);e.x=-e.x,e.y=-e.y;var n=new ir(e);return t.apply(n),t.geometryChanged(),t},tr.prototype.getCommonCoordinate=function(){return this._commonCoord},tr.prototype.add=function(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate();},tr.prototype.interfaces_=function(){return []},tr.prototype.getClass=function(){return tr},er.CommonCoordinateFilter.get=function(){return nr},er.Translater.get=function(){return ir},Object.defineProperties(tr,er);var nr=function(){this._commonBitsX=new $i,this._commonBitsY=new $i;};nr.prototype.filter=function(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y);},nr.prototype.getCommonCoordinate=function(){return new C(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())},nr.prototype.interfaces_=function(){return [ft]},nr.prototype.getClass=function(){return nr};var ir=function(){this.trans=null;var t=arguments[0];this.trans=t;};ir.prototype.filter=function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i);},ir.prototype.isDone=function(){return !1},ir.prototype.isGeometryChanged=function(){return !0},ir.prototype.interfaces_=function(){return [Ut]},ir.prototype.getClass=function(){return ir};var rr=function(t,e){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null,this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance();};rr.prototype.selfSnap=function(t){return new Ji(t).snapTo(t,this._snapTolerance)},rr.prototype.removeCommonBits=function(t){this._cbr=new tr,this._cbr.add(t[0]),this._cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e},rr.prototype.prepareResult=function(t){return this._cbr.addCommonBits(t),t},rr.prototype.getResultGeometry=function(t){var e=this.snap(this._geom),n=Lr.overlayOp(e[0],e[1],t);return this.prepareResult(n)},rr.prototype.checkValid=function(t){t.isValid()||Y.out.println("Snapped geometry is invalid");},rr.prototype.computeSnapTolerance=function(){this._snapTolerance=Ji.computeOverlaySnapTolerance(this._geom[0],this._geom[1]);},rr.prototype.snap=function(t){var e=this.removeCommonBits(t);return Ji.snap(e[0],e[1],this._snapTolerance)},rr.prototype.interfaces_=function(){return []},rr.prototype.getClass=function(){return rr},rr.overlayOp=function(t,e,n){return new rr(t,e).getResultGeometry(n)},rr.union=function(t,e){return rr.overlayOp(t,e,Lr.UNION)},rr.intersection=function(t,e){return rr.overlayOp(t,e,Lr.INTERSECTION)},rr.symDifference=function(t,e){return rr.overlayOp(t,e,Lr.SYMDIFFERENCE)},rr.difference=function(t,e){return rr.overlayOp(t,e,Lr.DIFFERENCE)};var or=function(t,e){this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e;};or.prototype.getResultGeometry=function(t){var e=null,n=!1,i=null;try{e=Lr.overlayOp(this._geom[0],this._geom[1],t);n=!0;}catch(t){if(!(t instanceof $))throw t;i=t;}if(!n)try{e=rr.overlayOp(this._geom[0],this._geom[1],t);}catch(t){throw t instanceof $?i:t}return e},or.prototype.interfaces_=function(){return []},or.prototype.getClass=function(){return or},or.overlayOp=function(t,e,n){return new or(t,e).getResultGeometry(n)},or.union=function(t,e){return or.overlayOp(t,e,Lr.UNION)},or.intersection=function(t,e){return or.overlayOp(t,e,Lr.INTERSECTION)},or.symDifference=function(t,e){return or.overlayOp(t,e,Lr.SYMDIFFERENCE)},or.difference=function(t,e){return or.overlayOp(t,e,Lr.DIFFERENCE)};var sr=function(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e;};sr.prototype.computeIntersections=function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e);},sr.prototype.interfaces_=function(){return []},sr.prototype.getClass=function(){return sr};var ar=function t(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){var e=arguments[0],n=arguments[1];this._eventType=t.DELETE,this._xValue=e,this._insertEvent=n;}else if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];this._eventType=t.INSERT,this._label=i,this._xValue=r,this._obj=o;}},ur={INSERT:{configurable:!0},DELETE:{configurable:!0}};ar.prototype.isDelete=function(){return this._eventType===ar.DELETE},ar.prototype.setDeleteEventIndex=function(t){this._deleteEventIndex=t;},ar.prototype.getObject=function(){return this._obj},ar.prototype.compareTo=function(t){var e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0},ar.prototype.getInsertEvent=function(){return this._insertEvent},ar.prototype.isInsert=function(){return this._eventType===ar.INSERT},ar.prototype.isSameLabel=function(t){return null!==this._label&&this._label===t._label},ar.prototype.getDeleteEventIndex=function(){return this._deleteEventIndex},ar.prototype.interfaces_=function(){return [E]},ar.prototype.getClass=function(){return ar},ur.INSERT.get=function(){return 1},ur.DELETE.get=function(){return 2},Object.defineProperties(ar,ur);var lr=function(){};lr.prototype.interfaces_=function(){return []},lr.prototype.getClass=function(){return lr};var cr=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n;};cr.prototype.isTrivialIntersection=function(t,e,n,i){if(t===n&&1===this._li.getIntersectionNum()){if(cr.isAdjacentSegments(e,i))return !0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return !0}}return !1},cr.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},cr.prototype.setIsDoneIfProperInt=function(t){this._isDoneWhenProperInt=t;},cr.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},cr.prototype.isBoundaryPointInternal=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next().getCoordinate();if(t.isIntersection(i))return !0}return !1},cr.prototype.hasProperIntersection=function(){return this._hasProper},cr.prototype.hasIntersection=function(){return this._hasIntersection},cr.prototype.isDone=function(){return this._isDone},cr.prototype.isBoundaryPoint=function(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))},cr.prototype.setBoundaryNodes=function(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e;},cr.prototype.addIntersections=function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],o=t.getCoordinates()[e+1],s=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this._li.computeIntersection(r,o,s,a),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,i,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))));},cr.prototype.interfaces_=function(){return []},cr.prototype.getClass=function(){return cr},cr.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)};var pr=function(t){function e(){t.call(this),this.events=new Nt,this.nOverlaps=null;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.prepareEvents=function(){$e.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t);}},e.prototype.computeIntersections=function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof cr&&T(arguments[0],xt)&&T(arguments[1],xt)){var i=arguments[0],r=arguments[1],o=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(o);}else if("boolean"==typeof arguments[2]&&T(arguments[0],xt)&&arguments[1]instanceof cr){var s=arguments[0],a=arguments[1];arguments[2]?this.addEdges(s,null):this.addEdges(s),this.computeIntersections(a);}},e.prototype.addEdge=function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var o=new sr(n,r),s=new ar(e,n.getMinX(r),o);this.events.add(s),this.events.add(new ar(n.getMaxX(r),s));}},e.prototype.processOverlaps=function(t,e,n,i){for(var r=n.getObject(),o=t;o<e;o++){var s=this.events.get(o);if(s.isInsert()){var a=s.getObject();n.isSameLabel(s)||(r.computeIntersections(a,i),this.nOverlaps++);}}},e.prototype.addEdges=function(){if(1===arguments.length)for(var t=arguments[0].iterator();t.hasNext();){var e=t.next();this.addEdge(e,e);}else if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var o=r.next();this.addEdge(o,i);}},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(lr),hr=function(){this._min=v.POSITIVE_INFINITY,this._max=v.NEGATIVE_INFINITY;},fr={NodeComparator:{configurable:!0}};hr.prototype.getMin=function(){return this._min},hr.prototype.intersects=function(t,e){return !(this._min>e||this._max<t)},hr.prototype.getMax=function(){return this._max},hr.prototype.toString=function(){return Z.toLineString(new C(this._min,0),new C(this._max,0))},hr.prototype.interfaces_=function(){return []},hr.prototype.getClass=function(){return hr},fr.NodeComparator.get=function(){return gr},Object.defineProperties(hr,fr);var gr=function(){};gr.prototype.compare=function(t,e){var n=t,i=e,r=(n._min+n._max)/2,o=(i._min+i._max)/2;return r<o?-1:r>o?1:0},gr.prototype.interfaces_=function(){return [N]},gr.prototype.getClass=function(){return gr};var dr=function(t){function e(){t.call(this),this._item=null;var e=arguments[0],n=arguments[1],i=arguments[2];this._min=e,this._max=n,this._item=i;}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.query=function(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(hr),yr=function(t){function e(){t.call(this),this._node1=null,this._node2=null;var e=arguments[0],n=arguments[1];this._node1=e,this._node2=n,this.buildExtent(this._node1,this._node2);}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.buildExtent=function(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max);},e.prototype.query=function(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n);},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(hr),_r=function(){this._leaves=new Nt,this._root=null,this._level=0;};_r.prototype.buildTree=function(){$e.sort(this._leaves,new hr.NodeComparator);for(var t=this._leaves,e=null,n=new Nt;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e;}},_r.prototype.insert=function(t,e,n){if(null!==this._root)throw new Error("Index cannot be added to once it has been queried");this._leaves.add(new dr(t,e,n));},_r.prototype.query=function(t,e,n){this.init(),this._root.query(t,e,n);},_r.prototype.buildRoot=function(){if(null!==this._root)return null;this._root=this.buildTree();},_r.prototype.printNode=function(t){Y.out.println(Z.toLineString(new C(t._min,this._level),new C(t._max,this._level)));},_r.prototype.init=function(){if(null!==this._root)return null;this.buildRoot();},_r.prototype.buildLevel=function(t,e){this._level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(i);else {var r=new yr(t.get(n),t.get(n+1));e.add(r);}}},_r.prototype.interfaces_=function(){return []},_r.prototype.getClass=function(){return _r};var mr=function(){this._items=new Nt;};mr.prototype.visitItem=function(t){this._items.add(t);},mr.prototype.getItems=function(){return this._items},mr.prototype.interfaces_=function(){return [Ke]},mr.prototype.getClass=function(){return mr};var vr=function(){this._index=null;var t=arguments[0];if(!T(t,Zt))throw new m("Argument must be Polygonal");this._index=new xr(t);},Ir={SegmentVisitor:{configurable:!0},IntervalIndexedGeometry:{configurable:!0}};vr.prototype.locate=function(t){var e=new st(t),n=new Er(e);return this._index.query(t.y,t.y,n),e.getLocation()},vr.prototype.interfaces_=function(){return [Vn]},vr.prototype.getClass=function(){return vr},Ir.SegmentVisitor.get=function(){return Er},Ir.IntervalIndexedGeometry.get=function(){return xr},Object.defineProperties(vr,Ir);var Er=function(){this._counter=null;var t=arguments[0];this._counter=t;};Er.prototype.visitItem=function(t){var e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1));},Er.prototype.interfaces_=function(){return [Ke]},Er.prototype.getClass=function(){return Er};var xr=function(){this._index=new _r;var t=arguments[0];this.init(t);};xr.prototype.init=function(t){for(var e=Ci.getLines(t).iterator();e.hasNext();){var n=e.next().getCoordinates();this.addLine(n);}},xr.prototype.addLine=function(t){for(var e=1;e<t.length;e++){var n=new dn(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this._index.insert(i,r,n);}},xr.prototype.query=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new mr;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];this._index.query(i,r,o);}},xr.prototype.interfaces_=function(){return []},xr.prototype.getClass=function(){return xr};var Nr=function(t){function e(){if(t.call(this),this._parentGeom=null,this._lineEdgeMap=new he,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new Si,2===arguments.length){var e=arguments[0],n=arguments[1],i=gt.OGC_SFS_BOUNDARY_RULE;this._argIndex=e,this._parentGeom=n,this._boundaryNodeRule=i,null!==n&&this.add(n);}else if(3===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2];this._argIndex=r,this._parentGeom=o,this._boundaryNodeRule=s,null!==o&&this.add(o);}}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.insertBoundaryPoint=function(t,n){var i=this._nodes.addNode(n).getLabel(),r=1;i.getLocation(t,Se.ON)===w.BOUNDARY&&r++;var o=e.determineBoundary(this._boundaryNodeRule,r);i.setLocation(t,o);},e.prototype.computeSelfNodes=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],o=new cr(n,!0,!1);o.setIsDoneIfProperInt(r);var s=this.createEdgeSetIntersector(),a=this._parentGeom instanceof ee||this._parentGeom instanceof $t||this._parentGeom instanceof ne,u=i||!a;return s.computeIntersections(this._edges,o,u),this.addSelfIntersectionNodes(this._argIndex),o}},e.prototype.computeSplitEdges=function(t){for(var e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t);}},e.prototype.computeEdgeIntersections=function(t,e,n){var i=new cr(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());return this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,i),i},e.prototype.getGeometry=function(){return this._parentGeom},e.prototype.getBoundaryNodeRule=function(){return this._boundaryNodeRule},e.prototype.hasTooFewPoints=function(){return this._hasTooFewPoints},e.prototype.addPoint=function(){if(arguments[0]instanceof Qt){var t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,w.INTERIOR);}else if(arguments[0]instanceof C){var e=arguments[0];this.insertPoint(this._argIndex,e,w.INTERIOR);}},e.prototype.addPolygon=function(t){this.addPolygonRing(t.getExteriorRing(),w.EXTERIOR,w.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,w.INTERIOR,w.EXTERIOR);}},e.prototype.addEdge=function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],w.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],w.BOUNDARY);},e.prototype.addLineString=function(t){var e=Lt.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;var n=new ni(e,new Pe(this._argIndex,w.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),et.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1]);},e.prototype.getInvalidPoint=function(){return this._invalidPoint},e.prototype.getBoundaryPoints=function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy();}return e},e.prototype.getBoundaryNodes=function(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes},e.prototype.addSelfIntersectionNode=function(t,e,n){if(this.isBoundaryNode(t,e))return null;n===w.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n);},e.prototype.addPolygonRing=function(t,e,n){if(t.isEmpty())return null;var i=Lt.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=i[0],null;var r=e,o=n;at.isCCW(i)&&(r=n,o=e);var s=new ni(i,new Pe(this._argIndex,w.BOUNDARY,r,o));this._lineEdgeMap.put(t,s),this.insertEdge(s),this.insertPoint(this._argIndex,i[0],w.BOUNDARY);},e.prototype.insertPoint=function(t,e,n){var i=this._nodes.addNode(e),r=i.getLabel();null===r?i._label=new Pe(t,n):r.setLocation(t,n);},e.prototype.createEdgeSetIntersector=function(){return new pr},e.prototype.addSelfIntersectionNodes=function(t){for(var e=this._edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var o=r.next();this.addSelfIntersectionNode(t,o.coord,i);}},e.prototype.add=function(){if(1!==arguments.length)return t.prototype.add.apply(this,arguments);var e=arguments[0];if(e.isEmpty())return null;if(e instanceof ne&&(this._useBoundaryDeterminationRule=!1),e instanceof $t)this.addPolygon(e);else if(e instanceof Kt)this.addLineString(e);else if(e instanceof Qt)this.addPoint(e);else if(e instanceof te)this.addCollection(e);else if(e instanceof Xt)this.addCollection(e);else if(e instanceof ne)this.addCollection(e);else {if(!(e instanceof zt))throw new Error(e.getClass().getName());this.addCollection(e);}},e.prototype.addCollection=function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n);}},e.prototype.locate=function(t){return T(this._parentGeom,Zt)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new vr(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)},e.prototype.findEdge=function(){if(1===arguments.length){var e=arguments[0];return this._lineEdgeMap.get(e)}return t.prototype.findEdge.apply(this,arguments)},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e.determineBoundary=function(t,e){return t.isInBoundary(e)?w.BOUNDARY:w.INTERIOR},e}(Ye),Cr=function(){if(this._li=new rt,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Nr(0,t);}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=gt.OGC_SFS_BOUNDARY_RULE;e.getPrecisionModel().compareTo(n.getPrecisionModel())>=0?this.setComputationPrecision(e.getPrecisionModel()):this.setComputationPrecision(n.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Nr(0,e,i),this._arg[1]=new Nr(1,n,i);}else if(3===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2];r.getPrecisionModel().compareTo(o.getPrecisionModel())>=0?this.setComputationPrecision(r.getPrecisionModel()):this.setComputationPrecision(o.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Nr(0,r,s),this._arg[1]=new Nr(1,o,s);}};Cr.prototype.getArgGeometry=function(t){return this._arg[t].getGeometry()},Cr.prototype.setComputationPrecision=function(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel);},Cr.prototype.interfaces_=function(){return []},Cr.prototype.getClass=function(){return Cr};var Sr=function(){};Sr.prototype.interfaces_=function(){return []},Sr.prototype.getClass=function(){return Sr},Sr.map=function(){if(arguments[0]instanceof ct&&T(arguments[1],Sr.MapOp)){for(var t=arguments[0],e=arguments[1],n=new Nt,i=0;i<t.getNumGeometries();i++){var r=e.map(t.getGeometryN(i));null!==r&&n.add(r);}return t.getFactory().buildGeometry(n)}if(T(arguments[0],It)&&T(arguments[1],Sr.MapOp)){for(var o=arguments[0],s=arguments[1],a=new Nt,u=o.iterator();u.hasNext();){var l=u.next(),c=s.map(l);null!==c&&a.add(c);}return a}},Sr.MapOp=function(){};var Lr=function(t){function e(){var e=arguments[0],n=arguments[1];t.call(this,e,n),this._ptLocator=new Si,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new Hn,this._resultPolyList=new Nt,this._resultLineList=new Nt,this._resultPointList=new Nt,this._graph=new Ye(new kn),this._geomFact=e.getFactory();}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.insertUniqueEdge=function(t){var e=this._edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new Pe(t.getLabel())).flip();var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i);}else this._edgeList.add(t);},e.prototype.getGraph=function(){return this._graph},e.prototype.cancelDuplicateResultEdges=function(){for(var t=this._graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1));}},e.prototype.isCoveredByLA=function(t){return !!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)},e.prototype.computeGeometry=function(t,n,i,r){var o=new Nt;return o.addAll(t),o.addAll(n),o.addAll(i),o.isEmpty()?e.createEmptyResult(r,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(o)},e.prototype.mergeSymLabels=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels();}},e.prototype.isCovered=function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(this._ptLocator.locate(t,i)!==w.EXTERIOR)return !0}return !1},e.prototype.replaceCollapsedEdges=function(){for(var t=new Nt,e=this._edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()));}this._edgeList.addAll(t);},e.prototype.updateNodeLabelling=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n);}},e.prototype.getResultGeometry=function(t){return this.computeOverlay(t),this._resultGeom},e.prototype.insertUniqueEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n);}},e.prototype.computeOverlay=function(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);var e=new Nt;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),Yi.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new ke(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();var i=new ji(this,this._geomFact,this._ptLocator);this._resultLineList=i.build(t);var r=new Hi(this,this._geomFact,this._ptLocator);this._resultPointList=r.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t);},e.prototype.labelIncompleteNode=function(t,e){var n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n);},e.prototype.copyPoints=function(t){for(var e=this._arg[t].getNodeIterator();e.hasNext();){var n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t));}},e.prototype.findResultAreaEdges=function(t){for(var n=this._graph.getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea()&&!i.isInteriorAreaEdge()&&e.isResultOfOp(r.getLocation(0,Se.RIGHT),r.getLocation(1,Se.RIGHT),t)&&i.setInResult(!0);}},e.prototype.computeLabelsFromDepths=function(){for(var t=this._edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;r<2;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(et.isTrue(!i.isNull(r,Se.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,Se.LEFT,i.getLocation(r,Se.LEFT)),et.isTrue(!i.isNull(r,Se.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,Se.RIGHT,i.getLocation(r,Se.RIGHT))));}}},e.prototype.computeLabelling=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg);}this.mergeSymLabels(),this.updateNodeLabelling();},e.prototype.labelIncompleteNodes=function(){for(var t=this._graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n);}},e.prototype.isCoveredByA=function(t){return !!this.isCovered(t,this._resultPolyList)},e.prototype.interfaces_=function(){return []},e.prototype.getClass=function(){return e},e}(Cr);Lr.overlayOp=function(t,e,n){return new Lr(t,e).getResultGeometry(n)},Lr.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return Lr.createEmptyResult(Lr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return ki.map(t,{interfaces_:function(){return [Sr.MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.INTERSECTION)},Lr.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Lr.createEmptyResult(Lr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.SYMDIFFERENCE)},Lr.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),o=-1;switch(t){case Lr.INTERSECTION:o=Math.min(i,r);break;case Lr.UNION:o=Math.max(i,r);break;case Lr.DIFFERENCE:o=i;break;case Lr.SYMDIFFERENCE:o=Math.max(i,r);}return o},Lr.createEmptyResult=function(t,e,n,i){var r=null;switch(Lr.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon();}return r},Lr.difference=function(t,e){return t.isEmpty()?Lr.createEmptyResult(Lr.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.DIFFERENCE))},Lr.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return Lr.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],o=arguments[1],s=arguments[2];switch(r===w.BOUNDARY&&(r=w.INTERIOR),o===w.BOUNDARY&&(o=w.INTERIOR),s){case Lr.INTERSECTION:return r===w.INTERIOR&&o===w.INTERIOR;case Lr.UNION:return r===w.INTERIOR||o===w.INTERIOR;case Lr.DIFFERENCE:return r===w.INTERIOR&&o!==w.INTERIOR;case Lr.SYMDIFFERENCE:return r===w.INTERIOR&&o!==w.INTERIOR||r!==w.INTERIOR&&o===w.INTERIOR}return !1}},Lr.INTERSECTION=1,Lr.UNION=2,Lr.DIFFERENCE=3,Lr.SYMDIFFERENCE=4;var br=function(){this._g=null,this._boundaryDistanceTolerance=null,this._linework=null,this._ptLocator=new Si,this._seg=new dn;var t=arguments[0],e=arguments[1];this._g=t,this._boundaryDistanceTolerance=e,this._linework=this.extractLinework(t);};br.prototype.isWithinToleranceOfBoundary=function(t){for(var e=0;e<this._linework.getNumGeometries();e++)for(var n=this._linework.getGeometryN(e).getCoordinateSequence(),i=0;i<n.size()-1;i++){n.getCoordinate(i,this._seg.p0),n.getCoordinate(i+1,this._seg.p1);if(this._seg.distance(t)<=this._boundaryDistanceTolerance)return !0}return !1},br.prototype.getLocation=function(t){return this.isWithinToleranceOfBoundary(t)?w.BOUNDARY:this._ptLocator.locate(t,this._g)},br.prototype.extractLinework=function(t){var e=new wr;t.apply(e);var n=e.getLinework(),i=_e.toLineStringArray(n);return t.getFactory().createMultiLineString(i)},br.prototype.interfaces_=function(){return []},br.prototype.getClass=function(){return br};var wr=function(){this._linework=null,this._linework=new Nt;};wr.prototype.getLinework=function(){return this._linework},wr.prototype.filter=function(t){if(t instanceof $t){var e=t;this._linework.add(e.getExteriorRing());for(var n=0;n<e.getNumInteriorRing();n++)this._linework.add(e.getInteriorRingN(n));}},wr.prototype.interfaces_=function(){return [Vt]},wr.prototype.getClass=function(){return wr};var Or=function(){this._g=null,this._doLeft=!0,this._doRight=!0;var t=arguments[0];this._g=t;};Or.prototype.extractPoints=function(t,e,n){for(var i=t.getCoordinates(),r=0;r<i.length-1;r++)this.computeOffsetPoints(i[r],i[r+1],e,n);},Or.prototype.setSidesToGenerate=function(t,e){this._doLeft=t,this._doRight=e;},Or.prototype.getPoints=function(t){for(var e=new Nt,n=Ci.getLines(this._g).iterator();n.hasNext();){var i=n.next();this.extractPoints(i,t,e);}return e},Or.prototype.computeOffsetPoints=function(t,e,n,i){var r=e.x-t.x,o=e.y-t.y,s=Math.sqrt(r*r+o*o),a=n*r/s,u=n*o/s,l=(e.x+t.x)/2,c=(e.y+t.y)/2;if(this._doLeft){var p=new C(l-u,c+a);i.add(p);}if(this._doRight){var h=new C(l+u,c-a);i.add(h);}},Or.prototype.interfaces_=function(){return []},Or.prototype.getClass=function(){return Or};var Tr=function t(){this._geom=null,this._locFinder=null,this._location=new Array(3).fill(null),this._invalidLocation=null,this._boundaryDistanceTolerance=t.TOLERANCE,this._testCoords=new Nt;var e=arguments[0],n=arguments[1],i=arguments[2];this._boundaryDistanceTolerance=t.computeBoundaryDistanceTolerance(e,n),this._geom=[e,n,i],this._locFinder=[new br(this._geom[0],this._boundaryDistanceTolerance),new br(this._geom[1],this._boundaryDistanceTolerance),new br(this._geom[2],this._boundaryDistanceTolerance)];},Rr={TOLERANCE:{configurable:!0}};Tr.prototype.reportResult=function(t,e,n){Y.out.println("Overlay result invalid - A:"+w.toLocationSymbol(e[0])+" B:"+w.toLocationSymbol(e[1])+" expected:"+(n?"i":"e")+" actual:"+w.toLocationSymbol(e[2]));},Tr.prototype.isValid=function(t){this.addTestPts(this._geom[0]),this.addTestPts(this._geom[1]);var e=this.checkValid(t);return e},Tr.prototype.checkValid=function(){if(1===arguments.length){for(var t=arguments[0],e=0;e<this._testCoords.size();e++){var n=this._testCoords.get(e);if(!this.checkValid(t,n))return this._invalidLocation=n,!1}return !0}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this._location[0]=this._locFinder[0].getLocation(r),this._location[1]=this._locFinder[1].getLocation(r),this._location[2]=this._locFinder[2].getLocation(r),!!Tr.hasLocation(this._location,w.BOUNDARY)||this.isValidResult(i,this._location)}},Tr.prototype.addTestPts=function(t){var e=new Or(t);this._testCoords.addAll(e.getPoints(5*this._boundaryDistanceTolerance));},Tr.prototype.isValidResult=function(t,e){var n=Lr.isResultOfOp(e[0],e[1],t),i=!(n^e[2]===w.INTERIOR);return i||this.reportResult(t,e,n),i},Tr.prototype.getInvalidLocation=function(){return this._invalidLocation},Tr.prototype.interfaces_=function(){return []},Tr.prototype.getClass=function(){return Tr},Tr.hasLocation=function(t,e){for(var n=0;n<3;n++)if(t[n]===e)return !0;return !1},Tr.computeBoundaryDistanceTolerance=function(t,e){return Math.min(Ji.computeSizeBasedSnapTolerance(t),Ji.computeSizeBasedSnapTolerance(e))},Tr.isValid=function(t,e,n,i){return new Tr(t,e,i).isValid(n)},Rr.TOLERANCE.get=function(){return 1e-6},Object.defineProperties(Tr,Rr);var Pr=function t(e){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null,this._geomFactory=t.extractFactory(e),this._inputGeoms=e;};Pr.prototype.extractElements=function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this._skipEmpty&&i.isEmpty()||e.add(i);}},Pr.prototype.combine=function(){for(var t=new Nt,e=this._inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t);}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection(null):null:this._geomFactory.buildGeometry(t)},Pr.prototype.interfaces_=function(){return []},Pr.prototype.getClass=function(){return Pr},Pr.combine=function(){if(1===arguments.length){var t=arguments[0];return new Pr(t).combine()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return new Pr(Pr.createList(e,n)).combine()}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2];return new Pr(Pr.createList(i,r,o)).combine()}},Pr.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},Pr.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Nt;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],o=arguments[2],s=new Nt;return s.add(i),s.add(r),s.add(o),s}};var Dr=function(){this._inputPolys=null,this._geomFactory=null;var t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new Nt);},Mr={STRTREE_NODE_CAPACITY:{configurable:!0}};Dr.prototype.reduceToGeometries=function(t){for(var e=new Nt,n=t.iterator();n.hasNext();){var i=n.next(),r=null;T(i,xt)?r=this.unionTree(i):i instanceof ct&&(r=i),e.add(r);}return e},Dr.prototype.extractByEnvelope=function(t,e,n){for(var i=new Nt,r=0;r<e.getNumGeometries();r++){var o=e.getGeometryN(r);o.getEnvelopeInternal().intersects(t)?i.add(o):n.add(o);}return this._geomFactory.buildGeometry(i)},Dr.prototype.unionOptimized=function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){return Pr.combine(t,e)}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var r=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,r)},Dr.prototype.union=function(){if(null===this._inputPolys)throw new Error("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();for(var t=new sn(Dr.STRTREE_NODE_CAPACITY),e=this._inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n);}this._inputPolys=null;var i=t.itemsTree();return this.unionTree(i)},Dr.prototype.binaryUnion=function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(i-n<=1){var r=Dr.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n==2)return this.unionSafe(Dr.getGeometry(e,n),Dr.getGeometry(e,n+1));var o=Math.trunc((i+n)/2),s=this.binaryUnion(e,n,o),a=this.binaryUnion(e,o,i);return this.unionSafe(s,a)}},Dr.prototype.repeatedUnion=function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i);}return e},Dr.prototype.unionSafe=function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},Dr.prototype.unionActual=function(t,e){return Dr.restrictToPolygons(t.union(e))},Dr.prototype.unionTree=function(t){var e=this.reduceToGeometries(t);return this.binaryUnion(e)},Dr.prototype.unionUsingEnvelopeIntersection=function(t,e,n){var i=new Nt,r=this.extractByEnvelope(n,t,i),o=this.extractByEnvelope(n,e,i),s=this.unionActual(r,o);i.add(s);return Pr.combine(i)},Dr.prototype.bufferUnion=function(){if(1===arguments.length){var t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().createGeometryCollection([e,n]).buffer(0)}},Dr.prototype.interfaces_=function(){return []},Dr.prototype.getClass=function(){return Dr},Dr.restrictToPolygons=function(t){if(T(t,Zt))return t;var e=Ni.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(_e.toPolygonArray(e))},Dr.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},Dr.union=function(t){return new Dr(t).union()},Mr.STRTREE_NODE_CAPACITY.get=function(){return 4},Object.defineProperties(Dr,Mr);var Ar=function(){};Ar.prototype.interfaces_=function(){return []},Ar.prototype.getClass=function(){return Ar},Ar.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return Lr.createEmptyResult(Lr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),or.overlayOp(t,e,Lr.UNION)},t.GeoJSONReader=Ne,t.GeoJSONWriter=Ce,t.OverlayOp=Lr,t.UnionOp=Ar,t.BufferOp=di,Object.defineProperty(t,"__esModule",{value:!0});});
    });

    // Adds floating point numbers with twice the normal precision.
    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
    // 305–363 (1997).
    // Code adapted from GeographicLib by Charles F. F. Karney,
    // http://geographiclib.sourceforge.net/

    function adder() {
      return new Adder;
    }

    function Adder() {
      this.reset();
    }

    Adder.prototype = {
      constructor: Adder,
      reset: function() {
        this.s = // rounded value
        this.t = 0; // exact error
      },
      add: function(y) {
        add(temp, y, this.t);
        add(this, temp.s, this.s);
        if (this.s) this.t += temp.t;
        else this.s = temp.t;
      },
      valueOf: function() {
        return this.s;
      }
    };

    var temp = new Adder;

    function add(adder, a, b) {
      var x = adder.s = a + b,
          bv = x - a,
          av = x - bv;
      adder.t = (a - av) + (b - bv);
    }

    var epsilon = 1e-6;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var quarterPi = pi / 4;
    var tau = pi * 2;

    var degrees = 180 / pi;
    var radians = pi / 180;

    var abs = Math.abs;
    var atan = Math.atan;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var sin = Math.sin;
    var sqrt = Math.sqrt;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
    }

    function noop() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    adder();

    adder();

    function spherical(cartesian) {
      return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
      return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    adder();

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos(deltaPhi),
          sinDeltaPhi = sin(deltaPhi),
          cosDeltaGamma = cos(deltaGamma),
          sinDeltaGamma = sin(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos(phi),
            x = cos(lambda) * cosPhi,
            y = sin(lambda) * cosPhi,
            z = sin(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos(phi),
            x = cos(lambda) * cosPhi,
            y = sin(lambda) * cosPhi,
            z = sin(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos(radius),
          sinRadius = sin(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y) {
          line.push([x, y]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    function pointEqual(a, b) {
      return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipPolygon(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        // If the first and last points of a segment are coincident, then treat as a
        // closed ring. TODO if all rings are closed, then the winding order of the
        // exterior ring should be checked.
        if (pointEqual(p0, p1)) {
          stream.lineStart();
          for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
          stream.lineEnd();
          return;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link(subject);
      link(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function(d, x) {
        return ascending(f(d), x);
      };
    }

    bisector(ascending);

    function merge$1(arrays) {
      var n = arrays.length,
          m,
          i = -1,
          j = 0,
          merged,
          array;

      while (++i < n) j += arrays[i].length;
      merged = new Array(j);

      while (--n >= 0) {
        array = arrays[n];
        m = array.length;
        while (--m >= 0) {
          merged[--j] = array[m];
        }
      }

      return merged;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipExtent(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
            : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
            : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge$1(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    var sum = adder();

    function polygonContains(polygon, point) {
      var lambda = point[0],
          phi = point[1],
          normal = [sin(lambda), -cos(lambda), 0],
          angle = 0,
          winding = 0;

      sum.reset();

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = point0[0],
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin(phi0),
            cosPhi0 = cos(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = point1[0],
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin(phi1),
              cosPhi1 = cos(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
          angle += antimeridian ? delta + sign * tau : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
    }

    adder();

    function identity(x) {
      return x;
    }

    adder();
        adder();

    var x0 = Infinity,
        y0 = x0,
        x1 = -x0,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: noop,
      polygonEnd: noop,
      result: function() {
        var bounds = [[x0, y0], [x1, y1]];
        x1 = y1 = -(y0 = x0 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    adder();

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(rotate, sink) {
        var line = clipLine(sink),
            rotatedStart = rotate.invert(start[0], start[1]),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge$1(segments);
            var startInside = polygonContains(polygon, rotatedStart);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          var point = rotate(lambda, phi);
          if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          var point = rotate(lambda, phi);
          line.point(point[0], point[1]);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          var point = rotate(lambda, phi);
          ringSink.point(point[0], point[1]);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi, -halfPi]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi : -pi,
              delta = abs(lambda1 - lambda0);
          if (abs(delta - pi) < epsilon) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
            if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
            if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin(lambda0 - lambda1);
      return abs(sinLambda0Lambda1) > epsilon
          ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
              - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi;
        stream.point(-pi, phi);
        stream.point(0, phi);
        stream.point(pi, phi);
        stream.point(pi, 0);
        stream.point(pi, -phi);
        stream.point(0, -phi);
        stream.point(-pi, -phi);
        stream.point(-pi, 0);
        stream.point(-pi, phi);
      } else if (abs(from[0] - to[0]) > epsilon) {
        var lambda = from[0] < to[0] ? pi : -pi;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius, delta) {
      var cr = cos(radius),
          smallRadius = cr > 0,
          notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos(lambda) * cos(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            // Handle degeneracies.
            // TODO ignore if not clipping polygons.
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
                point1[0] += epsilon;
                point1[1] += epsilon;
                v = visible(point1[0], point1[1]);
              }
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1]);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs(delta - pi) < epsilon,
            meridian = polar || delta < epsilon;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
    }

    function transformer(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fitExtent(projection, extent, object) {
      var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          clip = projection.clipExtent && projection.clipExtent();

      projection
          .scale(150)
          .translate([0, 0]);

      if (clip != null) projection.clipExtent(null);

      geoStream(object, projection.stream(boundsStream));

      var b = boundsStream.result(),
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

      if (clip != null) projection.clipExtent(clip);

      return projection
          .scale(k * 150)
          .translate([x, y]);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt(a * a + b * b + c * c),
              phi2 = asin(c /= m),
              lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          dx, dy, lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
          theta = null, preclip = clipAntimeridian, // clip angle
          x0 = null, y0, x1, y1, postclip = identity, // clip extent
          delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
          cache,
          cacheStream;

      function projection(point) {
        point = projectRotate(point[0] * radians, point[1] * radians);
        return [point[0] * k + dx, dy - point[1] * k];
      }

      function invert(point) {
        point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      function projectTransform(x, y) {
        return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      function recenter() {
        projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
        var center = project(lambda, phi);
        dx = x - center[0] * k;
        dy = y + center[1] * k;
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos(x),
            cy = cos(y),
            k = scale(cx * cy);
        return [
          k * cy * sin(x),
          k * sin(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt(x * x + y * y),
            c = angle(z),
            sc = sin(c),
            cc = cos(c);
        return [
          atan2(x * sc, z * cc),
          asin(z && y * sc / z)
        ];
      }
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos(c)) && c / sin(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function geoAzimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    /**
     * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
     *
     * When using a negative radius, the resulting geometry may be invalid if
     * it's too small compared to the radius magnitude. If the input is a
     * FeatureCollection, only valid members will be returned in the output
     * FeatureCollection - i.e., the output collection may have fewer members than
     * the input, or even be empty.
     *
     * @name buffer
     * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered
     * @param {number} radius distance to draw the buffer (negative values are allowed)
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units="kilometers"] any of the options supported by turf units
     * @param {number} [options.steps=8] number of steps
     * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features
     * @example
     * var point = turf.point([-90.548630, 14.616599]);
     * var buffered = turf.buffer(point, 500, {units: 'miles'});
     *
     * //addToMap
     * var addToMap = [point, buffered]
     */
    function buffer(geojson, radius, options) {
      // Optional params
      options = options || {};

      // use user supplied options or default values
      var units = options.units || "kilometers";
      var steps = options.steps || 8;

      // validation
      if (!geojson) throw new Error("geojson is required");
      if (typeof options !== "object") throw new Error("options must be an object");
      if (typeof steps !== "number") throw new Error("steps must be an number");

      // Allow negative buffers ("erosion") or zero-sized buffers ("repair geometry")
      if (radius === undefined) throw new Error("radius is required");
      if (steps <= 0) throw new Error("steps must be greater than 0");

      var results = [];
      switch (geojson.type) {
        case "GeometryCollection":
          geomEach$1(geojson, function (geometry) {
            var buffered = bufferFeature(geometry, radius, units, steps);
            if (buffered) results.push(buffered);
          });
          return featureCollection$1(results);
        case "FeatureCollection":
          featureEach$2(geojson, function (feature) {
            var multiBuffered = bufferFeature(feature, radius, units, steps);
            if (multiBuffered) {
              featureEach$2(multiBuffered, function (buffered) {
                if (buffered) results.push(buffered);
              });
            }
          });
          return featureCollection$1(results);
      }
      return bufferFeature(geojson, radius, units, steps);
    }

    /**
     * Buffer single Feature/Geometry
     *
     * @private
     * @param {Feature<any>} geojson input to be buffered
     * @param {number} radius distance to draw the buffer
     * @param {string} [units='kilometers'] any of the options supported by turf units
     * @param {number} [steps=8] number of steps
     * @returns {Feature<Polygon|MultiPolygon>} buffered feature
     */
    function bufferFeature(geojson, radius, units, steps) {
      var properties = geojson.properties || {};
      var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;

      // Geometry Types faster than jsts
      if (geometry.type === "GeometryCollection") {
        var results = [];
        geomEach$1(geojson, function (geometry) {
          var buffered = bufferFeature(geometry, radius, units, steps);
          if (buffered) results.push(buffered);
        });
        return featureCollection$1(results);
      }

      // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)
      var projection = defineProjection(geometry);
      var projected = {
        type: geometry.type,
        coordinates: projectCoords(geometry.coordinates, projection),
      };

      // JSTS buffer operation
      var reader = new jsts_min.GeoJSONReader();
      var geom = reader.read(projected);
      var distance = radiansToLength(lengthToRadians(radius, units), "meters");
      var buffered = jsts_min.BufferOp.bufferOp(geom, distance, steps);
      var writer = new jsts_min.GeoJSONWriter();
      buffered = writer.write(buffered);

      // Detect if empty geometries
      if (coordsIsNaN(buffered.coordinates)) return undefined;

      // Unproject coordinates (convert to Degrees)
      var result = {
        type: buffered.type,
        coordinates: unprojectCoords(buffered.coordinates, projection),
      };

      return feature(result, properties);
    }

    /**
     * Coordinates isNaN
     *
     * @private
     * @param {Array<any>} coords GeoJSON Coordinates
     * @returns {boolean} if NaN exists
     */
    function coordsIsNaN(coords) {
      if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
      return isNaN(coords[0]);
    }

    /**
     * Project coordinates to projection
     *
     * @private
     * @param {Array<any>} coords to project
     * @param {GeoProjection} proj D3 Geo Projection
     * @returns {Array<any>} projected coordinates
     */
    function projectCoords(coords, proj) {
      if (typeof coords[0] !== "object") return proj(coords);
      return coords.map(function (coord) {
        return projectCoords(coord, proj);
      });
    }

    /**
     * Un-Project coordinates to projection
     *
     * @private
     * @param {Array<any>} coords to un-project
     * @param {GeoProjection} proj D3 Geo Projection
     * @returns {Array<any>} un-projected coordinates
     */
    function unprojectCoords(coords, proj) {
      if (typeof coords[0] !== "object") return proj.invert(coords);
      return coords.map(function (coord) {
        return unprojectCoords(coord, proj);
      });
    }

    /**
     * Define Azimuthal Equidistant projection
     *
     * @private
     * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON
     * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection
     */
    function defineProjection(geojson) {
      var coords = center(geojson).geometry.coordinates;
      var rotation = [-coords[0], -coords[1]];
      return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);
    }

    /**
     * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
     *
     * @name union
     * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature
     * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1
     * @param {Object} [options={}] Optional Parameters
     * @param {Object} [options.properties={}] Translate Properties to output Feature
     * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature, or null if the inputs are empty
     * @example
     * var poly1 = turf.polygon([[
     *     [-82.574787, 35.594087],
     *     [-82.574787, 35.615581],
     *     [-82.545261, 35.615581],
     *     [-82.545261, 35.594087],
     *     [-82.574787, 35.594087]
     * ]], {"fill": "#0f0"});
     * var poly2 = turf.polygon([[
     *     [-82.560024, 35.585153],
     *     [-82.560024, 35.602602],
     *     [-82.52964, 35.602602],
     *     [-82.52964, 35.585153],
     *     [-82.560024, 35.585153]
     * ]], {"fill": "#00f"});
     *
     * var union = turf.union(poly1, poly2);
     *
     * //addToMap
     * var addToMap = [poly1, poly2, union];
     */
    function union(poly1, poly2, options) {
        if (options === void 0) { options = {}; }
        var geom1 = getGeom(poly1);
        var geom2 = getGeom(poly2);
        var unioned = polygonClipping.union(geom1.coordinates, geom2.coordinates);
        if (unioned.length === 0)
            return null;
        if (unioned.length === 1)
            return polygon(unioned[0], options.properties);
        else
            return multiPolygon(unioned, options.properties);
    }

    /**
     * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and
     * finds their polygonal intersection. If they don't intersect, returns null.
     *
     * @name intersect
     * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon
     * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon
     * @param {Object} [options={}] Optional Parameters
     * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature
     * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or
     * {@link MultiPolygon}). If they do not share any area, returns `null`.
     * @example
     * var poly1 = turf.polygon([[
     *   [-122.801742, 45.48565],
     *   [-122.801742, 45.60491],
     *   [-122.584762, 45.60491],
     *   [-122.584762, 45.48565],
     *   [-122.801742, 45.48565]
     * ]]);
     *
     * var poly2 = turf.polygon([[
     *   [-122.520217, 45.535693],
     *   [-122.64038, 45.553967],
     *   [-122.720031, 45.526554],
     *   [-122.669906, 45.507309],
     *   [-122.723464, 45.446643],
     *   [-122.532577, 45.408574],
     *   [-122.487258, 45.477466],
     *   [-122.520217, 45.535693]
     * ]]);
     *
     * var intersection = turf.intersect(poly1, poly2);
     *
     * //addToMap
     * var addToMap = [poly1, poly2, intersection];
     */
    function intersect(poly1, poly2, options) {
        if (options === void 0) { options = {}; }
        var geom1 = getGeom(poly1);
        var geom2 = getGeom(poly2);
        var intersection = polygonClipping.intersection(geom1.coordinates, geom2.coordinates);
        if (intersection.length === 0)
            return null;
        if (intersection.length === 1)
            return polygon(intersection[0], options.properties);
        return multiPolygon(intersection, options.properties);
    }

    /**
     * Dissolves a FeatureCollection of {@link polygon} features, filtered by an optional property name:value.
     * Note that {@link mulitpolygon} features within the collection are not supported
     *
     * @name dissolve
     * @param {FeatureCollection<Polygon>} featureCollection input feature collection to be dissolved
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.propertyName] features with the same `propertyName` value will be dissolved.
     * @returns {FeatureCollection<Polygon>} a FeatureCollection containing the dissolved polygons
     * @example
     * var features = turf.featureCollection([
     *   turf.polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]], {combine: 'yes'}),
     *   turf.polygon([[[0, -1], [0, 0], [1, 0], [1, -1], [0,-1]]], {combine: 'yes'}),
     *   turf.polygon([[[1,-1],[1, 0], [2, 0], [2, -1], [1, -1]]], {combine: 'no'}),
     * ]);
     *
     * var dissolved = turf.dissolve(features, {propertyName: 'combine'});
     *
     * //addToMap
     * var addToMap = [features, dissolved]
     */
    function dissolve(fc, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error("options is invalid");
      var propertyName = options.propertyName;

      // Input validation
      collectionOf(fc, "Polygon", "dissolve");

      // Main
      var outFeatures = [];
      if (!options.propertyName) {
        return flatten(
          multiPolygon(
            polygonClipping.union.apply(
              null,
              fc.features.map(function (f) {
                return f.geometry.coordinates;
              })
            )
          )
        );
      } else {
        var uniquePropertyVals = {};
        featureEach$2(fc, function (feature) {
          if (
            !Object.prototype.hasOwnProperty.call(
              uniquePropertyVals,
              feature.properties[propertyName]
            )
          ) {
            uniquePropertyVals[feature.properties[propertyName]] = [];
          }
          uniquePropertyVals[feature.properties[propertyName]].push(feature);
        });
        var vals = Object.keys(uniquePropertyVals);
        for (var i = 0; i < vals.length; i++) {
          var mp = multiPolygon(
            polygonClipping.union.apply(
              null,
              uniquePropertyVals[vals[i]].map(function (f) {
                return f.geometry.coordinates;
              })
            )
          );
          mp.properties[propertyName] = vals[i];
          outFeatures.push(mp);
        }
      }

      return flatten(featureCollection$1(outFeatures));
    }

    /**
     * Takes a bounding box and the diameter of the cell and returns a {@link FeatureCollection} of flat-topped
     * hexagons or triangles ({@link Polygon} features) aligned in an "odd-q" vertical grid as
     * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).
     *
     * @name hexGrid
     * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
     * @param {number} cellSide length of the side of the the hexagons or triangles, in units. It will also coincide with the
     * radius of the circumcircle of the hexagons.
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] used in calculating cell size, can be degrees, radians, miles, or kilometers
     * @param {Object} [options.properties={}] passed to each hexagon or triangle of the grid
     * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
     * @param {boolean} [options.triangles=false] whether to return as triangles instead of hexagons
     * @returns {FeatureCollection<Polygon>} a hexagonal grid
     * @example
     * var bbox = [-96,31,-84,40];
     * var cellSide = 50;
     * var options = {units: 'miles'};
     *
     * var hexgrid = turf.hexGrid(bbox, cellSide, options);
     *
     * //addToMap
     * var addToMap = [hexgrid];
     */
    function hexGrid(bbox, cellSide, options) {
        if (options === void 0) { options = {}; }
        // Issue => https://github.com/Turfjs/turf/issues/1284
        var clonedProperties = JSON.stringify(options.properties || {});
        var west = bbox[0], south = bbox[1], east = bbox[2], north = bbox[3];
        var centerY = (south + north) / 2;
        var centerX = (west + east) / 2;
        // https://github.com/Turfjs/turf/issues/758
        var xFraction = (cellSide * 2) / distance$1([west, centerY], [east, centerY], options);
        var cellWidth = xFraction * (east - west);
        var yFraction = (cellSide * 2) / distance$1([centerX, south], [centerX, north], options);
        var cellHeight = yFraction * (north - south);
        var radius = cellWidth / 2;
        var hex_width = radius * 2;
        var hex_height = (Math.sqrt(3) / 2) * cellHeight;
        var box_width = east - west;
        var box_height = north - south;
        var x_interval = (3 / 4) * hex_width;
        var y_interval = hex_height;
        // adjust box_width so all hexagons will be inside the bbox
        var x_span = (box_width - hex_width) / (hex_width - radius / 2);
        var x_count = Math.floor(x_span);
        var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 -
            radius / 2 +
            x_interval / 2;
        // adjust box_height so all hexagons will be inside the bbox
        var y_count = Math.floor((box_height - hex_height) / hex_height);
        var y_adjust = (box_height - y_count * hex_height) / 2;
        var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
        if (hasOffsetY) {
            y_adjust -= hex_height / 4;
        }
        // Precompute cosines and sines of angles used in hexagon creation for performance gain
        var cosines = [];
        var sines = [];
        for (var i = 0; i < 6; i++) {
            var angle = ((2 * Math.PI) / 6) * i;
            cosines.push(Math.cos(angle));
            sines.push(Math.sin(angle));
        }
        var results = [];
        for (var x = 0; x <= x_count; x++) {
            for (var y = 0; y <= y_count; y++) {
                var isOdd = x % 2 === 1;
                if (y === 0 && isOdd)
                    continue;
                if (y === 0 && hasOffsetY)
                    continue;
                var center_x = x * x_interval + west - x_adjust;
                var center_y = y * y_interval + south + y_adjust;
                if (isOdd) {
                    center_y -= hex_height / 2;
                }
                if (options.triangles === true) {
                    hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function (triangle) {
                        if (options.mask) {
                            if (intersect(options.mask, triangle))
                                results.push(triangle);
                        }
                        else {
                            results.push(triangle);
                        }
                    });
                }
                else {
                    var hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
                    if (options.mask) {
                        if (intersect(options.mask, hex))
                            results.push(hex);
                    }
                    else {
                        results.push(hex);
                    }
                }
            }
        }
        return featureCollection$1(results);
    }
    /**
     * Creates hexagon
     *
     * @private
     * @param {Array<number>} center of the hexagon
     * @param {number} rx half hexagon width
     * @param {number} ry half hexagon height
     * @param {Object} properties passed to each hexagon
     * @param {Array<number>} cosines precomputed
     * @param {Array<number>} sines precomputed
     * @returns {Feature<Polygon>} hexagon
     */
    function hexagon(center, rx, ry, properties, cosines, sines) {
        var vertices = [];
        for (var i = 0; i < 6; i++) {
            var x = center[0] + rx * cosines[i];
            var y = center[1] + ry * sines[i];
            vertices.push([x, y]);
        }
        //first and last vertex must be the same
        vertices.push(vertices[0].slice());
        return polygon([vertices], properties);
    }
    /**
     * Creates triangles composing an hexagon
     *
     * @private
     * @param {Array<number>} center of the hexagon
     * @param {number} rx half triangle width
     * @param {number} ry half triangle height
     * @param {Object} properties passed to each triangle
     * @param {Array<number>} cosines precomputed
     * @param {Array<number>} sines precomputed
     * @returns {Array<Feature<Polygon>>} triangles
     */
    function hexTriangles(center, rx, ry, properties, cosines, sines) {
        var triangles = [];
        for (var i = 0; i < 6; i++) {
            var vertices = [];
            vertices.push(center);
            vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);
            vertices.push([
                center[0] + rx * cosines[(i + 1) % 6],
                center[1] + ry * sines[(i + 1) % 6],
            ]);
            vertices.push(center);
            triangles.push(polygon([vertices], properties));
        }
        return triangles;
    }

    /**
     * Takes any type of {@link Polygon|polygon} and an optional mask and returns a {@link Polygon|polygon} exterior ring with holes.
     *
     * @name mask
     * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} polygon GeoJSON Polygon used as interior rings or holes.
     * @param {Feature<Polygon>} [mask] GeoJSON Polygon used as the exterior ring (if undefined, the world extent is used)
     * @returns {Feature<Polygon>} Masked Polygon (exterior ring with holes).
     * @example
     * var polygon = turf.polygon([[[112, -21], [116, -36], [146, -39], [153, -24], [133, -10], [112, -21]]]);
     * var mask = turf.polygon([[[90, -55], [170, -55], [170, 10], [90, 10], [90, -55]]]);
     *
     * var masked = turf.mask(polygon, mask);
     *
     * //addToMap
     * var addToMap = [masked]
     */
    function mask(polygon, mask) {
      // Define mask
      var maskPolygon = createMask(mask);

      var polygonOuters = null;
      if (polygon.type === "FeatureCollection") polygonOuters = unionFc(polygon);
      else
        polygonOuters = createGeomFromPolygonClippingOutput(
          polygonClipping.union(polygon.geometry.coordinates)
        );

      polygonOuters.geometry.coordinates.forEach(function (contour) {
        maskPolygon.geometry.coordinates.push(contour[0]);
      });

      return maskPolygon;
    }

    function unionFc(fc) {
      var unioned =
        fc.features.length === 2
          ? polygonClipping.union(
              fc.features[0].geometry.coordinates,
              fc.features[1].geometry.coordinates
            )
          : polygonClipping.union.apply(
              polygonClipping,
              fc.features.map(function (f) {
                return f.geometry.coordinates;
              })
            );
      return createGeomFromPolygonClippingOutput(unioned);
    }

    function createGeomFromPolygonClippingOutput(unioned) {
      return multiPolygon(unioned);
    }

    /**
     * Create Mask Coordinates
     *
     * @private
     * @param {Feature<Polygon>} [mask] default to world if undefined
     * @returns {Feature<Polygon>} mask coordinate
     */
    function createMask(mask) {
      var world = [
        [
          [180, 90],
          [-180, 90],
          [-180, -90],
          [180, -90],
          [180, 90],
        ],
      ];
      var coordinates = (mask && mask.geometry.coordinates) || world;
      return polygon(coordinates);
    }

    /**
     * Creates a grid of rectangles from a bounding box, {@link Feature} or {@link FeatureCollection}.
     *
     * @name rectangleGrid
     * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @param {number} cellWidth of each cell, in units
     * @param {number} cellHeight of each cell, in units
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] units ("degrees", "radians", "miles", "kilometers") that the given cellWidth
     * and cellHeight are expressed in. Converted at the southern border.
     * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,
     * the grid Points will be created only inside it
     * @param {Object} [options.properties={}] passed to each point of the grid
     * @returns {FeatureCollection<Polygon>} a grid of polygons
     * @example
     * var bbox = [-95, 30 ,-85, 40];
     * var cellWidth = 50;
     * var cellHeight = 20;
     * var options = {units: 'miles'};
     *
     * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);
     *
     * //addToMap
     * var addToMap = [rectangleGrid]
     */
    function rectangleGrid(bbox, cellWidth, cellHeight, options) {
        if (options === void 0) { options = {}; }
        // Containers
        var results = [];
        var west = bbox[0];
        var south = bbox[1];
        var east = bbox[2];
        var north = bbox[3];
        var xFraction = cellWidth / distance$1([west, south], [east, south], options);
        var cellWidthDeg = xFraction * (east - west);
        var yFraction = cellHeight / distance$1([west, south], [west, north], options);
        var cellHeightDeg = yFraction * (north - south);
        // rows & columns
        var bboxWidth = east - west;
        var bboxHeight = north - south;
        var columns = Math.floor(bboxWidth / cellWidthDeg);
        var rows = Math.floor(bboxHeight / cellHeightDeg);
        // if the grid does not fill the bbox perfectly, center it.
        var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
        var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
        // iterate over columns & rows
        var currentX = west + deltaX;
        for (var column = 0; column < columns; column++) {
            var currentY = south + deltaY;
            for (var row = 0; row < rows; row++) {
                var cellPoly = polygon([
                    [
                        [currentX, currentY],
                        [currentX, currentY + cellHeightDeg],
                        [currentX + cellWidthDeg, currentY + cellHeightDeg],
                        [currentX + cellWidthDeg, currentY],
                        [currentX, currentY],
                    ],
                ], options.properties);
                if (options.mask) {
                    if (booleanIntersects(options.mask, cellPoly)) {
                        results.push(cellPoly);
                    }
                }
                else {
                    results.push(cellPoly);
                }
                currentY += cellHeightDeg;
            }
            currentX += cellWidthDeg;
        }
        return featureCollection$1(results);
    }

    /**
     * Creates a square grid from a bounding box.
     *
     * @name squareGrid
     * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @param {number} cellSide of each cell, in units
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees,
     * radians, miles, or kilometers
     * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,
     * the grid Points will be created only inside it
     * @param {Object} [options.properties={}] passed to each point of the grid
     * @returns {FeatureCollection<Polygon>} grid a grid of polygons
     * @example
     * var bbox = [-95, 30 ,-85, 40];
     * var cellSide = 50;
     * var options = {units: 'miles'};
     *
     * var squareGrid = turf.squareGrid(bbox, cellSide, options);
     *
     * //addToMap
     * var addToMap = [squareGrid]
     */
    function squareGrid(bbox, cellSide, options) {
        if (options === void 0) { options = {}; }
        return rectangleGrid(bbox, cellSide, cellSide, options);
    }

    /**
     * Takes a bounding box and a cell depth and returns a set of triangular {@link Polygon|polygons} in a grid.
     *
     * @name triangleGrid
     * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @param {number} cellSide dimension of each cell
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers
     * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it
     * @param {Object} [options.properties={}] passed to each point of the grid
     * @returns {FeatureCollection<Polygon>} grid of polygons
     * @example
     * var bbox = [-95, 30 ,-85, 40];
     * var cellSide = 50;
     * var options = {units: 'miles'};
     *
     * var triangleGrid = turf.triangleGrid(bbox, cellSide, options);
     *
     * //addToMap
     * var addToMap = [triangleGrid];
     */
    function triangleGrid(bbox, cellSide, options) {
        if (options === void 0) { options = {}; }
        // Containers
        var results = [];
        // Input Validation is being handled by Typescript
        // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');
        // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');
        // if (!bbox) throw new Error('bbox is required');
        // if (!Array.isArray(bbox)) throw new Error('bbox must be array');
        // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');
        // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');
        // Main
        var xFraction = cellSide / distance$1([bbox[0], bbox[1]], [bbox[2], bbox[1]], options);
        var cellWidth = xFraction * (bbox[2] - bbox[0]);
        var yFraction = cellSide / distance$1([bbox[0], bbox[1]], [bbox[0], bbox[3]], options);
        var cellHeight = yFraction * (bbox[3] - bbox[1]);
        var xi = 0;
        var currentX = bbox[0];
        while (currentX <= bbox[2]) {
            var yi = 0;
            var currentY = bbox[1];
            while (currentY <= bbox[3]) {
                var cellTriangle1 = null;
                var cellTriangle2 = null;
                if (xi % 2 === 0 && yi % 2 === 0) {
                    cellTriangle1 = polygon([
                        [
                            [currentX, currentY],
                            [currentX, currentY + cellHeight],
                            [currentX + cellWidth, currentY],
                            [currentX, currentY],
                        ],
                    ], options.properties);
                    cellTriangle2 = polygon([
                        [
                            [currentX, currentY + cellHeight],
                            [currentX + cellWidth, currentY + cellHeight],
                            [currentX + cellWidth, currentY],
                            [currentX, currentY + cellHeight],
                        ],
                    ], options.properties);
                }
                else if (xi % 2 === 0 && yi % 2 === 1) {
                    cellTriangle1 = polygon([
                        [
                            [currentX, currentY],
                            [currentX + cellWidth, currentY + cellHeight],
                            [currentX + cellWidth, currentY],
                            [currentX, currentY],
                        ],
                    ], options.properties);
                    cellTriangle2 = polygon([
                        [
                            [currentX, currentY],
                            [currentX, currentY + cellHeight],
                            [currentX + cellWidth, currentY + cellHeight],
                            [currentX, currentY],
                        ],
                    ], options.properties);
                }
                else if (yi % 2 === 0 && xi % 2 === 1) {
                    cellTriangle1 = polygon([
                        [
                            [currentX, currentY],
                            [currentX, currentY + cellHeight],
                            [currentX + cellWidth, currentY + cellHeight],
                            [currentX, currentY],
                        ],
                    ], options.properties);
                    cellTriangle2 = polygon([
                        [
                            [currentX, currentY],
                            [currentX + cellWidth, currentY + cellHeight],
                            [currentX + cellWidth, currentY],
                            [currentX, currentY],
                        ],
                    ], options.properties);
                }
                else if (yi % 2 === 1 && xi % 2 === 1) {
                    cellTriangle1 = polygon([
                        [
                            [currentX, currentY],
                            [currentX, currentY + cellHeight],
                            [currentX + cellWidth, currentY],
                            [currentX, currentY],
                        ],
                    ], options.properties);
                    cellTriangle2 = polygon([
                        [
                            [currentX, currentY + cellHeight],
                            [currentX + cellWidth, currentY + cellHeight],
                            [currentX + cellWidth, currentY],
                            [currentX, currentY + cellHeight],
                        ],
                    ], options.properties);
                }
                if (options.mask) {
                    if (intersect(options.mask, cellTriangle1))
                        results.push(cellTriangle1);
                    if (intersect(options.mask, cellTriangle2))
                        results.push(cellTriangle2);
                }
                else {
                    results.push(cellTriangle1);
                    results.push(cellTriangle2);
                }
                currentY += cellHeight;
                yi++;
            }
            xi++;
            currentX += cellWidth;
        }
        return featureCollection$1(results);
    }

    /**
     * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).
     *
     * @name interpolate
     * @param {FeatureCollection<Point>} points with known value
     * @param {number} cellSize the distance across each grid point
     * @param {Object} [options={}] Optional parameters
     * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')
     * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.
     * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers
     * @param {number} [options.weight=1] exponent regulating the distance-decay weighting
     * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'
     * @example
     * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});
     *
     * // add a random property to each point
     * turf.featureEach(points, function(point) {
     *     point.properties.solRad = Math.random() * 50;
     * });
     * var options = {gridType: 'points', property: 'solRad', units: 'miles'};
     * var grid = turf.interpolate(points, 100, options);
     *
     * //addToMap
     * var addToMap = [grid];
     */
    function interpolate(points, cellSize, options) {
      // Optional parameters
      options = options || {};
      if (typeof options !== "object") throw new Error("options is invalid");
      var gridType = options.gridType;
      var property = options.property;
      var weight = options.weight;

      // validation
      if (!points) throw new Error("points is required");
      collectionOf(points, "Point", "input must contain Points");
      if (!cellSize) throw new Error("cellSize is required");
      if (weight !== undefined && typeof weight !== "number")
        throw new Error("weight must be a number");

      // default values
      property = property || "elevation";
      gridType = gridType || "square";
      weight = weight || 1;

      var box = bbox$2(points);
      var grid;
      switch (gridType) {
        case "point":
        case "points":
          grid = pointGrid(box, cellSize, options);
          break;
        case "square":
        case "squares":
          grid = squareGrid(box, cellSize, options);
          break;
        case "hex":
        case "hexes":
          grid = hexGrid(box, cellSize, options);
          break;
        case "triangle":
        case "triangles":
          grid = triangleGrid(box, cellSize, options);
          break;
        default:
          throw new Error("invalid gridType");
      }
      var results = [];
      featureEach$2(grid, function (gridFeature) {
        var zw = 0;
        var sw = 0;
        // calculate the distance from each input point to the grid points
        featureEach$2(points, function (point) {
          var gridPoint =
            gridType === "point" ? gridFeature : centroid(gridFeature);
          var d = distance$1(gridPoint, point, options);
          var zValue;
          // property has priority for zValue, fallbacks to 3rd coordinate from geometry
          if (property !== undefined) zValue = point.properties[property];
          if (zValue === undefined) zValue = point.geometry.coordinates[2];
          if (zValue === undefined) throw new Error("zValue is missing");
          if (d === 0) zw = zValue;
          var w = 1.0 / Math.pow(d, weight);
          sw += w;
          zw += w * zValue;
        });
        // write interpolated value for each grid point
        var newFeature = clone(gridFeature);
        newFeature.properties[property] = zw / sw;
        results.push(newFeature);
      });
      return featureCollection$1(results);
    }

    var turf = /*#__PURE__*/Object.freeze({
        __proto__: null,
        projection: index$2,
        random: index$1,
        clusters: index,
        helpers: index$6,
        invariant: index$4,
        meta: index$5,
        isolines: isolines,
        convex: convex,
        pointsWithinPolygon: pointsWithinPolygon,
        within: pointsWithinPolygon,
        concave: concave,
        collect: collect,
        flip: flip$1,
        simplify: simplify$1,
        bezier: bezier,
        bezierSpline: bezier,
        tag: tag,
        sample: sample,
        envelope: envelope,
        square: square,
        circle: circle,
        midpoint: midpoint,
        center: center,
        centerOfMass: centerOfMass,
        centroid: centroid,
        combine: combine,
        distance: distance$1,
        explode: explode$1,
        bbox: bbox$2,
        tesselate: tesselate,
        bboxPolygon: bboxPolygon,
        booleanPointInPolygon: booleanPointInPolygon,
        inside: booleanPointInPolygon,
        nearest: nearestPoint,
        nearestPoint: nearestPoint,
        nearestPointOnLine: nearestPointOnLine,
        pointOnLine: nearestPointOnLine,
        nearestPointToLine: nearestPointToLine,
        planepoint: planepoint,
        tin: tin,
        bearing: bearing,
        destination: destination,
        kinks: kinks,
        pointOnFeature: pointOnFeature,
        pointOnSurface: pointOnFeature,
        area: area,
        along: along,
        length: length,
        lineDistance: length,
        lineSlice: lineSlice,
        lineSliceAlong: lineSliceAlong,
        pointGrid: pointGrid,
        truncate: truncate,
        flatten: flatten,
        lineIntersect: lineIntersect,
        lineChunk: lineChunk,
        unkinkPolygon: unkinkPolygon,
        greatCircle: greatCircle,
        lineSegment: lineSegment,
        lineSplit: lineSplit,
        lineArc: lineArc,
        polygonToLine: polygonToLine,
        polygonToLineString: polygonToLine,
        lineStringToPolygon: lineToPolygon,
        lineToPolygon: lineToPolygon,
        bboxClip: bboxClip,
        lineOverlap: lineOverlap,
        sector: sector,
        rhumbBearing: rhumbBearing,
        rhumbDistance: rhumbDistance,
        rhumbDestination: rhumbDestination,
        polygonTangents: polygonTangents,
        rewind: rewind,
        isobands: isobands,
        transformRotate: transformRotate,
        transformScale: transformScale,
        transformTranslate: transformTranslate,
        lineOffset: lineOffset,
        polygonize: polygonize,
        booleanDisjoint: booleanDisjoint,
        booleanContains: booleanContains,
        booleanCrosses: booleanCrosses,
        booleanClockwise: booleanClockwise,
        booleanOverlap: booleanOverlap,
        booleanPointOnLine: booleanPointOnLine,
        booleanEqual: booleanEqual,
        booleanWithin: booleanWithin,
        booleanIntersects: booleanIntersects,
        clone: clone,
        cleanCoords: cleanCoords,
        clustersDbscan: clustersDbscan,
        clustersKmeans: clustersKmeans,
        pointToLineDistance: pointToLineDistance,
        booleanParallel: booleanParallel,
        shortestPath: shortestPath,
        voronoi: voronoi,
        ellipse: ellipse,
        centerMean: centerMean,
        centerMedian: centerMedian,
        standardDeviationalEllipse: standardDeviationalEllipse,
        angle: angle,
        polygonSmooth: polygonSmooth,
        moranIndex: index$3,
        distanceWeight: distanceWeight,
        bearingToAngle: bearingToAzimuth,
        convertDistance: convertLength,
        degrees2radians: degreesToRadians,
        distanceToDegrees: lengthToDegrees,
        distanceToRadians: lengthToRadians,
        radians2degrees: radiansToDegrees,
        radiansToDistance: radiansToLength,
        difference: difference,
        buffer: buffer,
        union: union,
        intersect: intersect,
        dissolve: dissolve,
        hexGrid: hexGrid,
        mask: mask,
        squareGrid: squareGrid,
        triangleGrid: triangleGrid,
        interpolate: interpolate,
        toMercator: toMercator,
        toWgs84: toWgs84,
        randomPosition: randomPosition,
        randomPoint: randomPoint,
        randomPolygon: randomPolygon,
        randomLineString: randomLineString,
        getCluster: getCluster,
        clusterEach: clusterEach,
        clusterReduce: clusterReduce,
        createBins: createBins,
        applyFilter: applyFilter,
        propertiesContainsFilter: propertiesContainsFilter,
        filterProperties: filterProperties,
        earthRadius: earthRadius,
        factors: factors,
        unitsFactors: unitsFactors,
        areaFactors: areaFactors,
        feature: feature,
        geometry: geometry$1,
        point: point,
        points: points,
        polygon: polygon,
        polygons: polygons,
        lineString: lineString,
        lineStrings: lineStrings,
        featureCollection: featureCollection$1,
        multiLineString: multiLineString,
        multiPoint: multiPoint,
        multiPolygon: multiPolygon,
        geometryCollection: geometryCollection,
        round: round$1,
        radiansToLength: radiansToLength,
        lengthToRadians: lengthToRadians,
        lengthToDegrees: lengthToDegrees,
        bearingToAzimuth: bearingToAzimuth,
        radiansToDegrees: radiansToDegrees,
        degreesToRadians: degreesToRadians,
        convertLength: convertLength,
        convertArea: convertArea,
        isNumber: isNumber,
        isObject: isObject,
        validateBBox: validateBBox,
        validateId: validateId,
        getCoord: getCoord,
        getCoords: getCoords,
        containsNumber: containsNumber,
        geojsonType: geojsonType,
        featureOf: featureOf,
        collectionOf: collectionOf,
        getGeom: getGeom,
        getType: getType$1,
        coordAll: coordAll$1,
        coordEach: coordEach$1,
        coordReduce: coordReduce$1,
        featureEach: featureEach$2,
        featureReduce: featureReduce$1,
        findPoint: findPoint$1,
        findSegment: findSegment$1,
        flattenEach: flattenEach$1,
        flattenReduce: flattenReduce$1,
        geomEach: geomEach$1,
        geomReduce: geomReduce$1,
        lineEach: lineEach$1,
        lineReduce: lineReduce$1,
        propEach: propEach$1,
        propReduce: propReduce$1,
        segmentEach: segmentEach$1,
        segmentReduce: segmentReduce$1
    });

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */


    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    /** @ignore */
    var ENTRIES = 'ENTRIES';
    /** @ignore */
    var KEYS = 'KEYS';
    /** @ignore */
    var VALUES = 'VALUES';
    /** @ignore */
    var LEAF = '';
    /**
     * @private
     */
    var TreeIterator = /** @class */ (function () {
        function TreeIterator(set, type) {
            var node = set._tree;
            var keys = Array.from(node.keys());
            this.set = set;
            this._type = type;
            this._path = keys.length > 0 ? [{ node: node, keys: keys }] : [];
        }
        TreeIterator.prototype.next = function () {
            var value = this.dive();
            this.backtrack();
            return value;
        };
        TreeIterator.prototype.dive = function () {
            if (this._path.length === 0) {
                return { done: true, value: undefined };
            }
            var _a = last$1(this._path), node = _a.node, keys = _a.keys;
            if (last$1(keys) === LEAF) {
                return { done: false, value: this.result() };
            }
            var child = node.get(last$1(keys));
            this._path.push({ node: child, keys: Array.from(child.keys()) });
            return this.dive();
        };
        TreeIterator.prototype.backtrack = function () {
            if (this._path.length === 0) {
                return;
            }
            var keys = last$1(this._path).keys;
            keys.pop();
            if (keys.length > 0) {
                return;
            }
            this._path.pop();
            this.backtrack();
        };
        TreeIterator.prototype.key = function () {
            return this.set._prefix + this._path
                .map(function (_a) {
                var keys = _a.keys;
                return last$1(keys);
            })
                .filter(function (key) { return key !== LEAF; })
                .join('');
        };
        TreeIterator.prototype.value = function () {
            return last$1(this._path).node.get(LEAF);
        };
        TreeIterator.prototype.result = function () {
            switch (this._type) {
                case VALUES: return this.value();
                case KEYS: return this.key();
                default: return [this.key(), this.value()];
            }
        };
        TreeIterator.prototype[Symbol.iterator] = function () {
            return this;
        };
        return TreeIterator;
    }());
    var last$1 = function (array) {
        return array[array.length - 1];
    };

    /**
     * @ignore
     */
    var fuzzySearch = function (node, query, maxDistance) {
        var results = new Map();
        if (query === undefined)
            return results;
        // Number of columns in the Levenshtein matrix.
        var n = query.length + 1;
        // Matching terms can never be longer than N + maxDistance.
        var m = n + maxDistance;
        // Fill first matrix row and column with numbers: 0 1 2 3 ...
        var matrix = new Uint8Array(m * n).fill(maxDistance + 1);
        for (var j = 0; j < n; ++j)
            matrix[j] = j;
        for (var i = 1; i < m; ++i)
            matrix[i * n] = i;
        recurse(node, query, maxDistance, results, matrix, 1, n, '');
        return results;
    };
    // Modified version of http://stevehanov.ca/blog/?id=114
    // This builds a Levenshtein matrix for a given query and continuously updates
    // it for nodes in the radix tree that fall within the given maximum edit
    // distance. Keeping the same matrix around is beneficial especially for larger
    // edit distances.
    //
    //           k   a   t   e   <-- query
    //       0   1   2   3   4
    //   c   1   1   2   3   4
    //   a   2   2   1   2   3
    //   t   3   3   2   1  [2]  <-- edit distance
    //   ^
    //   ^ term in radix tree, rows are added and removed as needed
    var recurse = function (node, query, maxDistance, results, matrix, m, n, prefix) {
        var e_1, _a;
        var offset = m * n;
        try {
            key: for (var _b = __values(node.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (key === LEAF) {
                    // We've reached a leaf node. Check if the edit distance acceptable and
                    // store the result if it is.
                    var distance = matrix[offset - 1];
                    if (distance <= maxDistance) {
                        results.set(prefix, [node.get(key), distance]);
                    }
                }
                else {
                    // Iterate over all characters in the key. Update the Levenshtein matrix
                    // and check if the minimum distance in the last row is still within the
                    // maximum edit distance. If it is, we can recurse over all child nodes.
                    var i = m;
                    for (var pos = 0; pos < key.length; ++pos, ++i) {
                        var char = key[pos];
                        var thisRowOffset = n * i;
                        var prevRowOffset = thisRowOffset - n;
                        // Set the first column based on the previous row, and initialize the
                        // minimum distance in the current row.
                        var minDistance = matrix[thisRowOffset];
                        var jmin = Math.max(0, i - maxDistance - 1);
                        var jmax = Math.min(n - 1, i + maxDistance);
                        // Iterate over remaining columns (characters in the query).
                        for (var j = jmin; j < jmax; ++j) {
                            var different = char !== query[j];
                            // It might make sense to only read the matrix positions used for
                            // deletion/insertion if the characters are different. But we want to
                            // avoid conditional reads for performance reasons.
                            var rpl = matrix[prevRowOffset + j] + +different;
                            var del = matrix[prevRowOffset + j + 1] + 1;
                            var ins = matrix[thisRowOffset + j] + 1;
                            var dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);
                            if (dist < minDistance)
                                minDistance = dist;
                        }
                        // Because distance will never decrease, we can stop. There will be no
                        // matching child nodes.
                        if (minDistance > maxDistance) {
                            continue key;
                        }
                    }
                    recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };

    /**
     * A class implementing the same interface as a standard JavaScript
     * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
     * with string keys, but adding support for efficiently searching entries with
     * prefix or fuzzy search. This class is used internally by {@link MiniSearch}
     * as the inverted index data structure. The implementation is a radix tree
     * (compressed prefix tree).
     *
     * Since this class can be of general utility beyond _MiniSearch_, it is
     * exported by the `minisearch` package and can be imported (or required) as
     * `minisearch/SearchableMap`.
     *
     * @typeParam T  The type of the values stored in the map.
     */
    var SearchableMap = /** @class */ (function () {
        /**
         * The constructor is normally called without arguments, creating an empty
         * map. In order to create a {@link SearchableMap} from an iterable or from an
         * object, check {@link SearchableMap.from} and {@link
         * SearchableMap.fromObject}.
         *
         * The constructor arguments are for internal use, when creating derived
         * mutable views of a map at a prefix.
         */
        function SearchableMap(tree, prefix) {
            if (tree === void 0) { tree = new Map(); }
            if (prefix === void 0) { prefix = ''; }
            this._size = undefined;
            this._tree = tree;
            this._prefix = prefix;
        }
        /**
         * Creates and returns a mutable view of this {@link SearchableMap},
         * containing only entries that share the given prefix.
         *
         * ### Usage:
         *
         * ```javascript
         * let map = new SearchableMap()
         * map.set("unicorn", 1)
         * map.set("universe", 2)
         * map.set("university", 3)
         * map.set("unique", 4)
         * map.set("hello", 5)
         *
         * let uni = map.atPrefix("uni")
         * uni.get("unique") // => 4
         * uni.get("unicorn") // => 1
         * uni.get("hello") // => undefined
         *
         * let univer = map.atPrefix("univer")
         * univer.get("unique") // => undefined
         * univer.get("universe") // => 2
         * univer.get("university") // => 3
         * ```
         *
         * @param prefix  The prefix
         * @return A {@link SearchableMap} representing a mutable view of the original
         * Map at the given prefix
         */
        SearchableMap.prototype.atPrefix = function (prefix) {
            var e_1, _a;
            if (!prefix.startsWith(this._prefix)) {
                throw new Error('Mismatched prefix');
            }
            var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2), node = _b[0], path = _b[1];
            if (node === undefined) {
                var _c = __read(last(path), 2), parentNode = _c[0], key = _c[1];
                try {
                    for (var _d = __values(parentNode.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var k = _e.value;
                        if (k !== LEAF && k.startsWith(key)) {
                            var node_1 = new Map();
                            node_1.set(k.slice(key.length), parentNode.get(k));
                            return new SearchableMap(node_1, prefix);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return new SearchableMap(node, prefix);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear
         */
        SearchableMap.prototype.clear = function () {
            this._size = undefined;
            this._tree.clear();
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete
         * @param key  Key to delete
         */
        SearchableMap.prototype.delete = function (key) {
            this._size = undefined;
            return remove(this._tree, key);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries
         * @return An iterator iterating through `[key, value]` entries.
         */
        SearchableMap.prototype.entries = function () {
            return new TreeIterator(this, ENTRIES);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach
         * @param fn  Iteration function
         */
        SearchableMap.prototype.forEach = function (fn) {
            var e_2, _a;
            try {
                for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                    fn(key, value, this);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        /**
         * Returns a Map of all the entries that have a key within the given edit
         * distance from the search key. The keys of the returned Map are the matching
         * keys, while the values are two-element arrays where the first element is
         * the value associated to the key, and the second is the edit distance of the
         * key to the search key.
         *
         * ### Usage:
         *
         * ```javascript
         * let map = new SearchableMap()
         * map.set('hello', 'world')
         * map.set('hell', 'yeah')
         * map.set('ciao', 'mondo')
         *
         * // Get all entries that match the key 'hallo' with a maximum edit distance of 2
         * map.fuzzyGet('hallo', 2)
         * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }
         *
         * // In the example, the "hello" key has value "world" and edit distance of 1
         * // (change "e" to "a"), the key "hell" has value "yeah" and edit distance of 2
         * // (change "e" to "a", delete "o")
         * ```
         *
         * @param key  The search key
         * @param maxEditDistance  The maximum edit distance (Levenshtein)
         * @return A Map of the matching keys to their value and edit distance
         */
        SearchableMap.prototype.fuzzyGet = function (key, maxEditDistance) {
            return fuzzySearch(this._tree, key, maxEditDistance);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get
         * @param key  Key to get
         * @return Value associated to the key, or `undefined` if the key is not
         * found.
         */
        SearchableMap.prototype.get = function (key) {
            var node = lookup(this._tree, key);
            return node !== undefined ? node.get(LEAF) : undefined;
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has
         * @param key  Key
         * @return True if the key is in the map, false otherwise
         */
        SearchableMap.prototype.has = function (key) {
            var node = lookup(this._tree, key);
            return node !== undefined && node.has(LEAF);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys
         * @return An `Iterable` iterating through keys
         */
        SearchableMap.prototype.keys = function () {
            return new TreeIterator(this, KEYS);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set
         * @param key  Key to set
         * @param value  Value to associate to the key
         * @return The {@link SearchableMap} itself, to allow chaining
         */
        SearchableMap.prototype.set = function (key, value) {
            if (typeof key !== 'string') {
                throw new Error('key must be a string');
            }
            this._size = undefined;
            var node = createPath(this._tree, key);
            node.set(LEAF, value);
            return this;
        };
        Object.defineProperty(SearchableMap.prototype, "size", {
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size
             */
            get: function () {
                if (this._size) {
                    return this._size;
                }
                /** @ignore */
                this._size = 0;
                var iter = this.entries();
                while (!iter.next().done)
                    this._size += 1;
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Updates the value at the given key using the provided function. The function
         * is called with the current value at the key, and its return value is used as
         * the new value to be set.
         *
         * ### Example:
         *
         * ```javascript
         * // Increment the current value by one
         * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)
         * ```
         *
         * If the value at the given key is or will be an object, it might not require
         * re-assignment. In that case it is better to use `fetch()`, because it is
         * faster.
         *
         * @param key  The key to update
         * @param fn  The function used to compute the new value from the current one
         * @return The {@link SearchableMap} itself, to allow chaining
         */
        SearchableMap.prototype.update = function (key, fn) {
            if (typeof key !== 'string') {
                throw new Error('key must be a string');
            }
            this._size = undefined;
            var node = createPath(this._tree, key);
            node.set(LEAF, fn(node.get(LEAF)));
            return this;
        };
        /**
         * Fetches the value of the given key. If the value does not exist, calls the
         * given function to create a new value, which is inserted at the given key
         * and subsequently returned.
         *
         * ### Example:
         *
         * ```javascript
         * const map = searchableMap.fetch('somekey', () => new Map())
         * map.set('foo', 'bar')
         * ```
         *
         * @param key  The key to update
         * @param defaultValue  A function that creates a new value if the key does not exist
         * @return The existing or new value at the given key
         */
        SearchableMap.prototype.fetch = function (key, initial) {
            if (typeof key !== 'string') {
                throw new Error('key must be a string');
            }
            this._size = undefined;
            var node = createPath(this._tree, key);
            var value = node.get(LEAF);
            if (value === undefined) {
                node.set(LEAF, value = initial());
            }
            return value;
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values
         * @return An `Iterable` iterating through values.
         */
        SearchableMap.prototype.values = function () {
            return new TreeIterator(this, VALUES);
        };
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator
         */
        SearchableMap.prototype[Symbol.iterator] = function () {
            return this.entries();
        };
        /**
         * Creates a {@link SearchableMap} from an `Iterable` of entries
         *
         * @param entries  Entries to be inserted in the {@link SearchableMap}
         * @return A new {@link SearchableMap} with the given entries
         */
        SearchableMap.from = function (entries) {
            var e_3, _a;
            var tree = new SearchableMap();
            try {
                for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                    var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
                    tree.set(key, value);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return tree;
        };
        /**
         * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object
         *
         * @param object  Object of entries for the {@link SearchableMap}
         * @return A new {@link SearchableMap} with the given entries
         */
        SearchableMap.fromObject = function (object) {
            return SearchableMap.from(Object.entries(object));
        };
        return SearchableMap;
    }());
    var trackDown = function (tree, key, path) {
        var e_4, _a;
        if (path === void 0) { path = []; }
        if (key.length === 0 || tree == null) {
            return [tree, path];
        }
        try {
            for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var k = _c.value;
                if (k !== LEAF && key.startsWith(k)) {
                    path.push([tree, k]); // performance: update in place
                    return trackDown(tree.get(k), key.slice(k.length), path);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        path.push([tree, key]); // performance: update in place
        return trackDown(undefined, '', path);
    };
    var lookup = function (tree, key) {
        var e_5, _a;
        if (key.length === 0 || tree == null) {
            return tree;
        }
        try {
            for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var k = _c.value;
                if (k !== LEAF && key.startsWith(k)) {
                    return lookup(tree.get(k), key.slice(k.length));
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    // Create a path in the radix tree for the given key, and returns the deepest
    // node. This function is in the hot path for indexing. It avoids unnecessary
    // string operations and recursion for performance.
    var createPath = function (node, key) {
        var e_6, _a;
        var keyLength = key.length;
        outer: for (var pos = 0; node && pos < keyLength;) {
            try {
                for (var _b = (e_6 = void 0, __values(node.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var k = _c.value;
                    // Check whether this key is a candidate: the first characters must match.
                    if (k !== LEAF && key[pos] === k[0]) {
                        var len = Math.min(keyLength - pos, k.length);
                        // Advance offset to the point where key and k no longer match.
                        var offset = 1;
                        while (offset < len && key[pos + offset] === k[offset])
                            ++offset;
                        var child_1 = node.get(k);
                        if (offset === k.length) {
                            // The existing key is shorter than the key we need to create.
                            node = child_1;
                        }
                        else {
                            // Partial match: we need to insert an intermediate node to contain
                            // both the existing subtree and the new node.
                            var intermediate = new Map();
                            intermediate.set(k.slice(offset), child_1);
                            node.set(key.slice(pos, pos + offset), intermediate);
                            node.delete(k);
                            node = intermediate;
                        }
                        pos += offset;
                        continue outer;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
            }
            // Create a final child node to contain the final suffix of the key.
            var child = new Map();
            node.set(key.slice(pos), child);
            return child;
        }
        return node;
    };
    var remove = function (tree, key) {
        var _a = __read(trackDown(tree, key), 2), node = _a[0], path = _a[1];
        if (node === undefined) {
            return;
        }
        node.delete(LEAF);
        if (node.size === 0) {
            cleanup(path);
        }
        else if (node.size === 1) {
            var _b = __read(node.entries().next().value, 2), key_1 = _b[0], value = _b[1];
            merge(path, key_1, value);
        }
    };
    var cleanup = function (path) {
        if (path.length === 0) {
            return;
        }
        var _a = __read(last(path), 2), node = _a[0], key = _a[1];
        node.delete(key);
        if (node.size === 0) {
            cleanup(path.slice(0, -1));
        }
        else if (node.size === 1) {
            var _b = __read(node.entries().next().value, 2), key_2 = _b[0], value = _b[1];
            if (key_2 !== LEAF) {
                merge(path.slice(0, -1), key_2, value);
            }
        }
    };
    var merge = function (path, key, value) {
        if (path.length === 0) {
            return;
        }
        var _a = __read(last(path), 2), node = _a[0], nodeKey = _a[1];
        node.set(nodeKey + key, value);
        node.delete(nodeKey);
    };
    var last = function (array) {
        return array[array.length - 1];
    };

    var _a;
    var OR = 'or';
    var AND = 'and';
    var AND_NOT = 'and_not';
    /**
     * {@link MiniSearch} is the main entrypoint class, implementing a full-text
     * search engine in memory.
     *
     * @typeParam T  The type of the documents being indexed.
     *
     * ### Basic example:
     *
     * ```javascript
     * const documents = [
     *   {
     *     id: 1,
     *     title: 'Moby Dick',
     *     text: 'Call me Ishmael. Some years ago...',
     *     category: 'fiction'
     *   },
     *   {
     *     id: 2,
     *     title: 'Zen and the Art of Motorcycle Maintenance',
     *     text: 'I can see by my watch...',
     *     category: 'fiction'
     *   },
     *   {
     *     id: 3,
     *     title: 'Neuromancer',
     *     text: 'The sky above the port was...',
     *     category: 'fiction'
     *   },
     *   {
     *     id: 4,
     *     title: 'Zen and the Art of Archery',
     *     text: 'At first sight it must seem...',
     *     category: 'non-fiction'
     *   },
     *   // ...and more
     * ]
     *
     * // Create a search engine that indexes the 'title' and 'text' fields for
     * // full-text search. Search results will include 'title' and 'category' (plus the
     * // id field, that is always stored and returned)
     * const miniSearch = new MiniSearch({
     *   fields: ['title', 'text'],
     *   storeFields: ['title', 'category']
     * })
     *
     * // Add documents to the index
     * miniSearch.addAll(documents)
     *
     * // Search for documents:
     * let results = miniSearch.search('zen art motorcycle')
     * // => [
     * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },
     * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }
     * // ]
     * ```
     */
    var MiniSearch = /** @class */ (function () {
        /**
         * @param options  Configuration options
         *
         * ### Examples:
         *
         * ```javascript
         * // Create a search engine that indexes the 'title' and 'text' fields of your
         * // documents:
         * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })
         * ```
         *
         * ### ID Field:
         *
         * ```javascript
         * // Your documents are assumed to include a unique 'id' field, but if you want
         * // to use a different field for document identification, you can set the
         * // 'idField' option:
         * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })
         * ```
         *
         * ### Options and defaults:
         *
         * ```javascript
         * // The full set of options (here with their default value) is:
         * const miniSearch = new MiniSearch({
         *   // idField: field that uniquely identifies a document
         *   idField: 'id',
         *
         *   // extractField: function used to get the value of a field in a document.
         *   // By default, it assumes the document is a flat object with field names as
         *   // property keys and field values as string property values, but custom logic
         *   // can be implemented by setting this option to a custom extractor function.
         *   extractField: (document, fieldName) => document[fieldName],
         *
         *   // tokenize: function used to split fields into individual terms. By
         *   // default, it is also used to tokenize search queries, unless a specific
         *   // `tokenize` search option is supplied. When tokenizing an indexed field,
         *   // the field name is passed as the second argument.
         *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),
         *
         *   // processTerm: function used to process each tokenized term before
         *   // indexing. It can be used for stemming and normalization. Return a falsy
         *   // value in order to discard a term. By default, it is also used to process
         *   // search queries, unless a specific `processTerm` option is supplied as a
         *   // search option. When processing a term from a indexed field, the field
         *   // name is passed as the second argument.
         *   processTerm: (term, _fieldName) => term.toLowerCase(),
         *
         *   // searchOptions: default search options, see the `search` method for
         *   // details
         *   searchOptions: undefined,
         *
         *   // fields: document fields to be indexed. Mandatory, but not set by default
         *   fields: undefined
         *
         *   // storeFields: document fields to be stored and returned as part of the
         *   // search results.
         *   storeFields: []
         * })
         * ```
         */
        function MiniSearch(options) {
            if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
                throw new Error('MiniSearch: option "fields" must be provided');
            }
            var autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;
            this._options = __assign(__assign(__assign({}, defaultOptions), options), { autoVacuum: autoVacuum, searchOptions: __assign(__assign({}, defaultSearchOptions), (options.searchOptions || {})), autoSuggestOptions: __assign(__assign({}, defaultAutoSuggestOptions), (options.autoSuggestOptions || {})) });
            this._index = new SearchableMap();
            this._documentCount = 0;
            this._documentIds = new Map();
            this._idToShortId = new Map();
            // Fields are defined during initialization, don't change, are few in
            // number, rarely need iterating over, and have string keys. Therefore in
            // this case an object is a better candidate than a Map to store the mapping
            // from field key to ID.
            this._fieldIds = {};
            this._fieldLength = new Map();
            this._avgFieldLength = [];
            this._nextId = 0;
            this._storedFields = new Map();
            this._dirtCount = 0;
            this._currentVacuum = null;
            this._enqueuedVacuum = null;
            this._enqueuedVacuumConditions = defaultVacuumConditions;
            this.addFields(this._options.fields);
        }
        /**
         * Adds a document to the index
         *
         * @param document  The document to be indexed
         */
        MiniSearch.prototype.add = function (document) {
            var e_1, _a, e_2, _b, e_3, _c;
            var _d = this._options, extractField = _d.extractField, tokenize = _d.tokenize, processTerm = _d.processTerm, fields = _d.fields, idField = _d.idField;
            var id = extractField(document, idField);
            if (id == null) {
                throw new Error("MiniSearch: document does not have ID field \"".concat(idField, "\""));
            }
            if (this._idToShortId.has(id)) {
                throw new Error("MiniSearch: duplicate ID ".concat(id));
            }
            var shortDocumentId = this.addDocumentId(id);
            this.saveStoredFields(shortDocumentId, document);
            try {
                for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
                    var field = fields_1_1.value;
                    var fieldValue = extractField(document, field);
                    if (fieldValue == null)
                        continue;
                    var tokens = tokenize(fieldValue.toString(), field);
                    var fieldId = this._fieldIds[field];
                    var uniqueTerms = new Set(tokens).size;
                    this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);
                    try {
                        for (var tokens_1 = (e_2 = void 0, __values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
                            var term = tokens_1_1.value;
                            var processedTerm = processTerm(term, field);
                            if (Array.isArray(processedTerm)) {
                                try {
                                    for (var processedTerm_1 = (e_3 = void 0, __values(processedTerm)), processedTerm_1_1 = processedTerm_1.next(); !processedTerm_1_1.done; processedTerm_1_1 = processedTerm_1.next()) {
                                        var t = processedTerm_1_1.value;
                                        this.addTerm(fieldId, shortDocumentId, t);
                                    }
                                }
                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                finally {
                                    try {
                                        if (processedTerm_1_1 && !processedTerm_1_1.done && (_c = processedTerm_1.return)) _c.call(processedTerm_1);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                }
                            }
                            else if (processedTerm) {
                                this.addTerm(fieldId, shortDocumentId, processedTerm);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return)) _b.call(tokens_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Adds all the given documents to the index
         *
         * @param documents  An array of documents to be indexed
         */
        MiniSearch.prototype.addAll = function (documents) {
            var e_4, _a;
            try {
                for (var documents_1 = __values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
                    var document_1 = documents_1_1.value;
                    this.add(document_1);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (documents_1_1 && !documents_1_1.done && (_a = documents_1.return)) _a.call(documents_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        /**
         * Adds all the given documents to the index asynchronously.
         *
         * Returns a promise that resolves (to `undefined`) when the indexing is done.
         * This method is useful when index many documents, to avoid blocking the main
         * thread. The indexing is performed asynchronously and in chunks.
         *
         * @param documents  An array of documents to be indexed
         * @param options  Configuration options
         * @return A promise resolving to `undefined` when the indexing is done
         */
        MiniSearch.prototype.addAllAsync = function (documents, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var _a = options.chunkSize, chunkSize = _a === void 0 ? 10 : _a;
            var acc = { chunk: [], promise: Promise.resolve() };
            var _b = documents.reduce(function (_a, document, i) {
                var chunk = _a.chunk, promise = _a.promise;
                chunk.push(document);
                if ((i + 1) % chunkSize === 0) {
                    return {
                        chunk: [],
                        promise: promise
                            .then(function () { return new Promise(function (resolve) { return setTimeout(resolve, 0); }); })
                            .then(function () { return _this.addAll(chunk); })
                    };
                }
                else {
                    return { chunk: chunk, promise: promise };
                }
            }, acc), chunk = _b.chunk, promise = _b.promise;
            return promise.then(function () { return _this.addAll(chunk); });
        };
        /**
         * Removes the given document from the index.
         *
         * The document to remove must NOT have changed between indexing and removal,
         * otherwise the index will be corrupted.
         *
         * This method requires passing the full document to be removed (not just the
         * ID), and immediately removes the document from the inverted index, allowing
         * memory to be released. A convenient alternative is {@link
         * MiniSearch#discard}, which needs only the document ID, and has the same
         * visible effect, but delays cleaning up the index until the next vacuuming.
         *
         * @param document  The document to be removed
         */
        MiniSearch.prototype.remove = function (document) {
            var e_5, _a, e_6, _b, e_7, _c;
            var _d = this._options, tokenize = _d.tokenize, processTerm = _d.processTerm, extractField = _d.extractField, fields = _d.fields, idField = _d.idField;
            var id = extractField(document, idField);
            if (id == null) {
                throw new Error("MiniSearch: document does not have ID field \"".concat(idField, "\""));
            }
            var shortId = this._idToShortId.get(id);
            if (shortId == null) {
                throw new Error("MiniSearch: cannot remove document with ID ".concat(id, ": it is not in the index"));
            }
            try {
                for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
                    var field = fields_2_1.value;
                    var fieldValue = extractField(document, field);
                    if (fieldValue == null)
                        continue;
                    var tokens = tokenize(fieldValue.toString(), field);
                    var fieldId = this._fieldIds[field];
                    var uniqueTerms = new Set(tokens).size;
                    this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);
                    try {
                        for (var tokens_2 = (e_6 = void 0, __values(tokens)), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
                            var term = tokens_2_1.value;
                            var processedTerm = processTerm(term, field);
                            if (Array.isArray(processedTerm)) {
                                try {
                                    for (var processedTerm_2 = (e_7 = void 0, __values(processedTerm)), processedTerm_2_1 = processedTerm_2.next(); !processedTerm_2_1.done; processedTerm_2_1 = processedTerm_2.next()) {
                                        var t = processedTerm_2_1.value;
                                        this.removeTerm(fieldId, shortId, t);
                                    }
                                }
                                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                                finally {
                                    try {
                                        if (processedTerm_2_1 && !processedTerm_2_1.done && (_c = processedTerm_2.return)) _c.call(processedTerm_2);
                                    }
                                    finally { if (e_7) throw e_7.error; }
                                }
                            }
                            else if (processedTerm) {
                                this.removeTerm(fieldId, shortId, processedTerm);
                            }
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (tokens_2_1 && !tokens_2_1.done && (_b = tokens_2.return)) _b.call(tokens_2);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (fields_2_1 && !fields_2_1.done && (_a = fields_2.return)) _a.call(fields_2);
                }
                finally { if (e_5) throw e_5.error; }
            }
            this._storedFields.delete(shortId);
            this._documentIds.delete(shortId);
            this._idToShortId.delete(id);
            this._fieldLength.delete(shortId);
            this._documentCount -= 1;
        };
        /**
         * Removes all the given documents from the index. If called with no arguments,
         * it removes _all_ documents from the index.
         *
         * @param documents  The documents to be removed. If this argument is omitted,
         * all documents are removed. Note that, for removing all documents, it is
         * more efficient to call this method with no arguments than to pass all
         * documents.
         */
        MiniSearch.prototype.removeAll = function (documents) {
            var e_8, _a;
            if (documents) {
                try {
                    for (var documents_2 = __values(documents), documents_2_1 = documents_2.next(); !documents_2_1.done; documents_2_1 = documents_2.next()) {
                        var document_2 = documents_2_1.value;
                        this.remove(document_2);
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (documents_2_1 && !documents_2_1.done && (_a = documents_2.return)) _a.call(documents_2);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
            }
            else if (arguments.length > 0) {
                throw new Error('Expected documents to be present. Omit the argument to remove all documents.');
            }
            else {
                this._index = new SearchableMap();
                this._documentCount = 0;
                this._documentIds = new Map();
                this._idToShortId = new Map();
                this._fieldLength = new Map();
                this._avgFieldLength = [];
                this._storedFields = new Map();
                this._nextId = 0;
            }
        };
        /**
         * Discards the document with the given ID, so it won't appear in search results
         *
         * It has the same visible effect of {@link MiniSearch.remove} (both cause the
         * document to stop appearing in searches), but a different effect on the
         * internal data structures:
         *
         *   - {@link MiniSearch#remove} requires passing the full document to be
         *   removed as argument, and removes it from the inverted index immediately.
         *
         *   - {@link MiniSearch#discard} instead only needs the document ID, and
         *   works by marking the current version of the document as discarded, so it
         *   is immediately ignored by searches. This is faster and more convenient
         *   than {@link MiniSearch#remove}, but the index is not immediately
         *   modified. To take care of that, vacuuming is performed after a certain
         *   number of documents are discarded, cleaning up the index and allowing
         *   memory to be released.
         *
         * After discarding a document, it is possible to re-add a new version, and
         * only the new version will appear in searches. In other words, discarding
         * and re-adding a document works exactly like removing and re-adding it. The
         * {@link MiniSearch.replace} method can also be used to replace a document
         * with a new version.
         *
         * #### Details about vacuuming
         *
         * Repetite calls to this method would leave obsolete document references in
         * the index, invisible to searches. Two mechanisms take care of cleaning up:
         * clean up during search, and vacuuming.
         *
         *   - Upon search, whenever a discarded ID is found (and ignored for the
         *   results), references to the discarded document are removed from the
         *   inverted index entries for the search terms. This ensures that subsequent
         *   searches for the same terms do not need to skip these obsolete references
         *   again.
         *
         *   - In addition, vacuuming is performed automatically by default (see the
         *   `autoVacuum` field in {@link Options}) after a certain number of
         *   documents are discarded. Vacuuming traverses all terms in the index,
         *   cleaning up all references to discarded documents. Vacuuming can also be
         *   triggered manually by calling {@link MiniSearch#vacuum}.
         *
         * @param id  The ID of the document to be discarded
         */
        MiniSearch.prototype.discard = function (id) {
            var _this = this;
            var shortId = this._idToShortId.get(id);
            if (shortId == null) {
                throw new Error("MiniSearch: cannot discard document with ID ".concat(id, ": it is not in the index"));
            }
            this._idToShortId.delete(id);
            this._documentIds.delete(shortId);
            this._storedFields.delete(shortId);
            (this._fieldLength.get(shortId) || []).forEach(function (fieldLength, fieldId) {
                _this.removeFieldLength(shortId, fieldId, _this._documentCount, fieldLength);
            });
            this._fieldLength.delete(shortId);
            this._documentCount -= 1;
            this._dirtCount += 1;
            this.maybeAutoVacuum();
        };
        MiniSearch.prototype.maybeAutoVacuum = function () {
            if (this._options.autoVacuum === false) {
                return;
            }
            var _a = this._options.autoVacuum, minDirtFactor = _a.minDirtFactor, minDirtCount = _a.minDirtCount, batchSize = _a.batchSize, batchWait = _a.batchWait;
            this.conditionalVacuum({ batchSize: batchSize, batchWait: batchWait }, { minDirtCount: minDirtCount, minDirtFactor: minDirtFactor });
        };
        /**
         * Discards the documents with the given IDs, so they won't appear in search
         * results
         *
         * It is equivalent to calling {@link MiniSearch#discard} for all the given
         * IDs, but with the optimization of triggering at most one automatic
         * vacuuming at the end.
         *
         * Note: to remove all documents from the index, it is faster and more
         * convenient to call {@link MiniSearch.removeAll} with no argument, instead
         * of passing all IDs to this method.
         */
        MiniSearch.prototype.discardAll = function (ids) {
            var e_9, _a;
            var autoVacuum = this._options.autoVacuum;
            try {
                this._options.autoVacuum = false;
                try {
                    for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
                        var id = ids_1_1.value;
                        this.discard(id);
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
            }
            finally {
                this._options.autoVacuum = autoVacuum;
            }
            this.maybeAutoVacuum();
        };
        /**
         * It replaces an existing document with the given updated version
         *
         * It works by discarding the current version and adding the updated one, so
         * it is functionally equivalent to calling {@link MiniSearch#discard}
         * followed by {@link MiniSearch#add}. The ID of the updated document should
         * be the same as the original one.
         *
         * Since it uses {@link MiniSearch#discard} internally, this method relies on
         * vacuuming to clean up obsolete document references from the index, allowing
         * memory to be released (see {@link MiniSearch#discard}).
         *
         * @param updatedDocument  The updated document to replace the old version
         * with
         */
        MiniSearch.prototype.replace = function (updatedDocument) {
            var _a = this._options, idField = _a.idField, extractField = _a.extractField;
            var id = extractField(updatedDocument, idField);
            this.discard(id);
            this.add(updatedDocument);
        };
        /**
         * Triggers a manual vacuuming, cleaning up references to discarded documents
         * from the inverted index
         *
         * Vacuuming is only useful for applications that use the {@link
         * MiniSearch#discard} or {@link MiniSearch#replace} methods.
         *
         * By default, vacuuming is performed automatically when needed (controlled by
         * the `autoVacuum` field in {@link Options}), so there is usually no need to
         * call this method, unless one wants to make sure to perform vacuuming at a
         * specific moment.
         *
         * Vacuuming traverses all terms in the inverted index in batches, and cleans
         * up references to discarded documents from the posting list, allowing memory
         * to be released.
         *
         * The method takes an optional object as argument with the following keys:
         *
         *   - `batchSize`: the size of each batch (1000 by default)
         *
         *   - `batchWait`: the number of milliseconds to wait between batches (10 by
         *   default)
         *
         * On large indexes, vacuuming could have a non-negligible cost: batching
         * avoids blocking the thread for long, diluting this cost so that it is not
         * negatively affecting the application. Nonetheless, this method should only
         * be called when necessary, and relying on automatic vacuuming is usually
         * better.
         *
         * It returns a promise that resolves (to undefined) when the clean up is
         * completed. If vacuuming is already ongoing at the time this method is
         * called, a new one is enqueued immediately after the ongoing one, and a
         * corresponding promise is returned. However, no more than one vacuuming is
         * enqueued on top of the ongoing one, even if this method is called more
         * times (enqueuing multiple ones would be useless).
         *
         * @param options  Configuration options for the batch size and delay. See
         * {@link VacuumOptions}.
         */
        MiniSearch.prototype.vacuum = function (options) {
            if (options === void 0) { options = {}; }
            return this.conditionalVacuum(options);
        };
        MiniSearch.prototype.conditionalVacuum = function (options, conditions) {
            var _this = this;
            // If a vacuum is already ongoing, schedule another as soon as it finishes,
            // unless there's already one enqueued. If one was already enqueued, do not
            // enqueue another on top, but make sure that the conditions are the
            // broadest.
            if (this._currentVacuum) {
                this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;
                if (this._enqueuedVacuum != null) {
                    return this._enqueuedVacuum;
                }
                this._enqueuedVacuum = this._currentVacuum.then(function () {
                    var conditions = _this._enqueuedVacuumConditions;
                    _this._enqueuedVacuumConditions = defaultVacuumConditions;
                    return _this.performVacuuming(options, conditions);
                });
                return this._enqueuedVacuum;
            }
            if (this.vacuumConditionsMet(conditions) === false) {
                return Promise.resolve();
            }
            this._currentVacuum = this.performVacuuming(options);
            return this._currentVacuum;
        };
        MiniSearch.prototype.performVacuuming = function (options, conditions) {
            return __awaiter(this, void 0, void 0, function () {
                var initialDirtCount, batchSize, batchWait_1, i, _a, _b, _c, term, fieldsData, fieldsData_1, fieldsData_1_1, _d, fieldId, fieldIndex, fieldIndex_1, fieldIndex_1_1, _e, shortId, e_10_1;
                var e_10, _f, e_11, _g, e_12, _h;
                return __generator(this, function (_j) {
                    switch (_j.label) {
                        case 0:
                            initialDirtCount = this._dirtCount;
                            if (!this.vacuumConditionsMet(conditions)) return [3 /*break*/, 10];
                            batchSize = options.batchSize || defaultVacuumOptions.batchSize;
                            batchWait_1 = options.batchWait || defaultVacuumOptions.batchWait;
                            i = 1;
                            _j.label = 1;
                        case 1:
                            _j.trys.push([1, 7, 8, 9]);
                            _a = __values(this._index), _b = _a.next();
                            _j.label = 2;
                        case 2:
                            if (!!_b.done) return [3 /*break*/, 6];
                            _c = __read(_b.value, 2), term = _c[0], fieldsData = _c[1];
                            try {
                                for (fieldsData_1 = (e_11 = void 0, __values(fieldsData)), fieldsData_1_1 = fieldsData_1.next(); !fieldsData_1_1.done; fieldsData_1_1 = fieldsData_1.next()) {
                                    _d = __read(fieldsData_1_1.value, 2), fieldId = _d[0], fieldIndex = _d[1];
                                    try {
                                        for (fieldIndex_1 = (e_12 = void 0, __values(fieldIndex)), fieldIndex_1_1 = fieldIndex_1.next(); !fieldIndex_1_1.done; fieldIndex_1_1 = fieldIndex_1.next()) {
                                            _e = __read(fieldIndex_1_1.value, 1), shortId = _e[0];
                                            if (this._documentIds.has(shortId)) {
                                                continue;
                                            }
                                            if (fieldIndex.size <= 1) {
                                                fieldsData.delete(fieldId);
                                            }
                                            else {
                                                fieldIndex.delete(shortId);
                                            }
                                        }
                                    }
                                    catch (e_12_1) { e_12 = { error: e_12_1 }; }
                                    finally {
                                        try {
                                            if (fieldIndex_1_1 && !fieldIndex_1_1.done && (_h = fieldIndex_1.return)) _h.call(fieldIndex_1);
                                        }
                                        finally { if (e_12) throw e_12.error; }
                                    }
                                }
                            }
                            catch (e_11_1) { e_11 = { error: e_11_1 }; }
                            finally {
                                try {
                                    if (fieldsData_1_1 && !fieldsData_1_1.done && (_g = fieldsData_1.return)) _g.call(fieldsData_1);
                                }
                                finally { if (e_11) throw e_11.error; }
                            }
                            if (this._index.get(term).size === 0) {
                                this._index.delete(term);
                            }
                            if (!(i % batchSize === 0)) return [3 /*break*/, 4];
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, batchWait_1); })];
                        case 3:
                            _j.sent();
                            _j.label = 4;
                        case 4:
                            i += 1;
                            _j.label = 5;
                        case 5:
                            _b = _a.next();
                            return [3 /*break*/, 2];
                        case 6: return [3 /*break*/, 9];
                        case 7:
                            e_10_1 = _j.sent();
                            e_10 = { error: e_10_1 };
                            return [3 /*break*/, 9];
                        case 8:
                            try {
                                if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                            }
                            finally { if (e_10) throw e_10.error; }
                            return [7 /*endfinally*/];
                        case 9:
                            this._dirtCount -= initialDirtCount;
                            _j.label = 10;
                        case 10: 
                        // Make the next lines always async, so they execute after this function returns
                        return [4 /*yield*/, null];
                        case 11:
                            // Make the next lines always async, so they execute after this function returns
                            _j.sent();
                            this._currentVacuum = this._enqueuedVacuum;
                            this._enqueuedVacuum = null;
                            return [2 /*return*/];
                    }
                });
            });
        };
        MiniSearch.prototype.vacuumConditionsMet = function (conditions) {
            if (conditions == null) {
                return true;
            }
            var minDirtCount = conditions.minDirtCount, minDirtFactor = conditions.minDirtFactor;
            minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;
            minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;
            return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;
        };
        Object.defineProperty(MiniSearch.prototype, "isVacuuming", {
            /**
             * Is `true` if a vacuuming operation is ongoing, `false` otherwise
             */
            get: function () {
                return this._currentVacuum != null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MiniSearch.prototype, "dirtCount", {
            /**
             * The number of documents discarded since the most recent vacuuming
             */
            get: function () {
                return this._dirtCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MiniSearch.prototype, "dirtFactor", {
            /**
             * A number between 0 and 1 giving an indication about the proportion of
             * documents that are discarded, and can therefore be cleaned up by vacuuming.
             * A value close to 0 means that the index is relatively clean, while a higher
             * value means that the index is relatively dirty, and vacuuming could release
             * memory.
             */
            get: function () {
                return this._dirtCount / (1 + this._documentCount + this._dirtCount);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns `true` if a document with the given ID is present in the index and
         * available for search, `false` otherwise
         *
         * @param id  The document ID
         */
        MiniSearch.prototype.has = function (id) {
            return this._idToShortId.has(id);
        };
        /**
         * Returns the stored fields (as configured in the `storeFields` constructor
         * option) for the given document ID. Returns `undefined` if the document is
         * not present in the index.
         *
         * @param id  The document ID
         */
        MiniSearch.prototype.getStoredFields = function (id) {
            var shortId = this._idToShortId.get(id);
            if (shortId == null) {
                return undefined;
            }
            return this._storedFields.get(shortId);
        };
        /**
         * Search for documents matching the given search query.
         *
         * The result is a list of scored document IDs matching the query, sorted by
         * descending score, and each including data about which terms were matched and
         * in which fields.
         *
         * ### Basic usage:
         *
         * ```javascript
         * // Search for "zen art motorcycle" with default options: terms have to match
         * // exactly, and individual terms are joined with OR
         * miniSearch.search('zen art motorcycle')
         * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]
         * ```
         *
         * ### Restrict search to specific fields:
         *
         * ```javascript
         * // Search only in the 'title' field
         * miniSearch.search('zen', { fields: ['title'] })
         * ```
         *
         * ### Field boosting:
         *
         * ```javascript
         * // Boost a field
         * miniSearch.search('zen', { boost: { title: 2 } })
         * ```
         *
         * ### Prefix search:
         *
         * ```javascript
         * // Search for "moto" with prefix search (it will match documents
         * // containing terms that start with "moto" or "neuro")
         * miniSearch.search('moto neuro', { prefix: true })
         * ```
         *
         * ### Fuzzy search:
         *
         * ```javascript
         * // Search for "ismael" with fuzzy search (it will match documents containing
         * // terms similar to "ismael", with a maximum edit distance of 0.2 term.length
         * // (rounded to nearest integer)
         * miniSearch.search('ismael', { fuzzy: 0.2 })
         * ```
         *
         * ### Combining strategies:
         *
         * ```javascript
         * // Mix of exact match, prefix search, and fuzzy search
         * miniSearch.search('ismael mob', {
         *  prefix: true,
         *  fuzzy: 0.2
         * })
         * ```
         *
         * ### Advanced prefix and fuzzy search:
         *
         * ```javascript
         * // Perform fuzzy and prefix search depending on the search term. Here
         * // performing prefix and fuzzy search only on terms longer than 3 characters
         * miniSearch.search('ismael mob', {
         *  prefix: term => term.length > 3
         *  fuzzy: term => term.length > 3 ? 0.2 : null
         * })
         * ```
         *
         * ### Combine with AND:
         *
         * ```javascript
         * // Combine search terms with AND (to match only documents that contain both
         * // "motorcycle" and "art")
         * miniSearch.search('motorcycle art', { combineWith: 'AND' })
         * ```
         *
         * ### Combine with AND_NOT:
         *
         * There is also an AND_NOT combinator, that finds documents that match the
         * first term, but do not match any of the other terms. This combinator is
         * rarely useful with simple queries, and is meant to be used with advanced
         * query combinations (see later for more details).
         *
         * ### Filtering results:
         *
         * ```javascript
         * // Filter only results in the 'fiction' category (assuming that 'category'
         * // is a stored field)
         * miniSearch.search('motorcycle art', {
         *   filter: (result) => result.category === 'fiction'
         * })
         * ```
         *
         * ### Wildcard query
         *
         * Searching for an empty string (assuming the default tokenizer) returns no
         * results. Sometimes though, one needs to match all documents, like in a
         * "wildcard" search. This is possible by passing the special value
         * {@link MiniSearch.wildcard} as the query:
         *
         * ```javascript
         * // Return search results for all documents
         * miniSearch.search(MiniSearch.wildcard)
         * ```
         *
         * Note that search options such as `filter` and `boostDocument` are still
         * applied, influencing which results are returned, and their order:
         *
         * ```javascript
         * // Return search results for all documents in the 'fiction' category
         * miniSearch.search(MiniSearch.wildcard, {
         *   filter: (result) => result.category === 'fiction'
         * })
         * ```
         *
         * ### Advanced combination of queries:
         *
         * It is possible to combine different subqueries with OR, AND, and AND_NOT,
         * and even with different search options, by passing a query expression
         * tree object as the first argument, instead of a string.
         *
         * ```javascript
         * // Search for documents that contain "zen" and ("motorcycle" or "archery")
         * miniSearch.search({
         *   combineWith: 'AND',
         *   queries: [
         *     'zen',
         *     {
         *       combineWith: 'OR',
         *       queries: ['motorcycle', 'archery']
         *     }
         *   ]
         * })
         *
         * // Search for documents that contain ("apple" or "pear") but not "juice" and
         * // not "tree"
         * miniSearch.search({
         *   combineWith: 'AND_NOT',
         *   queries: [
         *     {
         *       combineWith: 'OR',
         *       queries: ['apple', 'pear']
         *     },
         *     'juice',
         *     'tree'
         *   ]
         * })
         * ```
         *
         * Each node in the expression tree can be either a string, or an object that
         * supports all {@link SearchOptions} fields, plus a `queries` array field for
         * subqueries.
         *
         * Note that, while this can become complicated to do by hand for complex or
         * deeply nested queries, it provides a formalized expression tree API for
         * external libraries that implement a parser for custom query languages.
         *
         * @param query  Search query
         * @param options  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.
         */
        MiniSearch.prototype.search = function (query, searchOptions) {
            var e_13, _a;
            if (searchOptions === void 0) { searchOptions = {}; }
            var rawResults = this.executeQuery(query, searchOptions);
            var results = [];
            try {
                for (var rawResults_1 = __values(rawResults), rawResults_1_1 = rawResults_1.next(); !rawResults_1_1.done; rawResults_1_1 = rawResults_1.next()) {
                    var _b = __read(rawResults_1_1.value, 2), docId = _b[0], _c = _b[1], score = _c.score, terms = _c.terms, match = _c.match;
                    // terms are the matched query terms, which will be returned to the user
                    // as queryTerms. The quality is calculated based on them, as opposed to
                    // the matched terms in the document (which can be different due to
                    // prefix and fuzzy match)
                    var quality = terms.length || 1;
                    var result = {
                        id: this._documentIds.get(docId),
                        score: score * quality,
                        terms: Object.keys(match),
                        queryTerms: terms,
                        match: match
                    };
                    Object.assign(result, this._storedFields.get(docId));
                    if (searchOptions.filter == null || searchOptions.filter(result)) {
                        results.push(result);
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (rawResults_1_1 && !rawResults_1_1.done && (_a = rawResults_1.return)) _a.call(rawResults_1);
                }
                finally { if (e_13) throw e_13.error; }
            }
            // If it's a wildcard query, and no document boost is applied, skip sorting
            // the results, as all results have the same score of 1
            if (query === MiniSearch.wildcard &&
                searchOptions.boostDocument == null &&
                this._options.searchOptions.boostDocument == null) {
                return results;
            }
            results.sort(byScore);
            return results;
        };
        /**
         * Provide suggestions for the given search query
         *
         * The result is a list of suggested modified search queries, derived from the
         * given search query, each with a relevance score, sorted by descending score.
         *
         * By default, it uses the same options used for search, except that by
         * default it performs prefix search on the last term of the query, and
         * combine terms with `'AND'` (requiring all query terms to match). Custom
         * options can be passed as a second argument. Defaults can be changed upon
         * calling the {@link MiniSearch} constructor, by passing a
         * `autoSuggestOptions` option.
         *
         * ### Basic usage:
         *
         * ```javascript
         * // Get suggestions for 'neuro':
         * miniSearch.autoSuggest('neuro')
         * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]
         * ```
         *
         * ### Multiple words:
         *
         * ```javascript
         * // Get suggestions for 'zen ar':
         * miniSearch.autoSuggest('zen ar')
         * // => [
         * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },
         * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }
         * // ]
         * ```
         *
         * ### Fuzzy suggestions:
         *
         * ```javascript
         * // Correct spelling mistakes using fuzzy search:
         * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })
         * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]
         * ```
         *
         * ### Filtering:
         *
         * ```javascript
         * // Get suggestions for 'zen ar', but only within the 'fiction' category
         * // (assuming that 'category' is a stored field):
         * miniSearch.autoSuggest('zen ar', {
         *   filter: (result) => result.category === 'fiction'
         * })
         * // => [
         * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },
         * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }
         * // ]
         * ```
         *
         * @param queryString  Query string to be expanded into suggestions
         * @param options  Search options. The supported options and default values
         * are the same as for the {@link MiniSearch#search} method, except that by
         * default prefix search is performed on the last term in the query, and terms
         * are combined with `'AND'`.
         * @return  A sorted array of suggestions sorted by relevance score.
         */
        MiniSearch.prototype.autoSuggest = function (queryString, options) {
            var e_14, _a, e_15, _b;
            if (options === void 0) { options = {}; }
            options = __assign(__assign({}, this._options.autoSuggestOptions), options);
            var suggestions = new Map();
            try {
                for (var _c = __values(this.search(queryString, options)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = _d.value, score = _e.score, terms = _e.terms;
                    var phrase = terms.join(' ');
                    var suggestion = suggestions.get(phrase);
                    if (suggestion != null) {
                        suggestion.score += score;
                        suggestion.count += 1;
                    }
                    else {
                        suggestions.set(phrase, { score: score, terms: terms, count: 1 });
                    }
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_14) throw e_14.error; }
            }
            var results = [];
            try {
                for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
                    var _f = __read(suggestions_1_1.value, 2), suggestion = _f[0], _g = _f[1], score = _g.score, terms = _g.terms, count = _g.count;
                    results.push({ suggestion: suggestion, terms: terms, score: score / count });
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (suggestions_1_1 && !suggestions_1_1.done && (_b = suggestions_1.return)) _b.call(suggestions_1);
                }
                finally { if (e_15) throw e_15.error; }
            }
            results.sort(byScore);
            return results;
        };
        Object.defineProperty(MiniSearch.prototype, "documentCount", {
            /**
             * Total number of documents available to search
             */
            get: function () {
                return this._documentCount;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MiniSearch.prototype, "termCount", {
            /**
             * Number of terms in the index
             */
            get: function () {
                return this._index.size;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)
         * and instantiates a MiniSearch instance. It should be given the same options
         * originally used when serializing the index.
         *
         * ### Usage:
         *
         * ```javascript
         * // If the index was serialized with:
         * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })
         * miniSearch.addAll(documents)
         *
         * const json = JSON.stringify(miniSearch)
         * // It can later be deserialized like this:
         * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })
         * ```
         *
         * @param json  JSON-serialized index
         * @param options  configuration options, same as the constructor
         * @return An instance of MiniSearch deserialized from the given JSON.
         */
        MiniSearch.loadJSON = function (json, options) {
            if (options == null) {
                throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');
            }
            return this.loadJS(JSON.parse(json), options);
        };
        /**
         * Returns the default value of an option. It will throw an error if no option
         * with the given name exists.
         *
         * @param optionName  Name of the option
         * @return The default value of the given option
         *
         * ### Usage:
         *
         * ```javascript
         * // Get default tokenizer
         * MiniSearch.getDefault('tokenize')
         *
         * // Get default term processor
         * MiniSearch.getDefault('processTerm')
         *
         * // Unknown options will throw an error
         * MiniSearch.getDefault('notExisting')
         * // => throws 'MiniSearch: unknown option "notExisting"'
         * ```
         */
        MiniSearch.getDefault = function (optionName) {
            if (defaultOptions.hasOwnProperty(optionName)) {
                return getOwnProperty(defaultOptions, optionName);
            }
            else {
                throw new Error("MiniSearch: unknown option \"".concat(optionName, "\""));
            }
        };
        /**
         * @ignore
         */
        MiniSearch.loadJS = function (js, options) {
            var e_16, _a, e_17, _b, e_18, _c;
            var index = js.index, documentCount = js.documentCount, nextId = js.nextId, documentIds = js.documentIds, fieldIds = js.fieldIds, fieldLength = js.fieldLength, averageFieldLength = js.averageFieldLength, storedFields = js.storedFields, dirtCount = js.dirtCount, serializationVersion = js.serializationVersion;
            if (serializationVersion !== 1 && serializationVersion !== 2) {
                throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');
            }
            var miniSearch = new MiniSearch(options);
            miniSearch._documentCount = documentCount;
            miniSearch._nextId = nextId;
            miniSearch._documentIds = objectToNumericMap(documentIds);
            miniSearch._idToShortId = new Map();
            miniSearch._fieldIds = fieldIds;
            miniSearch._fieldLength = objectToNumericMap(fieldLength);
            miniSearch._avgFieldLength = averageFieldLength;
            miniSearch._storedFields = objectToNumericMap(storedFields);
            miniSearch._dirtCount = dirtCount || 0;
            miniSearch._index = new SearchableMap();
            try {
                for (var _d = __values(miniSearch._documentIds), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var _f = __read(_e.value, 2), shortId = _f[0], id = _f[1];
                    miniSearch._idToShortId.set(id, shortId);
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_16) throw e_16.error; }
            }
            try {
                for (var index_1 = __values(index), index_1_1 = index_1.next(); !index_1_1.done; index_1_1 = index_1.next()) {
                    var _g = __read(index_1_1.value, 2), term = _g[0], data = _g[1];
                    var dataMap = new Map();
                    try {
                        for (var _h = (e_18 = void 0, __values(Object.keys(data))), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var fieldId = _j.value;
                            var indexEntry = data[fieldId];
                            // Version 1 used to nest the index entry inside a field called ds
                            if (serializationVersion === 1) {
                                indexEntry = indexEntry.ds;
                            }
                            dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));
                        }
                    }
                    catch (e_18_1) { e_18 = { error: e_18_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                        }
                        finally { if (e_18) throw e_18.error; }
                    }
                    miniSearch._index.set(term, dataMap);
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (index_1_1 && !index_1_1.done && (_b = index_1.return)) _b.call(index_1);
                }
                finally { if (e_17) throw e_17.error; }
            }
            return miniSearch;
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.executeQuery = function (query, searchOptions) {
            var _this = this;
            if (searchOptions === void 0) { searchOptions = {}; }
            if (query === MiniSearch.wildcard) {
                return this.executeWildcardQuery(searchOptions);
            }
            if (typeof query !== 'string') {
                var options_1 = __assign(__assign(__assign({}, searchOptions), query), { queries: undefined });
                var results_1 = query.queries.map(function (subquery) { return _this.executeQuery(subquery, options_1); });
                return this.combineResults(results_1, options_1.combineWith);
            }
            var _a = this._options, tokenize = _a.tokenize, processTerm = _a.processTerm, globalSearchOptions = _a.searchOptions;
            var options = __assign(__assign({ tokenize: tokenize, processTerm: processTerm }, globalSearchOptions), searchOptions);
            var searchTokenize = options.tokenize, searchProcessTerm = options.processTerm;
            var terms = searchTokenize(query)
                .flatMap(function (term) { return searchProcessTerm(term); })
                .filter(function (term) { return !!term; });
            var queries = terms.map(termToQuerySpec(options));
            var results = queries.map(function (query) { return _this.executeQuerySpec(query, options); });
            return this.combineResults(results, options.combineWith);
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.executeQuerySpec = function (query, searchOptions) {
            var e_19, _a, e_20, _b;
            var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
            var boosts = (options.fields || this._options.fields).reduce(function (boosts, field) {
                var _a;
                return (__assign(__assign({}, boosts), (_a = {}, _a[field] = getOwnProperty(options.boost, field) || 1, _a)));
            }, {});
            var boostDocument = options.boostDocument, weights = options.weights, maxFuzzy = options.maxFuzzy, bm25params = options.bm25;
            var _c = __assign(__assign({}, defaultSearchOptions.weights), weights), fuzzyWeight = _c.fuzzy, prefixWeight = _c.prefix;
            var data = this._index.get(query.term);
            var results = this.termResults(query.term, query.term, 1, data, boosts, boostDocument, bm25params);
            var prefixMatches;
            var fuzzyMatches;
            if (query.prefix) {
                prefixMatches = this._index.atPrefix(query.term);
            }
            if (query.fuzzy) {
                var fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;
                var maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;
                if (maxDistance)
                    fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);
            }
            if (prefixMatches) {
                try {
                    for (var prefixMatches_1 = __values(prefixMatches), prefixMatches_1_1 = prefixMatches_1.next(); !prefixMatches_1_1.done; prefixMatches_1_1 = prefixMatches_1.next()) {
                        var _d = __read(prefixMatches_1_1.value, 2), term = _d[0], data_1 = _d[1];
                        var distance = term.length - query.term.length;
                        if (!distance) {
                            continue;
                        } // Skip exact match.
                        // Delete the term from fuzzy results (if present) if it is also a
                        // prefix result. This entry will always be scored as a prefix result.
                        fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);
                        // Weight gradually approaches 0 as distance goes to infinity, with the
                        // weight for the hypothetical distance 0 being equal to prefixWeight.
                        // The rate of change is much lower than that of fuzzy matches to
                        // account for the fact that prefix matches stay more relevant than
                        // fuzzy matches for longer distances.
                        var weight = prefixWeight * term.length / (term.length + 0.3 * distance);
                        this.termResults(query.term, term, weight, data_1, boosts, boostDocument, bm25params, results);
                    }
                }
                catch (e_19_1) { e_19 = { error: e_19_1 }; }
                finally {
                    try {
                        if (prefixMatches_1_1 && !prefixMatches_1_1.done && (_a = prefixMatches_1.return)) _a.call(prefixMatches_1);
                    }
                    finally { if (e_19) throw e_19.error; }
                }
            }
            if (fuzzyMatches) {
                try {
                    for (var _e = __values(fuzzyMatches.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var term = _f.value;
                        var _g = __read(fuzzyMatches.get(term), 2), data_2 = _g[0], distance = _g[1];
                        if (!distance) {
                            continue;
                        } // Skip exact match.
                        // Weight gradually approaches 0 as distance goes to infinity, with the
                        // weight for the hypothetical distance 0 being equal to fuzzyWeight.
                        var weight = fuzzyWeight * term.length / (term.length + distance);
                        this.termResults(query.term, term, weight, data_2, boosts, boostDocument, bm25params, results);
                    }
                }
                catch (e_20_1) { e_20 = { error: e_20_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_20) throw e_20.error; }
                }
            }
            return results;
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.executeWildcardQuery = function (searchOptions) {
            var e_21, _a;
            var results = new Map();
            var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
            try {
                for (var _b = __values(this._documentIds), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), shortId = _d[0], id = _d[1];
                    var score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;
                    results.set(shortId, {
                        score: score,
                        terms: [],
                        match: {}
                    });
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_21) throw e_21.error; }
            }
            return results;
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.combineResults = function (results, combineWith) {
            if (combineWith === void 0) { combineWith = OR; }
            if (results.length === 0) {
                return new Map();
            }
            var operator = combineWith.toLowerCase();
            return results.reduce(combinators[operator]) || new Map();
        };
        /**
         * Allows serialization of the index to JSON, to possibly store it and later
         * deserialize it with {@link MiniSearch.loadJSON}.
         *
         * Normally one does not directly call this method, but rather call the
         * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}
         * instance, and JavaScript will internally call this method. Upon
         * deserialization, one must pass to {@link MiniSearch.loadJSON} the same
         * options used to create the original instance that was serialized.
         *
         * ### Usage:
         *
         * ```javascript
         * // Serialize the index:
         * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })
         * miniSearch.addAll(documents)
         * const json = JSON.stringify(miniSearch)
         *
         * // Later, to deserialize it:
         * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })
         * ```
         *
         * @return A plain-object serializable representation of the search index.
         */
        MiniSearch.prototype.toJSON = function () {
            var e_22, _a, e_23, _b;
            var index = [];
            try {
                for (var _c = __values(this._index), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), term = _e[0], fieldIndex = _e[1];
                    var data = {};
                    try {
                        for (var fieldIndex_2 = (e_23 = void 0, __values(fieldIndex)), fieldIndex_2_1 = fieldIndex_2.next(); !fieldIndex_2_1.done; fieldIndex_2_1 = fieldIndex_2.next()) {
                            var _f = __read(fieldIndex_2_1.value, 2), fieldId = _f[0], freqs = _f[1];
                            data[fieldId] = Object.fromEntries(freqs);
                        }
                    }
                    catch (e_23_1) { e_23 = { error: e_23_1 }; }
                    finally {
                        try {
                            if (fieldIndex_2_1 && !fieldIndex_2_1.done && (_b = fieldIndex_2.return)) _b.call(fieldIndex_2);
                        }
                        finally { if (e_23) throw e_23.error; }
                    }
                    index.push([term, data]);
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_22) throw e_22.error; }
            }
            return {
                documentCount: this._documentCount,
                nextId: this._nextId,
                documentIds: Object.fromEntries(this._documentIds),
                fieldIds: this._fieldIds,
                fieldLength: Object.fromEntries(this._fieldLength),
                averageFieldLength: this._avgFieldLength,
                storedFields: Object.fromEntries(this._storedFields),
                dirtCount: this._dirtCount,
                index: index,
                serializationVersion: 2
            };
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.termResults = function (sourceTerm, derivedTerm, termWeight, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results) {
            var e_24, _a, e_25, _b, _c;
            if (results === void 0) { results = new Map(); }
            if (fieldTermData == null)
                return results;
            try {
                for (var _d = __values(Object.keys(fieldBoosts)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var field = _e.value;
                    var fieldBoost = fieldBoosts[field];
                    var fieldId = this._fieldIds[field];
                    var fieldTermFreqs = fieldTermData.get(fieldId);
                    if (fieldTermFreqs == null)
                        continue;
                    var matchingFields = fieldTermFreqs.size;
                    var avgFieldLength = this._avgFieldLength[fieldId];
                    try {
                        for (var _f = (e_25 = void 0, __values(fieldTermFreqs.keys())), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var docId = _g.value;
                            if (!this._documentIds.has(docId)) {
                                this.removeTerm(fieldId, docId, derivedTerm);
                                matchingFields -= 1;
                                continue;
                            }
                            var docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;
                            if (!docBoost)
                                continue;
                            var termFreq = fieldTermFreqs.get(docId);
                            var fieldLength = this._fieldLength.get(docId)[fieldId];
                            // NOTE: The total number of fields is set to the number of documents
                            // `this._documentCount`. It could also make sense to use the number of
                            // documents where the current field is non-blank as a normalization
                            // factor. This will make a difference in scoring if the field is rarely
                            // present. This is currently not supported, and may require further
                            // analysis to see if it is a valid use case.
                            var rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);
                            var weightedScore = termWeight * fieldBoost * docBoost * rawScore;
                            var result = results.get(docId);
                            if (result) {
                                result.score += weightedScore;
                                assignUniqueTerm(result.terms, sourceTerm);
                                var match = getOwnProperty(result.match, derivedTerm);
                                if (match) {
                                    match.push(field);
                                }
                                else {
                                    result.match[derivedTerm] = [field];
                                }
                            }
                            else {
                                results.set(docId, {
                                    score: weightedScore,
                                    terms: [sourceTerm],
                                    match: (_c = {}, _c[derivedTerm] = [field], _c)
                                });
                            }
                        }
                    }
                    catch (e_25_1) { e_25 = { error: e_25_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_25) throw e_25.error; }
                    }
                }
            }
            catch (e_24_1) { e_24 = { error: e_24_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_24) throw e_24.error; }
            }
            return results;
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.addTerm = function (fieldId, documentId, term) {
            var indexData = this._index.fetch(term, createMap);
            var fieldIndex = indexData.get(fieldId);
            if (fieldIndex == null) {
                fieldIndex = new Map();
                fieldIndex.set(documentId, 1);
                indexData.set(fieldId, fieldIndex);
            }
            else {
                var docs = fieldIndex.get(documentId);
                fieldIndex.set(documentId, (docs || 0) + 1);
            }
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.removeTerm = function (fieldId, documentId, term) {
            if (!this._index.has(term)) {
                this.warnDocumentChanged(documentId, fieldId, term);
                return;
            }
            var indexData = this._index.fetch(term, createMap);
            var fieldIndex = indexData.get(fieldId);
            if (fieldIndex == null || fieldIndex.get(documentId) == null) {
                this.warnDocumentChanged(documentId, fieldId, term);
            }
            else if (fieldIndex.get(documentId) <= 1) {
                if (fieldIndex.size <= 1) {
                    indexData.delete(fieldId);
                }
                else {
                    fieldIndex.delete(documentId);
                }
            }
            else {
                fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);
            }
            if (this._index.get(term).size === 0) {
                this._index.delete(term);
            }
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.warnDocumentChanged = function (shortDocumentId, fieldId, term) {
            var e_26, _a;
            try {
                for (var _b = __values(Object.keys(this._fieldIds)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var fieldName = _c.value;
                    if (this._fieldIds[fieldName] === fieldId) {
                        this._options.logger('warn', "MiniSearch: document with ID ".concat(this._documentIds.get(shortDocumentId), " has changed before removal: term \"").concat(term, "\" was not present in field \"").concat(fieldName, "\". Removing a document after it has changed can corrupt the index!"), 'version_conflict');
                        return;
                    }
                }
            }
            catch (e_26_1) { e_26 = { error: e_26_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_26) throw e_26.error; }
            }
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.addDocumentId = function (documentId) {
            var shortDocumentId = this._nextId;
            this._idToShortId.set(documentId, shortDocumentId);
            this._documentIds.set(shortDocumentId, documentId);
            this._documentCount += 1;
            this._nextId += 1;
            return shortDocumentId;
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.addFields = function (fields) {
            for (var i = 0; i < fields.length; i++) {
                this._fieldIds[fields[i]] = i;
            }
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.addFieldLength = function (documentId, fieldId, count, length) {
            var fieldLengths = this._fieldLength.get(documentId);
            if (fieldLengths == null)
                this._fieldLength.set(documentId, fieldLengths = []);
            fieldLengths[fieldId] = length;
            var averageFieldLength = this._avgFieldLength[fieldId] || 0;
            var totalFieldLength = (averageFieldLength * count) + length;
            this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.removeFieldLength = function (documentId, fieldId, count, length) {
            if (count === 1) {
                this._avgFieldLength[fieldId] = 0;
                return;
            }
            var totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;
            this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);
        };
        /**
         * @ignore
         */
        MiniSearch.prototype.saveStoredFields = function (documentId, doc) {
            var e_27, _a;
            var _b = this._options, storeFields = _b.storeFields, extractField = _b.extractField;
            if (storeFields == null || storeFields.length === 0) {
                return;
            }
            var documentFields = this._storedFields.get(documentId);
            if (documentFields == null)
                this._storedFields.set(documentId, documentFields = {});
            try {
                for (var storeFields_1 = __values(storeFields), storeFields_1_1 = storeFields_1.next(); !storeFields_1_1.done; storeFields_1_1 = storeFields_1.next()) {
                    var fieldName = storeFields_1_1.value;
                    var fieldValue = extractField(doc, fieldName);
                    if (fieldValue !== undefined)
                        documentFields[fieldName] = fieldValue;
                }
            }
            catch (e_27_1) { e_27 = { error: e_27_1 }; }
            finally {
                try {
                    if (storeFields_1_1 && !storeFields_1_1.done && (_a = storeFields_1.return)) _a.call(storeFields_1);
                }
                finally { if (e_27) throw e_27.error; }
            }
        };
        /**
         * The special wildcard symbol that can be passed to {@link MiniSearch#search}
         * to match all documents
         */
        MiniSearch.wildcard = Symbol('*');
        return MiniSearch;
    }());
    var getOwnProperty = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
    };
    var combinators = (_a = {},
        _a[OR] = function (a, b) {
            var e_28, _a;
            try {
                for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var docId = _c.value;
                    var existing = a.get(docId);
                    if (existing == null) {
                        a.set(docId, b.get(docId));
                    }
                    else {
                        var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
                        existing.score = existing.score + score;
                        existing.match = Object.assign(existing.match, match);
                        assignUniqueTerms(existing.terms, terms);
                    }
                }
            }
            catch (e_28_1) { e_28 = { error: e_28_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_28) throw e_28.error; }
            }
            return a;
        },
        _a[AND] = function (a, b) {
            var e_29, _a;
            var combined = new Map();
            try {
                for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var docId = _c.value;
                    var existing = a.get(docId);
                    if (existing == null)
                        continue;
                    var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
                    assignUniqueTerms(existing.terms, terms);
                    combined.set(docId, {
                        score: existing.score + score,
                        terms: existing.terms,
                        match: Object.assign(existing.match, match)
                    });
                }
            }
            catch (e_29_1) { e_29 = { error: e_29_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_29) throw e_29.error; }
            }
            return combined;
        },
        _a[AND_NOT] = function (a, b) {
            var e_30, _a;
            try {
                for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var docId = _c.value;
                    a.delete(docId);
                }
            }
            catch (e_30_1) { e_30 = { error: e_30_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_30) throw e_30.error; }
            }
            return a;
        },
        _a);
    var defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };
    var calcBM25Score = function (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) {
        var k = bm25params.k, b = bm25params.b, d = bm25params.d;
        var invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));
        return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));
    };
    var termToQuerySpec = function (options) { return function (term, i, terms) {
        var fuzzy = (typeof options.fuzzy === 'function')
            ? options.fuzzy(term, i, terms)
            : (options.fuzzy || false);
        var prefix = (typeof options.prefix === 'function')
            ? options.prefix(term, i, terms)
            : (options.prefix === true);
        return { term: term, fuzzy: fuzzy, prefix: prefix };
    }; };
    var defaultOptions = {
        idField: 'id',
        extractField: function (document, fieldName) { return document[fieldName]; },
        tokenize: function (text) { return text.split(SPACE_OR_PUNCTUATION); },
        processTerm: function (term) { return term.toLowerCase(); },
        fields: undefined,
        searchOptions: undefined,
        storeFields: [],
        logger: function (level, message) {
            if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')
                console[level](message);
        },
        autoVacuum: true
    };
    var defaultSearchOptions = {
        combineWith: OR,
        prefix: false,
        fuzzy: false,
        maxFuzzy: 6,
        boost: {},
        weights: { fuzzy: 0.45, prefix: 0.375 },
        bm25: defaultBM25params
    };
    var defaultAutoSuggestOptions = {
        combineWith: AND,
        prefix: function (term, i, terms) {
            return i === terms.length - 1;
        }
    };
    var defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };
    var defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };
    var defaultAutoVacuumOptions = __assign(__assign({}, defaultVacuumOptions), defaultVacuumConditions);
    var assignUniqueTerm = function (target, term) {
        // Avoid adding duplicate terms.
        if (!target.includes(term))
            target.push(term);
    };
    var assignUniqueTerms = function (target, source) {
        var e_31, _a;
        try {
            for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
                var term = source_1_1.value;
                // Avoid adding duplicate terms.
                if (!target.includes(term))
                    target.push(term);
            }
        }
        catch (e_31_1) { e_31 = { error: e_31_1 }; }
        finally {
            try {
                if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
            }
            finally { if (e_31) throw e_31.error; }
        }
    };
    var byScore = function (_a, _b) {
        var a = _a.score;
        var b = _b.score;
        return b - a;
    };
    var createMap = function () { return new Map(); };
    var objectToNumericMap = function (object) {
        var e_32, _a;
        var map = new Map();
        try {
            for (var _b = __values(Object.keys(object)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                map.set(parseInt(key, 10), object[key]);
            }
        }
        catch (e_32_1) { e_32 = { error: e_32_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_32) throw e_32.error; }
        }
        return map;
    };
    // This regular expression matches any Unicode space or punctuation character
    // Adapted from https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BZ%7D%5Cp%7BP%7D&abb=on&c=on&esc=on
    var SPACE_OR_PUNCTUATION = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;

    /**
     * Custom positioning reference element.
     * @see https://floating-ui.com/docs/virtual-elements
     */

    const sides = ['top', 'right', 'bottom', 'left'];
    const alignments = ['start', 'end'];
    const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
    const min = Math.min;
    const max = Math.max;
    const round = Math.round;
    const createCoords = v => ({
      x: v,
      y: v
    });
    const oppositeSideMap = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    const oppositeAlignmentMap = {
      start: 'end',
      end: 'start'
    };
    function clamp(start, value, end) {
      return max(start, min(value, end));
    }
    function evaluate(value, param) {
      return typeof value === 'function' ? value(param) : value;
    }
    function getSide(placement) {
      return placement.split('-')[0];
    }
    function getAlignment(placement) {
      return placement.split('-')[1];
    }
    function getOppositeAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }
    function getAxisLength(axis) {
      return axis === 'y' ? 'height' : 'width';
    }
    function getSideAxis(placement) {
      return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
    }
    function getAlignmentAxis(placement) {
      return getOppositeAxis(getSideAxis(placement));
    }
    function getAlignmentSides(placement, rects, rtl) {
      if (rtl === void 0) {
        rtl = false;
      }
      const alignment = getAlignment(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const length = getAxisLength(alignmentAxis);
      let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
      if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
      }
      return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
    }
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement(placement);
      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
    }
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
    }
    function getSideList(side, isStart, rtl) {
      const lr = ['left', 'right'];
      const rl = ['right', 'left'];
      const tb = ['top', 'bottom'];
      const bt = ['bottom', 'top'];
      switch (side) {
        case 'top':
        case 'bottom':
          if (rtl) return isStart ? rl : lr;
          return isStart ? lr : rl;
        case 'left':
        case 'right':
          return isStart ? tb : bt;
        default:
          return [];
      }
    }
    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
      const alignment = getAlignment(placement);
      let list = getSideList(getSide(placement), direction === 'start', rtl);
      if (alignment) {
        list = list.map(side => side + "-" + alignment);
        if (flipAlignment) {
          list = list.concat(list.map(getOppositeAlignmentPlacement));
        }
      }
      return list;
    }
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
    }
    function expandPaddingObject(padding) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
      };
    }
    function getPaddingObject(padding) {
      return typeof padding !== 'number' ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
      };
    }
    function rectToClientRect(rect) {
      const {
        x,
        y,
        width,
        height
      } = rect;
      return {
        width,
        height,
        top: y,
        left: x,
        right: x + width,
        bottom: y + height,
        x,
        y
      };
    }

    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let {
        reference,
        floating
      } = _ref;
      const sideAxis = getSideAxis(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const alignLength = getAxisLength(alignmentAxis);
      const side = getSide(placement);
      const isVertical = sideAxis === 'y';
      const commonX = reference.x + reference.width / 2 - floating.width / 2;
      const commonY = reference.y + reference.height / 2 - floating.height / 2;
      const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
      let coords;
      switch (side) {
        case 'top':
          coords = {
            x: commonX,
            y: reference.y - floating.height
          };
          break;
        case 'bottom':
          coords = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;
        case 'right':
          coords = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;
        case 'left':
          coords = {
            x: reference.x - floating.width,
            y: commonY
          };
          break;
        default:
          coords = {
            x: reference.x,
            y: reference.y
          };
      }
      switch (getAlignment(placement)) {
        case 'start':
          coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
          break;
        case 'end':
          coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
          break;
      }
      return coords;
    }

    /**
     * Computes the `x` and `y` coordinates that will place the floating element
     * next to a given reference element.
     *
     * This export does not have any `platform` interface logic. You will need to
     * write one for the platform you are using Floating UI with.
     */
    const computePosition$1 = async (reference, floating, config) => {
      const {
        placement = 'bottom',
        strategy = 'absolute',
        middleware = [],
        platform
      } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
      let rects = await platform.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x,
        y
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i = 0; i < validMiddleware.length; i++) {
        const {
          name,
          fn
        } = validMiddleware[i];
        const {
          x: nextX,
          y: nextY,
          data,
          reset
        } = await fn({
          x,
          y,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform,
          elements: {
            reference,
            floating
          }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === 'object') {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects = reset.rects === true ? await platform.getElementRects({
                reference,
                floating,
                strategy
              }) : reset.rects;
            }
            ({
              x,
              y
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i = -1;
        }
      }
      return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };

    /**
     * Resolves with an object of overflow side offsets that determine how much the
     * element is overflowing a given clipping boundary on each side.
     * - positive = overflowing the boundary by that number of pixels
     * - negative = how many pixels left before it will overflow
     * - 0 = lies flush with the boundary
     * @see https://floating-ui.com/docs/detectOverflow
     */
    async function detectOverflow(state, options) {
      var _await$platform$isEle;
      if (options === void 0) {
        options = {};
      }
      const {
        x,
        y,
        platform,
        rects,
        elements,
        strategy
      } = state;
      const {
        boundary = 'clippingAncestors',
        rootBoundary = 'viewport',
        elementContext = 'floating',
        altBoundary = false,
        padding = 0
      } = evaluate(options, state);
      const paddingObject = getPaddingObject(padding);
      const altContext = elementContext === 'floating' ? 'reference' : 'floating';
      const element = elements[altBoundary ? altContext : elementContext];
      const clippingClientRect = rectToClientRect(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
        boundary,
        rootBoundary,
        strategy
      }));
      const rect = elementContext === 'floating' ? {
        x,
        y,
        width: rects.floating.width,
        height: rects.floating.height
      } : rects.reference;
      const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
      const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
        x: 1,
        y: 1
      } : {
        x: 1,
        y: 1
      };
      const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements,
        rect,
        offsetParent,
        strategy
      }) : rect);
      return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
      };
    }

    /**
     * Provides data to position an inner element of the floating element so that it
     * appears centered to the reference element.
     * @see https://floating-ui.com/docs/arrow
     */
    const arrow = options => ({
      name: 'arrow',
      options,
      async fn(state) {
        const {
          x,
          y,
          placement,
          rects,
          platform,
          elements,
          middlewareData
        } = state;
        // Since `element` is required, we don't Partial<> the type.
        const {
          element,
          padding = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x,
          y
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform.getDimensions(element);
        const isYAxis = axis === 'y';
        const minProp = isYAxis ? 'top' : 'left';
        const maxProp = isYAxis ? 'bottom' : 'right';
        const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

        // DOM platform can return `window` as the `offsetParent`.
        if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;

        // If the padding is large enough that it causes the arrow to no longer be
        // centered, modify the padding so that it is centered.
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

        // Make sure the arrow doesn't overflow the floating element if the center
        // point is outside the floating element's bounds.
        const min$1 = minPadding;
        const max = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset = clamp(min$1, center, max);

        // If the reference is small enough that the arrow's padding causes it to
        // to point to nothing for an aligned placement, adjust the offset of the
        // floating element itself. To ensure `shift()` continues to take action,
        // a single reset is performed when this is true.
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset,
            centerOffset: center - offset - alignmentOffset,
            ...(shouldAddOffset && {
              alignmentOffset
            })
          },
          reset: shouldAddOffset
        };
      }
    });

    function getPlacementList(alignment, autoAlignment, allowedPlacements) {
      const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
      return allowedPlacementsSortedByAlignment.filter(placement => {
        if (alignment) {
          return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
        }
        return true;
      });
    }
    /**
     * Optimizes the visibility of the floating element by choosing the placement
     * that has the most space available automatically, without needing to specify a
     * preferred placement. Alternative to `flip`.
     * @see https://floating-ui.com/docs/autoPlacement
     */
    const autoPlacement$1 = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: 'autoPlacement',
        options,
        async fn(state) {
          var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
          const {
            rects,
            middlewareData,
            placement,
            platform,
            elements
          } = state;
          const {
            crossAxis = false,
            alignment,
            allowedPlacements = placements,
            autoAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
          const currentPlacement = placements$1[currentIndex];
          if (currentPlacement == null) {
            return {};
          }
          const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

          // Make `computeCoords` start from the right place.
          if (placement !== currentPlacement) {
            return {
              reset: {
                placement: placements$1[0]
              }
            };
          }
          const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
          const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
            placement: currentPlacement,
            overflows: currentOverflows
          }];
          const nextPlacement = placements$1[currentIndex + 1];

          // There are more placements to check.
          if (nextPlacement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          const placementsSortedByMostSpace = allOverflows.map(d => {
            const alignment = getAlignment(d.placement);
            return [d.placement, alignment && crossAxis ?
            // Check along the mainAxis and main crossAxis side.
            d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
            // Check only the mainAxis.
            d.overflows[0], d.overflows];
          }).sort((a, b) => a[1] - b[1]);
          const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
          // Aligned placements should not check their opposite crossAxis
          // side.
          getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
          const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
          if (resetPlacement !== placement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: resetPlacement
              }
            };
          }
          return {};
        }
      };
    };

    /**
     * Optimizes the visibility of the floating element by flipping the `placement`
     * in order to keep it in view when the preferred placement(s) will overflow the
     * clipping boundary. Alternative to `autoPlacement`.
     * @see https://floating-ui.com/docs/flip
     */
    const flip = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: 'flip',
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = 'bestFit',
            fallbackAxisSideDirection = 'none',
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);

          // If a reset by the arrow was caused due to an alignment offset being
          // added, we should skip any logic now since `flip()` has already done its
          // work.
          // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];

          // One or more sides is overflowing.
          if (!overflows.every(side => side <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              // Try next placement and re-run the lifecycle.
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }

            // First, find the candidates that fit on the mainAxis side of overflow,
            // then find the placement that fits the best on the main crossAxis side.
            let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

            // Otherwise fallback.
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case 'bestFit':
                  {
                    var _overflowsData$map$so;
                    const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                    if (placement) {
                      resetPlacement = placement;
                    }
                    break;
                  }
                case 'initialPlacement':
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };

    function getSideOffsets(overflow, rect) {
      return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width
      };
    }
    function isAnySideFullyClipped(overflow) {
      return sides.some(side => overflow[side] >= 0);
    }
    /**
     * Provides data to hide the floating element in applicable situations, such as
     * when it is not in the same clipping context as the reference element.
     * @see https://floating-ui.com/docs/hide
     */
    const hide = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: 'hide',
        options,
        async fn(state) {
          const {
            rects
          } = state;
          const {
            strategy = 'referenceHidden',
            ...detectOverflowOptions
          } = evaluate(options, state);
          switch (strategy) {
            case 'referenceHidden':
              {
                const overflow = await detectOverflow(state, {
                  ...detectOverflowOptions,
                  elementContext: 'reference'
                });
                const offsets = getSideOffsets(overflow, rects.reference);
                return {
                  data: {
                    referenceHiddenOffsets: offsets,
                    referenceHidden: isAnySideFullyClipped(offsets)
                  }
                };
              }
            case 'escaped':
              {
                const overflow = await detectOverflow(state, {
                  ...detectOverflowOptions,
                  altBoundary: true
                });
                const offsets = getSideOffsets(overflow, rects.floating);
                return {
                  data: {
                    escapedOffsets: offsets,
                    escaped: isAnySideFullyClipped(offsets)
                  }
                };
              }
            default:
              {
                return {};
              }
          }
        }
      };
    };

    function getBoundingRect(rects) {
      const minX = min(...rects.map(rect => rect.left));
      const minY = min(...rects.map(rect => rect.top));
      const maxX = max(...rects.map(rect => rect.right));
      const maxY = max(...rects.map(rect => rect.bottom));
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    function getRectsByLine(rects) {
      const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
      const groups = [];
      let prevRect = null;
      for (let i = 0; i < sortedRects.length; i++) {
        const rect = sortedRects[i];
        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
          groups.push([rect]);
        } else {
          groups[groups.length - 1].push(rect);
        }
        prevRect = rect;
      }
      return groups.map(rect => rectToClientRect(getBoundingRect(rect)));
    }
    /**
     * Provides improved positioning for inline reference elements that can span
     * over multiple lines, such as hyperlinks or range selections.
     * @see https://floating-ui.com/docs/inline
     */
    const inline = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: 'inline',
        options,
        async fn(state) {
          const {
            placement,
            elements,
            rects,
            platform,
            strategy
          } = state;
          // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
          // ClientRect's bounds, despite the event listener being triggered. A
          // padding of 2 seems to handle this issue.
          const {
            padding = 2,
            x,
            y
          } = evaluate(options, state);
          const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);
          const clientRects = getRectsByLine(nativeClientRects);
          const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
          const paddingObject = getPaddingObject(padding);
          function getBoundingClientRect() {
            // There are two rects and they are disjoined.
            if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
              // Find the first rect in which the point is fully inside.
              return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
            }

            // There are 2 or more connected rects.
            if (clientRects.length >= 2) {
              if (getSideAxis(placement) === 'y') {
                const firstRect = clientRects[0];
                const lastRect = clientRects[clientRects.length - 1];
                const isTop = getSide(placement) === 'top';
                const top = firstRect.top;
                const bottom = lastRect.bottom;
                const left = isTop ? firstRect.left : lastRect.left;
                const right = isTop ? firstRect.right : lastRect.right;
                const width = right - left;
                const height = bottom - top;
                return {
                  top,
                  bottom,
                  left,
                  right,
                  width,
                  height,
                  x: left,
                  y: top
                };
              }
              const isLeftSide = getSide(placement) === 'left';
              const maxRight = max(...clientRects.map(rect => rect.right));
              const minLeft = min(...clientRects.map(rect => rect.left));
              const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
              const top = measureRects[0].top;
              const bottom = measureRects[measureRects.length - 1].bottom;
              const left = minLeft;
              const right = maxRight;
              const width = right - left;
              const height = bottom - top;
              return {
                top,
                bottom,
                left,
                right,
                width,
                height,
                x: left,
                y: top
              };
            }
            return fallback;
          }
          const resetRects = await platform.getElementRects({
            reference: {
              getBoundingClientRect
            },
            floating: elements.floating,
            strategy
          });
          if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
            return {
              reset: {
                rects: resetRects
              }
            };
          }
          return {};
        }
      };
    };

    // For type backwards-compatibility, the `OffsetOptions` type was also
    // Derivable.

    async function convertValueToCoords(state, options) {
      const {
        placement,
        platform,
        elements
      } = state;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isVertical = getSideAxis(placement) === 'y';
      const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = evaluate(options, state);

      // eslint-disable-next-line prefer-const
      let {
        mainAxis,
        crossAxis,
        alignmentAxis
      } = typeof rawValue === 'number' ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
      } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
      };
      if (alignment && typeof alignmentAxis === 'number') {
        crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
      } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
      };
    }

    /**
     * Modifies the placement by translating the floating element along the
     * specified axes.
     * A number (shorthand for `mainAxis` or distance), or an axes configuration
     * object may be passed.
     * @see https://floating-ui.com/docs/offset
     */
    const offset$1 = function (options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: 'offset',
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x,
            y,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);

          // If the placement is the same and the arrow caused an alignment offset
          // then we don't need to change the positioning coordinates.
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x + diffCoords.x,
            y: y + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };

    /**
     * Optimizes the visibility of the floating element by shifting it in order to
     * keep it in view when it will overflow the clipping boundary.
     * @see https://floating-ui.com/docs/shift
     */
    const shift = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: 'shift',
        options,
        async fn(state) {
          const {
            x,
            y,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: _ref => {
                let {
                  x,
                  y
                } = _ref;
                return {
                  x,
                  y
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const coords = {
            x,
            y
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === 'y' ? 'top' : 'left';
            const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
            const min = mainAxisCoord + overflow[minSide];
            const max = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min, mainAxisCoord, max);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === 'y' ? 'top' : 'left';
            const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
            const min = crossAxisCoord + overflow[minSide];
            const max = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min, crossAxisCoord, max);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x,
              y: limitedCoords.y - y
            }
          };
        }
      };
    };
    /**
     * Built-in `limiter` that will stop `shift()` at a certain point.
     */
    const limitShift = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        options,
        fn(state) {
          const {
            x,
            y,
            placement,
            rects,
            middlewareData
          } = state;
          const {
            offset = 0,
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true
          } = evaluate(options, state);
          const coords = {
            x,
            y
          };
          const crossAxis = getSideAxis(placement);
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          const rawOffset = evaluate(offset, state);
          const computedOffset = typeof rawOffset === 'number' ? {
            mainAxis: rawOffset,
            crossAxis: 0
          } : {
            mainAxis: 0,
            crossAxis: 0,
            ...rawOffset
          };
          if (checkMainAxis) {
            const len = mainAxis === 'y' ? 'height' : 'width';
            const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
            const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
            if (mainAxisCoord < limitMin) {
              mainAxisCoord = limitMin;
            } else if (mainAxisCoord > limitMax) {
              mainAxisCoord = limitMax;
            }
          }
          if (checkCrossAxis) {
            var _middlewareData$offse, _middlewareData$offse2;
            const len = mainAxis === 'y' ? 'width' : 'height';
            const isOriginSide = ['top', 'left'].includes(getSide(placement));
            const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
            const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
            if (crossAxisCoord < limitMin) {
              crossAxisCoord = limitMin;
            } else if (crossAxisCoord > limitMax) {
              crossAxisCoord = limitMax;
            }
          }
          return {
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          };
        }
      };
    };

    /**
     * Provides data that allows you to change the size of the floating element —
     * for instance, prevent it from overflowing the clipping boundary or match the
     * width of the reference element.
     * @see https://floating-ui.com/docs/size
     */
    const size = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: 'size',
        options,
        async fn(state) {
          const {
            placement,
            rects,
            platform,
            elements
          } = state;
          const {
            apply = () => {},
            ...detectOverflowOptions
          } = evaluate(options, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === 'y';
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === 'top' || side === 'bottom') {
            heightSide = side;
            widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
          } else {
            widthSide = side;
            heightSide = alignment === 'end' ? 'top' : 'bottom';
          }
          const overflowAvailableHeight = height - overflow[heightSide];
          const overflowAvailableWidth = width - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            const maximumClippingWidth = width - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };

    function getNodeName(node) {
      if (isNode(node)) {
        return (node.nodeName || '').toLowerCase();
      }
      // Mocked nodes in testing environments may not be instances of Node. By
      // returning `#document` an infinite loop won't occur.
      // https://github.com/floating-ui/floating-ui/issues/2317
      return '#document';
    }
    function getWindow(node) {
      var _node$ownerDocument;
      return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
    }
    function getDocumentElement(node) {
      var _ref;
      return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
    }
    function isNode(value) {
      return value instanceof Node || value instanceof getWindow(value).Node;
    }
    function isElement(value) {
      return value instanceof Element || value instanceof getWindow(value).Element;
    }
    function isHTMLElement(value) {
      return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
    }
    function isShadowRoot(value) {
      // Browsers without `ShadowRoot` support.
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }
      return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
    }
    function isOverflowElement(element) {
      const {
        overflow,
        overflowX,
        overflowY,
        display
      } = getComputedStyle(element);
      return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
    }
    function isTableElement(element) {
      return ['table', 'td', 'th'].includes(getNodeName(element));
    }
    function isContainingBlock(element) {
      const webkit = isWebKit();
      const css = getComputedStyle(element);

      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
      return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
    }
    function getContainingBlock(element) {
      let currentNode = getParentNode(element);
      while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
        if (isContainingBlock(currentNode)) {
          return currentNode;
        }
        currentNode = getParentNode(currentNode);
      }
      return null;
    }
    function isWebKit() {
      if (typeof CSS === 'undefined' || !CSS.supports) return false;
      return CSS.supports('-webkit-backdrop-filter', 'none');
    }
    function isLastTraversableNode(node) {
      return ['html', 'body', '#document'].includes(getNodeName(node));
    }
    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function getNodeScroll(element) {
      if (isElement(element)) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
        };
      }
      return {
        scrollLeft: element.pageXOffset,
        scrollTop: element.pageYOffset
      };
    }
    function getParentNode(node) {
      if (getNodeName(node) === 'html') {
        return node;
      }
      const result =
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot ||
      // DOM Element detected.
      node.parentNode ||
      // ShadowRoot detected.
      isShadowRoot(node) && node.host ||
      // Fallback.
      getDocumentElement(node);
      return isShadowRoot(result) ? result.host : result;
    }
    function getNearestOverflowAncestor(node) {
      const parentNode = getParentNode(node);
      if (isLastTraversableNode(parentNode)) {
        return node.ownerDocument ? node.ownerDocument.body : node.body;
      }
      if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
      }
      return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list, traverseIframes) {
      var _node$ownerDocument2;
      if (list === void 0) {
        list = [];
      }
      if (traverseIframes === void 0) {
        traverseIframes = true;
      }
      const scrollableAncestor = getNearestOverflowAncestor(node);
      const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
      const win = getWindow(scrollableAncestor);
      if (isBody) {
        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
      }
      return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
    }

    function getCssDimensions(element) {
      const css = getComputedStyle(element);
      // In testing environments, the `width` and `height` properties are empty
      // strings for SVG elements, returning NaN. Fallback to `0` in this case.
      let width = parseFloat(css.width) || 0;
      let height = parseFloat(css.height) || 0;
      const hasOffset = isHTMLElement(element);
      const offsetWidth = hasOffset ? element.offsetWidth : width;
      const offsetHeight = hasOffset ? element.offsetHeight : height;
      const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
      if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
      }
      return {
        width,
        height,
        $: shouldFallback
      };
    }

    function unwrapElement(element) {
      return !isElement(element) ? element.contextElement : element;
    }

    function getScale(element) {
      const domElement = unwrapElement(element);
      if (!isHTMLElement(domElement)) {
        return createCoords(1);
      }
      const rect = domElement.getBoundingClientRect();
      const {
        width,
        height,
        $
      } = getCssDimensions(domElement);
      let x = ($ ? round(rect.width) : rect.width) / width;
      let y = ($ ? round(rect.height) : rect.height) / height;

      // 0, NaN, or Infinity should always fallback to 1.

      if (!x || !Number.isFinite(x)) {
        x = 1;
      }
      if (!y || !Number.isFinite(y)) {
        y = 1;
      }
      return {
        x,
        y
      };
    }

    const noOffsets = /*#__PURE__*/createCoords(0);
    function getVisualOffsets(element) {
      const win = getWindow(element);
      if (!isWebKit() || !win.visualViewport) {
        return noOffsets;
      }
      return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
      };
    }
    function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
        return false;
      }
      return isFixed;
    }

    function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      const clientRect = element.getBoundingClientRect();
      const domElement = unwrapElement(element);
      let scale = createCoords(1);
      if (includeScale) {
        if (offsetParent) {
          if (isElement(offsetParent)) {
            scale = getScale(offsetParent);
          }
        } else {
          scale = getScale(element);
        }
      }
      const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
      let x = (clientRect.left + visualOffsets.x) / scale.x;
      let y = (clientRect.top + visualOffsets.y) / scale.y;
      let width = clientRect.width / scale.x;
      let height = clientRect.height / scale.y;
      if (domElement) {
        const win = getWindow(domElement);
        const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
        let currentWin = win;
        let currentIFrame = currentWin.frameElement;
        while (currentIFrame && offsetParent && offsetWin !== currentWin) {
          const iframeScale = getScale(currentIFrame);
          const iframeRect = currentIFrame.getBoundingClientRect();
          const css = getComputedStyle(currentIFrame);
          const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
          const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
          x *= iframeScale.x;
          y *= iframeScale.y;
          width *= iframeScale.x;
          height *= iframeScale.y;
          x += left;
          y += top;
          currentWin = getWindow(currentIFrame);
          currentIFrame = currentWin.frameElement;
        }
      }
      return rectToClientRect({
        width,
        height,
        x,
        y
      });
    }

    const topLayerSelectors = [':popover-open', ':modal'];
    function isTopLayer(floating) {
      return topLayerSelectors.some(selector => {
        try {
          return floating.matches(selector);
        } catch (e) {
          return false;
        }
      });
    }

    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
      let {
        elements,
        rect,
        offsetParent,
        strategy
      } = _ref;
      const isFixed = strategy === 'fixed';
      const documentElement = getDocumentElement(offsetParent);
      const topLayer = elements ? isTopLayer(elements.floating) : false;
      if (offsetParent === documentElement || topLayer && isFixed) {
        return rect;
      }
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      let scale = createCoords(1);
      const offsets = createCoords(0);
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          const offsetRect = getBoundingClientRect(offsetParent);
          scale = getScale(offsetParent);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        }
      }
      return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
      };
    }

    function getClientRects(element) {
      return Array.from(element.getClientRects());
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
    }

    // Gets the entire size of the scrollable document area, even extending outside
    // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
    function getDocumentRect(element) {
      const html = getDocumentElement(element);
      const scroll = getNodeScroll(element);
      const body = element.ownerDocument.body;
      const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
      const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
      let x = -scroll.scrollLeft + getWindowScrollBarX(element);
      const y = -scroll.scrollTop;
      if (getComputedStyle(body).direction === 'rtl') {
        x += max(html.clientWidth, body.clientWidth) - width;
      }
      return {
        width,
        height,
        x,
        y
      };
    }

    function getViewportRect(element, strategy) {
      const win = getWindow(element);
      const html = getDocumentElement(element);
      const visualViewport = win.visualViewport;
      let width = html.clientWidth;
      let height = html.clientHeight;
      let x = 0;
      let y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = isWebKit();
        if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x,
        y
      };
    }

    // Returns the inner client rect, subtracting scrollbars if present.
    function getInnerBoundingClientRect(element, strategy) {
      const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
      const top = clientRect.top + element.clientTop;
      const left = clientRect.left + element.clientLeft;
      const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
      const width = element.clientWidth * scale.x;
      const height = element.clientHeight * scale.y;
      const x = left * scale.x;
      const y = top * scale.y;
      return {
        width,
        height,
        x,
        y
      };
    }
    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
      let rect;
      if (clippingAncestor === 'viewport') {
        rect = getViewportRect(element, strategy);
      } else if (clippingAncestor === 'document') {
        rect = getDocumentRect(getDocumentElement(element));
      } else if (isElement(clippingAncestor)) {
        rect = getInnerBoundingClientRect(clippingAncestor, strategy);
      } else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
          ...clippingAncestor,
          x: clippingAncestor.x - visualOffsets.x,
          y: clippingAncestor.y - visualOffsets.y
        };
      }
      return rectToClientRect(rect);
    }
    function hasFixedPositionAncestor(element, stopNode) {
      const parentNode = getParentNode(element);
      if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
        return false;
      }
      return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
    }

    // A "clipping ancestor" is an `overflow` element with the characteristic of
    // clipping (or hiding) child elements. This returns all clipping ancestors
    // of the given element up the tree.
    function getClippingElementAncestors(element, cache) {
      const cachedResult = cache.get(element);
      if (cachedResult) {
        return cachedResult;
      }
      let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
      let currentContainingBlockComputedStyle = null;
      const elementIsFixed = getComputedStyle(element).position === 'fixed';
      let currentNode = elementIsFixed ? getParentNode(element) : element;

      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
      while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
        const computedStyle = getComputedStyle(currentNode);
        const currentNodeIsContaining = isContainingBlock(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
          currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) {
          // Drop non-containing blocks.
          result = result.filter(ancestor => ancestor !== currentNode);
        } else {
          // Record last containing block for next iteration.
          currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = getParentNode(currentNode);
      }
      cache.set(element, result);
      return result;
    }

    // Gets the maximum area that the element is visible in due to any number of
    // clipping ancestors.
    function getClippingRect(_ref) {
      let {
        element,
        boundary,
        rootBoundary,
        strategy
      } = _ref;
      const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
      const clippingAncestors = [...elementClippingAncestors, rootBoundary];
      const firstClippingAncestor = clippingAncestors[0];
      const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
      return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
      };
    }

    function getDimensions(element) {
      const {
        width,
        height
      } = getCssDimensions(element);
      return {
        width,
        height
      };
    }

    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      const isFixed = strategy === 'fixed';
      const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets = createCoords(0);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isOffsetParentAnElement) {
          const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      const x = rect.left + scroll.scrollLeft - offsets.x;
      const y = rect.top + scroll.scrollTop - offsets.y;
      return {
        x,
        y,
        width: rect.width,
        height: rect.height
      };
    }

    function getTrueOffsetParent(element, polyfill) {
      if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
        return null;
      }
      if (polyfill) {
        return polyfill(element);
      }
      return element.offsetParent;
    }

    // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.
    function getOffsetParent(element, polyfill) {
      const window = getWindow(element);
      if (!isHTMLElement(element) || isTopLayer(element)) {
        return window;
      }
      let offsetParent = getTrueOffsetParent(element, polyfill);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
      }
      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
        return window;
      }
      return offsetParent || getContainingBlock(element) || window;
    }

    const getElementRects = async function (data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      const floatingDimensions = await getDimensionsFn(data.floating);
      return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
          x: 0,
          y: 0,
          width: floatingDimensions.width,
          height: floatingDimensions.height
        }
      };
    };

    function isRTL(element) {
      return getComputedStyle(element).direction === 'rtl';
    }

    const platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement,
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement,
      isRTL
    };

    /**
     * Modifies the placement by translating the floating element along the
     * specified axes.
     * A number (shorthand for `mainAxis` or distance), or an axes configuration
     * object may be passed.
     * @see https://floating-ui.com/docs/offset
     */
    const offset = offset$1;

    /**
     * Optimizes the visibility of the floating element by choosing the placement
     * that has the most space available automatically, without needing to specify a
     * preferred placement. Alternative to `flip`.
     * @see https://floating-ui.com/docs/autoPlacement
     */
    const autoPlacement = autoPlacement$1;

    /**
     * Optimizes the visibility of the floating element by shifting it in order to
     * keep it in view when it will overflow the clipping boundary.
     * @see https://floating-ui.com/docs/shift
     */
    shift;

    /**
     * Optimizes the visibility of the floating element by flipping the `placement`
     * in order to keep it in view when the preferred placement(s) will overflow the
     * clipping boundary. Alternative to `autoPlacement`.
     * @see https://floating-ui.com/docs/flip
     */
    flip;

    /**
     * Provides data that allows you to change the size of the floating element —
     * for instance, prevent it from overflowing the clipping boundary or match the
     * width of the reference element.
     * @see https://floating-ui.com/docs/size
     */
    size;

    /**
     * Provides data to hide the floating element in applicable situations, such as
     * when it is not in the same clipping context as the reference element.
     * @see https://floating-ui.com/docs/hide
     */
    hide;

    /**
     * Provides data to position an inner element of the floating element so that it
     * appears centered to the reference element.
     * @see https://floating-ui.com/docs/arrow
     */
    arrow;

    /**
     * Provides improved positioning for inline reference elements that can span
     * over multiple lines, such as hyperlinks or range selections.
     * @see https://floating-ui.com/docs/inline
     */
    inline;

    /**
     * Built-in `limiter` that will stop `shift()` at a certain point.
     */
    limitShift;

    /**
     * Computes the `x` and `y` coordinates that will place the floating element
     * next to a given reference element.
     */
    const computePosition = (reference, floating, options) => {
      // This caches the expensive `getClippingElementAncestors` function so that
      // multiple lifecycle resets re-use the same result. It only lives for a
      // single call. If other functions become expensive, we can add them as well.
      const cache = new Map();
      const mergedOptions = {
        platform,
        ...options
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
      };
      return computePosition$1(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };

    /* src/App.svelte generated by Svelte v3.42.4 */

    const { console: console_1 } = globals$1;
    const file = "src/App.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[39] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[39] = list[i];
    	return child_ctx;
    }

    // (382:2) {#each features as feature}
    function create_each_block_2(ctx) {
    	let option;
    	let t_value = /*feature*/ ctx[39].properties.municipal + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*feature*/ ctx[39].properties.muni_id;
    			option.value = option.__value;
    			add_location(option, file, 382, 3, 11123);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*features*/ 8192 && t_value !== (t_value = /*feature*/ ctx[39].properties.municipal + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*features*/ 8192 && option_value_value !== (option_value_value = /*feature*/ ctx[39].properties.muni_id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(382:2) {#each features as feature}",
    		ctx
    	});

    	return block;
    }

    // (388:2) {#each features as feature}
    function create_each_block_1(ctx) {
    	let option;
    	let t_value = /*feature*/ ctx[39].properties.municipal + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*feature*/ ctx[39].properties.muni_id;
    			option.value = option.__value;
    			add_location(option, file, 388, 3, 11335);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*features*/ 8192 && t_value !== (t_value = /*feature*/ ctx[39].properties.municipal + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*features*/ 8192 && option_value_value !== (option_value_value = /*feature*/ ctx[39].properties.muni_id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(388:2) {#each features as feature}",
    		ctx
    	});

    	return block;
    }

    // (401:1) {:else}
    function create_else_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$5,
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(401:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (392:1) {#if counterfactualHousing}
    function create_if_block_4(ctx) {
    	let t;
    	let button;
    	let icon_1;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*counterfactualHousing*/ ctx[10] >= 0) return create_if_block_5;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	icon_1 = new Icon({
    			props: {
    				class: "resetIcon",
    				icon: /*icon*/ ctx[14]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    			button = element("button");
    			create_component(icon_1.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "id", "resetButton");
    			attr_dev(button, "class", "svelte-a7490r");
    			add_location(button, file, 397, 2, 11646);
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button, anchor);
    			mount_component(icon_1, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button);
    			destroy_component(icon_1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(392:1) {#if counterfactualHousing}",
    		ctx
    	});

    	return block;
    }

    // (395:2) {:else}
    function create_else_block_1(ctx) {
    	let t0;
    	let b;
    	let t1;
    	let t2_value = -/*counterfactualHousing*/ ctx[10] + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			t0 = text$1("we would ");
    			b = element("b");
    			t1 = text$1("displace ");
    			t2 = text$1(t2_value);
    			t3 = text$1(" people.");
    			add_location(b, file, 395, 12, 11587);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, b, anchor);
    			append_dev(b, t1);
    			append_dev(b, t2);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*counterfactualHousing*/ 1024 && t2_value !== (t2_value = -/*counterfactualHousing*/ ctx[10] + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(b);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(395:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (393:2) {#if counterfactualHousing >= 0}
    function create_if_block_5(ctx) {
    	let t0;
    	let b;
    	let t1;
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			t0 = text$1("we would ");
    			b = element("b");
    			t1 = text$1("house ");
    			t2 = text$1(/*counterfactualHousing*/ ctx[10]);
    			t3 = text$1(" more people.");
    			add_location(b, file, 393, 12, 11515);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, b, anchor);
    			append_dev(b, t1);
    			append_dev(b, t2);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*counterfactualHousing*/ 1024) set_data_dev(t2, /*counterfactualHousing*/ ctx[10]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(b);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(393:2) {#if counterfactualHousing >= 0}",
    		ctx
    	});

    	return block;
    }

    // (422:1) {:else}
    function create_else_block(ctx) {
    	let div5;
    	let h4;
    	let t1;
    	let p;
    	let t3;
    	let div0;
    	let span0;
    	let t4;
    	let t5;
    	let div1;
    	let span1;
    	let t6;
    	let t7;
    	let div2;
    	let span2;
    	let t8;
    	let t9;
    	let div3;
    	let span3;
    	let t10;
    	let t11;
    	let div4;
    	let span4;
    	let t12;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Zoned Density";
    			t1 = space();
    			p = element("p");
    			p.textContent = "(dwelling units per acre)";
    			t3 = space();
    			div0 = element("div");
    			span0 = element("span");
    			t4 = text$1("0.00-1.99");
    			t5 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t6 = text$1("1.99-3.00");
    			t7 = space();
    			div2 = element("div");
    			span2 = element("span");
    			t8 = text$1("3.00-4.51");
    			t9 = space();
    			div3 = element("div");
    			span3 = element("span");
    			t10 = text$1("4.51-6.17");
    			t11 = space();
    			div4 = element("div");
    			span4 = element("span");
    			t12 = text$1("6.17-51.50");
    			attr_dev(h4, "class", "svelte-a7490r");
    			add_location(h4, file, 424, 2, 12829);
    			attr_dev(p, "class", "svelte-a7490r");
    			add_location(p, file, 424, 25, 12852);
    			set_style(span0, "background-color", "#a8dbd9");
    			attr_dev(span0, "class", "svelte-a7490r");
    			add_location(span0, file, 425, 7, 12892);
    			add_location(div0, file, 425, 2, 12887);
    			set_style(span1, "background-color", "#85c4c9");
    			attr_dev(span1, "class", "svelte-a7490r");
    			add_location(span1, file, 426, 7, 12962);
    			add_location(div1, file, 426, 2, 12957);
    			set_style(span2, "background-color", "#68abb8");
    			attr_dev(span2, "class", "svelte-a7490r");
    			add_location(span2, file, 427, 7, 13032);
    			add_location(div2, file, 427, 2, 13027);
    			set_style(span3, "background-color", "#4f90a6");
    			attr_dev(span3, "class", "svelte-a7490r");
    			add_location(span3, file, 428, 7, 13102);
    			add_location(div3, file, 428, 2, 13097);
    			set_style(span4, "background-color", "#3b738f");
    			attr_dev(span4, "class", "svelte-a7490r");
    			add_location(span4, file, 429, 7, 13172);
    			add_location(div4, file, 429, 2, 13167);
    			add_location(div5, file, 422, 1, 12704);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, h4);
    			append_dev(div5, t1);
    			append_dev(div5, p);
    			append_dev(div5, t3);
    			append_dev(div5, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t4);
    			append_dev(div5, t5);
    			append_dev(div5, div1);
    			append_dev(div1, span1);
    			append_dev(div1, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div2);
    			append_dev(div2, span2);
    			append_dev(div2, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, span3);
    			append_dev(div3, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, span4);
    			append_dev(div4, t12);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div5, "outrostart", outrostart_handler_1, false, false, false),
    					listen_dev(div5, "introstart", introstart_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(422:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (412:1) {#if visFeature === "dwellingDensity"}
    function create_if_block_3(ctx) {
    	let div5;
    	let h4;
    	let t1;
    	let p;
    	let t3;
    	let div0;
    	let span0;
    	let t4;
    	let t5;
    	let div1;
    	let span1;
    	let t6;
    	let t7;
    	let div2;
    	let span2;
    	let t8;
    	let t9;
    	let div3;
    	let span3;
    	let t10;
    	let t11;
    	let div4;
    	let span4;
    	let t12;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Density";
    			t1 = space();
    			p = element("p");
    			p.textContent = "(dwelling units per acre)";
    			t3 = space();
    			div0 = element("div");
    			span0 = element("span");
    			t4 = text$1("0.00-1.13");
    			t5 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t6 = text$1("1.13-1.22");
    			t7 = space();
    			div2 = element("div");
    			span2 = element("span");
    			t8 = text$1("1.22-1.38");
    			t9 = space();
    			div3 = element("div");
    			span3 = element("span");
    			t10 = text$1("1.38-1.63");
    			t11 = space();
    			div4 = element("div");
    			span4 = element("span");
    			t12 = text$1("1.63-3.40");
    			attr_dev(h4, "class", "svelte-a7490r");
    			add_location(h4, file, 414, 2, 12286);
    			attr_dev(p, "class", "svelte-a7490r");
    			add_location(p, file, 414, 19, 12303);
    			set_style(span0, "background-color", "#a8dbd9");
    			attr_dev(span0, "class", "svelte-a7490r");
    			add_location(span0, file, 415, 7, 12343);
    			add_location(div0, file, 415, 2, 12338);
    			set_style(span1, "background-color", "#85c4c9");
    			attr_dev(span1, "class", "svelte-a7490r");
    			add_location(span1, file, 416, 7, 12413);
    			add_location(div1, file, 416, 2, 12408);
    			set_style(span2, "background-color", "#68abb8");
    			attr_dev(span2, "class", "svelte-a7490r");
    			add_location(span2, file, 417, 7, 12483);
    			add_location(div2, file, 417, 2, 12478);
    			set_style(span3, "background-color", "#4f90a6");
    			attr_dev(span3, "class", "svelte-a7490r");
    			add_location(span3, file, 418, 7, 12553);
    			add_location(div3, file, 418, 2, 12548);
    			set_style(span4, "background-color", "#3b738f");
    			attr_dev(span4, "class", "svelte-a7490r");
    			add_location(span4, file, 419, 7, 12623);
    			add_location(div4, file, 419, 2, 12618);
    			add_location(div5, file, 412, 1, 12161);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, h4);
    			append_dev(div5, t1);
    			append_dev(div5, p);
    			append_dev(div5, t3);
    			append_dev(div5, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t4);
    			append_dev(div5, t5);
    			append_dev(div5, div1);
    			append_dev(div1, span1);
    			append_dev(div1, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div2);
    			append_dev(div2, span2);
    			append_dev(div2, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div3, span3);
    			append_dev(div3, t10);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			append_dev(div4, span4);
    			append_dev(div4, t12);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div5, "outrostart", outrostart_handler, false, false, false),
    					listen_dev(div5, "introstart", introstart_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(412:1) {#if visFeature === \\\"dwellingDensity\\\"}",
    		ctx
    	});

    	return block;
    }

    // (435:0) {#if dataLookup != {} && sourceMuni && targetMuni}
    function create_if_block_1(ctx) {
    	let svg;
    	let style;
    	let t;
    	let previous_key = /*mapViewChanged*/ ctx[6];
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			style = svg_element("style");
    			t = text$1(".text {\n\t\t\t\tfont: 16px sans-serif;\n\t\t\t}\n\t\t");
    			key_block.c();
    			add_location(style, file, 436, 2, 13347);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100vh");
    			attr_dev(svg, "class", "svelte-a7490r");
    			add_location(svg, file, 435, 1, 13311);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, style);
    			append_dev(style, t);
    			key_block.m(svg, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*mapViewChanged*/ 64 && safe_not_equal(previous_key, previous_key = /*mapViewChanged*/ ctx[6])) {
    				key_block.d(1);
    				key_block = create_key_block(ctx);
    				key_block.c();
    				key_block.m(svg, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(435:0) {#if dataLookup != {} && sourceMuni && targetMuni}",
    		ctx
    	});

    	return block;
    }

    // (444:5) {#if centroid.properties.muni_id == sourceMuni || centroid.properties.muni_id == targetMuni}
    function create_if_block_2(ctx) {
    	let text_1;
    	let t_value = /*centroid*/ ctx[36].properties.municipal + "";
    	let t;

    	let text_1_levels = [
    		{ class: "text" },
    		{ "dominant-baseline": "middle" },
    		{ "text-anchor": "middle" },
    		/*projectCentroid*/ ctx[15](/*centroid*/ ctx[36].geometry.coordinates)
    	];

    	let text_1_data = {};

    	for (let i = 0; i < text_1_levels.length; i += 1) {
    		text_1_data = assign(text_1_data, text_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			text_1 = svg_element("text");
    			t = text$1(t_value);
    			set_svg_attributes(text_1, text_1_data);
    			toggle_class(text_1, "svelte-a7490r", true);
    			add_location(text_1, file, 444, 6, 13572);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, text_1, anchor);
    			append_dev(text_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*centroids*/ 4096 && t_value !== (t_value = /*centroid*/ ctx[36].properties.municipal + "")) set_data_dev(t, t_value);

    			set_svg_attributes(text_1, text_1_data = get_spread_update(text_1_levels, [
    				{ class: "text" },
    				{ "dominant-baseline": "middle" },
    				{ "text-anchor": "middle" },
    				dirty[0] & /*centroids*/ 4096 && /*projectCentroid*/ ctx[15](/*centroid*/ ctx[36].geometry.coordinates)
    			]));

    			toggle_class(text_1, "svelte-a7490r", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(text_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(444:5) {#if centroid.properties.muni_id == sourceMuni || centroid.properties.muni_id == targetMuni}",
    		ctx
    	});

    	return block;
    }

    // (443:4) {#each centroids as centroid}
    function create_each_block(ctx) {
    	let if_block_anchor;
    	let if_block = (/*centroid*/ ctx[36].properties.muni_id == /*sourceMuni*/ ctx[3] || /*centroid*/ ctx[36].properties.muni_id == /*targetMuni*/ ctx[2]) && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*centroid*/ ctx[36].properties.muni_id == /*sourceMuni*/ ctx[3] || /*centroid*/ ctx[36].properties.muni_id == /*targetMuni*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(443:4) {#each centroids as centroid}",
    		ctx
    	});

    	return block;
    }

    // (442:3) {#key mapViewChanged}
    function create_key_block(ctx) {
    	let each_1_anchor;
    	let each_value = /*centroids*/ ctx[12];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*projectCentroid, centroids, sourceMuni, targetMuni*/ 36876) {
    				each_value = /*centroids*/ ctx[12];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(442:3) {#key mapViewChanged}",
    		ctx
    	});

    	return block;
    }

    // (460:1) {#if hoveredProperties && hoveredData}
    function create_if_block(ctx) {
    	let dt0;
    	let dd0;
    	let t1_value = /*hoveredProperties*/ ctx[0].municipal + "";
    	let t1;
    	let dt1;
    	let dd1;
    	let t3_value = /*hoveredProperties*/ ctx[0].pop + "";
    	let t3;
    	let dt2;
    	let dd2;
    	let t5_value = /*hoveredProperties*/ ctx[0].area.toFixed(2) + "";
    	let t5;
    	let sup;
    	let t7;
    	let dt3;
    	let dd3;
    	let t9_value = /*hoveredProperties*/ ctx[0].density.toFixed(2) + "";
    	let t9;
    	let dt4;
    	let dd4;
    	let t11_value = /*hoveredProperties*/ ctx[0].zonedDensity.toFixed(2) + "";
    	let t11;

    	const block = {
    		c: function create() {
    			dt0 = element("dt");
    			dt0.textContent = "Municipality";
    			dd0 = element("dd");
    			t1 = text$1(t1_value);
    			dt1 = element("dt");
    			dt1.textContent = "Population";
    			dd1 = element("dd");
    			t3 = text$1(t3_value);
    			dt2 = element("dt");
    			dt2.textContent = "Area";
    			dd2 = element("dd");
    			t5 = text$1(t5_value);
    			sup = element("sup");
    			sup.textContent = "2";
    			t7 = space();
    			dt3 = element("dt");
    			dt3.textContent = "Average Density";
    			dd3 = element("dd");
    			t9 = text$1(t9_value);
    			dt4 = element("dt");
    			dt4.textContent = "Zoned Density";
    			dd4 = element("dd");
    			t11 = text$1(t11_value);
    			attr_dev(dt0, "class", "svelte-a7490r");
    			add_location(dt0, file, 460, 2, 13963);
    			attr_dev(dd0, "class", "svelte-a7490r");
    			add_location(dd0, file, 461, 2, 13987);
    			attr_dev(dt1, "class", "svelte-a7490r");
    			add_location(dt1, file, 463, 2, 14029);
    			attr_dev(dd1, "class", "svelte-a7490r");
    			add_location(dd1, file, 464, 2, 14051);
    			attr_dev(dt2, "class", "svelte-a7490r");
    			add_location(dt2, file, 466, 2, 14087);
    			add_location(sup, file, 467, 41, 14142);
    			attr_dev(dd2, "class", "svelte-a7490r");
    			add_location(dd2, file, 467, 2, 14103);
    			attr_dev(dt3, "class", "svelte-a7490r");
    			add_location(dt3, file, 469, 2, 14164);
    			attr_dev(dd3, "class", "svelte-a7490r");
    			add_location(dd3, file, 470, 2, 14191);
    			attr_dev(dt4, "class", "svelte-a7490r");
    			add_location(dt4, file, 472, 2, 14242);
    			attr_dev(dd4, "class", "svelte-a7490r");
    			add_location(dd4, file, 473, 2, 14267);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, dt0, anchor);
    			insert_dev(target, dd0, anchor);
    			append_dev(dd0, t1);
    			insert_dev(target, dt1, anchor);
    			insert_dev(target, dd1, anchor);
    			append_dev(dd1, t3);
    			insert_dev(target, dt2, anchor);
    			insert_dev(target, dd2, anchor);
    			append_dev(dd2, t5);
    			append_dev(dd2, sup);
    			append_dev(dd2, t7);
    			insert_dev(target, dt3, anchor);
    			insert_dev(target, dd3, anchor);
    			append_dev(dd3, t9);
    			insert_dev(target, dt4, anchor);
    			insert_dev(target, dd4, anchor);
    			append_dev(dd4, t11);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*hoveredProperties*/ 1 && t1_value !== (t1_value = /*hoveredProperties*/ ctx[0].municipal + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*hoveredProperties*/ 1 && t3_value !== (t3_value = /*hoveredProperties*/ ctx[0].pop + "")) set_data_dev(t3, t3_value);
    			if (dirty[0] & /*hoveredProperties*/ 1 && t5_value !== (t5_value = /*hoveredProperties*/ ctx[0].area.toFixed(2) + "")) set_data_dev(t5, t5_value);
    			if (dirty[0] & /*hoveredProperties*/ 1 && t9_value !== (t9_value = /*hoveredProperties*/ ctx[0].density.toFixed(2) + "")) set_data_dev(t9, t9_value);
    			if (dirty[0] & /*hoveredProperties*/ 1 && t11_value !== (t11_value = /*hoveredProperties*/ ctx[0].zonedDensity.toFixed(2) + "")) set_data_dev(t11, t11_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(dt0);
    			if (detaching) detach_dev(dd0);
    			if (detaching) detach_dev(dt1);
    			if (detaching) detach_dev(dd1);
    			if (detaching) detach_dev(dt2);
    			if (detaching) detach_dev(dd2);
    			if (detaching) detach_dev(dt3);
    			if (detaching) detach_dev(dd3);
    			if (detaching) detach_dev(dt4);
    			if (detaching) detach_dev(dd4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(460:1) {#if hoveredProperties && hoveredData}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let head;
    	let t0;
    	let div0;
    	let t1;
    	let select0;
    	let t2;
    	let select1;
    	let t3;
    	let current_block_type_index;
    	let if_block0;
    	let t4;
    	let div1;
    	let label;
    	let input;
    	let t5;
    	let span;
    	let t6;
    	let t7;
    	let t8;
    	let dl;
    	let dl_hidden_value;
    	let t9;
    	let div3;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*features*/ ctx[13];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	let each_value_1 = /*features*/ ctx[13];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const if_block_creators = [create_if_block_4, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*counterfactualHousing*/ ctx[10]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*visFeature*/ ctx[11] === "dwellingDensity") return create_if_block_3;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block1 = current_block_type(ctx);
    	let if_block2 = /*dataLookup*/ ctx[1] != {} && /*sourceMuni*/ ctx[3] && /*targetMuni*/ ctx[2] && create_if_block_1(ctx);
    	let if_block3 = /*hoveredProperties*/ ctx[0] && /*hoveredData*/ ctx[8] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			head = element("head");
    			t0 = space();
    			div0 = element("div");
    			t1 = text$1("If\n\t");
    			select0 = element("select");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = text$1("\n\thad the density of\n\t");
    			select1 = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			if_block0.c();
    			t4 = space();
    			div1 = element("div");
    			label = element("label");
    			input = element("input");
    			t5 = space();
    			span = element("span");
    			t6 = space();
    			if_block1.c();
    			t7 = space();
    			if (if_block2) if_block2.c();
    			t8 = space();
    			dl = element("dl");
    			if (if_block3) if_block3.c();
    			t9 = space();
    			div3 = element("div");
    			div2 = element("div");
    			add_location(head, file, 376, 0, 10993);
    			attr_dev(select0, "class", "svelte-a7490r");
    			if (/*targetMuni*/ ctx[2] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[17].call(select0));
    			add_location(select0, file, 380, 1, 11036);
    			attr_dev(select1, "class", "svelte-a7490r");
    			if (/*sourceMuni*/ ctx[3] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[18].call(select1));
    			add_location(select1, file, 386, 1, 11248);
    			attr_dev(div0, "class", "sidebar svelte-a7490r");
    			add_location(div0, file, 378, 0, 11009);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "svelte-a7490r");
    			add_location(input, file, 408, 2, 12003);
    			attr_dev(span, "class", "slider round svelte-a7490r");
    			add_location(span, file, 409, 2, 12075);
    			attr_dev(label, "class", "switch svelte-a7490r");
    			add_location(label, file, 407, 1, 11978);
    			attr_dev(div1, "id", "density-legend");
    			attr_dev(div1, "class", "legend svelte-a7490r");
    			add_location(div1, file, 406, 0, 11936);
    			attr_dev(dl, "id", "muni-tooltip");
    			attr_dev(dl, "class", "info tooltip svelte-a7490r");
    			dl.hidden = dl_hidden_value = /*hoveredId*/ ctx[7] === null;
    			add_location(dl, file, 458, 0, 13829);
    			attr_dev(div2, "class", "map svelte-a7490r");
    			add_location(div2, file, 478, 1, 14358);
    			attr_dev(div3, "class", "map-wrap");
    			add_location(div3, file, 477, 0, 14334);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, head, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t1);
    			append_dev(div0, select0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select0, null);
    			}

    			select_option(select0, /*targetMuni*/ ctx[2]);
    			append_dev(div0, t2);
    			append_dev(div0, select1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			select_option(select1, /*sourceMuni*/ ctx[3]);
    			append_dev(div0, t3);
    			if_blocks[current_block_type_index].m(div0, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label);
    			append_dev(label, input);
    			input.checked = /*visToggle*/ ctx[4];
    			append_dev(label, t5);
    			append_dev(label, span);
    			append_dev(div1, t6);
    			if_block1.m(div1, null);
    			insert_dev(target, t7, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, dl, anchor);
    			if (if_block3) if_block3.m(dl, null);
    			/*dl_binding*/ ctx[21](dl);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			/*div2_binding*/ ctx[22](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[17]),
    					listen_dev(select0, "change", /*paintMap*/ ctx[16], false, false, false),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[18]),
    					listen_dev(select1, "change", /*paintMap*/ ctx[16], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[20]),
    					listen_dev(input, "change", /*paintMap*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*features*/ 8192) {
    				each_value_2 = /*features*/ ctx[13];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty[0] & /*targetMuni, features*/ 8196) {
    				select_option(select0, /*targetMuni*/ ctx[2]);
    			}

    			if (dirty[0] & /*features*/ 8192) {
    				each_value_1 = /*features*/ ctx[13];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty[0] & /*sourceMuni, features*/ 8200) {
    				select_option(select1, /*sourceMuni*/ ctx[3]);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div0, null);
    			}

    			if (dirty[0] & /*visToggle*/ 16) {
    				input.checked = /*visToggle*/ ctx[4];
    			}

    			if (current_block_type !== (current_block_type = select_block_type_2(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			}

    			if (/*dataLookup*/ ctx[1] != {} && /*sourceMuni*/ ctx[3] && /*targetMuni*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1(ctx);
    					if_block2.c();
    					if_block2.m(t8.parentNode, t8);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*hoveredProperties*/ ctx[0] && /*hoveredData*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block(ctx);
    					if_block3.c();
    					if_block3.m(dl, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!current || dirty[0] & /*hoveredId*/ 128 && dl_hidden_value !== (dl_hidden_value = /*hoveredId*/ ctx[7] === null)) {
    				prop_dev(dl, "hidden", dl_hidden_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(head);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div1);
    			if_block1.d();
    			if (detaching) detach_dev(t7);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(dl);
    			if (if_block3) if_block3.d();
    			/*dl_binding*/ ctx[21](null);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div3);
    			/*div2_binding*/ ctx[22](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const outrostart_handler = e => e.target.classList.add('isFading');
    const introstart_handler = e => e.target.classList.remove('isFading');
    const outrostart_handler_1 = e => e.target.classList.add('isFading');
    const introstart_handler_1 = e => e.target.classList.remove('isFading');

    function instance($$self, $$props, $$invalidate) {
    	let visToggle;
    	let visFeature;
    	let features;
    	let centroids;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let icon = faXmark.faXmark;
    	let map;
    	let mapContainer;
    	let mapViewChanged = 0;
    	let hoveredProperties = null;
    	let hoveredId = null;
    	let hoveredData = null;
    	let cursor = { x: 0, y: 0 };
    	let lng, lat, zoom;
    	let tooltip;
    	let tooltipPosition = { x: 0, y: 0 };
    	let minisearch;
    	let data;
    	let densityData;
    	let dataLookup = {};
    	let geography;

    	let densityCmap = [
    		"#d1eeea",
    		1e-3,
    		"#a8dbd9",
    		1.129606099,
    		"#85c4c9",
    		1.217380321,
    		"#68abb8",
    		1.377882152,
    		"#4f90a6",
    		1.631587289,
    		"#3b738f",
    		3.396340725,
    		"#2a5674"
    	];

    	let zonedDensityCmap = [
    		"#d1eeea",
    		1e-3,
    		"#a8dbd9",
    		1.993243243,
    		"#85c4c9",
    		3,
    		"#68abb8",
    		4.513858696,
    		"#4f90a6",
    		6.170743498,
    		"#3b738f",
    		51.51252103,
    		"#2a5674"
    	];

    	let targetMuni;
    	let sourceMuni;
    	let counterfactualHousing = null;
    	lng = -71.224518;
    	lat = 42.213995;
    	zoom = 10;

    	onMount(async function () {
    		const initialState = { lng, lat, zoom };

    		data = await csv("housing_census_municipalities_compliance.csv", d => ({
    			...d,
    			area_km: +d.land_area_sq_miles_2020 * 2.59,
    			density: +d.pop / (+d.land_area_sq_miles_2020 * 2.59)
    		}));

    		densityData = await csv("agg_density.csv", d => d);

    		data.forEach(datum => {
    			$$invalidate(1, dataLookup[datum.muni_id] = datum, dataLookup);

    			densityData.forEach(densityDatum => {
    				if (datum.municipal !== densityDatum.municipal) {
    					return;
    				}

    				$$invalidate(
    					1,
    					dataLookup[datum.muni_id] = {
    						...dataLookup[datum.muni_id],
    						avg_zoned_density: densityDatum.avg_zoned_density,
    						avg_actual_density: densityDatum.avg_actual_density
    					},
    					dataLookup
    				);
    			});
    		});

    		// densityData.forEach((datum) => {
    		// 	console.log(densityData)
    		// 	dataLookup[datum.muni_id] = {
    		// 		...dataLookup[datum.muni_id],
    		// 		avg_zoned_density: datum.avg_zoned_density,
    		// 		avg_actual_density: datum.avg_actual_density,
    		// 	};
    		// });
    		// console.log(JSON.stringify(dataLookup));
    		geography = await json("ma_municipalities.geojson", // "Existing_Bike_Network_2022.geojson",
    		g => g);

    		$$invalidate(13, features = geography.features);

    		if (geography.crs.properties.name === "urn:ogc:def:crs:EPSG::26986") {
    			proj4.defs("EPSG:26986", 'PROJCS["NAD83 / Massachusetts Mainland",GEOGCS["NAD83",DATUM["North_American_Datum_1983",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],AUTHORITY["EPSG","6269"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4269"]],UNIT["metre",1,AUTHORITY["EPSG","9001"]],PROJECTION["Lambert_Conformal_Conic_2SP"],PARAMETER["standard_parallel_1",42.68333333333333],PARAMETER["standard_parallel_2",41.71666666666667],PARAMETER["latitude_of_origin",41],PARAMETER["central_meridian",-71.5],PARAMETER["false_easting",200000],PARAMETER["false_northing",750000],AUTHORITY["EPSG","26986"],AXIS["X",EAST],AXIS["Y",NORTH]]');
    			let massProj = proj4.defs("EPSG:26986");
    			let worldProj = proj4.defs("EPSG:4326");
    			let proj = proj4(massProj, worldProj);

    			features.forEach(function (feature) {
    				var geom = feature.geometry;

    				if (geom && geom.type === "MultiPolygon") {
    					for (var i = 0; i < geom.coordinates.length; i++) {
    						for (var j = 0; j < geom.coordinates[i].length; j++) {
    							for (var k = 0; k < geom.coordinates[i][j].length; k++) {
    								// console.log(geom.coordinates[i][j][k]);
    								geom.coordinates[i][j][k] = proj.forward(geom.coordinates[i][j][k]);
    							}
    						}
    					}
    				} else if (geom && geom.type === "Polygon") {
    					for (var i = 0; i < geom.coordinates.length; i++) {
    						for (var j = 0; j < geom.coordinates[i].length; j++) {
    							geom.coordinates[i][j] = proj.forward(geom.coordinates[i][j]);
    						}
    					}
    				}

    				let area$1 = area(feature.geometry) / (1000 * 1000);
    				let pop = dataLookup[feature.properties.muni_id].pop;
    				let density = pop / area$1;
    				let dwellingDensity = dataLookup[feature.properties.muni_id].avg_actual_density;
    				let zonedDensity = dataLookup[feature.properties.muni_id].avg_zoned_density;

    				feature.properties = {
    					...feature.properties,
    					"area": +area$1,
    					"pop": +pop,
    					"density": +density,
    					"dwellingDensity": +dwellingDensity,
    					"zonedDensity": +zonedDensity
    				};

    				$$invalidate(1, dataLookup[feature.properties.muni_id]["area"] = area$1, dataLookup);
    				$$invalidate(1, dataLookup[feature.properties.muni_id]["pop"] = pop, dataLookup);
    				$$invalidate(1, dataLookup[feature.properties.muni_id]["density"] = density, dataLookup);
    				$$invalidate(1, dataLookup[feature.properties.muni_id]["geometry"] = feature.geometry, dataLookup);
    			});

    			$$invalidate(13, features = features.sort((a, b) => a.properties.municipal > b.properties.municipal
    			? 1
    			: b.properties.municipal > a.properties.municipal ? -1 : 0));

    			minisearch = new MiniSearch({
    					fields: ["municipal", "muni_id"],
    					storeFields: ["municipal"]
    				});

    			let searchDocument = geography.features.map(feature => ({
    				...feature.properties,
    				id: feature.properties.muni_id
    			}));

    			minisearch.addAll(searchDocument);
    		} // console.log(JSON.stringify(searchDocument));

    		map = new mapboxGl.Map({
    				container: mapContainer,
    				accessToken: "pk.eyJ1IjoidGhlZGl2dGFnZ3V5IiwiYSI6ImNpcWM4N3FlaDAxd2Nmd20xejdwdmVoNmwifQ.Toi-P83h-0tC_mj60h25rg",
    				style: `mapbox://styles/mapbox/light-v9`,
    				center: [initialState.lng, initialState.lat],
    				zoom: initialState.zoom,
    				transition: { "duration": 1200, "delay": 0 }
    			});

    		map.on("load", () => {
    			map.addSource("mass", {
    				type: "geojson",
    				data: geography,
    				generateId: true
    			});

    			map.addLayer({
    				id: "mass-layer",
    				type: "fill",
    				source: "mass",
    				layout: {},
    				paint: {
    					"fill-color": [
    						"step",
    						["get", "dwellingDensity"],
    						"#d1eeea",
    						0,
    						"#a8dbd9",
    						1.129606099,
    						"#85c4c9",
    						1.217380321,
    						"#68abb8",
    						1.377882152,
    						"#4f90a6",
    						1.631587289,
    						"#3b738f",
    						3.396340725,
    						"#2a5674"
    					], // "#e4f1e1",10,"#b4d9cc",100,"#89c0b6",1000,"#63a6a0",3000,"#448c8a",6000,"#287274",9000,"#0d585f",
    					// "#d1eeea",100,"#a8dbd9",500,"#85c4c9",1000,"#68abb8",3000,"#4f90a6",6000,"#3b738f",9000,"#2a5674"
    					// "#d1eeea",0,"#a8dbd9",25,"#85c4c9",50,"#68abb8",75,"#4f90a6",100,"#3b738f",120,"#2a5674"
    					// "#ffeda0",10,"#ffeda0",50,"#fed976",100,"#feb24c",500,"#fd8d3c",1000,"#fc4e2a",2000,"#e31a1c",3000,"hsl(348, 100%, 37%)",6000,"#bd0026"
    					"fill-opacity": ["case", ["boolean", ["feature-state", "hover"], false], 1, 0.9]
    				}
    			});

    			map.addLayer({
    				id: "outline",
    				type: "line",
    				source: "mass",
    				layout: {},
    				paint: { "line-color": "#000", "line-width": 0.5 }
    			});

    			map.fitBounds(bbox$2(geography), {
    				padding: { top: 10, bottom: 25, left: 15, right: 5 }
    			});

    			map.on("move", () => {
    				$$invalidate(6, mapViewChanged++, mapViewChanged);
    				updateData();
    			});

    			map.on("mousemove", "mass-layer", e => {
    				if (e.features.length > 0) {
    					if (hoveredId !== null) {
    						map.setFeatureState({ source: "mass", id: hoveredId }, { hover: false });
    					}

    					$$invalidate(0, hoveredProperties = e.features[0].properties);
    					$$invalidate(7, hoveredId = e.features[0].id);
    					map.setFeatureState({ source: "mass", id: e.features[0].id }, { hover: true });
    				}
    			});

    			map.on("mouseleave", "mass-layer", () => {
    				map.setFeatureState({ source: "mass", id: hoveredId }, { hover: false });

    				// hoveredProperties = null;
    				$$invalidate(7, hoveredId = null);
    			});

    			features.forEach(function (feature) {
    				let centroid = centerOfMass(feature.geometry);

    				// let centroid = turf.centerOfMass(turf.bboxPolygon(turf.bbox(feature.geometry)));
    				centroid = {
    					...centroid,
    					properties: feature.properties
    				};

    				$$invalidate(12, centroids = [...centroids, centroid]);
    			});
    		}); // console.log(centroids);
    	});

    	function updateData() {
    		zoom = map.getZoom();
    		lng = map.getCenter().lng;
    		lat = map.getCenter().lat;
    	}

    	onDestroy(() => {
    		map.remove();
    	});

    	function projectCentroid(centroid) {
    		let point = new mapboxGl.LngLat(+centroid[0], +centroid[1]);
    		let { x, y } = map.project(point);
    		return { x, y };
    	}

    	function paintMap() {
    		let cmap;

    		if (visFeature == "dwellingDensity") {
    			cmap = densityCmap;
    		} else {
    			cmap = zonedDensityCmap;
    		}

    		if (sourceMuni && targetMuni) {
    			map.style.stylesheet.layers.forEach(function (layer) {
    				if (layer.type === 'symbol') {
    					map.setLayoutProperty(layer.id, "visibility", "none");
    				}
    			});

    			let geometry = union(dataLookup[sourceMuni]["geometry"], dataLookup[targetMuni]["geometry"]);

    			map.fitBounds(bbox$2(geometry), {
    				padding: {
    					top: 100,
    					bottom: 100,
    					left: 100,
    					right: 100
    				},
    				easing: t => {
    					return t * t * t;
    				},
    				duration: 1000
    			});

    			map?.setPaintProperty('mass-layer', 'fill-color', [
    				"step",
    				[
    					"case",
    					["==", ["get", "muni_id"], targetMuni],
    					["get", visFeature],
    					["==", ["get", "muni_id"], sourceMuni],
    					["get", visFeature],
    					-1
    				],
    				"#DDDDDD",
    				0,
    				...cmap
    			]);

    			map?.setPaintProperty("mass-layer", "fill-opacity", [
    				"*",
    				["case", ["boolean", ["feature-state", "hover"], false], 1, 0.9],
    				[
    					"case",
    					["==", ["get", "muni_id"], targetMuni],
    					1,
    					["==", ["get", "muni_id"], sourceMuni],
    					1,
    					0.5
    				]
    			]);
    		} else {
    			map.style.stylesheet.layers.forEach(function (layer) {
    				if (layer.type === 'symbol') {
    					map.setLayoutProperty(layer.id, "visibility", "visible");
    				}
    			});

    			map.fitBounds(bbox$2(geography), {
    				padding: { top: 10, bottom: 25, left: 15, right: 5 }
    			});

    			map?.setPaintProperty("mass-layer", "fill-color", ["step", ["get", visFeature], ...cmap]);
    			map?.setPaintProperty("mass-layer", "fill-opacity", ["case", ["boolean", ["feature-state", "hover"], false], 1, 0.9]);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function select0_change_handler() {
    		targetMuni = select_value(this);
    		$$invalidate(2, targetMuni);
    		$$invalidate(13, features);
    	}

    	function select1_change_handler() {
    		sourceMuni = select_value(this);
    		$$invalidate(3, sourceMuni);
    		$$invalidate(13, features);
    	}

    	const click_handler = () => {
    		$$invalidate(2, targetMuni = null);
    		$$invalidate(3, sourceMuni = null);
    		paintMap();
    	};

    	function input_change_handler() {
    		visToggle = this.checked;
    		$$invalidate(4, visToggle);
    	}

    	function dl_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			tooltip = $$value;
    			$$invalidate(9, tooltip);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			mapContainer = $$value;
    			$$invalidate(5, mapContainer);
    		});
    	}

    	$$self.$capture_state = () => ({
    		Map: mapboxGl.Map,
    		LngLat: mapboxGl.LngLat,
    		Icon,
    		faXmarkSquare: faXmarkSquare.faXmarkSquare,
    		faXmark: faXmark.faXmark,
    		onMount,
    		onDestroy,
    		d3,
    		proj4,
    		turf,
    		MiniSearch,
    		computePosition,
    		autoPlacement,
    		offset,
    		icon,
    		map,
    		mapContainer,
    		mapViewChanged,
    		hoveredProperties,
    		hoveredId,
    		hoveredData,
    		cursor,
    		lng,
    		lat,
    		zoom,
    		tooltip,
    		tooltipPosition,
    		minisearch,
    		data,
    		densityData,
    		dataLookup,
    		geography,
    		densityCmap,
    		zonedDensityCmap,
    		targetMuni,
    		sourceMuni,
    		counterfactualHousing,
    		updateData,
    		projectCentroid,
    		paintMap,
    		visFeature,
    		centroids,
    		features,
    		visToggle
    	});

    	$$self.$inject_state = $$props => {
    		if ('icon' in $$props) $$invalidate(14, icon = $$props.icon);
    		if ('map' in $$props) map = $$props.map;
    		if ('mapContainer' in $$props) $$invalidate(5, mapContainer = $$props.mapContainer);
    		if ('mapViewChanged' in $$props) $$invalidate(6, mapViewChanged = $$props.mapViewChanged);
    		if ('hoveredProperties' in $$props) $$invalidate(0, hoveredProperties = $$props.hoveredProperties);
    		if ('hoveredId' in $$props) $$invalidate(7, hoveredId = $$props.hoveredId);
    		if ('hoveredData' in $$props) $$invalidate(8, hoveredData = $$props.hoveredData);
    		if ('cursor' in $$props) cursor = $$props.cursor;
    		if ('lng' in $$props) lng = $$props.lng;
    		if ('lat' in $$props) lat = $$props.lat;
    		if ('zoom' in $$props) zoom = $$props.zoom;
    		if ('tooltip' in $$props) $$invalidate(9, tooltip = $$props.tooltip);
    		if ('tooltipPosition' in $$props) tooltipPosition = $$props.tooltipPosition;
    		if ('minisearch' in $$props) minisearch = $$props.minisearch;
    		if ('data' in $$props) data = $$props.data;
    		if ('densityData' in $$props) densityData = $$props.densityData;
    		if ('dataLookup' in $$props) $$invalidate(1, dataLookup = $$props.dataLookup);
    		if ('geography' in $$props) geography = $$props.geography;
    		if ('densityCmap' in $$props) densityCmap = $$props.densityCmap;
    		if ('zonedDensityCmap' in $$props) zonedDensityCmap = $$props.zonedDensityCmap;
    		if ('targetMuni' in $$props) $$invalidate(2, targetMuni = $$props.targetMuni);
    		if ('sourceMuni' in $$props) $$invalidate(3, sourceMuni = $$props.sourceMuni);
    		if ('counterfactualHousing' in $$props) $$invalidate(10, counterfactualHousing = $$props.counterfactualHousing);
    		if ('visFeature' in $$props) $$invalidate(11, visFeature = $$props.visFeature);
    		if ('centroids' in $$props) $$invalidate(12, centroids = $$props.centroids);
    		if ('features' in $$props) $$invalidate(13, features = $$props.features);
    		if ('visToggle' in $$props) $$invalidate(4, visToggle = $$props.visToggle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*hoveredProperties, dataLookup*/ 3) {
    			if (hoveredProperties) $$invalidate(8, hoveredData = dataLookup[hoveredProperties.muni_id]);
    		}

    		if ($$self.$$.dirty[0] & /*visToggle*/ 16) {
    			{
    				console.log(visToggle);

    				if (visToggle) {
    					$$invalidate(11, visFeature = "dwellingDensity");
    				} else {
    					$$invalidate(11, visFeature = "zonedDensity");
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*sourceMuni*/ 8) {
    			console.log(sourceMuni);
    		}

    		if ($$self.$$.dirty[0] & /*targetMuni, sourceMuni, dataLookup*/ 14) {
    			{
    				if (targetMuni && sourceMuni) {
    					$$invalidate(10, counterfactualHousing = Math.floor(dataLookup[targetMuni].area * dataLookup[sourceMuni].density) - dataLookup[targetMuni].pop);
    				} else {
    					$$invalidate(10, counterfactualHousing = null);
    				}
    			}
    		}
    	};

    	$$invalidate(4, visToggle = true);
    	$$invalidate(11, visFeature = "dwellingDensity");
    	$$invalidate(13, features = []);
    	$$invalidate(12, centroids = []);

    	return [
    		hoveredProperties,
    		dataLookup,
    		targetMuni,
    		sourceMuni,
    		visToggle,
    		mapContainer,
    		mapViewChanged,
    		hoveredId,
    		hoveredData,
    		tooltip,
    		counterfactualHousing,
    		visFeature,
    		centroids,
    		features,
    		icon,
    		projectCentroid,
    		paintMap,
    		select0_change_handler,
    		select1_change_handler,
    		click_handler,
    		input_change_handler,
    		dl_binding,
    		div2_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$z(this, options, instance, create_fragment, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		name: 'world'
    	}
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
